<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/t.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/t.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/t.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"silver-eagle.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="面试金典题解">
<meta property="og:url" content="https://silver-eagle.top/posts/e017732d.html">
<meta property="og:site_name" content="Tong&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-09T10:02:46.000Z">
<meta property="article:modified_time" content="2022-07-23T07:25:30.000Z">
<meta property="article:author" content="Zhang Tong">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://silver-eagle.top/posts/e017732d.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>面试金典题解 | Tong's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tong's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to my Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://silver-eagle.top/posts/e017732d.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/curry.jpg">
      <meta itemprop="name" content="Zhang Tong">
      <meta itemprop="description" content="Veni, Vidi, Vici">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tong's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          面试金典题解
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-09 18:02:46" itemprop="dateCreated datePublished" datetime="2022-07-09T18:02:46+08:00">2022-07-09</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-23 15:25:30" itemprop="dateModified" datetime="2022-07-23T15:25:30+08:00">2022-07-23</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>27k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>24 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<span id="more"></span>

<h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><h3 id="1-1-确定字符互异"><a href="#1-1-确定字符互异" class="headerlink" title="1.1 确定字符互异"></a>1.1 确定字符互异</h3><p>描述：</p>
<p>给定一个字符串string str，请返回一个bool值,<strong>True</strong>代表字符串的所有字符全都不同，<strong>False</strong>代表存在相同的字符。保证字符串中的字符为ASCII字符且不允许使用额外的存储结构，字符串的长度小于等于3000。大小写字母算不同的字符</p>
<p>测试样例：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;aeiou&quot;</span></span><br><span class="line">返回：<span class="literal">True</span></span><br><span class="line"><span class="string">&quot;BarackObama&quot;</span></span><br><span class="line">返回：<span class="literal">False</span></span><br></pre></td></tr></table></figure>

<p>假设不使用额外的数据结构。</p>
<p>解法：</p>
<p>假定字符集为ASCII，若字符串的长度大于字母表的字符个数，直接返回false；字母表一共只有256个字符。<br>构建一个布尔值的数组，索引值i对应的标记该字符串是否含有字母表的第i个字符。若这个字符第二次出现，返回false。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkDifferent</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">char_set</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = str[i];</span><br><span class="line">        <span class="keyword">if</span> (char_set[val]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这个字符已在字符串中出现过</span></span><br><span class="line">        char_set[val] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-原串翻转"><a href="#1-2-原串翻转" class="headerlink" title="1.2 原串翻转"></a>1.2 原串翻转</h3><p>描述：</p>
<p>给定一个string <strong>iniString</strong>，请返回一个string，为该字符串翻转后的结果。要求不使用额外数据结构和储存空间，可以使用单个过程变量，保证字符串的长度小于等于5000。</p>
<p>测试样例：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;This is nowcoder&quot;</span></span><br><span class="line">返回：<span class="string">&quot;redocwon si sihT&quot;</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>不分配额外空间，直接就地翻转字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (iniString.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> iniString;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = iniString.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123; <span class="comment">// 字符串首尾开始交换两个字符，直至两个指针在中间碰头</span></span><br><span class="line">        tmp = iniString[i];</span><br><span class="line">        iniString[i++] = iniString[j];</span><br><span class="line">        iniString[j--] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iniString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-3-确定两串乱序同构"><a href="#1-3-确定两串乱序同构" class="headerlink" title="1.3 确定两串乱序同构"></a>1.3 确定两串乱序同构</h3><p>描述：</p>
<p>给定string <strong>stringA</strong>和string <strong>stringB</strong>，编写程序确认两字符串包含的字符是否完全相同，注意大小写为不同字符，且考虑字符串中的空格，返回一个bool，代表两串是否由一样的字符组成。保证两串的长度都小于等于5000。</p>
<figure class="highlight smalltalk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span></span><br><span class="line">输入：<span class="comment">&quot;This is nowcoder&quot;</span>,<span class="comment">&quot;is This nowcoder&quot;</span></span><br><span class="line">返回值：<span class="keyword">true</span></span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span></span><br><span class="line">输入：<span class="comment">&quot;Here you are&quot;</span>,<span class="comment">&quot;Are you here&quot;</span></span><br><span class="line">返回值：<span class="keyword">false</span></span><br></pre></td></tr></table></figure>

<p>注：变位词区分大小写，空白也考虑在内。比较两个如果长度不同，就不可能是变位词。</p>
<p>解法1：排序字符串</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (stringA.<span class="built_in">size</span>() != stringB.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">sort</span>(stringA.<span class="built_in">begin</span>(), stringA.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(stringB.<span class="built_in">begin</span>(), stringB.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> stringA == stringB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2：检查两个字符串的各字符数是否相等</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (stringA.<span class="built_in">size</span>() != stringB.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : stringA) &#123;</span><br><span class="line">        letters[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> d : stringB) &#123;</span><br><span class="line">        letters[d]--;</span><br><span class="line">        <span class="keyword">if</span> (letters[d] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-4-空格替换"><a href="#1-4-空格替换" class="headerlink" title="1.4 空格替换"></a>1.4 空格替换</h3><p>描述：</p>
<p>给定一个string <strong>iniString</strong> 及其长度 int <strong>len</strong>, 已知该字符串中有空格，现要求编写程序将字符串中空格替换为“%20”。返回更改后的string。假设该字符串有足够的空间存放新增的字符，并且知道原字符的长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。</p>
<figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span></span><br><span class="line">输入：<span class="string">&quot;Mr John Smith&quot;</span>,<span class="number">13</span></span><br><span class="line">返回值：<span class="string">&quot;Mr%20John%20Smith&quot;</span></span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span></span><br><span class="line">输入：<span class="string">&quot;Hello  World&quot;</span>,<span class="number">12</span></span><br><span class="line">返回值：<span class="string">&quot;Hello%20%20World&quot;</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>处理字符串操作问题，常用做法是从字符串尾部开始编辑，从后向前反向操作。因为字符串尾部有额外的缓存，可以直接修改，不必担心会覆写原来的数据。</p>
<p>两次扫描，一次先数出字符串中有多少空格，从而算出最终的字符串的长度；第二次扫描反向编辑字符串。检测到空格将%20复制到下一个位置，若不是空白，就复制原来的字符。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string iniString, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, newLength = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    newLength = length + <span class="number">2</span> * count;</span><br><span class="line">    <span class="function">string <span class="title">res</span><span class="params">(newLength, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            res[newLength - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res[newLength - <span class="number">2</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            res[newLength - <span class="number">3</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            newLength -= <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[newLength - <span class="number">1</span>] = iniString[i];</span><br><span class="line">            newLength--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-5-基本字符串压缩"><a href="#1-5-基本字符串压缩" class="headerlink" title="1.5 基本字符串压缩"></a>1.5 基本字符串压缩</h3><p>描述：</p>
<p>现给定一个string iniString字符串(长度小于等于10000)，请按连续重复字母压缩的方式将该字符串压缩，返回结果为string，比如，字符串“aabbcccccaaa”经压缩会变成“a2b2c5a3”，若压缩后的字符串没有变短，则返回原先的字符串。注意保证串内字符均由大小写英文字母组成。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例<span class="number">1</span></span><br><span class="line">输入：<span class="string">&quot;aabcccccaaa&quot;</span></span><br><span class="line">返回值：<span class="string">&quot;a2b1c5a3&quot;</span></span><br><span class="line"></span><br><span class="line">示例<span class="number">2</span></span><br><span class="line">输入：<span class="string">&quot;welcometonowcoderrrrr&quot;</span></span><br><span class="line">返回值：<span class="string">&quot;welcometonowcoderrrrr&quot;</span></span><br><span class="line"></span><br><span class="line">说明：welcometonowcoderrrrr转换成重复字母压缩的结果是w<span class="number">1e1</span>l<span class="number">1</span><span class="keyword">c</span><span class="number">1</span>o<span class="number">1</span>m<span class="number">1e1</span>t<span class="number">1</span>o<span class="number">1</span>n<span class="number">1</span>o<span class="number">1</span>w<span class="number">1</span><span class="keyword">c</span><span class="number">1</span>o<span class="number">1</span>d<span class="number">1e1</span>r<span class="number">5</span>，比原字符串的长度还要长，所以返回原先的字符串。 </span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>加入压缩长度检查，算出压缩后的长度，构建相应大小的字符串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">zipString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">countCompression</span>(iniString);</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= iniString.<span class="built_in">size</span>()) <span class="keyword">return</span> iniString;</span><br><span class="line">    <span class="function">string <span class="title">res</span><span class="params">(size, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> last = iniString[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">0</span>] = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; iniString.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == last) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = iniString[i];</span><br><span class="line">            string tmp = <span class="built_in">to_string</span>(count);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> d : tmp) &#123;</span><br><span class="line">                res[index++] = d;</span><br><span class="line">            &#125;</span><br><span class="line">            res[index++] = last;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string tmp = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> d : tmp) &#123;</span><br><span class="line">        res[index++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCompression</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> last = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == last) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = str[i];</span><br><span class="line">            size += <span class="number">1</span> + <span class="built_in">to_string</span>(count).<span class="built_in">size</span>();</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span> + <span class="built_in">to_string</span>(count).<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-6-像素翻转"><a href="#1-6-像素翻转" class="headerlink" title="1.6 像素翻转"></a>1.6 像素翻转</h3><p>描述：</p>
<p>现有一个NxN的矩阵，阶数为N，请编写一个算法将矩阵顺时针旋转90度并将其作为返回值。要求不使用缓存矩阵，保证N不大于500，元素不大于256，每个元素用int表示。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line"><span class="string">[[1,2,3],[4,5,6],[7,8,9]]</span>,<span class="number">3</span></span><br><span class="line">返回：<span class="string">[[7,4,1],[8,5,2],[9,6,3]]</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>按索引一个一个进行交换，从最外层开始逐渐向里，在每一层进行交换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">transformImage</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = layer, last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> offset = i - first;</span><br><span class="line">            <span class="comment">// 存储上边</span></span><br><span class="line">            <span class="keyword">int</span> top = mat[first][i];</span><br><span class="line">            mat[first][i] = mat[last - offset][first]; <span class="comment">// 左到上</span></span><br><span class="line">            mat[last - offset][first] = mat[last][last - offset]; <span class="comment">// 下到左</span></span><br><span class="line">            mat[last][last - offset] = mat[i][last]; <span class="comment">// 右到下</span></span><br><span class="line">            mat[i][last] = top; <span class="comment">// 上到右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-7-清除行列"><a href="#1-7-清除行列" class="headerlink" title="1.7 清除行列"></a>1.7 清除行列</h3><p>描述：给定一个N阶方阵<code>int[][]</code>(C++中为<code>vector&lt;vector&gt;&lt;int&gt;&gt;</code>)<strong>mat</strong>及其阶数<strong>n</strong>，若方阵中某个元素为0，则将其所在的行与列清零。返回改变后的<code>int[][]</code>方阵(C++中为<code>vector&lt;vector&gt;&lt;int&gt;&gt;</code>)，保证n小于等于300，矩阵中的元素在nt范围内。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line"><span class="string">[[1,2,3],[0,1,2],[0,0,1]]</span></span><br><span class="line">返回：<span class="string">[[0,0,3],[0,0,0],[0,0,0]]</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>避免陷阱将矩阵所有元素清零。用两个数组记录包含零的所有行与列，第二次遍历矩阵时，若所在行或列标记为零，则将元素清零。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">clearZero</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = <span class="literal">true</span>;</span><br><span class="line">                col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="1-8-翻转子串"><a href="#1-8-翻转子串" class="headerlink" title="1.8 翻转子串"></a>1.8 翻转子串</h3><p>描述：</p>
<p>给定2个字符串s1和s2，请判断s2是否为s1旋转而成，返回bool值。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line"><span class="string">&quot;Hello world&quot;</span>,<span class="string">&quot;worldhello &quot;</span></span><br><span class="line">返回：<span class="literal">false</span></span><br><span class="line"><span class="string">&quot;waterbottle&quot;</span>,<span class="string">&quot;erbottlewat&quot;</span></span><br><span class="line">返回：<span class="literal">true</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>假定s2由s1旋转而成，将s1划分为两部分：x和y，满足xy = s1和yx = s2.无论分割点在哪里，yx肯定是xyxy的子串，即s2为s1s1的子串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkReverseEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == s2.<span class="built_in">size</span>() &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        string s1s1 = s1 + s1;</span><br><span class="line">        <span class="keyword">if</span> (s1s1.<span class="built_in">find</span>(s2) != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="2-1-访问单个节点的删除"><a href="#2-1-访问单个节点的删除" class="headerlink" title="2.1 访问单个节点的删除"></a>2.1 访问单个节点的删除</h3><p>描述：</p>
<p>编写代码，移除未排序链表中的重复节点。<br>进阶：不使用临时缓冲区</p>
<p>解法：</p>
<p>使用散列表，直接迭代访问整个链表，将每个节点加入散列表，若发现重复元素，将该节点从链表中删除，然后继续迭代。一次扫描完成。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(ListNode* n)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(n-&gt;val) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            pre-&gt;next = n-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[n-&gt;val] = <span class="number">1</span>;</span><br><span class="line">            pre = n;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶：不使用缓冲区。<br>用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点是否重复。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除后续值相同的节点</span></span><br><span class="line">        ListNode* runner = current;</span><br><span class="line">        <span class="keyword">while</span> (runner-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runner-&gt;next-&gt;val == current-&gt;val) &#123;</span><br><span class="line">                runner-&gt;next = runner-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runner = runner-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空间复杂度O(1), 时间复杂度O(N^2)</span></span><br></pre></td></tr></table></figure>

<h3 id="2-2-倒数第k个节点"><a href="#2-2-倒数第k个节点" class="headerlink" title="2.2 倒数第k个节点"></a>2.2 倒数第k个节点</h3><p>描述：</p>
<p>实现一个算法，找出单向链表中倒数第K个节点。</p>
<p>解法1：链表长度已知</p>
<p>若链表长度已知，那么倒数第k个节点就是第(length - k)个节点，直接迭代访问即可，比较简单。</p>
<p>解法2：递归</p>
<p>递归访问整个链表，当抵达链表末端时，该方法回传一个置为零的计数器，之后每次调用都会计数器加一。当计数器等于k时，表示访问的是倒数第k个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">nthToLast</span><span class="params">(ListNode* head, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* node = <span class="built_in">nthToLast</span>(head-&gt;next, k, i);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* l1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">10</span>);</span><br><span class="line">    l1 = <span class="built_in">fun</span>(l1);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ListNode* node = <span class="built_in">nthToLast</span>(l1, <span class="number">3</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-删除某个节点"><a href="#2-3-删除某个节点" class="headerlink" title="2.3 删除某个节点"></a>2.3 删除某个节点</h3><p>描述：</p>
<p>实现一个算法，删除单向链表中间的某个节点，假定只能访问该节点。</p>
<p>解法：</p>
<p>访问不到链表的首节点，只能访问待删除节点。解法很简单，直接将后继节点的数据复制到当前节点，然后删除该节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNode</span><span class="params">(ListNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">nullptr</span> || n-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* next = n-&gt;next;</span><br><span class="line">    n-&gt;val = next-&gt;val;</span><br><span class="line">    n-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意，若待删除节点为链表的尾节点，则这个问题无解。</p>
<h3 id="2-4-链表分割"><a href="#2-4-链表分割" class="headerlink" title="2.4 链表分割"></a>2.4 链表分割</h3><p>描述：</p>
<p>现有一链表的头指针 ListNode* <strong>pHead</strong>，给一定值x，以x为基准将链表分割成两部分，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。</p>
<p>解法：</p>
<p>不必移动和交换元素，直接创建两个链表，一个链表存储小于x的元素，一个链表存储大于等于x的元素。迭代访问整个链表，将元素插入before或after链表中。一旦抵达链表末端，表面拆分完成，最后合并两个链表。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* pHead, in</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// write code here</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* beforeStart = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* beforeEnd = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* afterStart = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* afterEnd = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* cur = pHead;</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 分割链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ListNode* next = cur-&gt;next; <span class="comment">// 临时变量记录后继结点</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cur-&gt;next = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (cur-&gt;val &lt; x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 将节点插入before链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (beforeStart == <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeStart = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd-&gt;next = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd = beforeEnd-&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        	<span class="comment">// 将节点插入after链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (afterStart == <span class="literal">nullptr</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">                afterStart = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd-&gt;next = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd = afterEnd-&gt;ne</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        cur = next;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (beforeStart == <span class="literal">nullptr</span>) <span class="keyword">return</span> afterStart;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 合并链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    beforeEnd-&gt;next = afterStart;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> beforeStart;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="2-5-链式A-B"><a href="#2-5-链式A-B" class="headerlink" title="2.5 链式A+B"></a>2.5 链式A+B</h3><p>描述：</p>
<p>将两个反向存储在链表中的整数求和（即整数的个位存放在了链表首部，一位数对应一个节点），返回的结果仍用链表形式。给定两个链表ListNode* <strong>A</strong>，ListNode* <strong>B</strong>，请返回A+B的结果(ListNode*)。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">测试样例：</span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;1,2,3&#125;</span><span class="xml">,</span><span class="template-variable">&#123;3,2,1&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">返回：</span><span class="template-variable">&#123;4,4,4&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml"></span><span class="template-variable">&#123;7,1,6&#125;</span><span class="xml">,</span><span class="template-variable">&#123;5,9,2&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">返回：</span><span class="template-variable">&#123;2,1,9&#125;</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>递归模拟，两个节点的值相加，如有进位则转入下一节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addList</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">addList</span><span class="params">(ListNode* a, ListNode* b, <span class="keyword">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> val = carry;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val += a-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val += b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    res-&gt;val = val % <span class="number">10</span>;</span><br><span class="line">    ListNode* more = <span class="built_in">addList</span>(a == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : a-&gt;next, b == <span class="literal">nullptr</span> ?</span><br><span class="line">                             <span class="literal">nullptr</span> : b-&gt;next, val &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    res-&gt;next = more;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>迭代遍历：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode* haha = b;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        b-&gt;val += a-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            b-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">                b-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b-&gt;next-&gt;val++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            b-&gt;next = a-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-6-有环链表的环路开头节点"><a href="#2-6-有环链表的环路开头节点" class="headerlink" title="2.6 有环链表的环路开头节点"></a>2.6 有环链表的环路开头节点</h3><p>描述：</p>
<p>给定一个有环链表，实现一个算法返回环路的开头节点。</p>
<p>解法：</p>
<ul>
<li>创建两个指针：fast和slow；</li>
<li>slow每走1步，fast走2步；</li>
<li>两者碰在一起时，将slow指向链表的头节点head，fast保持不变</li>
<li>以相同的速度移动slow和fast，一次走1步，返回新的碰撞处。</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findBeginning</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出第一次相遇的位置</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;<span class="comment">// 碰撞</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误检查：没有碰撞即没有环路</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow指向链表首部，fast不变，直到第二次相遇</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回环路起始点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-7-回文链表"><a href="#2-7-回文链表" class="headerlink" title="2.7 回文链表"></a>2.7 回文链表</h3><p>描述：编写一个函数，检查链表是否为回文。 </p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">1</span>&#125;</span><br><span class="line">返回：<span class="literal">true</span></span><br><span class="line">&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>&#125;</span><br><span class="line">返回：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>解法1：反转并比较</p>
<p>反转整个链表，然后比较反转链表和原始链表。若两者相同，则该链表为回文。<br>注意，在比较原始链表和反转链表时，其实只需比较链表的前半部分。若原始链表和反转链表的前半部分相同，那么，两者的后半部分肯定相同。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode* revered = <span class="built_in">reverseList</span>(pHead);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isEqual</span>(pHead, revered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">        n-&gt;next = res;</span><br><span class="line">        res = n;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">nullptr</span> &amp;&amp; b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;val != b-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2：迭代法</p>
<p>将链表前半部分反转，利用栈来实现。<br>入栈有两种方式，若链表长度已知：可以用for循环迭代访问前半部分节点，将每个节点入栈；<br>若链表长度未知，使用快慢指针，迭代访问链表，在快指针到达链表尾部时，慢指针刚好在链表中间位置。<br>至此，栈里就存放了链表前半部分的所有节点，不过顺序是相反的。接下来，只需迭代访问链表余下节点。每次迭代时，比较当前节点和栈顶元素，若完成迭代时比较结果完全相同，则该链表是回文序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line">	<span class="comment">// 链表前半部分元素入栈，偶数个节点fast最后指向nullptr，奇数个节点fast最后指向最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(slow-&gt;val);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数个节点，跳过中间节点</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">nullptr</span> &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 判断回文</span></span><br><span class="line">        <span class="keyword">if</span> (top != slow-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法3：递归法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* myLeft = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    myLeft = pHead;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tranverse</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tranverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">tranverse</span>(right-&gt;next);       </span><br><span class="line">    res = (res &amp;&amp; right-&gt;val == myLeft-&gt;val);</span><br><span class="line">    myLeft = myLeft-&gt;next;                  </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="3-1-三合一"><a href="#3-1-三合一" class="headerlink" title="3.1 三合一"></a>3.1 三合一</h3><p>描述：</p>
<p>如何只用一个数组来实现三个栈。</p>
<p>解法：</p>
<p>固定分割：将整个数组三等分，并将每个栈的增长限制在各自的空间里。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedMultiStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> numberOfStacks = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> stackCapacity;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sizes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FixedMultiStack</span>(<span class="keyword">int</span> stackSize) : <span class="built_in">stackCapacity</span>(stackSize) &#123;</span><br><span class="line">        values.<span class="built_in">resize</span>(stackSize * numberOfStacks);</span><br><span class="line">        sizes.<span class="built_in">resize</span>(numberOfStacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将值压入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> throws FullStackException </span>&#123; </span><br><span class="line">		<span class="comment">/* 检查有空间容纳下一个元素 */</span> </span><br><span class="line">		<span class="keyword">if</span> (<span class="built_in">isFull</span>(stackNum)) &#123; </span><br><span class="line">			<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">FullStackException</span>(); </span><br><span class="line">		&#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 对栈顶指针加 1 并更新顶部的值 */</span> </span><br><span class="line">        sizes[stackNum]++; </span><br><span class="line">        values[<span class="built_in">indexOfTop</span>(stackNum)] = value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(stackNum)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> topIndex = <span class="built_in">indexOfTop</span>(stackNum);</span><br><span class="line">        <span class="keyword">int</span> value = values[topIndex]; <span class="comment">// 获取顶部元素</span></span><br><span class="line">        values[topIndex] = <span class="number">0</span>; <span class="comment">// 清零</span></span><br><span class="line">        sizes[stackNum]--; <span class="comment">// 缩减大小</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizes[stackNum] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizes[stackNum] == stackCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回栈顶元素索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IndexOfTop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = stackNum * stackCapacity;</span><br><span class="line">        <span class="keyword">int</span> size = sizes[stackNum];</span><br><span class="line">        <span class="keyword">return</span> offset + size - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-栈的最小值"><a href="#3-2-栈的最小值" class="headerlink" title="3.2 栈的最小值"></a>3.2 栈的最小值</h3><p>描述：</p>
<p>请设计一个栈，除了 pop 与 push 函数，还支持 min 函数，其可返回栈元素中的最小值。执行 push、pop 和 min 操作的时间复杂度必须为O(1)。</p>
<p>解法：</p>
<p>每个节点记录当前最小值。这么一来，要找到 min，直接查看栈顶元素就能得到最小值。缺点是栈很大时，每个元素都要记录min，会浪费大量空间。改进：用其他的栈来记录。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1; <span class="comment">// 数据栈</span></span><br><span class="line">    satck&lt;<span class="keyword">int</span>&gt; s2; <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= <span class="built_in">min</span>()) &#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = s1.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="built_in">min</span>()) &#123;</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-集合栈"><a href="#3-3-集合栈" class="headerlink" title="3.3 集合栈"></a>3.3 集合栈</h3><p>描述：</p>
<p>请实现一种数据结构SetOfStacks，由多个大小为size的栈组成，当前一个栈填满时，则新建一个栈，且也可以与普通栈一样拥有相同的push和pop操作。<br>现给定一个操作序列<code>int[][2] </code>ope(C++为<code>vector&lt;vector&lt;int&gt;&gt;</code>)，若执行push操作则第一个数为1，第二个数为应push的数字；若执行pop操作，则第一个数为2，第二个数为空。返回值为int[]<a href="C++%E4%B8%BA%60vector%3Cvector%3Cint%3E%3E%60"></a>，即为变动后的SetOfStacks，顺序从下到上，初始SetOfStacks为空，并保证数据合法。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">setOfStacks</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ope, <span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = ope.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ope[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>().<span class="built_in">size</span>() == size) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">back</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="3-4-双栈排序"><a href="#3-4-双栈排序" class="headerlink" title="3.4 双栈排序"></a>3.4 双栈排序</h3><p>描述：</p>
<p>给定一个<code>int[] numbers</code>(C++中为<code>vector&lt;int&gt;</code>)，其中第一个元素为栈顶，请编写程序将栈进行升序排列（即<strong>最大元素位于栈顶</strong>），返回排序后的栈。要求最多使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。并注意这是一个栈，意味着排序过程中只能访问到最后一个元素。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line"><span class="string">[1,2,3,4,5]</span></span><br><span class="line">返回：<span class="string">[5,4,3,2,1]</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>s1为原先的栈，s2为最终排好序的栈，若要对s1排序，可以从s1逐一弹出元素，然后按顺序插入s2中。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoStacksSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 把s1中的每个元素有序地插入到tmp中</span></span><br><span class="line">        <span class="keyword">int</span> top = s1.<span class="built_in">top</span>();</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>() &amp;&amp; tmp.<span class="built_in">top</span>() &gt; top) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">            tmp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 将tmp中元素复制回s</span></span><br><span class="line">    <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = tmp.<span class="built_in">top</span>();</span><br><span class="line">        s1.<span class="built_in">push</span>(top);</span><br><span class="line">        res.<span class="built_in">push_back</span>(top);</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h2><h3 id="4-1-二叉树平衡检查"><a href="#4-1-二叉树平衡检查" class="headerlink" title="4.1 二叉树平衡检查"></a>4.1 二叉树平衡检查</h3><p>描述：</p>
<p>平衡的定义如下，已知对于树中的任意一个结点，若其两颗子树的高度差不超过1，则我们称该树平衡。现给定指向树根结点的指针<code>TreeNode* root</code>，请编写函数返回一个bool，表示该二叉树是否平衡。</p>
<p>解法：</p>
<p>递归访问整棵树，计算每个节点的两个子树的高度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">int</span> diff = <span class="built_in">getHeight</span>(root-&gt;left) - <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(diff) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBalance</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalance</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root -&gt; left), <span class="built_in">getHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：<code>getHeight</code>函数不仅可以检查高度，还能检查这棵树是否平衡。从根节点递归向下检查每棵子树的高度，设计<code>checkHeight</code>函数，若子树平衡返回子树的实际高度，若子树不平衡返回-1并中断执行。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkHeight</span>(root) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 高度为0</span></span><br><span class="line">    <span class="comment">// 检查左子树是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> leftHeight = <span class="built_in">checkHeight</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 检查右子树是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> rightHeight = <span class="built_in">checkHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 检查当前节点是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> diff = leftHeight - rightHeight;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(diff) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不平衡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>; <span class="comment">// 返回高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-2-高度最小的BST"><a href="#4-2-高度最小的BST" class="headerlink" title="4.2 高度最小的BST"></a>4.2 高度最小的BST</h3><p>描述：</p>
<p>给定一个元素各不相同的有序序列int[] vals（升序排列）,请编写算法创建一棵高度最小的二叉查找树，并返回二叉查找树的高度。</p>
<p>解法：</p>
<p>递归方法创建高度最小的BST。将数组中间位置的元素插入树中，数组左半部分插入左子树，数组右半部分插入右子树，递归处理。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildMinimalBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    TreeNode* root = <span class="built_in">createMinBST</span>(vals, <span class="number">0</span>, vals.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">createMinBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; start) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode* n = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[mid]);</span><br><span class="line">    n-&gt;left = <span class="built_in">createMinBST</span>(vals, start, mid - <span class="number">1</span>);</span><br><span class="line">    n-&gt;right = <span class="built_in">createMinBST</span>(vals, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root -&gt; left), <span class="built_in">getHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-输出单层节点"><a href="#4-3-输出单层节点" class="headerlink" title="4.3 输出单层节点"></a>4.3 输出单层节点</h3><p>描述：</p>
<p>已知二叉树的根结点指针TreeNode* root以及链表上结点的深度，请设计算法返回一个链表ListNode，该链表代表该深度上所有结点的值，并按树上从左往右的顺序链接，深度不能超过树的高度，且树上结点的值为不大于100000的非负整数。</p>
<p>解法：</p>
<p>广度优先遍历，从根节点开始迭代，处于第i层时，表明访问过第i-1层的所有节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getTreeLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* res = node;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (deep == dep - <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                node-&gt;next = tmp;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-检查是否为BST"><a href="#4-4-检查是否为BST" class="headerlink" title="4.4 检查是否为BST"></a>4.4 检查是否为BST</h3><p>描述：</p>
<p>现给定树的根结点指针TreeNode* <strong>root</strong>，编辑函数返回一个bool值，判断该树是否为二叉查找树。</p>
<p>解法：</p>
<p>假定没有重复的值，可以采用中序遍历。BST中序遍历结果为递增序列。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">process</span>(arr, root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i<span class="number">-1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历BST</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">process</span>(arr, root-&gt;left);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">process</span>(arr, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法二：最小与最大法</p>
<p>二叉搜索树的条件：所有左边的节点必须小于或等于当前节点，而当前节点必须小于所有右边的节点。<br>迭代遍历整个树，自上而下传递最小与最大值，逐渐变窄的范围检查各个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* root, <span class="keyword">int</span> minval, <span class="keyword">int</span> maxval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; minval || root-&gt;val &gt; maxval) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, minval, root-&gt;val) &amp;&amp; </span><br><span class="line">        <span class="built_in">check</span>(root-&gt;right, root-&gt;val, maxval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-5-寻找下一个节点"><a href="#4-5-寻找下一个节点" class="headerlink" title="4.5 寻找下一个节点"></a>4.5 寻找下一个节点</h3><p>描述：</p>
<p>给定树的根结点指针TreeNode* root和结点的值int p，编写一个函数，寻找该二叉树中指定结点的下一个结点（即中序遍历的后继），并返回p结点的后继结点的值。保证结点的值是小于等于100000的正数且没有重复值，若不存在后继返回-1。</p>
<p>解法：</p>
<p>递归中序遍历。当节点值等于p，标记为true，返回遍历的下一个节点。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSucc</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findSuccCore</span>(root, p, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSuccCore</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p, <span class="keyword">bool</span>&amp; sign)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 左子树中寻找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">findSuccCore</span>(root-&gt;left, p, sign);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="literal">true</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="comment">// 当前值等于p，将标记置为true</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == p) sign = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findSuccCore</span>(root-&gt;right, p, sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-6-最近公共祖先"><a href="#4-6-最近公共祖先" class="headerlink" title="4.6 最近公共祖先"></a>4.6 最近公共祖先</h3><p>描述：</p>
<p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p>
<p>解法：</p>
<p>顺着一条 p 和 q 都在同一边的链子查找，也就是说，若 p 和 q 都在某节点的左边，就到左子树中查找共同祖先，若都在右边，则在右子树中查找共同祖先。要是 p 和 q不在同一边，那就表示已经找到第一个共同祖先。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">commonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 错误检查，一个节点不在树中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cover</span>(root, p) || !<span class="built_in">cover</span>(root, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> pIsOnLeft = <span class="built_in">cover</span>(root-&gt;left, p);</span><br><span class="line">    <span class="keyword">bool</span> pIsOnRight = <span class="built_in">cover</span>(root-&gt;right, q);</span><br><span class="line">    <span class="keyword">if</span> (pIsOnLeft != pIsOnRight) &#123; <span class="comment">// 两个节点位于不同的两边</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* childSize = pIsOnLeft ? root-&gt;left : root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(childSize, p, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cover</span>(root-&gt;left, p) || <span class="built_in">cover</span>(root-&gt;right, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-7-求和路径"><a href="#4-7-求和路径" class="headerlink" title="4.7 求和路径"></a>4.7 求和路径</h3><p>描述：</p>
<p>给定一棵二叉树，其中每个节点都含有一个整数数值（该值或正或负）。设计一个算法，打印节点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下（只能从父节点指向子节点方向）。</p>
<p>解法1：暴力解法</p>
<p>遍历每个节点。对于每个节点，用递归法尝试所有向下的路径，并随着递归的进行跟踪路径的和。每当得到目标和，将发现的路径数目加一。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从root开始，符合目标和的路径进行计数</span></span><br><span class="line">    <span class="keyword">int</span> pathFromRoot = <span class="built_in">countPathWithSumFromRoot</span>(root, target, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左节点与右节点</span></span><br><span class="line">    <span class="keyword">int</span> pathFromLeft = <span class="built_in">countPathWithSum</span>(root-&gt;left, target);</span><br><span class="line">    <span class="keyword">int</span> pathFromRight = <span class="built_in">countPathWithSum</span>(root-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pathFromRoot + pathFromLeft + pathFromRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从根节点开始，符合目标和的路径总数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSumFromRoot</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum += node-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalPath = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123; <span class="comment">// 找到一条从root开始的路径</span></span><br><span class="line">        totalPath++;</span><br><span class="line">    &#125;</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSumFromRoot</span>(node-&gt;left, target, sum);</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSumFromRoot</span>(node-&gt;right, target, sum);</span><br><span class="line">    <span class="keyword">return</span> totalPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>解法2：优化算法</p>
<p>使用哈希表减少重复计算。使用深度优先查找对树进行遍历。当我们访问每个节点时，执行以下操作。(1) 跟踪 runningSum 的值。我们将使该变量成为函数的一个参数，并对其增加 node.value。<br>(2) 在散列表中查找 runningSum - targetSum。我们从散列表获得的值为路径的总数。将变量 totalPaths 的值设置为该值。<br>(3) 如果 runningSum == targetSum，则发现了另外一条从根节点开始的路径。将变量 totalPaths加 1。<br>(4) 将 runningSum 加入到散列表中（如果 runningSum 已经存在，则将增加其值）。<br>(5) 对左子树和右子树进行递归，计算和为 targetSum 的路径的条数。<br>(6) 对左子树和右子树的递归调用结束后，减少散列表中 runningSum 对应的值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(root, target, <span class="number">0</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 基础情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对终止于该节点，符合目标和的路径进行计数</span></span><br><span class="line">    sum += node-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> diff = sum - target;</span><br><span class="line">    <span class="comment">//map[diff] = 0;</span></span><br><span class="line">    <span class="keyword">int</span> totalPath = map[diff];</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        totalPath++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map[sum]++;</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSum</span>(node-&gt;left, target, sum, map);</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSum</span>(node-&gt;right, target, sum, map);</span><br><span class="line">    map[sum]--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="递归与动态规划"><a href="#递归与动态规划" class="headerlink" title="递归与动态规划"></a>递归与动态规划</h2><h3 id="5-1-加到n"><a href="#5-1-加到n" class="headerlink" title="5.1 加到n"></a>5.1 加到n</h3><p>描述：</p>
<p>给定一个正整数int <strong>n</strong>，从0开始加到n，每次可增加1、2或3，直到其大于等于n，请返回一个数，代表加到n的方案的个数。保证n小于等于100000，并为了防止溢出，请将结果Mod 1000000007。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试样例1：</span><br><span class="line">1</span><br><span class="line">返回：1</span><br><span class="line">测试样例2：</span><br><span class="line">3</span><br><span class="line">返回：4</span><br><span class="line">测试样例3：</span><br><span class="line">4</span><br><span class="line">返回：7</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>暴力解求解：递归，指数级增长，会超时。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countWays</span>(n - <span class="number">1</span>) + <span class="built_in">countWays</span>(n - <span class="number">2</span>) + <span class="built_in">countWays</span>(n - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>改进：制表法，利用memo数组记录中间过程的值</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//memo[1] = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countWaysCore</span>(n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWaysCore</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memo[n] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memo[n] = ((<span class="built_in">countWaysCore</span>(n - <span class="number">1</span>, memo)  </span><br><span class="line">                    + <span class="built_in">countWaysCore</span>(n - <span class="number">2</span>, memo))% <span class="number">1000000007</span></span><br><span class="line">                   + <span class="built_in">countWaysCore</span>(n - <span class="number">3</span>, memo))% <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-2-机器人走方格I"><a href="#5-2-机器人走方格I" class="headerlink" title="5.2 机器人走方格I"></a>5.2 机器人走方格I</h3><p>描述：</p>
<p>给定两个正整数int <strong>x</strong>,int <strong>y</strong>，代表一个x乘y的网格，现有一个机器人要从网格左上角顶点走到右下角，每次只能走一步且只能向右或向下走，返回机器人有多少种走法。保证x＋y小于等于12。</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">2,2</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>假设网格r行c列，移动到(r, c), 需要先移动到相邻点(r-1, c)或(r, c-1)。<br>动态规划，用一个二维表dp记录每个点的走法，<code>dp[r][c] = dp[r - 1][c] + dp[r][c - 1]</code>.<br>需要注意边界的情况。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> dp[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp[1][1] = 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= y; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-3-机器人走方格II"><a href="#5-3-机器人走方格II" class="headerlink" title="5.3 机器人走方格II"></a>5.3 机器人走方格II</h3><p>描述：</p>
<p>给定一个int[][] <strong>map</strong>(C++ 中为vector &gt;)网格图，若map[i][j]为1则该点不是障碍点，否则为障碍点。另外给定int <strong>x</strong>,int <strong>y</strong>，表示网格的大小。现有一个机器人要从网格左上角走到右下角，只能走格点且只能向右或向下走。请返回机器人从(0,0)走到(x - 1,y - 1)有多少种走法。请将结果Mod 1000000007以防止溢出，并保证x和y均小于等于50。</p>
<p>解法：</p>
<p>动态规划，建立dp表存储中间结果，如果<code>map[r][c]</code>值不为1，则<code>dp[r][c] = 0</code>。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; map, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(x, vector&lt;<span class="keyword">int</span>&gt;(y, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[i][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; y; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x - <span class="number">1</span>][y - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-4-魔术索引"><a href="#5-4-魔术索引" class="headerlink" title="5.4 魔术索引"></a>5.4 魔术索引</h3><p>描述：</p>
<p>已知数组<strong>A</strong>[0..n-1]和数组大小<strong>n</strong>（升序数组，元素值各不相同），若存在A[i]=i则称该数组有魔术索引，请判断该数组是否存在魔术索引，返回值为bool，要求复杂度优于o(n)。</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line"><span class="string">[1,2,3,4,5]</span></span><br><span class="line">返回：<span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>有序数组，二分查找，要找出元素k，会先拿它跟数组中间的元素 x比较，确定k位于x的左边还是右边。递归二分查找：（数组中没有重复的值）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findMagicIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; mid)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, start, mid - <span class="number">1</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, end); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进阶：数组中有重复的值，判断是否存在魔术索引。</p>
<p>解法：如果数组元素有重复值，前面的算法就会失效。如果 A[mid] &lt; mid，我们无法断定魔术索引位于数组哪一边。它可能在数组右侧，也可能在左侧。<br>二分递归：（也适用于不存在重复的值，暴力解法）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findMagicIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, start, mid - <span class="number">1</span>) || <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, end); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="5-5-子集"><a href="#5-5-子集" class="headerlink" title="5.5 子集"></a>5.5 子集</h3><p>描述：</p>
<p>已知数组<strong>A</strong>和其大小<strong>n</strong>，请返回A的所有非空子集。要求A中元素个数不大于20且互异。各子集内部从大到小排序,子集间字典逆序排序。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line"><span class="selector-attr">[123,456,789]</span></span><br><span class="line">返回：&#123;<span class="selector-attr">[789,456,123]</span>,<span class="selector-attr">[789,456]</span>,<span class="selector-attr">[789,123]</span>,<span class="selector-attr">[789]</span>,<span class="selector-attr">[456 123]</span>,<span class="selector-attr">[456]</span>,<span class="selector-attr">[123]</span>&#125;</span><br></pre></td></tr></table></figure>

<p>解法：</p>
<p>递归，path记录中间过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">getSubsets</span>(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">    <span class="comment">// res.clear();</span></span><br><span class="line">    <span class="comment">// path.clear();</span></span><br><span class="line">    <span class="built_in">recur</span>(A, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= arr.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">recur</span>(arr, i + <span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Zhang Tong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://silver-eagle.top/posts/e017732d.html" title="面试金典题解">https://silver-eagle.top/posts/e017732d.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/20a59019.html" rel="prev" title="C++并发编程笔记">
      <i class="fa fa-chevron-left"></i> C++并发编程笔记
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/47fa327.html" rel="next" title="Linux网络编程基础API">
      Linux网络编程基础API <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E7%BB%84%E4%B8%8E%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">1.</span> <span class="nav-text">数组与字符串</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-%E7%A1%AE%E5%AE%9A%E5%AD%97%E7%AC%A6%E4%BA%92%E5%BC%82"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 确定字符互异</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-2-%E5%8E%9F%E4%B8%B2%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.2.</span> <span class="nav-text">1.2 原串翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-3-%E7%A1%AE%E5%AE%9A%E4%B8%A4%E4%B8%B2%E4%B9%B1%E5%BA%8F%E5%90%8C%E6%9E%84"><span class="nav-number">1.3.</span> <span class="nav-text">1.3 确定两串乱序同构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-4-%E7%A9%BA%E6%A0%BC%E6%9B%BF%E6%8D%A2"><span class="nav-number">1.4.</span> <span class="nav-text">1.4 空格替换</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-5-%E5%9F%BA%E6%9C%AC%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8E%8B%E7%BC%A9"><span class="nav-number">1.5.</span> <span class="nav-text">1.5 基本字符串压缩</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-6-%E5%83%8F%E7%B4%A0%E7%BF%BB%E8%BD%AC"><span class="nav-number">1.6.</span> <span class="nav-text">1.6 像素翻转</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-7-%E6%B8%85%E9%99%A4%E8%A1%8C%E5%88%97"><span class="nav-number">1.7.</span> <span class="nav-text">1.7 清除行列</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#1-8-%E7%BF%BB%E8%BD%AC%E5%AD%90%E4%B8%B2"><span class="nav-number">1.8.</span> <span class="nav-text">1.8 翻转子串</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%93%BE%E8%A1%A8"><span class="nav-number">2.</span> <span class="nav-text">链表</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-%E8%AE%BF%E9%97%AE%E5%8D%95%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E5%88%A0%E9%99%A4"><span class="nav-number">2.1.</span> <span class="nav-text">2.1 访问单个节点的删除</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-2-%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.2.</span> <span class="nav-text">2.2 倒数第k个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-3-%E5%88%A0%E9%99%A4%E6%9F%90%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">2.3.</span> <span class="nav-text">2.3 删除某个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-4-%E9%93%BE%E8%A1%A8%E5%88%86%E5%89%B2"><span class="nav-number">2.4.</span> <span class="nav-text">2.4 链表分割</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-5-%E9%93%BE%E5%BC%8FA-B"><span class="nav-number">2.5.</span> <span class="nav-text">2.5 链式A+B</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-6-%E6%9C%89%E7%8E%AF%E9%93%BE%E8%A1%A8%E7%9A%84%E7%8E%AF%E8%B7%AF%E5%BC%80%E5%A4%B4%E8%8A%82%E7%82%B9"><span class="nav-number">2.6.</span> <span class="nav-text">2.6 有环链表的环路开头节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#2-7-%E5%9B%9E%E6%96%87%E9%93%BE%E8%A1%A8"><span class="nav-number">2.7.</span> <span class="nav-text">2.7 回文链表</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97"><span class="nav-number">3.</span> <span class="nav-text">栈与队列</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-%E4%B8%89%E5%90%88%E4%B8%80"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 三合一</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-%E6%A0%88%E7%9A%84%E6%9C%80%E5%B0%8F%E5%80%BC"><span class="nav-number">3.2.</span> <span class="nav-text">3.2 栈的最小值</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-%E9%9B%86%E5%90%88%E6%A0%88"><span class="nav-number">3.3.</span> <span class="nav-text">3.3 集合栈</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-%E5%8F%8C%E6%A0%88%E6%8E%92%E5%BA%8F"><span class="nav-number">3.4.</span> <span class="nav-text">3.4 双栈排序</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%A0%91%E4%B8%8E%E5%9B%BE"><span class="nav-number">4.</span> <span class="nav-text">树与图</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B3%E8%A1%A1%E6%A3%80%E6%9F%A5"><span class="nav-number">4.1.</span> <span class="nav-text">4.1 二叉树平衡检查</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-%E9%AB%98%E5%BA%A6%E6%9C%80%E5%B0%8F%E7%9A%84BST"><span class="nav-number">4.2.</span> <span class="nav-text">4.2 高度最小的BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-3-%E8%BE%93%E5%87%BA%E5%8D%95%E5%B1%82%E8%8A%82%E7%82%B9"><span class="nav-number">4.3.</span> <span class="nav-text">4.3 输出单层节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-4-%E6%A3%80%E6%9F%A5%E6%98%AF%E5%90%A6%E4%B8%BABST"><span class="nav-number">4.4.</span> <span class="nav-text">4.4 检查是否为BST</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-5-%E5%AF%BB%E6%89%BE%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">4.5.</span> <span class="nav-text">4.5 寻找下一个节点</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-6-%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">4.6.</span> <span class="nav-text">4.6 最近公共祖先</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-7-%E6%B1%82%E5%92%8C%E8%B7%AF%E5%BE%84"><span class="nav-number">4.7.</span> <span class="nav-text">4.7 求和路径</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%80%92%E5%BD%92%E4%B8%8E%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="nav-number">5.</span> <span class="nav-text">递归与动态规划</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#5-1-%E5%8A%A0%E5%88%B0n"><span class="nav-number">5.1.</span> <span class="nav-text">5.1 加到n</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-2-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E6%96%B9%E6%A0%BCI"><span class="nav-number">5.2.</span> <span class="nav-text">5.2 机器人走方格I</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-3-%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%B5%B0%E6%96%B9%E6%A0%BCII"><span class="nav-number">5.3.</span> <span class="nav-text">5.3 机器人走方格II</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-4-%E9%AD%94%E6%9C%AF%E7%B4%A2%E5%BC%95"><span class="nav-number">5.4.</span> <span class="nav-text">5.4 魔术索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#5-5-%E5%AD%90%E9%9B%86"><span class="nav-number">5.5.</span> <span class="nav-text">5.5 子集</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Tong"
      src="/images/curry.jpg">
  <p class="site-author-name" itemprop="name">Zhang Tong</p>
  <div class="site-description" itemprop="description">Veni, Vidi, Vici</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:zt_scut@163.com" title="E-Mail → mailto:zt_scut@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Tong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">512k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:46</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/cursor/clicklove.js"></script>
</body>
</html>
