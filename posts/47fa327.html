<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/t.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/t.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/t.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">
  <link rel="stylesheet" href="/lib/pace/pace-theme-loading-bar.min.css">
  <script src="/lib/pace/pace.min.js"></script>

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"silver-eagle.top","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"hide","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":"flat"},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta property="og:type" content="article">
<meta property="og:title" content="Linux网络编程基础API">
<meta property="og:url" content="https://silver-eagle.top/posts/47fa327.html">
<meta property="og:site_name" content="Tong&#39;s Blog">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://silver-eagle.top/20220723/image-20220724232946013.png">
<meta property="og:image" content="https://silver-eagle.top/20220723/image-20220725111725849.png">
<meta property="og:image" content="https://silver-eagle.top/20220723/image-20220725112716763.png">
<meta property="og:image" content="https://silver-eagle.top/20220723/image-20220725112747241.png">
<meta property="article:published_time" content="2022-07-23T09:32:05.000Z">
<meta property="article:modified_time" content="2022-07-25T07:14:15.000Z">
<meta property="article:author" content="Zhang Tong">
<meta property="article:tag" content="Linux网络编程">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://silver-eagle.top/20220723/image-20220724232946013.png">

<link rel="canonical" href="https://silver-eagle.top/posts/47fa327.html">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>Linux网络编程基础API | Tong's Blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="stylesheet" href="/css/prism.css" type="text/css"></head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Tong's Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Welcome to my Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div id="search-result">
  <div id="no-result">
    <i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>
  </div>
</div>

    </div>
  </div>

</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://silver-eagle.top/posts/47fa327.html">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/curry.jpg">
      <meta itemprop="name" content="Zhang Tong">
      <meta itemprop="description" content="Veni, Vidi, Vici">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Tong's Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux网络编程基础API
        </h1>

        <div class="post-meta">

          
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2022-07-23 17:32:05" itemprop="dateCreated datePublished" datetime="2022-07-23T17:32:05+08:00">2022-07-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2022-07-25 15:14:15" itemprop="dateModified" datetime="2022-07-25T15:14:15+08:00">2022-07-25</time>
              </span>

          <br>
            <span class="post-meta-item" title="本文字数">
              <span class="post-meta-item-icon">
                <i class="far fa-file-word"></i>
              </span>
                <span class="post-meta-item-text">本文字数：</span>
              <span>28k</span>
            </span>
            <span class="post-meta-item" title="阅读时长">
              <span class="post-meta-item-icon">
                <i class="far fa-clock"></i>
              </span>
                <span class="post-meta-item-text">阅读时长 &asymp;</span>
              <span>25 分钟</span>
            </span>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <hr>
<span id="more"></span>

<p>Linux网络API：</p>
<ul>
<li>socket地址API。一个ip地址和端口对(ip, port)。唯一表示使用TCP通信的一端</li>
<li>socket基础API。头文件&lt;sys/socket.h&gt;，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</li>
<li>网络信息API。Linux提供的网络信息API，实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。头文件&lt;netdb.h&gt;中。</li>
</ul>
<h2 id="1-socket地址API"><a href="#1-socket地址API" class="headerlink" title="1.socket地址API"></a>1.socket地址API</h2><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><ul>
<li>大端字节序：一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7bit）存储在内存的高地址处</li>
<li>小端字节序：整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</li>
</ul>
<p><strong>现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。</strong><br>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞ </span></span><br><span class="line"><span class="comment">// host to network long 将长整型（32bit）的主机字节序数据转化为网络字节序数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure>

<p>长整型函数通常用来转换IP地址，短整型函数用来转换端口号。</p>
<h3 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h3><p>结构体sockaddr，定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 地址族类型，与协议族类型相对应</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 存放socket地址值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>常见协议族与对应的地址族的关系：</p>
<table>
<thead>
<tr>
<th align="center">协议族</th>
<th align="center">地址族</th>
<th align="center">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="center">PF_UNIX</td>
<td align="center">AF_UNIX</td>
<td align="center">UNIX本地域协议族</td>
</tr>
<tr>
<td align="center">PF_INET</td>
<td align="center">AF_INET</td>
<td align="center">TCP/IPv4协议族</td>
</tr>
<tr>
<td align="center">PF_INET6</td>
<td align="center">AF_INET6</td>
<td align="center">TCP/IPv6协议族</td>
</tr>
</tbody></table>
<p>宏<code>PF_*</code>和<code>AF_*</code>都定义在<code>bits/socket.h</code>头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p>
<p>不同的协议族的地址值具有不同的含义和长度。14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line">	char__ss_padding[<span class="number">128</span>-<span class="built_in"><span class="keyword">sizeof</span></span>(__ss_align)]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不仅提供了足够大的空间用于存放地址值，而且是内存对齐的（这是<code>__ss_align</code>成员的作用）</p>
<h3 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h3><p>Linux为各个协议族提供了专门的socket地址结构体。  </p>
<p>UNIX本地域协议族的专用socket地址<code>sockaddr_un</code>：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/un.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_UNIX*/</span> </span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];<span class="comment">/*文件路径名*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>TCP/IP协议族:<code>sockaddr_in</code>(IPV4)和<code>sockaddr_in6</code>(IPV6)地址结构体</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span> </span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;<span class="comment">/*IPv4地址，要用网络字节序表示*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span> </span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。 </p>
<h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p>IPV4地址：点分十进制字符串<br>IPV6地址：十六进制字符串<br>编程中需要将他们转化为整数（二进制数）使用，记录日志则相反，需要由整数转化为可读的字符串。</p>
<p>用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*strptr)</span></span>; </span><br><span class="line"><span class="comment">// 点分十进制字符串-&gt;网络字节序整数，失败返回INADDR_NONE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*cp,struct in_addr*inp)</span></span>; </span><br><span class="line"><span class="comment">// 功能与inet_addr相同，结果存在inp指向的地址结构（传出参数），成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">// 网络字节序整数-&gt;点分十进制字符串。函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存</span></span><br><span class="line"><span class="comment">// inet_ntoa是不 可重入的，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* szValue1 = <span class="built_in">inet_ntoa</span>(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”); </span><br><span class="line"><span class="keyword">char</span>* szValue2 = <span class="built_in">inet_ntoa</span>(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”); </span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”, szValue1); </span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”, szValue2);</span><br><span class="line"><span class="comment">// 返回结果为：</span></span><br><span class="line"><span class="comment">// address1:10.194.71.60 </span></span><br><span class="line"><span class="comment">// address2:10.194.71.60</span></span><br></pre></td></tr></table></figure>

<p>更新函数适用于IPV4和IPV6：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 字符串IP地址src-&gt;网络字节序整数，结果存储在dst指向的内存中</span></span><br><span class="line"><span class="comment">// 参数af：指定地址族，AF_INET或者AF_INET6</span></span><br><span class="line"><span class="comment">// 成功返回1，失败返回0并设置errno</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br><span class="line"><span class="comment">// 网络字节序整数-&gt;字符串IP地址src，前三个参数与之前的函数相同</span></span><br><span class="line"><span class="comment">// 参数cnt：指定目标存储单元的大小，定义两个宏帮助指定大小（分别用于IPV4和IPV6）</span></span><br><span class="line"><span class="comment">// 成功返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure>

<h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>UNIX/Linux系统中：所有东西都是文件。<br>socket，可读可写、可控制、可关闭的文件描述符。<br>socket系统调用创建一个socket：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	domain：底层的协议族。</span></span><br><span class="line"><span class="comment">		PF_INET（IPv4）、 PF_INET6（IPv6）、PF_UNIX（本地域）</span></span><br><span class="line"><span class="comment">	type：指定服务类型。</span></span><br><span class="line"><span class="comment">		SOCK_STREAM（TCP）、SOCK_UGRAM（UDP）、SOCK_NONBLOCK（非阻塞的）、SOCK_CLOEXEC</span></span><br><span class="line"><span class="comment">	protocol：选择协议，通常由前两个参数决定。</span></span><br><span class="line"><span class="comment">		设置为0，使用默认协议</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功返回一个socket文件描述符，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>命名socket：将一个socket与socket地址绑定。<br>服务器程序中，命名后客户端才知道如何连接它。<br>命名socket的系统调用：bind函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：未命名的sockfd文件描述符</span></span><br><span class="line"><span class="comment">	my_addr：指向socket地址</span></span><br><span class="line"><span class="comment">	addrlen：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功返回0，失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">	错误：</span></span><br><span class="line"><span class="comment">		EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。</span></span><br><span class="line"><span class="comment">		EADDRINUSE，被绑定的地址正在使用中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>创建一个监听队列以存放待处理的客户连接，listen函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：指定被监听的socket</span></span><br><span class="line"><span class="comment">	backlog：提示内核监听队列的最大长度。如果监听队列的长度超过backlog，服务器不受理新的客户连接，客户端收到ECONNREFUSED错误信息。backlog典型值为5</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功返回0，失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>backlog函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-3testlisten.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// SIGTERM信号的处理函数，触发时结束主程序中的循环</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">( <span class="keyword">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testlisten函数接收三个参数：IP地址，端口号，backlog值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>( SIGTERM, handle_term );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>]; <span class="comment">// ip地址</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ); <span class="comment">// 端口号</span></span><br><span class="line">    <span class="keyword">int</span> backlog = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] ); <span class="comment">// backlog值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> ); <span class="comment">// 创建ipv4 socket文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">// 创建一个ipv4 socket地址</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr ); <span class="comment">// 字符串ip地址转化为网络字节序整数</span></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port ); <span class="comment">// 主机字节序转化为网络字节序，短整型函数转化端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, backlog );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待连接，直到有SIGTERM信号将它中断</span></span><br><span class="line">    <span class="keyword">while</span> ( ! stop )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器程序testlisten，接受3个参数：IP地址，端口号，backlog值。<br>服务器运行该程序，客户端多次执行telnet命令连接该服务器程序。使用telnet建立连接，执行netstat命令查看服务器上连接的状态。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testlisten 192.168.1.109 12345 5<span class="comment">#监听12345端口，给backlog传递典型 值5</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">telnet 192.168.1.109 12345<span class="comment">#多次执行之</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 12345<span class="comment">#多次执行之</span></span></span><br></pre></td></tr></table></figure>

<p>在监听队列中，处于ESTABLISHED状态的连接只有6个（backlog值加1），其他的连接都处于SYN_RCVD状态。即完整连接最多有（backlog+1）个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p>
<h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>从listen监听队列中接受一个连接，accept函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr*addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：执行过listen系统调用的监听socket（处于LISTEN状态的socket，而所有处于ESTABLISHED状态的socket则称为连接socket）</span></span><br><span class="line"><span class="comment">	addr：获取被接受的远端socket地址</span></span><br><span class="line"><span class="comment">	addrlen：socket地址的长度	</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信；</span></span><br><span class="line"><span class="comment">	失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>接受一个异常的连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-5testaccept.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>]; <span class="comment">// ipv4地址</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ); <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">// 创建socket地址结构体，传入ip地址和端口号</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> ); <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址结构体与socket文件描述符，命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> ); <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*暂停20秒以等待客户端连接和相关操作（掉线或者退出）完成*/</span> </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span> <span class="comment">// 客户端socket地址结构体</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept接收连接调用，返回值connfd</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接成功，打印客户端地址和端口号</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器运行testaccept程序，在客户端执行telnet命令连接该服务器的程序：<br>(服务器ip地址：192.168.1.109)</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testaccept 192.168.1.109 54321<span class="comment">#监听54321端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">telnet 192.168.1.109 54321</span></span><br></pre></td></tr></table></figure>

<p>启动telnet客户端程序，立即断开该客户端的网络连接（建立和断开连接的过程要在服务器启动后20秒内完成）。结果发现accept调用能够正常返回，服务器输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected with ip:192.168.1.108 and port:38545</span><br></pre></td></tr></table></figure>

<p>服务器运行netstat命令查看accept返回socket连接的状态：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 54321</span></span><br><span class="line">tcp 0 0 192.168.1.109:54321 192.168.1.108:38545 ESTABLISHED</span><br></pre></td></tr></table></figure>

<p>accept调用对于客户端网络断开毫不知情。重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回。服务器运行netstat命令查看：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 54321</span></span><br><span class="line">tcp 1 0 192.168.1.109:54321 192.168.1.108:52070 CLOSE_WAIT</span><br></pre></td></tr></table></figure>

<p>由此可见，accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。</p>
<h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>服务器通过listen调用，被动接受连接；客户端通过connect调用，主动与服务器建立连接：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：socket系统调用返回的socket文件描述符</span></span><br><span class="line"><span class="comment">	serv_addr：服务器监听的socket地址</span></span><br><span class="line"><span class="comment">	addrlen：指定地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">	常见错误：</span></span><br><span class="line"><span class="comment">		ECONNREFUSED：目标端口不存在，连接被拒绝</span></span><br><span class="line"><span class="comment">		ETIMEDOUT：连接超时</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭该连接所对应的socket，通过关闭普通文件描述符的系统调用完成：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">	参数fd：待关闭的socket</span></span><br><span class="line"><span class="comment">	close函数将fd的引用计数减1，只有当fd的引用计数为0时，才真正关闭连接。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>多进程程序中，一次fork系统调用默认使父进程中打开的socket的引用计数加1，因此，必须在父进程和子进程中都对该socket执行close调用，才能将连接关闭。</p>
<p>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的）：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：待关闭的socket</span></span><br><span class="line"><span class="comment">	howto：决定shutdown的行为，可选择：</span></span><br><span class="line"><span class="comment">		SHUT_RD：关闭sockfd的读，应用程序无法对socket文件描述符执行读操作</span></span><br><span class="line"><span class="comment">		SHUT_WR：关闭sockfd的写，应用程序无法对socket文件描述符指向写操作，连接处于半关闭状态</span></span><br><span class="line"><span class="comment">		SHUT_RDWD：同时关闭sockfd上的读和写</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功时返回0，失败则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p>
<h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><p>对文件的读写操作read和write同样适用于socket。用于TCP流数据读写的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">recv作用：读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：要读取的sockfd文件描述符</span></span><br><span class="line"><span class="comment">	buf：指定读缓冲区的位置（传出参数）</span></span><br><span class="line"><span class="comment">	len：缓冲区大小</span></span><br><span class="line"><span class="comment">	flags：通常设置为0</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	可能要多次调用recv，才能读取到完整的数据。</span></span><br><span class="line"><span class="comment">	返回0表示通信对方已经关闭连接，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">send作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">	sockfd：要写入数据的sockfd文件描述符</span></span><br><span class="line"><span class="comment">	buf：指定读缓冲区的位置（传出参数）</span></span><br><span class="line"><span class="comment">	len：缓冲区大小</span></span><br><span class="line"><span class="comment">	flags：数据收发的额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>发送带外数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-6oobsend.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ip地址与端口号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sockfd &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connection failed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 发起连接成功</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;send oob data out\n&quot;</span> );</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* oob_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="comment">// 写入数据发送</span></span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">send</span>( sockfd, oob_data, <span class="built_in">strlen</span>( oob_data ), MSG_OOB ); <span class="comment">// 发送或接受紧急数据</span></span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接受带外数据：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-7oobrecv.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取ip地址与端口号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受地址socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket文件描述符与socket地址信息</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket地址监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听的socket接受连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="keyword">char</span> buffer[ BUF_SIZE ]; <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取socket中的数据，写入到buffer缓冲区中，打印缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OOB );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>现在服务器上启动5-7oobrecv.cpp服务器程序testoobrecv，客户端执行5-6oobsend.cpp客户端程序testoobsend，向服务器发送带外数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testoobrecv 192.168.1.109 54321 <span class="comment">#在Kongming20上执行服务器程序，监听 54321端口 $./testoobsend 192.168.1.109 54321 #在ernest-laptop上执行客户端程序</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">sudo tcpdump-ntx-i eth0 port 54321</span></span><br></pre></td></tr></table></figure>

<p>服务器的输出如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got 5 bytes of normal data&#x27;123ab&#x27; </span><br><span class="line">got 1 bytes of oob data&#x27;c&#x27; </span><br><span class="line">got 3 bytes of normal data&#x27;123&#x27;</span><br></pre></td></tr></table></figure>

<p>客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收。并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p>
<h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><p>用于UDP数据报读写的系统调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; </span><br><span class="line"><span class="comment">/* recvfrom调用</span></span><br><span class="line"><span class="comment">作用：读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：要读取的socket文件描述符</span></span><br><span class="line"><span class="comment">	buf：指定缓冲区位置</span></span><br><span class="line"><span class="comment">	len：缓冲区的大小</span></span><br><span class="line"><span class="comment">	flags：额外控制</span></span><br><span class="line"><span class="comment">	src_addr：获取发送端的socket的地址</span></span><br><span class="line"><span class="comment">	addrlen：发送端socket地址的大小</span></span><br><span class="line"><span class="comment">	</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/* sendto调用：</span></span><br><span class="line"><span class="comment">作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：要写入数据的socket文件描述符</span></span><br><span class="line"><span class="comment">	buf：指定缓冲区位置</span></span><br><span class="line"><span class="comment">	len：缓冲区的大小</span></span><br><span class="line"><span class="comment">	flags：额外控制</span></span><br><span class="line"><span class="comment">	dest_addr：指定接收端的socket的地址</span></span><br><span class="line"><span class="comment">	addrlen：接收端socket地址的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p>recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。</p>
<h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><p>不仅适用于TCP流数据，也能用于UDP数据报：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="comment">/* recvmsg调用：</span></span><br><span class="line"><span class="comment">作用：接收读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：要读取的socket文件描述符</span></span><br><span class="line"><span class="comment">	msg：指向msghdr结构体</span></span><br><span class="line"><span class="comment">	flags：额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：要写入数据的socket文件描述符</span></span><br><span class="line"><span class="comment">	msg：指向msghdr结构体</span></span><br><span class="line"><span class="comment">	flags：额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// msghdr结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* msg_name; <span class="comment">/*socket地址*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen; <span class="comment">/*socket地址的长度*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span> <span class="comment">/*分散的内存块，见后文*/</span> </span><br><span class="line">    <span class="keyword">int</span> msg_iovlen; <span class="comment">/*分散内存块的数量*/</span></span><br><span class="line">    <span class="keyword">void</span>* msg_control; <span class="comment">/*指向辅助数据的起始位置*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_controllen; <span class="comment">/*辅助数据的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> msg_flags; <span class="comment">/*复制函数中的flags参数，并在调用过程中更新*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iovec结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* iov_base; <span class="comment">/*内存起始地址*/</span> </span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/*这块内存的长度*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>msghdr结构体中，msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。</p>
<p>iovec结构体封装了一块内存的起始位置和长度。</p>
<p>分散读（scatter read）：recvmsg调用，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定。</p>
<p>集中写（gather write）：sendmsg调用，msg_iovlen块分散内存中的数据将被一并发送。</p>
<p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</p>
<h2 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h2><p>内核通知应用进程带外数据抵达的两种方式：</p>
<ul>
<li>I/O复用产生的异常事件</li>
<li>SIGURG信号</li>
</ul>
<p>即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。使用sockatmark调用：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：判断sockfd是否处于带外标记，即下一个被读取的数据是否是带外数据</span></span><br><span class="line"><span class="comment">参数fd：需要判断的socket文件描述符</span></span><br><span class="line"><span class="comment">返回值：若是带外数据，返回1，此时可以利用带MSG_OOB标志的recv调用来接收带外数据；若不是，返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h2><p>获取一个连接socket的本端socket地址，以及远端的socket地址。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取sockfd对应的本端socket地址，存储在address指向的内存中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：需要获取的socket文件描述符</span></span><br><span class="line"><span class="comment">	address：指向socket地址结构体的指针，传出参数</span></span><br><span class="line"><span class="comment">	address_len：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功时返回0，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取sockfd对应的远端socket地址</span></span><br><span class="line"><span class="comment">参数，返回值的含义与getsockname调用的相同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><p>读取和设置socket文件描述符属性的方法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：读取sockfd的属性</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockfd：指定被操作的目标socket文件描述符</span></span><br><span class="line"><span class="comment">	level：指定要操作的协议属性（IPV4、IPV6、TCP等）</span></span><br><span class="line"><span class="comment">	option_name：指定选项的名字，socket选项</span></span><br><span class="line"><span class="comment">	option_value：被操作选项的值</span></span><br><span class="line"><span class="comment">	option_len：被操作选项的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置sockfd的属性</span></span><br><span class="line"><span class="comment">参数，返回值：参照getsockopt调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/20220723/image-20220724232946013.png" alt="image-20220724232946013"></p>
<p>对于服务器，有部分socket选项只能在调用listen系统调用前针对监听socket设置才有效。因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。</p>
<p>解决方法：对监听socket设置socket选项，那么accept返回的连接socket将自动继承这些选项。这些socket选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。</p>
<p>对于客户端，socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成。</p>
<h3 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h3><p>服务器程序可以通过设置socket选项SO_REUSEADDR，来强制使用被处于TIME_WAIT状态的连接占用的socket地址。重用本地地址：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-9reuse_address.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// 设置socket属性为SO_REUSEADDR，重用本地地址</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="built_in"><span class="keyword">sizeof</span></span>( reuse ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址并绑定socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端接收socket地址，accept调用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功并打印</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭服务器连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a>SO_RCVBUF和SO_SNDBUF选项</h3><p>SO_RCVBUF选项：TCP接收缓冲区的大小，最小值256字节<br>SO_SNDBUF选项：TCP发送缓冲区的大小，最小值2048字节<br>用setsockopt来设置TCP的接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞。</p>
<p>修改TCP发送缓冲区的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-10set_send_buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TCP发送缓冲区的大小</span></span><br><span class="line">    <span class="keyword">int</span> sendbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>( sendbuf );</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="built_in"><span class="keyword">sizeof</span></span>( sendbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="keyword">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动发起连接成功</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sock, ( struct sockaddr* )&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) ) != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;a&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="number">0</span> ); <span class="comment">// 发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改TCP接收缓存区的大小：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-11set_recv_buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">int</span> recvbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>( recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket属性，设置接收缓冲区大小</span></span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="built_in"><span class="keyword">sizeof</span></span>( recvbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="keyword">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址与socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收连接accept调用</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功</span></span><br><span class="line">        <span class="keyword">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> ) &gt; <span class="number">0</span> )&#123;&#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>服务器端运行5-11set_recv_buffer.cpp（set_recv_buffer程序），在客户端上运行5-10set_send_buffer.cpp（set_send_buffer程序），客户端向服务器发送512字节的数据。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./set_recv_buffer 192.168.1.108 12345 50<span class="comment">#将TCP接收缓冲区的大小设置为 50字节</span></span></span><br><span class="line">the tcp receive buffer size after settting is 256 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./set_send_buffer 192.168.1.108 12345 2000<span class="comment">#将TCP发送缓冲区的大小设置 为2000字节</span></span> </span><br><span class="line">the tcp send buffer size after setting is 4000</span><br></pre></td></tr></table></figure>

<p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将忽略我们的设置。从客户端的输出来看，我们设置的TCP发送缓冲区的大小被系统增加了一倍。</p>
<h3 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h3><p>SO_RCVLOWAT选项：TCP接收缓冲区的低水位标记，可读数据总数大于其低水位标记，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据。<br>SO_SNDLOWAT选项：TCP发送缓冲区的低水位标记，缓冲区的空闲空间（可写入数据的空间）大于其低水位标记，I/O复用系统调用将通知应用程序可以往对应的socke上写入数据。<br>一般被I/O复用系统调用，用来判断socket是否可读或可写</p>
<p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。 </p>
<h3 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h3><p>SO_LINGER选项：用于控制close系统调用在关闭TCP连接时的行为。</p>
<p>默认情况下，使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方。</p>
<p>设置（获取）SO_LINGER选项的值时，需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff;<span class="comment">/*开启（非0）还是关闭（0）该选项*/</span> </span><br><span class="line">    <span class="keyword">int</span> l_linger;<span class="comment">/*滞留时间*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>close系统调用可能产生的3种行为：</p>
<ul>
<li>l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为关闭socket。</li>
<li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。</li>
<li>l_onoff不为0，l_linger大于0。close的行为取决于两个条件： <ul>
<li>被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据。</li>
<li>该socket是阻塞的，还是非阻塞的。<br>对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。<br>如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li>
</ul>
</li>
</ul>
<h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。可以用主机名来访问一台机器，而避免直接使用其IP地址，用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80 </span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure>

<p>telnet客户端程序，通过调用某些网络信息API，来实现主机名到IP地址的转换，以及服务名称到端口号的转换。</p>
<h3 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h3><p>gethostbyname函数：根据主机名称获取主机的完整信息。通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。<br>gethostbyaddr函数：根据IP地址获取主机的完整信息。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数name：指定目标主机的主机名</span></span><br><span class="line"><span class="comment">返回值：指向hostent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：	</span></span><br><span class="line"><span class="comment">	addr：指定目标主机的IP地址</span></span><br><span class="line"><span class="comment">	len：IP地址的长度</span></span><br><span class="line"><span class="comment">	type：IP地址的类型，合法取值有AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址）</span></span><br><span class="line"><span class="comment">返回值：指向hostent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hostnet结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* h_name; <span class="comment">/*主机名*/</span> </span><br><span class="line">    <span class="keyword">char</span>** h_aliases; <span class="comment">/*主机别名列表，可能有多个*/</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/*地址类型（地址族）*/</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/*地址长度*/</span> </span><br><span class="line">    <span class="keyword">char</span>** h_addr_list <span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h3><p>getservbyname函数：根据名称获取某个服务的完整信息。<br>getservbyport函数：根据端口号获取某个服务的完整信息。<br>它们实际上都是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	name：指定服务的名字</span></span><br><span class="line"><span class="comment">	proto：指定服务类型</span></span><br><span class="line"><span class="comment">返回值：指向servent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	port：指定目标服务对应的端口号</span></span><br><span class="line"><span class="comment">	proto：指定服务类型</span></span><br><span class="line"><span class="comment">返回值：指向servent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// servent结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* s_name; <span class="comment">/*服务名称*/</span></span><br><span class="line">    <span class="keyword">char</span>** s_aliases; <span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line">    <span class="keyword">int</span> s_port; <span class="comment">/*端口号*/</span> </span><br><span class="line">    <span class="keyword">char</span>* s_proto; <span class="comment">/*服务类型,通常是tcp或者udp*/</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>通过主机名和服务名来访问目标服务器上的daytime服务，以获取该机器的系统时间：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-12access_daytime.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="built_in">assert</span>( argc == <span class="number">2</span> );</span><br><span class="line">	<span class="keyword">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取目标主机的地址信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hostinfo</span> =</span> <span class="built_in">gethostbyname</span>( host );</span><br><span class="line">	<span class="built_in">assert</span>( hostinfo );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 获取daytime服务信息</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">servent</span>* <span class="title">servinfo</span> =</span> <span class="built_in">getservbyname</span>( <span class="string">&quot;daytime&quot;</span>, <span class="string">&quot;tcp&quot;</span> );</span><br><span class="line">	<span class="built_in">assert</span>( servinfo );</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;daytime port is %d\n&quot;</span>, <span class="built_in">ntohs</span>( servinfo-&gt;s_port ) );</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建socket地址</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">	address.sin_family = AF_INET;</span><br><span class="line">	address.sin_port = servinfo-&gt;s_port;</span><br><span class="line">	<span class="comment">// 因为h_addr_list本身是使用网络字节序的地址列表，所以使用其中的IP地址时，无须对目标IP地址转换字节序</span></span><br><span class="line">	address.sin_addr = *( struct in_addr* )*hostinfo-&gt;h_addr_list;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 创建socket文件描述符，主动发起连接</span></span><br><span class="line">	<span class="keyword">int</span> sockfd = <span class="built_in">socket</span>( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">	<span class="keyword">int</span> result = <span class="built_in">connect</span>( sockfd, (struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">	<span class="built_in">assert</span>( result != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">	<span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">	result = <span class="built_in">read</span>( sockfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>( buffer ) );</span><br><span class="line">	<span class="built_in">assert</span>( result &gt; <span class="number">0</span> );</span><br><span class="line">	buffer[ result ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	<span class="built_in">printf</span>( <span class="string">&quot;the day item is: %s&quot;</span>, buffer );</span><br><span class="line">	<span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注：以上讨论的4个函数都是不可重入的，即非线程安全的。不过netdb.h头文件给出了它们的可重入版本。这些函数的函数名是在原函数名尾部加上_r（re-entrant）。</p>
<h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>getaddrinfo函数：既能通过主机名获得IP地址（内部使用的是gethostbyname函数），也能通过服务名获得端口号（内部使用的是getservbyname函数）。<br>是否可重入取决于其内部调用的gethostbyname和getservbyname函数是否是它们的可重入版本。该函数的定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname, <span class="keyword">const</span> <span class="keyword">char</span>* service, <span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	hostname：可以接收主机名，也可接收字符串表示的IP地址。</span></span><br><span class="line"><span class="comment">	service：可以接收服务名，也可以接收字符串表示的十进制端口号。</span></span><br><span class="line"><span class="comment">	hints：应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。</span></span><br><span class="line"><span class="comment">		可以设置为NULL，表示允许getaddrinfo反馈任何可用的结果。</span></span><br><span class="line"><span class="comment">	result：指向一个链表，存储getaddrinfo反馈的结果（传出参数）。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功时返回0，失败则返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addrinfo结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ai_flags; <span class="comment">/*标志位，可以按位与*/</span></span><br><span class="line">    <span class="keyword">int</span> ai_family; <span class="comment">/*地址族*/</span> </span><br><span class="line">    <span class="keyword">int</span> ai_socktype; <span class="comment">/*服务类型，SOCK_STREAM或SOCK_DGRAM*/</span></span><br><span class="line">    <span class="keyword">int</span> ai_protocol; <span class="comment">/*具体的网络协议，通常设置为0*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> ai_addrlen; <span class="comment">/*socket地址ai_addr的长度*/</span> </span><br><span class="line">    <span class="keyword">char</span>* ai_canonname; <span class="comment">/*主机的别名*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/*指向socket地址*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/*指向下一个sockinfo结构的对象*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><img src="/20220723/image-20220725111725849.png" alt="image-20220725111725849"></p>
<p>使用hints参数的时候，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。</p>
<p>利用hints参数获取主机ernest-laptop上的“daytime”流服务信息：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">res</span>;</span></span><br><span class="line"><span class="built_in">bzero</span>(＆hints, <span class="built_in"><span class="keyword">sizeof</span></span>(hints)); </span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="built_in">getaddrinfo</span>(<span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, ＆hints, ＆res);</span><br></pre></td></tr></table></figure>

<p> getaddrinfo将隐式地分配堆内存（可以通过valgrind等工具查看），因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存： </p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>getnameinfo函数：通过socket地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数）。函数定义如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* sockaddr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">char</span>* host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span>* serv, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">	sockaddr：socket地址结构体</span></span><br><span class="line"><span class="comment">	addrlen：socket地址长度</span></span><br><span class="line"><span class="comment">	host：存储主机名</span></span><br><span class="line"><span class="comment">	hostlen：主机名长度</span></span><br><span class="line"><span class="comment">	serv：存储服务名</span></span><br><span class="line"><span class="comment">	servlen：服务名长度</span></span><br><span class="line"><span class="comment">	flags：控制getnameinfo的行为</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">	成功时返回0，失败则返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>

<p><img src="/20220723/image-20220725112716763.png" alt="image-20220725112716763"></p>
<p><img src="/20220723/image-20220725112747241.png" alt="image-20220725112747241"></p>
<p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。同样，下面的函数可将表5-8中的错误码转换成其字符串形式：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure>


    </div>

    
    
    
        

<div>
<ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者： </strong>Zhang Tong
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
    <a href="https://silver-eagle.top/posts/47fa327.html" title="Linux网络编程基础API">https://silver-eagle.top/posts/47fa327.html</a>
  </li>
  <li class="post-copyright-license">
    <strong>版权声明： </strong>本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/zh-CN" rel="noopener" target="_blank"><i class="fab fa-fw fa-creative-commons"></i>BY-NC-SA</a> 许可协议。转载请注明出处！
  </li>
</ul>
</div>


      <footer class="post-footer">
          
          <div class="post-tags">
              <a href="/tags/Linux%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" rel="tag"><i class="fa fa-tag"></i> Linux网络编程</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/posts/e017732d.html" rel="prev" title="面试金典题解">
      <i class="fa fa-chevron-left"></i> 面试金典题解
    </a></div>
      <div class="post-nav-item">
    <a href="/posts/4131876a.html" rel="next" title="Linux高级I/O函数">
      Linux高级I/O函数 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-socket%E5%9C%B0%E5%9D%80API"><span class="nav-number">1.</span> <span class="nav-text">1.socket地址API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F%E5%92%8C%E7%BD%91%E7%BB%9C%E5%AD%97%E8%8A%82%E5%BA%8F"><span class="nav-number">1.1.</span> <span class="nav-text">主机字节序和网络字节序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="nav-number">1.2.</span> <span class="nav-text">通用socket地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%93%E7%94%A8socket%E5%9C%B0%E5%9D%80"><span class="nav-number">1.3.</span> <span class="nav-text">专用socket地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#IP%E5%9C%B0%E5%9D%80%E8%BD%AC%E6%8D%A2%E5%87%BD%E6%95%B0"><span class="nav-number">1.4.</span> <span class="nav-text">IP地址转换函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%88%9B%E5%BB%BAsocket"><span class="nav-number">2.</span> <span class="nav-text">创建socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%91%BD%E5%90%8Dsocket"><span class="nav-number">3.</span> <span class="nav-text">命名socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%9B%91%E5%90%ACsocket"><span class="nav-number">4.</span> <span class="nav-text">监听socket</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%8E%A5%E5%8F%97%E8%BF%9E%E6%8E%A5"><span class="nav-number">5.</span> <span class="nav-text">接受连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%91%E8%B5%B7%E8%BF%9E%E6%8E%A5"><span class="nav-number">6.</span> <span class="nav-text">发起连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%85%B3%E9%97%AD%E8%BF%9E%E6%8E%A5"><span class="nav-number">7.</span> <span class="nav-text">关闭连接</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">8.</span> <span class="nav-text">数据读写</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#TCP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">8.1.</span> <span class="nav-text">TCP数据读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#UDP%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99"><span class="nav-number">8.2.</span> <span class="nav-text">UDP数据读写</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%9A%E7%94%A8%E6%95%B0%E6%8D%AE%E8%AF%BB%E5%86%99%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.</span> <span class="nav-text">通用数据读写函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E5%A4%96%E6%A0%87%E8%AE%B0"><span class="nav-number">9.</span> <span class="nav-text">带外标记</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%9C%B0%E5%9D%80%E4%BF%A1%E6%81%AF%E5%87%BD%E6%95%B0"><span class="nav-number">10.</span> <span class="nav-text">地址信息函数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#socket%E9%80%89%E9%A1%B9"><span class="nav-number">11.</span> <span class="nav-text">socket选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-REUSEADDR%E9%80%89%E9%A1%B9"><span class="nav-number">11.1.</span> <span class="nav-text">SO_REUSEADDR选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-RCVBUF%E5%92%8CSO-SNDBUF%E9%80%89%E9%A1%B9"><span class="nav-number">11.2.</span> <span class="nav-text">SO_RCVBUF和SO_SNDBUF选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-RCVLOWAT%E5%92%8CSO-SNDLOWAT%E9%80%89%E9%A1%B9"><span class="nav-number">11.3.</span> <span class="nav-text">SO_RCVLOWAT和SO_SNDLOWAT选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#SO-LINGER%E9%80%89%E9%A1%B9"><span class="nav-number">11.4.</span> <span class="nav-text">SO_LINGER选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BD%91%E7%BB%9C%E4%BF%A1%E6%81%AFAPI"><span class="nav-number">12.</span> <span class="nav-text">网络信息API</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#gethostbyname%E5%92%8Cgethostbyaddr"><span class="nav-number">12.1.</span> <span class="nav-text">gethostbyname和gethostbyaddr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getservbyname%E5%92%8Cgetservbyport"><span class="nav-number">12.2.</span> <span class="nav-text">getservbyname和getservbyport</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getaddrinfo"><span class="nav-number">12.3.</span> <span class="nav-text">getaddrinfo</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#getnameinfo"><span class="nav-number">12.4.</span> <span class="nav-text">getnameinfo</span></a></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Zhang Tong"
      src="/images/curry.jpg">
  <p class="site-author-name" itemprop="name">Zhang Tong</p>
  <div class="site-description" itemprop="description">Veni, Vidi, Vici</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">34</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">1</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">18</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="mailto:zt_scut@163.com" title="E-Mail → mailto:zt_scut@163.com" rel="noopener" target="_blank"><i class="fa fa-envelope fa-fw"></i>E-Mail</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 2021 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Zhang Tong</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-area"></i>
    </span>
    <span title="站点总字数">512k</span>
    <span class="post-meta-divider">|</span>
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:46</span>
</div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  




  
<script src="/js/local-search.js"></script>









<script>
document.querySelectorAll('.pdfobject-container').forEach(element => {
  let url = element.dataset.target;
  let pdfOpenParams = {
    navpanes : 0,
    toolbar  : 0,
    statusbar: 0,
    pagemode : 'thumbs',
    view     : 'FitH'
  };
  let pdfOpenFragment = '#' + Object.entries(pdfOpenParams).map(([key, value]) => `${key}=${encodeURIComponent(value)}`).join('&');
  let fullURL = `/lib/pdf/web/viewer.html?file=${encodeURIComponent(url)}${pdfOpenFragment}`;

  if (NexT.utils.supportsPDFs()) {
    element.innerHTML = `<embed class="pdfobject" src="${url + pdfOpenFragment}" type="application/pdf" style="height: ${element.dataset.height};">`;
  } else {
    element.innerHTML = `<iframe src="${fullURL}" style="height: ${element.dataset.height};" frameborder="0"></iframe>`;
  }
});
</script>




  

  

  


<!-- 页面点击小红心 -->
<script type="text/javascript" src="/js/cursor/clicklove.js"></script>
</body>
</html>
