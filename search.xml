<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>The End of 2022</title>
      <link href="/posts/ceebbd88/"/>
      <url>/posts/ceebbd88/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><iframe src="/images/2022.mp4" position="absolute" frameboder="0" width="100%" height="415" controls="controls" allow="encrypted-media" allowfullscreen></iframe><div style="border:silver 1px dashed;background-color: rgba(0, 0, 0, 0);width:fit-content;padding:12px;font-size: 12px;font-family: 微软雅黑; ">   <strong>免责声明：</strong><br>   &nbsp;&nbsp;&nbsp;&nbsp;本视频转自网络文章，转载此视频仅为个人收藏，分享知识，如有侵权，请联系<a target="_blank">博主</a>进行删除。<br>   &nbsp;&nbsp;&nbsp;&nbsp;原文作者：<a href="https://news.163.com/" target="_blank">网易新闻</a>   原文地址：<a>404</a></div>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>华为机考复盘</title>
      <link href="/posts/84f2e3b5/"/>
      <url>/posts/84f2e3b5/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="相等的IPV6地址"><a href="#相等的IPV6地址" class="headerlink" title="相等的IPV6地址"></a>相等的IPV6地址</h2><p>IPV6地址首选表示法：<code>x:x:x:x:x:x:x:x</code>，分为8段，每段x是4个字符的十六进制值，每段x地址范围从0000 至 ffff，字母大小写等价。</p><p>其他两种短格式缩写：</p><ul><li>省略前导零 通过省略前导零指定IPV6地址，例如，IPV6地址1050:0000:0000:0000:0005:0600:300c:326b 可写作 1050:0000:0:0:5:600:300c:326b 或 1050:0000:0:0000:5:600:300c:326b，都算为等价地址，但每一段需缩写完整，例如0030只能省略成30，不能省略成030.</li><li>双冒号 通过双冒号(::)替换一系列零（不小于2段）来指定IPV6地址。例如，IPV6地址ff06:0:0:0:1:0:0:c3 可写作ff06::1:0:0:c3 或ff06:0:0:0:1::c3，都算作等价地址。一个IP地址中只可以使用一次双冒号，并要求一系列零缩写完整，例如0:0:0:0 只能省略成 ::，不能省略成0::或0::0等。</li></ul><p>输入：一个字符串，合法的IPV6地址</p><p>输出：一个正整数，表示所有等价地址的数量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">样例1</span><br><span class="line">输入：1050:0:1000:1234:12:3450:1234:3269</span><br><span class="line">输出：4</span><br><span class="line">解释：需要考虑省略前导零，等价地址有：</span><br><span class="line">1050:0:1000:1234:12:3450:1234:3269</span><br><span class="line">1050:0000:1000:1234:12:3450:1234:3269</span><br><span class="line">1050:0:1000:1234:0012:3450:1234:3269</span><br><span class="line">1050:0000:1000:1234:0012:3450:1234:3269</span><br><span class="line"></span><br><span class="line">样例2</span><br><span class="line">输入：1050:0:0:1234:6789:3450:3333:3261</span><br><span class="line">输出：5</span><br><span class="line">解释：需要考虑省略前导零和双冒号，等价地址有：</span><br><span class="line">1050:0:0:1234:6789:3450:3333:3261</span><br><span class="line">1050:0000:0:1234:6789:3450:3333:3261</span><br><span class="line">1050:0:0000:1234:6789:3450:3333:3261</span><br><span class="line">1050:0000:0000:1234:6789:3450:3333:3261</span><br><span class="line">1050::1234:6789:3450:3333:3261</span><br><span class="line"></span><br><span class="line">样例3</span><br><span class="line">输入：1050:0:1000:1234:a000:3450:1234:3269</span><br><span class="line">输出：4</span><br><span class="line">解释：需要考虑省略前导零和字母大小写，等价地址有：</span><br><span class="line">1050:0:1000:1234:a000:3450:1234:3269</span><br><span class="line">1050:0000:1000:1234:a000:3450:1234:3269</span><br><span class="line">1050:0:1000:1234:A000:3450:1234:3269</span><br><span class="line">1050:0000:1000:1234:A000:3450:1234:3269</span><br></pre></td></tr></table></figure><p>解析：</p><ol><li>字符串分割，方便后续操作，末尾加上一个’:’，分割后存储在字符串数组v里边；</li><li>用一个tmp临时数组存储v，清空v，遍历tmp数组，将全为0的地址项置为”0”，遇到双冒号展开（某一地址项的长度为0），检测地址项长度和8的距离差，补全”0”。</li><li>枚举可能的双冒号：<ol><li>每一次可能的情况（哪几个0缩起来）进行一次枚举</li><li>每次枚举，我们需要考虑，前导零和大小写，前导零（<code>*2</code>），大小写（<code>*2</code>）</li></ol></li><li>累加所有的枚举</li></ol><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//#include&lt;bits/stdc++.h&gt;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回地址的组合数</span></span><br><span class="line"><span class="comment">// 遍历字符串数组，如果地址项长度小于4或地址项以0开头，res*=2，</span></span><br><span class="line"><span class="comment">// 遍历地址项，遇到字母（非数字字符）res*=2.</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve2</span><span class="params">(vector&lt;string&gt;&amp; v)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(string str : v) &#123;</span><br><span class="line"><span class="keyword">if</span>(str[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span> || str.<span class="built_in">size</span>() &lt; <span class="number">4</span>) &#123;</span><br><span class="line">res *= <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line"><span class="keyword">if</span>(c &lt; <span class="string">&#x27;0&#x27;</span> || c &gt; <span class="string">&#x27;9&#x27;</span> ) res *= <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回地址分割后的数组，(pre, i)之间的地址不保留，保留[0, pre]和[i, n]的地址</span></span><br><span class="line"><span class="function">vector&lt;string&gt; <span class="title">getSub</span><span class="params">(vector&lt;string&gt;&amp; v, <span class="keyword">int</span> pre, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">vector&lt;string&gt; tmp;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= pre; j++) &#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(v[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">tmp.<span class="built_in">push_back</span>(v[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">solve</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line"><span class="comment">// puts(&quot;hello&quot;);</span></span><br><span class="line">str += <span class="string">&quot;:&quot;</span>;</span><br><span class="line">vector&lt;string&gt; v;</span><br><span class="line">string tmpStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">    <span class="comment">// 字符串分割，得到输入的地址</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> c : str) &#123;</span><br><span class="line"><span class="keyword">if</span>(c == <span class="string">&#x27;:&#x27;</span>) &#123;</span><br><span class="line">v.<span class="built_in">push_back</span>(tmpStr);</span><br><span class="line">tmpStr = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">tmpStr += c;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">vector&lt;string&gt; tmp = v;</span><br><span class="line">v.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输入的地址进行调整，全为0的地址项变为&quot;0&quot;，输入含有双冒号的话进行展开</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; tmp.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(tmp[i] == <span class="string">&quot;00&quot;</span> || tmp[i] == <span class="string">&quot;000&quot;</span> || tmp[i] == <span class="string">&quot;0000&quot;</span>)&#123;</span><br><span class="line">tmp[i] = <span class="string">&quot;0&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(tmp[i].<span class="built_in">size</span>()) v.<span class="built_in">push_back</span>(tmp[i]);</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> cnt = <span class="number">8</span> - tmp.<span class="built_in">size</span>() + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(cnt--) v.<span class="built_in">push_back</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> pre = <span class="number">-1</span>; <span class="comment">//标记前一个不为&quot;0&quot;的地址项的位置</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line"><span class="keyword">if</span>(v[i] != <span class="string">&quot;0&quot;</span>) &#123; <span class="comment">// 地址项不为&quot;0&quot;</span></span><br><span class="line"><span class="keyword">if</span>(i - pre &gt; <span class="number">2</span>) &#123; <span class="comment">// 可以写为双冒号的情形</span></span><br><span class="line">tmp = <span class="built_in">getSub</span>(v, pre, i); <span class="comment">// 进行地址分割，删去地址为&quot;0&quot;项</span></span><br><span class="line">ans += <span class="built_in">solve2</span>(tmp); <span class="comment">// 加上该地址下的组合数</span></span><br><span class="line">&#125;</span><br><span class="line">pre = i; <span class="comment">// 更新pre</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span>(v.<span class="built_in">size</span>()- pre &gt; <span class="number">2</span>) &#123; <span class="comment">// 末尾项有连续的0，即双冒号在末尾位置</span></span><br><span class="line">tmp = <span class="built_in">getSub</span>(v, pre, v.<span class="built_in">size</span>());</span><br><span class="line">ans += <span class="built_in">solve2</span>(tmp);</span><br><span class="line">&#125;</span><br><span class="line">ans += <span class="built_in">solve2</span>(v); <span class="comment">// 加上不考虑双冒号的地址组合情况</span></span><br><span class="line"><span class="keyword">return</span> ans;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">string str;</span><br><span class="line">cin &gt;&gt; str;</span><br><span class="line"><span class="comment">// str = &quot;1050:0:1000:1234:12:3450:1234:3269&quot;;</span></span><br><span class="line"><span class="comment">// str = &quot;1050:0:0:1234:6789:3450:3333:3261&quot;;</span></span><br><span class="line"><span class="comment">// str = &quot;1050:0:1000:1234:a000:3450:1234:3269&quot;;</span></span><br><span class="line">cout &lt;&lt; <span class="built_in">solve</span>(str) &lt;&lt; endl;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="游览小镇"><a href="#游览小镇" class="headerlink" title="游览小镇"></a>游览小镇</h2><p>需要规划一条路线，保证能游览完所有的小镇，同时走的路程（走过的路径之和）最短。</p><p>假定：</p><ol><li>有些小镇之间有路径直接相连，有些小镇之间不直接相连；所有小镇都至少跟其他一个小镇相连；</li><li>可以在任意小镇出发和停止，可以多次访问同一个小镇；</li><li>路径无方向（可以从A到B，也可以从B到A）；可以多次通过同一条路径；相连接的小镇间的路径长度相当；</li><li>小镇编号从1开始。</li></ol><p>输入</p><ol><li>假定有N个小镇（3&lt;=N&lt;=16），则输入N+1行数据</li><li>第一行输入N，表示小镇的数量；接下去N行是各个小镇的邻接信息。</li><li>第i+1行数据里包含n(1&lt;=n&lt;=N-1)个数据，且不会包含i本身，即不存在从i到i小镇的路径。</li><li>如果存在联通i(1&lt;=i&lt;=N)与j(1&lt;=i&lt;=N)的路径，那么这条路径在第i+1行和第j+1行都会出现。</li></ol><p>输出</p><p>能够访问所有小镇的最短路径长度；假如不存在可以访问所有小镇的路径，则输出-1</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">样例1</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">2 4</span><br><span class="line">1 3</span><br><span class="line">2 4</span><br><span class="line">1 3 5</span><br><span class="line">4</span><br><span class="line">输出：</span><br><span class="line">4</span><br><span class="line">解释：一个5个点。1号与2、4相连，2号与1、3相连，3号与2、4相连，4号与1、3、5号相连，5号与4号相连。</span><br><span class="line"></span><br><span class="line">样例2</span><br><span class="line">输入：</span><br><span class="line">5</span><br><span class="line">2 4</span><br><span class="line">1 </span><br><span class="line">4</span><br><span class="line">1 3 5</span><br><span class="line">4</span><br><span class="line">输出：</span><br><span class="line">5</span><br><span class="line">解释：一个5个点。1号与2、4相连，2号与1相连，3号与4相连，4号与1、3、5号相连，5号与4号相连。</span><br></pre></td></tr></table></figure><p>解析：</p><p>状态压缩dp，用一个二进制数位上的0或1，代表不同的状态（取1代表位于集合中）。用二进制表示所有物品的放与不放的情况，这些二进制用十进制表示就一个维度，这个维度能表示所有物品放与不放的情况，即状态压缩。</p><p>假设每个边的权值都为1，权值矩阵w存储每个节点直接的连接情况，两点之间存在边则权值为1，不存在边则权值为inf。</p><p>初始化状态矩阵<code>dp[i][j]</code>，i表示状态，j表示结尾的地方。</p><p>求最短的路径和，采用Floyd算法求最短路径，是一种插点法，通过3重循环，k为中转点，v为起点，w为终点，循环比较<code>D[v][w]</code> 和 <code>D[v][k] + D[k][w] </code>最小值，如果<code>D[v][k] + D[k][w] </code>为更小值，则把<code>D[v][k] + D[k][w] </code>覆盖保存在<code>D[v][w]</code>中。</p><p>dp转移方程，首先枚举状态，再枚举这次要访问的点，第j位置上为1，循环遍历点k，如果k这个点在当前的状态（j不在状态集合）中，比较当前状态与从k这个点的状态转移过来的最小值，即<code>dp[i][j]=min(dp[i-(1&lt;&lt;j)][k]+w[k][j],dp[i][j]);</code></p><p>循环遍历结尾点i，更新路径和最小值<code>mn = min(mn,dp[(1&lt;&lt;n)-1][i])</code>，<code>dp[(1&lt;&lt;n)-1][i]</code>指的是结尾点为i，n位集合上全为1，代表所有节点都访问过。</p><p>代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">50</span>;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">1</span>&lt;&lt;<span class="number">20</span>][<span class="number">50</span>];<span class="comment">//i是状态，j是结尾的地方</span></span><br><span class="line"><span class="keyword">int</span> w[<span class="number">50</span>][<span class="number">50</span>]; <span class="comment">//边的权值</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="built_in">getchar</span>();</span><br><span class="line">    <span class="built_in">memset</span>(w,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> w); <span class="comment">//将边的权值初始化为无穷大</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">        string str;</span><br><span class="line">        <span class="built_in">getline</span>(cin, str);</span><br><span class="line">        <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; str.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(str[j] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span>(tmp == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//设置i与tmp-1的边，把点的id设为从0开始</span></span><br><span class="line">                w[i][tmp - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">                w[tmp - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">                tmp = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//保存点的序号比如输入的是13</span></span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                那就是 tmp = 0*10 + 1</span></span><br><span class="line"><span class="comment">                           = 1*10 + 3</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">                tmp = tmp * <span class="number">10</span> + (str[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tmp) &#123;</span><br><span class="line">            <span class="comment">//设置边，节点编号是从1开始的，因此需要减一</span></span><br><span class="line">            w[tmp - <span class="number">1</span>][i] = <span class="number">1</span>;</span><br><span class="line">            w[i][tmp - <span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Folyd求最短路</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(w[i][j] &gt; w[i][k] + w[k][j])&#123;</span><br><span class="line">                    w[i][j] = w[i][k] + w[k][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化dp数组无穷大</span></span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">0x3f</span>, <span class="keyword">sizeof</span> dp);</span><br><span class="line">    <span class="comment">//设置起点为i的坐标为0</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n; i++) &#123;</span><br><span class="line">        dp[<span class="number">1</span> &lt;&lt; i][i]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    <span class="comment">//状压dp,枚举状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; (<span class="number">1</span>&lt;&lt;n); i++)&#123;</span><br><span class="line">        <span class="comment">//枚举这次要访问的点</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>((i &gt;&gt; j) &amp; <span class="number">1</span>)&#123; <span class="comment">// 第j位置为1</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; n; k++)&#123;</span><br><span class="line">                    <span class="comment">//k这个点在当前状态中</span></span><br><span class="line">                    <span class="keyword">if</span>(((i - (<span class="number">1</span>&lt;&lt;j)) &gt;&gt; k) &amp; <span class="number">1</span>)&#123; <span class="comment">// 第k位置为1</span></span><br><span class="line">                        <span class="comment">//就是从排除k这个点的状态转移过来更小还是就是当前状态的更小</span></span><br><span class="line">                        dp[i][j] = <span class="built_in">min</span>(dp[i - (<span class="number">1</span>&lt;&lt;j)][k] + w[k][j], dp[i][j]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mn = <span class="number">100000000</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++) &#123;</span><br><span class="line">    mn=<span class="built_in">min</span>(mn, dp[(<span class="number">1</span>&lt;&lt;n) - <span class="number">1</span>][i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(mn == <span class="number">100000000</span>)  &#123;</span><br><span class="line">        cout &lt;&lt; <span class="number">-1</span> &lt;&lt; endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cout&lt;&lt;mn&lt;&lt;endl;    </span><br><span class="line">    &#125;                </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>面试复习总结</title>
      <link href="/posts/65fbd269/"/>
      <url>/posts/65fbd269/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Linux网络编程相关"><a href="#Linux网络编程相关" class="headerlink" title="Linux网络编程相关"></a>Linux网络编程相关</h2><h3 id="概念说明"><a href="#概念说明" class="headerlink" title="概念说明"></a>概念说明</h3><h4 id="用户空间与内核空间"><a href="#用户空间与内核空间" class="headerlink" title="用户空间与内核空间"></a>用户空间与内核空间</h4><p>对32位操作系统而言，它的寻址空间（虚拟存储空间）为4G（2的32次方）。</p><p>为了保证用户进程不能直接操作内核（kernel），保证内核的安全，操心系统将虚拟空间划分为两部分，一部分为内核空间，一部分为用户空间。在Linux系统下：</p><ul><li>内核空间：最高的1G字节（从虚拟地址0xC0000000到0xFFFFFFFF），供内核使用。</li><li>用户空间：将较低的3G字节（从虚拟地址0x00000000到0xBFFFFFFF），供各个进程使用。</li></ul><h4 id="进程切换"><a href="#进程切换" class="headerlink" title="进程切换"></a>进程切换</h4><p>进程切换：为了控制进程的执行，内核必须有能力挂起正在CPU上运行的进程，并恢复以前挂起的某个进程的执行。从一个进程的运行转到另一个进程上运行，这个过程中经过下面这些变化：</p><ol><li>保存处理机上下文，包括程序计数器和其他寄存器。</li><li>更新PCB信息。</li><li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li><li>选择另一个进程执行，并更新其PCB。</li><li>更新内存管理的数据结构。</li><li>恢复处理机上下文。</li></ol><p>进程的切换<strong>很耗资源</strong>。</p><h4 id="进程阻塞"><a href="#进程阻塞" class="headerlink" title="进程阻塞"></a>进程阻塞</h4><p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新工作做等，则由系统自动执行阻塞原语(Block)，使自己由运行状态变为阻塞状态。</p><p>进程的阻塞是进程自身的一种主动行为，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞状态。<strong>当进程进入阻塞状态，是不占用CPU资源的。</strong></p><h4 id="文件描述符"><a href="#文件描述符" class="headerlink" title="文件描述符"></a>文件描述符</h4><p>适用于UNIX，Linux系统。文件描述符（File descriptor）是计算机科学中的一个术语，是一个用于表述<strong>指向文件的引用</strong>的抽象化概念。</p><p>文件描述符在形式上是一个<strong>非负整数</strong>。实际上，它是一个<strong>索引值</strong>，指向<strong>内核为每一个进程所维护的该进程打开文件的记录表</strong>。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><h4 id="缓存IO"><a href="#缓存IO" class="headerlink" title="缓存IO"></a>缓存IO</h4><p>缓存 I/O 又被称作标准 I/O，大多数文件系统的默认 I/O 操作都是缓存 I/O。</p><p>在Linux的缓存 I/O 机制中，操作系统会将 I/O 的数据缓存在文件系统的<strong>页缓存（page cache）</strong>中，也就是说，<strong>数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间</strong>。</p><p><strong>缓存IO缺点：</strong>数据在传输过程中需要在应用程序地址空间和内核进行多次数据拷贝操作，这些数据拷贝操作所带来的 CPU 以及内存开销是非常大的。</p><h3 id="IO模式"><a href="#IO模式" class="headerlink" title="IO模式"></a>IO模式</h3><p>对于一次IO访问（以read举例），会经历两个阶段：</p><ul><li>等待数据准备 (Waiting for the data to be ready)</li><li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li></ul><p>Linux系统产生了下面五种网络模式：</p><ul><li>阻塞IO</li><li>非阻塞IO</li><li>IO多路复用</li><li>信号驱动IO （实际中不常用）</li><li>异步IO</li></ul><h4 id="阻塞IO"><a href="#阻塞IO" class="headerlink" title="阻塞IO"></a>阻塞IO</h4><p>Linux系统中默认情况下，所有的socket都是阻塞的，一个典型的读操作流程大概是这样：</p><p><img src="/20220923/bVm1c3" alt="clipboard.png"></p><p>当用户进程调用了recvfrom这个系统调用，kernel就开始了IO的第一个阶段：准备数据。</p><p>数据被拷贝到操作系统内核的缓冲区中是需要一个过程的。而在用户进程这边，整个进程会被阻塞（当然，是进程自己选择的阻塞）。当kernel一直等到数据准备好了，它就会将数据从kernel中拷贝到用户内存，然后kernel返回结果，用户进程才解除block的状态，重新运行起来。</p><p><strong>阻塞IO特点</strong>：在IO执行的两个阶段都被阻塞了。</p><h4 id="非阻塞IO"><a href="#非阻塞IO" class="headerlink" title="非阻塞IO"></a>非阻塞IO</h4><p>设置socket为非阻塞的，当对一个非阻塞的socket执行读操作的流程：</p><p><img src="/20220923/bVm1c4" alt="clipboard.png"></p><p>当用户进程发出read操作时，如果kernel中的数据还没有准备好，那么它并不会block用户进程，而是立刻返回一个error。从用户进程角度讲 ，它发起一个read操作后，并不需要等待，而是马上就得到了一个结果。</p><p>一旦kernel中的数据准备好了，并且又再次收到了用户进程的system call，那么它马上就将数据拷贝到了用户内存，然后返回。</p><p><strong>非阻塞IO特点：</strong>用户进程需要<strong>不断的主动询问</strong>kernel数据好了没有。</p><h4 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h4><p>IO多路复用主要指的就是select、poll、epoll这几个关键字。</p><p>I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll本质上都是<strong>同步I/O</strong>，因为他们都需要在读写事件就绪后，自己负责进行读写，也就是说这个<strong>读写过程是阻塞的</strong>，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。</p><p><img src="/20220923/bVm1c5" alt="clipboard.png"></p><p><strong>当用户进程调用了select，那么整个进程会被阻塞</strong>，而同时，kernel会“监视”所有select负责的socket，当任何一个socket中的数据准备好了，select就会返回。这个时候用户进程再调用read操作，将数据从kernel拷贝到用户进程。</p><p><strong>IO多路复用的特点：</strong>通过一种机制一个进程能同时等待多个文件描述符，而这些文件描述符（套接字描述符）其中的任意一个进入读就绪状态，select()函数就可以返回。</p><p>和非阻塞IO相比，用select的优势在于它可以同时处理多个connection。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><p>实际中，对于每一个socket，一般都设置成为非阻塞的，整个用户的process其实是一直被block的。只不过process是被select这个函数block，而不是被socket IO给block。</p><h4 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h4><p>Linux下的异步IO使用较少。</p><p><img src="/20220923/bVm1c8" alt="clipboard.png"></p><p>用户进程发起read操作之后，立刻就可以开始去做其它的事。而另一方面，从kernel的角度，当它受到一个asynchronous read之后，首先它会立刻返回，所以不会对用户进程产生任何block。</p><p>然后，kernel会等待数据准备完成，然后将数据拷贝到用户内存，当这一切都完成之后，kernel会给用户进程发送一个signal，告诉它read操作完成了。</p><p><strong>各个IO Model的比较如图所示：</strong></p><p><img src="/20220923/bVm1c9" alt="clipboard.png"></p><p>调用阻塞IO会一直阻塞住对应的进程直到操作完成，而非阻塞IO在内核还准备数据的情况下会立即返回。</p><p>非阻塞IO虽然大部分时间都不会被阻塞，但它仍要求进程去主动的check，当数据准备完成后，也需要进程主动的再次调用recvfrom来将数据拷贝到用户内存。而异步IO完全不同，它就像是用户进程将整个IO操作交给了他人（kernel）完成，然后他人做完后发信号通知。在此期间，用户进程不需要去检查IO操作的状态，也不需要主动的去拷贝数据。</p><h3 id="IO复用select、poll、epoll详解"><a href="#IO复用select、poll、epoll详解" class="headerlink" title="IO复用select、poll、epoll详解"></a>IO复用select、poll、epoll详解</h3><h4 id="select模式"><a href="#select模式" class="headerlink" title="select模式"></a>select模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span> <span class="params">(<span class="keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;</span><br></pre></td></tr></table></figure><p>select 函数监视的文件描述符分3类，分别是writefds、readfds、和exceptfds。调用后select函数会阻塞，直到有描述符就绪（有数据可读可写或者有异常），或者超时（timeout指定等待时间，如果立即返回设为null即可），函数返回。当select函数返回后，可以 通过遍历fdset，来找到就绪的描述符。</p><p>优点：几乎在所有的平台上支持，良好跨平台支持。</p><p>缺点：单个进程能够监视的文件描述符的数量存在最大限制，在Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但 是这样也会造成效率的降低。</p><h4 id="poll模式"><a href="#poll模式" class="headerlink" title="poll模式"></a>poll模式</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span> <span class="params">(struct pollfd *fds, <span class="keyword">unsigned</span> <span class="keyword">int</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd; <span class="comment">/* file descriptor */</span></span><br><span class="line">    <span class="keyword">short</span> events; <span class="comment">/* requested events to watch */</span></span><br><span class="line">    <span class="keyword">short</span> revents; <span class="comment">/* returned events witnessed */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>不同于select使用三个位图来表示fdset，poll使用一个 pollfd的指针实现。</p><p>pollfd结构包含了要监视的event和发生的event，不再使用select“参数-值”传递的方式。</p><p>同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。<strong>和select函数一样，poll返回后，需要轮询pollfd来获取就绪的描述符。</strong></p><p>从上面看，select和poll都需要在返回后，通过遍历文件描述符来获取已经就绪的socket。事实上，同时连接的大量客户端在一时刻可能只有很少的处于就绪状态，因此<strong>随着监视的描述符数量的增长，其效率也会线性下降。</strong></p><h4 id="epoll模式"><a href="#epoll模式" class="headerlink" title="epoll模式"></a>epoll模式</h4><p>相对于select和poll来说，epoll更加灵活，没有描述符限制。<strong>epoll使用一个文件描述符管理多个描述符，将用户关系的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的copy只需一次。</strong></p><h5 id="epoll操作过程："><a href="#epoll操作过程：" class="headerlink" title="epoll操作过程："></a><strong>epoll操作过程</strong>：</h5><p>epoll操作过程需要三个接口，分别如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span>；<span class="comment">//创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event *event)</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event * events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br></pre></td></tr></table></figure><p><strong>int epoll_create(int size);</strong></p><p>创建一个epoll的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于select()中的第一个参数，给出最大监听的fd+1的值，<strong>参数size并不是限制了epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。</strong></p><p>返回值：<strong>额外的文件描述符，唯一标识内核中的事件表。</strong></p><p><strong>int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event)；</strong></p><p>对指定描述符fd执行op操作。</p><ul><li>epfd：是epoll_create()的返回值。额外的文件描述符，唯一标识内核中的事件表。</li><li>op：表示op操作，用三个宏来表示：添加EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改EPOLL_CTL_MOD。分别添加、删除和修改对fd的监听事件。</li><li>fd：是需要监听的fd（文件描述符）</li><li>epoll_event：指定事件，是告诉内核需要监听什么事，struct epoll_event结构如下：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">  <span class="keyword">__uint32_t</span> events;  <span class="comment">/* Epoll events */</span></span><br><span class="line">  <span class="keyword">epoll_data_t</span> data;  <span class="comment">/* User data variable */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//events可以是以下几个宏的集合：</span></span><br><span class="line">EPOLLIN ：表示对应的文件描述符可以读（包括对端SOCKET正常关闭）；</span><br><span class="line">EPOLLOUT：表示对应的文件描述符可以写；</span><br><span class="line">EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；</span><br><span class="line">EPOLLERR：表示对应的文件描述符发生错误；</span><br><span class="line">EPOLLHUP：表示对应的文件描述符被挂断；</span><br><span class="line">EPOLLET： 将EPOLL设为边缘触发(Edge Triggered)模式，这是相对于水平触发(Level Triggered)来说的。</span><br><span class="line">EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个socket的话，需要再次把这个socket加入到EPOLL队列里</span><br></pre></td></tr></table></figure><p>返回值：成功返回0，失败返回-1并设置errno。</p><p><strong>int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout);</strong></p><p>在一段超时时间内，等待一组文件描述符上的事件，等待epfd上的io事件，最多返回maxevents个事件（最多监听多少个事件，必须大于0）。</p><p>参数events用来从内核得到事件的集合，maxevents告之内核这个events有多大，这个maxevents的值不能大于创建epoll_create()时的size，参数timeout是超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p><p>所有就绪的事件从内核事件表（epfd指定）复制到events指向的数组，events输出 epoll_wait 检测到的就绪事件 ，而不像select和poll的数组参数，既用于传入用户注册添加的事件，又用于输出内核检测到的就绪事件。这极大提高了应用程序索引就绪文件描述符的效率。</p><h5 id="工作模式"><a href="#工作模式" class="headerlink" title="工作模式"></a>工作模式</h5><p>epoll对文件描述符的操作有两种模式：<strong>LT（level trigger）水平触发</strong> 和<strong>ET（edge trigger）边缘触发</strong>。LT模式是默认模式，LT模式与ET模式的区别如下：</p><ul><li><strong>LT模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序可以不立即处理该事件</strong>。下次调用epoll_wait时，会再次响应应用程序并通知此事件。</li><li><strong>ET模式</strong>：当epoll_wait检测到描述符事件发生并将此事件通知应用程序，<strong>应用程序必须立即处理该事件</strong>。如果不处理，下次调用epoll_wait时，不会再次响应应用程序并通知此事件。</li></ul><ol><li>LT模式</li></ol><p><strong>LT(level triggered)是缺省的工作方式，并且同时支持阻塞和非阻塞socket。</strong>在这种做法中，内核告诉你一个文件描述符是否就绪了，然后你可以对这个就绪的fd进行IO操作。如果你不作任何操作，内核还是会继续通知你的。</p><ol start="2"><li>ET模式</li></ol><p><strong>ET(edge-triggered)是高速工作方式，只支持非阻塞socket。</strong>在这种模式下，当描述符从未就绪变为就绪时，内核通过epoll告诉你。然后它会假设你知道文件描述符已经就绪，并且不会再为那个文件描述符发送更多的就绪通知，直到你做了某些操作导致那个文件描述符不再为就绪状态了(比如，你在发送，接收或者接收请求，或者发送接收的数据少于一定量时导致了一个EWOULDBLOCK 错误）。但是请注意，如果一直不对这个fd作IO操作(从而导致它再次变成未就绪)，内核不会发送更多的通知(only once)</p><p><strong>ET模式在很大程度上减少了epoll事件被重复触发的次数，因此效率要比LT模式高。epoll工作在ET模式的时候，必须使用非阻塞套接口，以避免由于一个文件句柄的阻塞读/阻塞写操作把处理多个文件描述符的任务饿死。</strong></p><p><strong>epoll的优点</strong>主要是以下几个方面：</p><p>1、<strong>监视的描述符数量不受限制，它所支持的FD上限是最大可以打开文件的数目</strong>，这个数字一般远大于2048,举个例子,在1GB内存的机器上大约是10万左 右，具体数目可以cat /proc/sys/fs/file-max察看,一般来说这个数目和系统内存关系很大。select的最大缺点就是进程打开的fd是有数量限制的。这对 于连接数量比较大的服务器来说根本不能满足。虽然也可以选择多进程的解决方案( Apache就是这样实现的)，不过虽然linux上面创建进程的代价比较小，但仍旧是不可忽视的，加上进程间数据同步远比不上线程间同步的高效，所以也不是一种完美的方案。</p><p>2、IO的效率不会随着监视fd的数量的增长而下降。epoll不同于select和poll轮询的方式，而是<strong>通过每个fd定义的回调函数来实现的。只有就绪的fd才会执行回调函数</strong>。</p><p>如果没有大量的idle -connection(空闲连接)或者dead-connection，epoll的效率并不会比select/poll高很多，但是当遇到大量的idle- connection，就会发现epoll的效率大大高于select/poll。</p><h4 id="三组IO复用函数的比较"><a href="#三组IO复用函数的比较" class="headerlink" title="三组IO复用函数的比较"></a>三组IO复用函数的比较</h4><p>select、poll、epoll三组IO复用系统调用，都能同时监听多个文件描述符，等待timeout指定的超时时间，直到一个或多个文件描述符上有事件发生时返回，返回值是就绪的文件描述符的数量，返回0表示没有事件发生。这三组函数都是通过某种结构体变量来告诉内核监听哪些文件描述符上的哪些事件，并使用该结构体类型的参数来获取内核处理的结果。</p><ul><li>select的参数类型fd_set，<strong>没有将文件描述符与事件绑定</strong>，仅仅是一个文件描述符的集合，因此，select需提供3个这种类型的参数来分别传入和输出可读、可写、异常等事件。这使得select不能处理更多类型的事件，又由于内核对fd_set集合的在线修改，应用程序下次调用select前需要重置这3个fd_set集合。</li><li>poll的参数类型pollfd，它把文件描述符和事件都定义在其中，统一处理所有事件类型，只需一个事件集参数。内核每次修改的都是pollfd结构体中的revents成员（反馈就绪的事件），而events成员（用户传入的感兴趣事件）保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。由于每次<strong>select和poll调用都是返回整个用户注册添加的事件集合（其中包括就绪与未就绪的），所以应用程序索引就绪文件描述符的时间复杂度为O(n)。</strong>select和poll都只能工作在相对低效的<strong>LT模式</strong>，实现原理上采用的都是<strong>轮询</strong>的方式检测就绪事件，每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，所以**时间复杂度为O(n)**。</li><li>epoll在内核中维护一个事件表，直接管理用户感兴趣的所有事件，并提供一个独立的系统调用epoll_ctl来控制往其中添加、修改、删除事件。每次<strong>epoll_wait调用都是直接从内核事件表中取得用户注册添加的事件，而无须反复从用户空间读入这些事件</strong>。epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得<strong>应用程序索引就绪文件描述符的时间复杂度为O(1)。</strong>epoll可以工作在<strong>ET高效模式，</strong>还支持EPOLLONESHOT事件，进一步减少可读、可写和异常等事件被触发的次数。实现原理上采用的是<strong>回调</strong>的方式检测就绪事件，内核检测到就绪的文件描述符时，将触发回调函数，回调函数将该文件描述符上对应的事件插入到内核就绪事件队列，内核最后在合适的时机将该就绪队列中的内容拷贝到用户空间。因此，epoll_wait无须轮询整个文件描述符集合，**时间复杂度为O(1)**。</li></ul><h2 id="Mysql数据库"><a href="#Mysql数据库" class="headerlink" title="Mysql数据库"></a>Mysql数据库</h2><h3 id="事务管理"><a href="#事务管理" class="headerlink" title="事务管理"></a>事务管理</h3><p><strong>事务：</strong>一组数据库操作命令（sql语句），其执行的结果必须使数据库从一种一致性状态变到另一种一致性状态。事务把所有的命令作为一个整体一起向系统提交或撤销操作请求，即这一组数据库命令要么都执行，要么都不执行，因此事务是一个不可分割的工作逻辑单元。</p><p>事务是保持 <strong>逻辑数据一致性</strong> 和 <strong>可恢复性</strong> 的重要利器。而锁是实现事务的关键，可以保证事务的完整性和并发性。</p><h4 id="事务特性"><a href="#事务特性" class="headerlink" title="事务特性"></a>事务特性</h4><p>四个特性ACID，<strong>关系型数据库</strong> 需要遵循 ACID 规则。</p><ul><li>原子性：事务是最小的执行单位，不可分割的（原子的）。事务的原子性确保动作要么全部执行，要么全部不执行。</li><li>一致性：当事务完成时，数据必须处于一致状态，多个事务对同一个数据读取的结果是相同的。</li><li>隔离性：<strong>并发访问数据库</strong> 时，一个用户的事务不被其他事务所干扰，各个事务不干涉内部的数据。</li><li>持久性：一个事务被提交之后，它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p><strong>事务特性的实现：</strong></p><ul><li>DBMS 采用 日志 来保证事务的 原子性、一致性 和 持久性。日志记录了事务对数据库所做的更新，如果某个事务在执行过程中发生错误，就可以根据日志，撤销事务对数据库已做的更新，使数据库退回到执行事务前的初始状态。</li><li>DBMS 采用 锁机制 来实现事务的隔离性。当多个事务同时更新数据库中相同的数据时，只允许 持有锁的事务 能更新该数据，其他事务必须等待，直到前一个事务释放了锁，其他事务才有机会更新该数据。</li></ul><h4 id="事务之间的相互影响"><a href="#事务之间的相互影响" class="headerlink" title="事务之间的相互影响"></a>事务之间的相互影响</h4><p>在同时处理多个事务的时候，就可能出现脏读（dirty read）、不可重复读（non-repeatable read）、幻读（phantom read）的问题。</p><ul><li>脏读：一个事务读到了另一个事务未提交的数据。</li><li>不可重复读：在一个事务内多次读取同一个数据，出现前后两次读到的数据不一样的情况。这是因为在此间隔内有其他事务对数据进行了修改。</li><li>幻读：当事务 <strong>不是独立执行时</strong> 发生的一种现象。在一个事务内多次查询某个符合查询条件的「记录数量」，出现前后两次查询到的记录数量不一样的情况。</li><li>丢失更新：两个事务同时读取同一条记录，事务 A 先修改记录，事务 B 也修改记录（B 是不知道 A 修改过），当 B 提交数据后， 其修改结果覆盖了 A 的修改结果，导致事务 A 更新丢失。</li></ul><h4 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h4><p>SQL 标准定义了 4 种不同的事务隔离级。即 <strong>并发事务对同一资源的读取深度层次</strong>，由低到高依次是 <strong>读取未提交</strong>（READ-UNCOMMITTED）、<strong>读取已提交</strong>（READ-COMMITTED）、可重复读（REPEATABLE-READ）、<strong>可串行化</strong>（SERIALIZABLE）</p><ul><li>读取未提交：指一个事务还没提交时，它做的变更就能被其他事务看到；最低的隔离级别。</li><li>读取已提交：指一个事务提交之后，它做的变更才能被其他事务看到；可以解决 <strong>脏读问题</strong>。</li><li>可重复读：指一个事务执行过程中看到的数据，一直跟这个事务启动时看到的数据是一致的，<strong>MySQL InnoDB 引擎的默认隔离级别</strong>；可以解决 <strong>脏读、不可重复读</strong>。</li><li>串行化：会对记录加上读写锁，在多个事务对这条记录进行读写操作时，如果发生了读写冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行；隔离级别最高，完全服从 ACID，牺牲了系统的并发性。</li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><h4 id="索引数据结构"><a href="#索引数据结构" class="headerlink" title="索引数据结构"></a>索引数据结构</h4><p>根据结构分类：</p><ul><li>B+树索引： <strong>平衡树索引</strong>，是 MySQL 数据库中使用最频繁的索引类型，MySQL、Oracle 和 SQL Server 数据库默认的都是 B+ 树索引。</li><li>Hash索引：采用一定的 <strong>哈希算法</strong>，将数据库字段数据转换成定长的 Hash 值，与这条数据的行指针一并存入 Hash 表的对应位置，如果发生 Hash 碰撞（两个不同关键字的 Hash 值相同），则在对应 Hash 键下以 链表形式 存储。</li><li>位图索引：为存储在某列中的每个值生成一个位图，查询时一行行扫描所有记录。位图索引适合静态数据，而不适合索引频繁更新的列。</li></ul><p>根据字段特性：</p><ul><li><p>主键索引：建立在主键字段上的索引，通常在创建表的时候一起创建，一张表最多只有一个主键索引，索引列的值不允许有空值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name  (</span><br><span class="line">  ....</span><br><span class="line">  PRIMARY KEY (index_column_1) USING BTREE</span><br><span class="line">);</span><br></pre></td></tr></table></figure></li><li><p>唯一索引：建立在 UNIQUE 字段上的索引，一张表可以有多个唯一索引，索引列的值必须唯一，但是允许有空值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name  (</span><br><span class="line">  ....</span><br><span class="line">  UNIQUE KEY(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>建表后，如果要创建唯一索引，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE UNIQUE INDEX index_name</span><br><span class="line">ON table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure></li><li><p>普通索引：建立在普通字段上的索引，既不要求字段为主键，也不要求字段为 UNIQUE。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name  (</span><br><span class="line">  ....</span><br><span class="line">  INDEX(index_column_1,index_column_2,...) </span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>建表后，如果要创建普通索引，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name(index_column_1,index_column_2,...); </span><br></pre></td></tr></table></figure></li><li><p>前缀索引：对字符类型字段的前几个字符建立的索引，而不是在整个字段上建立的索引，前缀索引可以建立在字段类型为 char、 varchar、binary、varbinary 的列上。使用前缀索引的目的是为了减少索引占用的存储空间，提升查询效率。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">CREATE TABLE table_name(</span><br><span class="line">    column_list,</span><br><span class="line">    INDEX(column_name(length))</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>建表后，如果要创建前缀索引，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_name</span><br><span class="line">ON table_name(column_name(length)); </span><br></pre></td></tr></table></figure></li></ul><p>按字段个数：</p><ul><li><p>单列索引：建立在单列上的索引称为单列索引，比如主键索引；</p></li><li><p>建立在多列上的索引称为联合索引；使用联合索引时，存在<strong>最左匹配原则</strong>，也就是按照最左优先的方式进行索引的匹配。MySQL 会一直向右匹配直到遇到 <strong>范围查询</strong>（&gt;、&lt;、between、like）就停止匹配，<strong>范围列可以用到联合索引，但是范围列后面的列无法用到联合索引</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CREATE INDEX index_product_no_name ON product(product_no, name);</span><br></pre></td></tr></table></figure></li></ul><p><img src="/20220923/%E7%B4%A2%E5%BC%95%E6%80%BB%E7%BB%93.drawio.png" alt="img"></p><h3 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h3><p>根据加锁范围，可以分为全局锁、表级锁和行锁。</p><h4 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h4><p>要使用全局锁，则要执行这条命：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flush tables with read lock</span><br></pre></td></tr></table></figure><p>执行后，<strong>整个数据库就处于只读状态了</strong>，这时其他线程执行以下操作，都会被阻塞：</p><ul><li>对数据的增删改操作，比如 insert、delete、update等语句；</li><li>对表结构的更改操作，比如 alter table、drop table 等语句。</li></ul><p>如果要释放全局锁，则要执行这条命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>当然，当会话断开了，全局锁会被自动释放。</p><p>应用场景：全局锁主要应用于做<strong>全库逻辑备份</strong>，这样在备份数据库期间，不会因为数据或表结构的更新，而出现备份文件的数据与预期的不一样。</p><p>缺点：加上全局锁，意味着整个数据库都是只读状态。如果数据库里有很多数据，备份就会花费很多的时间，关键是备份期间，业务只能读数据，而不能更新数据，这样会造成业务停滞。</p><p>备份数据库的工具是 mysqldump，在使用 mysqldump 时加上 <code>–single-transaction</code> 参数的时候，就会在备份数据库之前先开启事务。这种方法只适用于支持「可重复读隔离级别的事务」的存储引擎。</p><p>InnoDB 存储引擎默认的事务隔离级别正是可重复读，因此可以采用这种方式来备份数据库。</p><p>但是，对于 MyISAM 这种不支持事务的引擎，在备份数据库时就要使用全局锁的方法。</p><h4 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h4><p>MySQL 里面表级别的锁有这几种：</p><ul><li>表锁；</li><li>元数据锁（MDL）;</li><li>意向锁；</li><li>AUTO-INC 锁；</li></ul><h5 id="表锁"><a href="#表锁" class="headerlink" title="表锁"></a>表锁</h5><p>如果我们想对学生表（t_student）加表锁，可以使用下面的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//表级别的共享锁，也就是读锁；</span><br><span class="line">lock tables t_student read;</span><br><span class="line"></span><br><span class="line">//表级别的独占锁，也就是写锁；</span><br><span class="line">lock tables t_stuent write;</span><br></pre></td></tr></table></figure><p>需要注意的是，表锁除了会限制别的线程的读写外，也会限制本线程接下来的读写操作。</p><p>也就是说如果本线程对学生表加了「共享表锁」，那么本线程接下来如果要对学生表执行写操作的语句，是会被阻塞的，当然其他线程对学生表进行写操作时也会被阻塞，直到锁被释放。</p><p>要释放表锁，可以使用下面这条命令，会释放当前会话的所有表锁：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unlock tables</span><br></pre></td></tr></table></figure><p>另外，当会话退出后，也会释放所有表锁。</p><p>不过尽量避免在使用 InnoDB 引擎的表使用表锁，因为表锁的颗粒度太大，会影响并发性能，<strong>InnoDB 实现了颗粒度更细的行级锁</strong>。</p><h5 id="元数据锁（MDL）"><a href="#元数据锁（MDL）" class="headerlink" title="元数据锁（MDL）"></a>元数据锁（MDL）</h5><p>不需要显示的使用 MDL，因为当我们对数据库表进行操作时，会自动给这个表加上 MDL：</p><ul><li>对一张表进行 CRUD 操作时，加的是 <strong>MDL 读锁</strong>；</li><li>对一张表做结构变更操作的时候，加的是 <strong>MDL 写锁</strong>；</li></ul><p>MDL 是在事务提交后才会释放，这意味着<strong>事务执行期间，MDL 是一直持有的</strong>。</p><p>申请 MDL 锁的操作会形成一个队列，队列中<strong>写锁获取优先级高于读锁</strong>，一旦出现 MDL 写锁等待，会阻塞后续该表的所有 CRUD 操作。</p><h5 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h5><ul><li>在使用 InnoDB 引擎的表里对某些记录加上「共享锁」之前，需要先在表级别加上一个「意向共享锁」；</li><li>在使用 InnoDB 引擎的表里对某些纪录加上「独占锁」之前，需要先在表级别加上一个「意向独占锁」；</li></ul><p>也就是，当执行插入、更新、删除操作，需要先对表加上「意向独占锁」，然后对该记录加独占锁。</p><p>而普通的 select 是不会加行级锁的，普通的 select 语句是利用 MVCC 实现一致性读，是无锁的。</p><p>不过，select 也是可以对记录加共享锁和独占锁的，具体方式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//先在表上加上意向共享锁，然后对读取的记录加共享锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">//先表上加上意向独占锁，然后对读取的记录加独占锁</span><br><span class="line">select ... for update;</span><br></pre></td></tr></table></figure><p><strong>意向共享锁和意向独占锁是表级锁，不会和行级的共享锁和独占锁发生冲突，而且意向锁之间也不会发生冲突，只会和共享表锁（*lock tables … read*）和独占表锁（*lock tables … write*）发生冲突。</strong></p><p>表锁和行锁是满足读读共享、读写互斥、写写互斥的。</p><p><strong>意向锁的目的是为了快速判断表里是否有记录被加锁</strong>。</p><h5 id="AUTO-INC锁"><a href="#AUTO-INC锁" class="headerlink" title="AUTO-INC锁"></a>AUTO-INC锁</h5><p>在为某个字段声明 <code>AUTO_INCREMENT</code> 属性时，之后可以在插入数据时，可以不指定该字段的值，数据库会自动给该字段赋值递增的值，这主要是通过 AUTO-INC 锁实现的。</p><p>AUTO-INC 锁是特殊的表锁机制，锁<strong>不是再一个事务提交后才释放，而是再执行完插入语句后就会立即释放</strong>。</p><p><strong>在插入数据时，会加一个表级别的 AUTO-INC 锁</strong>，然后为被 <code>AUTO_INCREMENT</code> 修饰的字段赋值递增的值，等插入语句执行完成后，才会把 AUTO-INC 锁释放掉。</p><p>InnoDB 存储引擎提供了一种<strong>轻量级的锁</strong>来实现自增。</p><p>一样也是在插入数据的时候，会为被 <code>AUTO_INCREMENT</code> 修饰的字段加上轻量级锁，<strong>然后给该字段赋值一个自增的值，就把这个轻量级锁释放了，而不需要等待整个插入语句执行完后才释放锁</strong>。</p><h4 id="行级锁"><a href="#行级锁" class="headerlink" title="行级锁"></a>行级锁</h4><p>InnoDB 引擎是支持行级锁的，而 MyISAM 引擎并不支持行级锁。</p><p>普通的 select 语句是不会对记录加锁的，因为它属于快照读。如果要在查询时对记录加行锁，可以使用下面这两个方式，这种查询会加锁的语句称为<strong>锁定读</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//对读取的记录加共享锁</span><br><span class="line">select ... lock in share mode;</span><br><span class="line"></span><br><span class="line">//对读取的记录加独占锁</span><br><span class="line">select ... for update;</span><br></pre></td></tr></table></figure><p>上面这两条语句必须在一个事务中，<strong>因为当事务提交了，锁就会被释放</strong>，所以在使用这两条语句的时候，要加上 begin、start transaction 或者 set autocommit = 0。</p><p>共享锁（S锁）满足读读共享，读写互斥。独占锁（X锁）满足写写互斥、读写互斥。</p><p>行级锁的类型主要有三类：</p><ul><li>Record Lock，记录锁，也就是仅仅把一条记录锁上；</li><li>Gap Lock，间隙锁，锁定一个范围，但是不包含记录本身；</li><li>Next-Key Lock：Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</li></ul><h5 id="Record-Lock"><a href="#Record-Lock" class="headerlink" title="Record Lock"></a>Record Lock</h5><p>Record Lock 称为记录锁，锁住的是一条记录。而且记录锁是有 S 锁和 X 锁之分的：</p><ul><li>当一个事务对一条记录加了 S 型记录锁后，其他事务也可以继续对该记录加 S 型记录锁（S 型与 S 锁兼容），但是不可以对该记录加 X 型记录锁（S 型与 X 锁不兼容）;</li><li>当一个事务对一条记录加了 X 型记录锁后，其他事务既不可以对该记录加 S 型记录锁（S 型与 X 锁不兼容），也不可以对该记录加 X 型记录锁（X 型与 X 锁不兼容）。</li></ul><h5 id="Gap-Lock"><a href="#Gap-Lock" class="headerlink" title="Gap Lock"></a>Gap Lock</h5><p>Gap Lock 称为间隙锁，只存在于可重复读隔离级别，目的是为了解决可重复读隔离级别下幻读的现象。</p><p>假设，表中有一个范围 id 为（3，5）间隙锁，那么其他事务就无法插入 id = 4 这条记录了，这样就有效的防止幻读现象的发生。</p><p>间隙锁虽然存在 X 型间隙锁和 S 型间隙锁，但是并没有什么区别，<strong>间隙锁之间是兼容的，即两个事务可以同时持有包含共同间隙范围的间隙锁，并不存在互斥关系，因为间隙锁的目的是防止插入幻影记录而提出的</strong>。</p><h5 id="Next-Key-Lock"><a href="#Next-Key-Lock" class="headerlink" title="Next-Key Lock"></a>Next-Key Lock</h5><p>Next-Key Lock 称为临键锁，是 Record Lock + Gap Lock 的组合，锁定一个范围，并且锁定记录本身。</p><p>假设，表中有一个范围 id 为（3，5] 的 next-key lock，那么其他事务即不能插入 id = 4 记录，也不能修改 id = 5 这条记录。next-key lock 即能保护该记录，又能阻止其他事务将新纪录插入到被保护记录前面的间隙中。</p><p><strong>next-key lock 是包含间隙锁+记录锁的，如果一个事务获取了 X 型的 next-key lock，那么另外一个事务在获取相同范围的 X 型的 next-key lock 时，是会被阻塞的</strong>。</p><h5 id="插入意向锁"><a href="#插入意向锁" class="headerlink" title="插入意向锁"></a>插入意向锁</h5><p>一个事务在插入一条记录的时候，需要判断插入位置是否已被其他事务加了间隙锁（next-key lock 也包含间隙锁）。</p><p>如果有的话，插入操作就会发生<strong>阻塞</strong>，直到拥有间隙锁的那个事务提交为止（释放间隙锁的时刻），在此期间会生成一个<strong>插入意向锁</strong>，表明有事务想在某个区间插入新记录，但是现在处于等待状态。</p><p>插入意向锁名字虽然有意向锁，但是它并<strong>不是意向锁，它是一种特殊的间隙锁，属于行级别锁</strong>。</p><p>如果说间隙锁锁住的是一个区间，那么「插入意向锁」锁住的就是一个点。因而从这个角度来说，插入意向锁确实是一种特殊的间隙锁。</p><p>插入意向锁与间隙锁的另一个非常重要的差别是：尽管「插入意向锁」也属于间隙锁，但两个事务却不能在同一时间内，一个拥有间隙锁，另一个拥有该间隙区间内的插入意向锁（当然，插入意向锁如果不在间隙锁区间内则是可以的）。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Redis学习记录（一）</title>
      <link href="/posts/ccb8439b/"/>
      <url>/posts/ccb8439b/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="基本架构"><a href="#基本架构" class="headerlink" title="基本架构"></a>基本架构</h2><p>Redis 是典型的键值数据库，自己构建一个简单的键值数据库，建立起<strong>系统观</strong>，对它的总体架构和关键模块有一个全局的认知，然后再深入到具体的技术点。</p><p>简单的键值数据库称为 SimpleKV。开始构建时考虑存什么样的数据，对数据有哪些操作，也就是<strong>数据模型</strong>和<strong>操作接口</strong>。</p><h3 id="数据模型"><a href="#数据模型" class="headerlink" title="数据模型"></a>数据模型</h3><p>对于键值数据库，基本的数据模型是key-value模型。在 SimpleKV 中，key 是 String 类型，而 value 是基本数据类型，例如 String、整型等。对于实际生产环境中的键值数据库，value类型还可以是复杂类型。</p><p>对数据库选型时，一个重要考虑因素是它<strong>支持的value类型</strong>。例如，Memcached支持的 value 类型仅为 String 类型，而 Redis 支持的 value 类型包括了 String、哈希表、列表、集合等。<strong>Redis 能够在实际业务场景中得到广泛的应用，就是得益于支持多样化类型的 value。</strong></p><p>从使用的角度来说，不同 value 类型的实现，不仅可以支撑不同业务的数据需求，而且也隐含着不同数据结构在性能、空间效率等方面的差异，从而导致不同的 value 操作之间存在着差异。</p><h3 id="操作接口"><a href="#操作接口" class="headerlink" title="操作接口"></a>操作接口</h3><p>对数据的基本操作。基本操作无外乎增删改查。</p><p>SimpleKV 需要支持的 3 种基本操作，即 PUT、GET 和 DELETE。</p><ul><li>PUT：新写入或更新一个 key-value 对；</li><li>GET：根据一个 key 读取相应的 value 值；</li><li>DELETE：根据一个 key 删除整个 key-value 对。</li></ul><p>需要注意的是，<strong>有些键值数据库的新写/更新操作叫 SET</strong>。新写入和更新虽然是用一个操作接口，但在实际执行时，会根据 key 是否存在而执行相应的新写或更新流程。</p><p>在实际的业务场景中，我们经常会碰到这种情况：查询一个用户在一段时间内的访问记录。这种操作在键值数据库中属于 SCAN 操作，即<strong>根据一段 key 的范围返回相应的 value 值</strong>。</p><p>因此，<strong>PUT/GET/DELETE/SCAN 是一个键值数据库的基本操作集合</strong>。</p><p>对于一个具体的键值数据库而言，你可以通过查看操作文档，了解其详细的操作接口。</p><h3 id="保存位置"><a href="#保存位置" class="headerlink" title="保存位置"></a>保存位置</h3><p>完成构造数据模型与操作接口，进一步，一个重要的设计问题：<strong>键值对保存在内存还是外存？</strong></p><ul><li><p>保存在内存的好处是读写很快，毕竟内存的访问速度一般都在百 ns 级别。但是，潜在的风险是一旦掉电，所有的数据都会丢失。</p></li><li><p>保存在外存，虽然可以避免数据丢失，但是受限于磁盘的慢速读写（通常在几 ms 级别），键值数据库的整体性能会被拉低。</p></li></ul><p><strong>如何进行设计选择，我们通常需要考虑键值数据库的主要应用场景</strong>。比如，缓存场景下的数据需要能快速访问但允许丢失，那么，用于此场景的键值数据库通常采用内存保存键值数据。Memcached 和 Redis 都是属于内存键值数据库。对于 Redis 而言，缓存是非常重要的一个应用场景。</p><p>为了与Redis保持一致，SimpleKV 就采用内存保存键值数据。</p><h3 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h3><p>大体来说，一个键值数据库包括了<strong>访问框架、索引模块、操作模块和存储模块</strong>四部分：</p><img src="/posts/ccb8439b/image-20220912203425948.png" alt="image-20220912203425948" style="zoom: 67%;"><h3 id="访问模式"><a href="#访问模式" class="headerlink" title="访问模式"></a>访问模式</h3><p>访问模式通常有两种：</p><ul><li><p>一种是<strong>通过函数库调用的方式供外部应用使用</strong>，比如，上图中的libsimplekv.so，就是以动态链接库的形式链接到我们自己的程序中，提供键值存储功能；</p></li><li><p>另一种是<strong>通过网络框架以 Socket 通信的形式对外提供键值对操作</strong>，这种形式可以提供广泛的键值存储服务。在上图中，我们可以看到，网络框架中包括 Socket Server 和协议解析。</p></li></ul><p>实际的键值数据库也基本采用上述两种方式，例如，RocksDB 以动态链接库的形式使用，而 Memcached 和 Redis 则是通过网络框架访问。通过网络框架提供键值存储服务，一方面扩大了键值数据库的受用面，但另一方面，也给键值数据库的性能、运行模型提供了不同的设计选择，带来了一些潜在的问题。</p><p>I/O 模型设计问题，简单来说，就是网络连接的处理、网络请求的解析，以及数据存取的处理，是用一个线程、多个线程，还是多个进程来交互处理呢？该如何进行设计和取舍呢？举个例子，如果一个线程既要处理网络连接、解析请求，又要完成数据存取，一旦某一步操作发生阻塞，整个线程就会阻塞住，这就降低了系统响应速度。如果我们采用不同线程处理不同操作，那么，某个线程被阻塞时，其他线程还能正常运行。但是，不同线程间如果需要访问共享资源，那又会产生线程竞争，也会影响系统效率，这又该怎么办呢？所以，这的确是个“两难”选择，需要我们进行精心的设计。</p><h3 id="索引设计"><a href="#索引设计" class="headerlink" title="索引设计"></a>索引设计</h3><p>当 SimpleKV 解析了客户端发来的请求，知道了要进行的键值对操作，此时，SimpleKV 需要查找所要操作的键值对是否存在，这依赖于键值数据库的索引模块。<strong>索引的作用是让键值数据库根据 key 找到相应 value 的存储位置，进而执行操作</strong>。</p><p>索引的类型有很多，常见的有哈希表、B+ 树、字典树等。不同的索引结构在性能、空间消耗、并发控制等方面具有不同的特征。不同键值数据库采用的索引并不相同，例如，Memcached 和 Redis 采用哈希表作为 key-value 索引，而 RocksDB 则采用跳表作为内存中 key-value 的索引。</p><p>一般而言，内存键值数据库（例如 Redis）采用哈希表作为索引，很大一部分原因在于，其键值数据基本都是保存在内存中的，而内存的高性能随机访问特性可以很好地与哈希表O(1) 的操作复杂度相匹配。</p><p>SimpleKV 的索引根据 key 找到 value 的存储位置即可。但是，和 SimpleKV 不同，对于<br>Redis 而言，很有意思的一点是，它的 value 支持多种类型，当我们通过索引找到一个key 所对应的 value 后，仍然需要从 value 的复杂结构（例如集合和列表）中进一步找到我们实际需要的数据，这个操作的效率本身就依赖于它们的实现结构。Redis 采用一些常见的高效索引结构作为某些 value 类型的底层数据结构，这一技术路线为 Redis 实现高性能访问提供了良好的支撑。</p><h3 id="不同操作的具体逻辑"><a href="#不同操作的具体逻辑" class="headerlink" title="不同操作的具体逻辑"></a>不同操作的具体逻辑</h3><p>SimpleKV 的索引模块负责根据 key 找到相应的 value 的存储位置。对于不同的操作来说，找到存储位置之后，需要进一步执行的操作的具体逻辑会有所差异。SimpleKV 的操作模块就实现了不同操作的具体逻辑：</p><ul><li>对于 GET/SCAN 操作而言，此时根据 value 的存储位置返回 value 值即可；</li><li>对于 PUT 一个新的键值对数据而言，SimpleKV 需要为该键值对分配内存空间；</li><li>对于 DELETE 操作，SimpleKV 需要删除键值对，并释放相应的内存空间，这个过程由分配器完成。</li></ul><h3 id="重启后快速提供服务"><a href="#重启后快速提供服务" class="headerlink" title="重启后快速提供服务"></a>重启后快速提供服务</h3><p>分配器是键值数据库中的一个关键因素。对于以内存存储为主的 Redis 而言，这点尤为重要。Redis 的内存分配器提供了多种选择，分配效率也不一样。</p><p>希望 SimpleKV 重启后能快速重新提供服务，所以，在 SimpleKV 的存储模块中增加了持久化功能。鉴于磁盘管理要比内存管理复杂，SimpleKV 就直接采用了文件形式，将键值数据通过调用本地文件系统的操作接口保存在磁盘上。此时，SimpleKV 只需要考虑何时将内存中的键值数据保存到文件中，就可以了。</p><ul><li>一种方式是，对于每一个键值对，SimpleKV 都对其进行落盘保存，这虽然让 SimpleKV的数据更加可靠，但是，因为每次都要写盘，SimpleKV 的性能会受到很大影响。</li><li>另一种方式是，SimpleKV 只是周期性地把内存中的键值数据保存到文件中，这样可以避免频繁写盘操作的性能影响。但是，一个潜在的代价是 SimpleKV 的数据仍然有丢失的风险。</li></ul><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><p>构建一个简单的键值数据库 SimpleKV。SimpleKV 包含了一个键值数据库的基本组件，对这些组件有了了解之后，后面在学习Redis 这个丰富版的 SimpleKV 时，就会轻松很多。</p><img src="/posts/ccb8439b/image-20220912204855598.png" alt="image-20220912204855598" style="zoom:80%;"><p>从对比图中，可以看到，从 SimpleKV 演进到 Redis，有以下几个重要变化：</p><ul><li>Redis 主要通过网络框架进行访问，而不再是动态库了，这也使得 Redis 可以作为一个基础性的网络服务进行访问，扩大了 Redis 的应用范围。</li><li>Redis 数据模型中的 value 类型很丰富，因此也带来了更多的操作接口，例如面向列表的 LPUSH/LPOP，面向集合的 SADD/SREM 等。</li><li>Redis 的持久化模块能支持两种方式：日志（AOF）和快照（RDB），这两种持久化方式具有不同的优劣势，影响到 Redis 的访问性能和可靠性。</li><li>SimpleKV 是个简单的单机键值数据库，但是，Redis 支持高可靠集群和高可扩展集群，因此，Redis 中包含了相应的集群功能支撑模块。</li></ul><h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><p>Redis接收到一个键值对操作后，能以<strong>微秒级别</strong>的速度找到数据，并快速完成操作。速度快的原因：</p><ul><li>它是内存数据库，所有操作都在内存上完成，内存的访问速度本身就很快。</li><li>归功于它的数据结构。这是因为，键值对是按一定的数据结构来组织的，操作键值对最终就是对数据结构进行增删改查操作，所以高效的数据结构是 Redis 快速处理数据的基础。</li></ul><p>Redis的键值对中值的数据类型：String（字符串）、List（列表）、Hash（哈希）、Set（集合）和 Sorted Set（有序集合）。</p><p>其底层实现，数据结构一共6种，分别是简单动态字符串、双向链表、压缩列表、哈希表、跳表和整数数组。它们和数据类型的对应关系如下图所示：</p><img src="/posts/ccb8439b/image-20220912212558889.png" alt="image-20220912212558889" style="zoom:80%;"><p>String 类型的底层实现只有一种数据结构，也就是简单动态字符串。而 List、Hash、Set 和 Sorted Set 这四种数据类型，都有两种底层实现结构。通常情况下，我们会把这四种类型称为集合类型，它们的特点是<strong>一个键对应了一个集合的数据</strong>。</p><h3 id="键和值的结构组织"><a href="#键和值的结构组织" class="headerlink" title="键和值的结构组织"></a>键和值的结构组织</h3><p>为了实现从键到值的快速访问，Redis 使用了一个哈希表来保存所有键值对。</p><p>一个哈希表，其实就是一个数组，数组的每个元素称为一个哈希桶。所以，我们常说，一个哈希表是由多个哈希桶组成的，每个哈希桶中保存了键值对数据。其实，哈希桶中的元素保存的并不是值本身，而是指向具体值的指针。这也就是说，不管值是 String，还是集合类型，哈希桶中的元素都是指向它们的指针。</p><img src="/posts/ccb8439b/image-20220912214443579.png" alt="image-20220912214443579" style="zoom:80%;"><p>哈希桶中的 entry 元素中保存了<em>key和</em>value指针，分别指向了实际的键和值，这样一来，即使值是一个集合，也可以通过*value指针被查找到。因为这个哈希表保存了所有的键值对，所以，我也把它称为<strong>全局哈希表</strong>。哈希表的最大好处很明显，就是让我们可以用 <strong>O(1) 的时间复杂度来快速查找到键值对</strong>——我们只需要计算键的哈希值，就可以知道它所对应的哈希桶位置，然后就可以访问相应的 entry 元素。</p><p>查找过程主要依赖于哈希计算，和数据量的多少并没有直接关系。也就是说，不管哈希表里有 10 万个键还是 100 万个键，我们只需要一次计算就能找到相应的键。当你往 Redis 中写入大量数据后，就可能发现操作有时候会突然变慢了。这其实是因为你忽略了一个潜在的风险点，那就是<strong>哈希表的冲突问题和 rehash 可能带来的操作阻塞。</strong></p><p><strong>哈希冲突：</strong>两个 key 的哈希值和哈希桶计算对应关系时，正好落在了同一个哈希桶中。</p><p>Redis 解决哈希冲突的方式，就是链式哈希。链式哈希也很容易理解，就是指<strong>同一个哈希桶中的多个元素用一个链表来保存，它们之间依次用指针连接</strong>。</p><img src="/posts/ccb8439b/image-20220912214804037.png" alt="image-20220912214804037" style="zoom:80%;"><p>通过 entry 元素中的指针，把它们连起来。这就形成了一个链表，也叫作哈希冲突链。但是，这里依然存在一个问题，哈希冲突链上的元素只能通过指针逐一查找再操作。如果哈希表里写入的数据越来越多，哈希冲突可能也会越来越多，这就会导致某些哈希冲突链过长，进而导致这个链上的元素查找耗时长，效率降低。</p><p><strong>rehash 操作</strong>：增加现有的哈希桶数量，让逐渐增多的 entry 元素能在更多的桶之间分散保存，减少单个桶中的元素数量，从而减少单个桶中的冲突。</p><p>为了使 rehash 操作更高效，Redis 默认使用了两个全局哈希表：哈希表 1 和哈希表 2。一开始，当你刚插入数据时，默认使用哈希表 1，此时的哈希表 2 并没有被分配空间。随着数据逐步增多，Redis 开始执行 rehash，这个过程分为三步：</p><ul><li>给哈希表 2 分配更大的空间，例如是当前哈希表 1 大小的两倍；</li><li>把哈希表 1 中的数据重新映射并拷贝到哈希表 2 中；</li><li>释放哈希表 1 的空间。</li></ul><p>可以从哈希表 1 切换到哈希表 2，用增大的哈希表 2 保存更多数据，而原来的哈希表 1 留作下一次 rehash 扩容备用。</p><p>过程看似简单，但是第二步涉及大量的数据拷贝，如果一次性把哈希表 1 中的数据都迁移完，会造成 Redis 线程阻塞，无法服务其他请求。此时，Redis 就无法快速访问数据了。为了避免这个问题，Redis 采用了<strong>渐进式 rehash</strong>。</p><p>在第二步拷贝数据时，Redis 仍然正常处理客户端请求，每处理一个请求时，从哈希表 1 中的第一个索引位置开始，顺带着将这个索引位置上的所有 entries 拷贝到哈希表 2 中；等处理下一个请求时，再顺带拷贝哈希表 1 中的下一个索引位置的entries。如下图所示：</p><img src="/posts/ccb8439b/image-20220912215055175.png" alt="image-20220912215055175" style="zoom:80%;"><p>巧妙地把一次性大量拷贝的开销，分摊到了多次处理请求的过程中，避免了耗时操作，保证了数据的快速访问。</p><h3 id="集合操作效率"><a href="#集合操作效率" class="headerlink" title="集合操作效率"></a>集合操作效率</h3><p>和 String 类型不同，一个集合类型的值，第一步是通过全局哈希表找到对应的哈希桶位置，第二步是在集合中再增删改查。集合的操作效率影响因素：</p><ul><li>与集合的底层数据结构有关。例如，使用哈希表实现的集合，要比使用链表实现的集合访问效率更高。</li><li>操作效率和这些操作本身的执行特点有关，比如读写一个元素的操作要比读写所有元素的效率高。</li></ul><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p>集合类型的底层数据结构主要有 5 种：整数数组、双向链表、哈希表、压缩列表和跳表。</p><p>哈希表的操作特点我们刚刚已经学过了；整数数组和双向链表也很常见，它们的操作特征都是顺序读写，也就是通过数组下标或者链表的指针逐个元素访问，操作复杂度基本是 O(N)，操作效率比较低；压缩列表和跳表我们平时接触得可能不多，但它们也是Redis 重要的数据结构。</p><p><strong>压缩列表：</strong>类似于一个数组，数组中的每一个元素都对应保存一个数据。和数组不同的是，压缩列表在表头有三个字段 zlbytes、zltail 和 zllen，分别表示列表长度、列表尾的偏移量和列表中的 entry 个数；压缩列表在表尾还有一个 zlend，表示列表结束。</p><img src="/posts/ccb8439b/image-20220912215439186.png" alt="image-20220912215439186" style="zoom: 67%;"><p>在压缩列表中，如果我们要查找定位第一个元素和最后一个元素，可以通过表头三个字段的长度直接定位，复杂度是 O(1)。而查找其他元素时，就没有这么高效了，只能逐个查找，此时的复杂度就是 O(N) 了。</p><p><strong>跳表：</strong>跳表在链表的基础上，<strong>增加了多级索引，通过索引位置的几个跳转，实现数据的快速定位</strong>，</p><img src="/posts/ccb8439b/image-20220912215609415.png" alt="image-20220912215609415" style="zoom:80%;"><p>如果我们要在链表中查找 33 这个元素，只能从头开始遍历链表，查找 6 次，直到找到 33 为止。此时，复杂度是 O(N)，查找效率很低。</p><p>增加一级索引：从第一个元素开始，每两个元素选一个出来作为索引。这些索引再通过指针指向原始的链表。例如，从前两个元素中抽取元素 1 作为一级索引，从第三、四个元素中抽取元素 11 作为一级索引。此时，我们只需要 4 次查找就能定位到元素 33 了。</p><p>增加二级索引：从一级索引中，再抽取部分元素作为二级索引。例如，从一级索引中抽取 1、27、100 作为二级索引，二级索引指向一级索引。这样，我们只需要 3 次查找，就能定位到元素 33 了。</p><p>整个查找过程就是在多级索引上跳来跳去，最后定位到元素。这也正好符合“跳”表的叫法。当数据量很大时，跳表的查找复杂度就是 O(logN)。</p><p>按照查找的时间复杂度对这些数据结构进行分类：</p><table><thead><tr><th align="center">名称</th><th align="center">时间复杂度</th></tr></thead><tbody><tr><td align="center">哈希表</td><td align="center">O(1)</td></tr><tr><td align="center">跳表</td><td align="center">O(logN)</td></tr><tr><td align="center">双向链表</td><td align="center">O(N)</td></tr><tr><td align="center">压缩链表</td><td align="center">O(N)</td></tr><tr><td align="center">整数数组</td><td align="center">O(N)</td></tr></tbody></table><h3 id="不同操作的复杂度"><a href="#不同操作的复杂度" class="headerlink" title="不同操作的复杂度"></a>不同操作的复杂度</h3><p>集合类型的操作类型很多，有读写单个集合元素的，例如 HGET、HSET，也有操作多个元素的，例如 SADD，还有对整个集合进行遍历操作的，例如 SMEMBERS。这么多操作，它们的复杂度也各不相同。而复杂度的高低又是选择集合类型的重要依据。</p><p><strong>单元素操作是基础；范围操作非常耗时；统计操作通常高效；例外情况只有几个。</strong></p><p><strong>单元素操作</strong>：<strong>指每一种集合类型对单个数据实现的增删改查操作</strong>。例如，Hash 类型的 HGET、HSET 和 HDEL，Set 类型的 SADD、SREM、SRANDMEMBER 等。这些操作的复杂度由集合采用的数据结构决定，例如，HGET、HSET 和 HDEL 是对哈希表做操作，所以它们的复杂度都是 O(1)；Set 类型用哈希表作为底层数据结构时，它的 SADD、SREM、SRANDMEMBER 复杂度也是 O(1)。<br>需要注意的是，集合类型支持同时对多个元素进行增删改查，例如 Hash类型的 HMGET 和 HMSET，Set 类型的 SADD 也支持同时增加多个元素。此时，这些操作的复杂度，就是由单个元素操作复杂度和元素个数决定的。例如，HMSET 增加 M 个元素时，复杂度就从 O(1) 变成 O(M) 了。</p><p><strong>范围操作</strong>：<strong>指集合类型中的遍历操作，可以返回集合中的所有数据</strong>。比如 Hash类型的 HGETALL 和 Set 类型的 SMEMBERS，或者返回一个范围内的部分数据，比如 List类型的 LRANGE 和 ZSet 类型的 ZRANGE。<strong>这类操作的复杂度一般是 O(N)，比较耗时，应该尽量避免</strong>。<br>Redis 从 2.8 版本开始提供了 SCAN 系列操作（包括 HSCAN，SSCAN 和 ZSCAN），这类操作实现了渐进式遍历，每次只返回有限数量的数据。这样一来，相比于HGETALL、SMEMBERS 这类操作来说，就避免了一次性返回所有元素而导致的 Redis 阻塞。</p><p><strong>统计操作</strong>：<strong>集合类型对集合中所有元素个数的记录</strong>。例如 LLEN 和 SCARD。这类操作复杂度只有 O(1)，这是因为当集合类型采用压缩列表、双向链表、整数数组这些数据结构时，这些结构中专门记录了元素的个数统计，因此可以高效地完成相关操作。</p><p>例外情况：指某些数据结构的特殊记录，例如<strong>压缩列表和双向链表都会记录表头和表尾的偏移量</strong>。这样一来，对于 List 类型的 LPOP、RPOP、LPUSH、RPUSH 这四个操作来说，它们是在列表的头尾增删元素，这就可以通过偏移量直接定位，所以它们的复杂度也只有 O(1)，可以实现快速操作。</p><p>Redis 之所以能快速操作键值对，一方面是因为 O(1) 复杂度的哈希表被广泛使用，包括String、Hash 和 Set，它们的操作复杂度基本由哈希表决定，另一方面，Sorted Set 也采用了 O(logN) 复杂度的跳表。不过，集合类型的范围操作，因为要遍历底层数据结构，复杂度通常是 O(N)。这里的建议是：<strong>用其他命令来替代</strong>，例如可以用 SCAN 来代替，避免在 Redis 内部产生费时的全集合遍历操作。</p><p>对于复杂度较高的 List 类型，它的两种底层实现结构：双向链表和压缩列表的操作复杂度都是 O(N)。因此建议是：<strong>因地制宜地使用 List 类型</strong>。例如，既然它的 POP/PUSH 效率很高，那么就将它主要用于 FIFO 队列场景，而不是作为一个可以随机读写的集合。</p><h2 id="高性能IO模型：单线程-Redis-高性能"><a href="#高性能IO模型：单线程-Redis-高性能" class="headerlink" title="高性能IO模型：单线程 Redis 高性能"></a>高性能IO模型：单线程 Redis 高性能</h2><p>Redis 是单线程，主要是指 <strong>Redis 的网络 IO 和键值对读写是由一个线程来完成的，这也是 Redis 对外提供键值存储服务的主要流程</strong>。但 Redis 的其他功能，比如持久化、异步删除、集群数据同步等，其实是由额外的线程执行的。</p><h3 id="Redis采用单线程的原因"><a href="#Redis采用单线程的原因" class="headerlink" title="Redis采用单线程的原因"></a>Redis采用单线程的原因</h3><p>需要考虑<strong>多线程的开销问题</strong>，使用多线程，可以增加系统吞吐率，或是可以增加系统扩展性。对于一个多线程的系统来说，在有合理的资源分配的情况下，可以增加系统中处理请求操作的资源实体，进而提升系统能够同时处理的请求数，即吞吐率。但是，一个关键的瓶颈在于，系统中通常会存在被多线程同时访问的共享资源，比如一个共享的数据结构。当有多个线程要修改这个共享资源时，为了保证共享资源的正确性，就需要有额外的机制进行保证，而这个额外的机制，就会带来额外的开销。</p><p><strong>多线程编程模式面临的共享资源的并发访问控制问题</strong>。并发访问控制一直是多线程开发中的一个难点问题，如果没有精细的设计，比如说，只是简单地采用一个粗粒度互斥锁，就会出现不理想的结果：即使增加了线程，大部分线程也在等待获取访问共享资源的互斥锁，并行变串行，系统吞吐率并没有随着线程的增加而增加。</p><p>采用多线程开发一般会引入同步原语来保护共享资源的并发访问，这也会降低系统代码的易调试性和可维护性。为了避免这些问题，Redis 直接采用了单线程模式。</p><h3 id="单线程-Redis-高性能的原因"><a href="#单线程-Redis-高性能的原因" class="headerlink" title="单线程 Redis 高性能的原因"></a>单线程 Redis 高性能的原因</h3><ul><li>Redis 的大部分操作在内存上完成，再加上它采用了高效的数据结构，例如哈希表和跳表，这是它实现高性能的一个重要原因。</li><li>Redis 采用了<strong>多路复用机制</strong>，使其在网络 IO 操作中能并发处理大量的客户端请求，实现高吞吐率。</li></ul><h3 id="基本IO模型与阻塞点"><a href="#基本IO模型与阻塞点" class="headerlink" title="基本IO模型与阻塞点"></a>基本IO模型与阻塞点</h3><p>以 Get 请求为例，SimpleKV 为了处理一个 Get 请求，需要监听客户端请求（bind/listen），和客户端建立连接（accept），从 socket 中读取请求（recv），解析客户端发送请求（parse），根据请求类型读取键值数据（get），最后给客户端返回结果，即向 socket 中写回数据（send）。</p><img src="/posts/ccb8439b/image-20220912221548653.png" alt="image-20220912221548653" style="zoom:80%;"><p>bind/listen、accept、recv、parse 和 send 属于网络 IO 处理，而 get 属于键值数据操作。既然 Redis 是单线程，那么，最基本的一种实现是在一个线程中依次执行上面说的这些操作。</p><p>潜在的阻塞点：分别是 **accept() 和 recv()**。当 Redis 监听到一个客户端有连接请求，但一直未能成功建立起连接时，会阻塞在 accept() 函数这里，导致其他客户端无法和 Redis 建立连接。类似的，当 Redis 通过 recv() 从一个客户端读取数据时，如果数据一直没有到达，Redis 也会一直阻塞在 recv()。这就导致 Redis 整个线程阻塞，无法处理其他客户端请求，效率很低。不过，socket 网络模型本身支持非阻塞模式。</p><h3 id="非阻塞模式"><a href="#非阻塞模式" class="headerlink" title="非阻塞模式"></a>非阻塞模式</h3><p>Socket 网络模型的非阻塞模式设置，主要体现在三个关键的函数调用上。在 socket 模型中，不同操作调用后会返回不同的套接字类型。</p><ul><li>首先，socket() 方法会返回主动套接字。</li><li>然后，调用 listen() 方法，将主动套接字转化为监听套接字，此时，可以监听来自客户端的连接请求。</li><li>最后，调用 accept() 方法接收到达的客户端连接，并返回已连接套接字。</li></ul><img src="/posts/ccb8439b/image-20220912221918081.png" alt="image-20220912221918081" style="zoom:80%;"><p>针对监听套接字，我们可以设置非阻塞模式：当 Redis 调用 accept() 但一直未有连接请求到达时，Redis 线程可以返回处理其他操作，而不用一直等待。但是要注意的是，调用 accept() 时，已经存在监听套接字了。</p><p>类似的，也可以针对已连接套接字设置非阻塞模式：Redis 调用 recv() 后，如果已连接套接字上一直没有数据到达，Redis 线程同样可以返回处理其他操作。我们也需要有机制继续监听该已连接套接字，并在有数据达到时通知 Redis。</p><p>这样才能保证 Redis 线程，既不会像基本 IO 模型中一直在阻塞点等待，也不会导致 Redis无法处理实际到达的连接请求或数据。</p><h3 id="基于多路复用的高性能I-O模型"><a href="#基于多路复用的高性能I-O模型" class="headerlink" title="基于多路复用的高性能I/O模型"></a>基于多路复用的高性能I/O模型</h3><p>Linux 中的 IO 多路复用机制是指一个线程处理多个 IO 流，就是经常听到的select/epoll 机制。简单来说，在 Redis 只运行单线程的情况下，<strong>该机制允许内核中，同时存在多个监听套接字和已连接套接字</strong>。内核会一直监听这些套接字上的连接请求或数据请求。一旦有请求到达，就会交给 Redis 线程处理，这就实现了一个 Redis 线程处理多个 IO 流的效果。</p><img src="/posts/ccb8439b/image-20220912222349372.png" alt="image-20220912222349372" style="zoom:80%;"><p>Redis 网络框架调用 epoll 机制，让内核监听这些套接字。此时，Redis 线程不会阻塞在某一个特定的监听或已连接套接字上，也就是说，不会阻塞在某一个特定的客户端请求处理上。正因为此，Redis 可以同时和多个客户端连接并处理请求，从而提升并发性。</p><p>为了在请求到达时能通知到 Redis 线程，select/epoll 提供了<strong>基于事件的回调机制</strong>，即<strong>针对不同事件的发生，调用相应的处理函数</strong>。select/epoll 一旦监测到 FD 上有请求到达时，就会触发相应的事件。</p><p><strong>这些事件会被放进一个事件队列，Redis 单线程对该事件队列不断进行处理。</strong>这样一来，Redis 无需一直轮询是否有请求实际发生，这就可以避免造成 CPU 资源浪费。同时，Redis 在对事件队列中的事件进行处理时，会调用相应的处理函数，这就实现了基于事件的回调。因为 Redis 一直在对事件队列进行处理，所以能及时响应客户端请求，提升Redis 的响应性能。</p><p>以连接请求和读数据请求为例，两个请求分别对应 Accept 事件和 Read 事件，Redis 分别对这两个事件注册 accept 和 get 回调函数。当 Linux 内核监听到有连接请求或读数据请求时，就会触发 Accept 事件和 Read 事件，此时，内核就会回调 Redis 相应的 accept 和 get 函数进行处理。</p><p>Redis 单线程是指它对网络 IO 和数据读写的操作采用了一个线程，而采用单线程的一个核心原因是避免多线程开发的并发控制问题。单线程的 Redis 也能获得高性能，跟多路复用的 IO 模型密切相关，因为这避免了 accept() 和 send()/recv() 潜在的网络 IO 操作阻塞点。</p><p>注：2020 年 5 月，Redis 6.0 的稳定版发布了，Redis 6.0 中提出了多线程模型。</p><h2 id="AOF日志：Redis避免数据丢失"><a href="#AOF日志：Redis避免数据丢失" class="headerlink" title="AOF日志：Redis避免数据丢失"></a>AOF日志：Redis避免数据丢失</h2><p>Redis可以当作缓存使用，因为它把后端数据库中的数据存储在内存中，然后直接从内存中读取数据，响应速度会非常快，但是，这里也有一个绝对不能忽略的问题：<strong>一旦服务器宕机，内存中的数据将全部丢失。</strong></p><p>很容易想到的一个解决方案是，从后端数据库恢复这些数据，但这种方式存在两个问题：一是，需要频繁访问数据库，会给数据库带来巨大的压力；二是，这些数据是从慢速数据库中读取出来的，性能肯定比不上从 Redis 中读取，导致使用这些数据的应用程序响应变慢。所以，对 Redis 来说，实现数据的持久化，避免从后端数据库中进行恢复，是至关重要的。</p><p>Redis 的<strong>持久化</strong>主要有两大机制：<strong>AOF 日志和 RDB 快照。</strong></p><h3 id="AOF日志的实现"><a href="#AOF日志的实现" class="headerlink" title="AOF日志的实现"></a>AOF日志的实现</h3><p>不同于写前日志（Write Ahead Log, WAL），也就是，在实际写数据前，先把修改的数据记到日志文件中，以便故障时进行恢复。</p><p>AOF日志正好相反，它是<strong>写后日志</strong>，“写后”的意思是 Redis 是先执行命令，把数据写入内存，然后才记录日志，如下图所示：</p><img src="/posts/ccb8439b/image-20220912233456867.png" alt="image-20220912233456867" style="zoom: 50%;"><p>传统数据库的日志，例如 redo log（重做日志），记录的是修改后的数据，而 AOF 里记录的是 Redis 收到的每一条命令，这些命令是以文本形式保存的。</p><p>以 Redis 收到“set testkey testvalue”命令后记录的日志为例，看看 AOF 日志的内容。其中，“*3”表示当前命令有三个部分，每部分都是由“<code>$+数字</code>”开头，后面紧跟着具体的命令、键或值。这里，“数字”表示这部分中的命令、键或值一共有多少字节。例如，“$3 set”表示这部分有 3 个字节，也就是“set”命令。</p><img src="/posts/ccb8439b/image-20220912233653313.png" alt="image-20220912233653313" style="zoom: 67%;"><p>但是，为了避免额外的检查开销，Redis 在向 AOF 里面记录日志的时候，并不会先去对这些命令进行语法检查。所以，如果先记日志再执行命令的话，日志中就有可能记录了错误的命令，Redis 在使用日志恢复数据时，就可能会出错。</p><p>而写后日志这种方式，就是先让系统执行命令，只有命令能执行成功，才会被记录到日志中，否则，系统就会直接向客户端报错。所以，Redis 使用写后日志这一方式的一大好处是，可以<strong>避免出现记录错误命令的情况。</strong></p><p>除此之外，AOF 还有一个好处：它是在命令执行后才记录日志，所以<strong>不会阻塞当前的写操作</strong>.</p><p>不过，AOF 也有两个潜在的风险：</p><ul><li>如果刚执行完一个命令，还没有来得及记日志就宕机了，那么这个命令和相应的数据就有丢失的风险。如果此时 Redis 是用作缓存，还可以从后端数据库重新读入数据进行恢复，但是，如果 Redis 是直接用作数据库的话，此时，因为命令没有记入日志，所以就无法用日志进行恢复了。</li><li>AOF 虽然避免了对当前命令的阻塞，但可能会给下一个操作带来阻塞风险。这是因为，AOF 日志也是在主线程中执行的，如果在把日志文件写入磁盘时，磁盘写压力大，就会导致写盘很慢，进而导致后续的操作也无法执行了。</li></ul><p>这两个风险都是和 AOF 写回磁盘的时机相关的。这也就意味着，如果我们能够控制一个写命令执行完后 AOF 日志写回磁盘的时机，这两个风险就解除了。</p><h3 id="三种写回策略"><a href="#三种写回策略" class="headerlink" title="三种写回策略"></a>三种写回策略</h3><p>AOF 机制给我们提供了三个选择，也就是 AOF 配置项 appendfsync 的三个可选值。</p><ul><li><strong>Always</strong>，同步写回：每个写命令执行完，立马同步地将日志写回磁盘；</li><li><strong>Everysec</strong>，每秒写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，每隔一秒把缓冲区中的内容写入磁盘；</li><li><strong>No</strong>，操作系统控制的写回：每个写命令执行完，只是先把日志写到 AOF 文件的内存缓冲区，由操作系统决定何时将缓冲区内容写回磁盘。</li></ul><p>针对避免主线程阻塞和减少数据丢失问题，这三种写回策略都无法做到两全其美。</p><ul><li>“同步写回”可以做到基本不丢数据，但是它在每一个写命令后都有一个慢速的落盘操作，不可避免地会影响主线程性能；</li><li>“每秒写回”采用一秒写回一次的频率，避免了“同步写回”的性能开销，虽然减少了对系统性能的影响，但是如果发生宕机，上一秒内未落盘的命令操作仍然会丢失。所以，这只能算是，在避免影响主线程性能和避免数据丢失两者间取了个折中。</li><li>虽然“操作系统控制的写回”在写完缓冲区后，就可以继续执行后续的命令，但是落盘的时机已经不在 Redis 手中了，只要 AOF 记录没有写回磁盘，一旦宕机对应的数据就丢失了；</li></ul><p>三种策略的写回时机，以及优缺点汇总在了一张表格里：</p><img src="/posts/ccb8439b/image-20220912234311901.png" alt="image-20220912234311901" style="zoom:67%;"><p>因此，可以根据系统对高性能和高可靠性的要求，来选择使用哪种写回策略了。总结一下就是：想要获得高性能，就选择 No 策略；如果想要得到高可靠性保证，就选择Always 策略；如果允许数据有一点丢失，又希望性能别受太大影响的话，那么就选择Everysec 策略。</p><p>AOF 是以文件的形式在记录接收到的所有写命令。随着接收的写命令越来越多，AOF 文件会越来越大。一定要小心 AOF 文件过大带来的性能问题。主要在于以下三个方面：</p><ul><li>文件系统本身对文件大小有限制，无法保存过大的文件；</li><li>如果文件太大，之后再往里面追加命令记录的话，效率也会变低；</li><li>如果发生宕机，AOF 中记录的命令要一个个被重新执行，用于故障恢复，如果日志文件太大，整个恢复过程就会非常缓慢，这就会影响到 Redis 的正常使用。</li></ul><p>因此，需要采取一定的控制手段：<strong>AOF 重写机制</strong>。</p><h3 id="AOF重写机制"><a href="#AOF重写机制" class="headerlink" title="AOF重写机制"></a>AOF重写机制</h3><p>AOF 重写机制就是在重写时，Redis 根据数据库的现状创建一个新的 AOF 文件，也就是说，读取数据库中的所有键值对，然后对每一个键值对用一条命令记录它的写入。比如说，当读取了键值对“testkey”: “testvalue”之后，重写机制会记录 set testkey testvalue 这条命令。这样，当需要恢复时，可以重新执行该命令，实现“testkey”: “testvalue”的写入。</p><p>重写机制具有“多变一”功能。所谓的“多变一”，也就是说，旧日志文件中的多条命令，在重写后的新日志中变成了一条命令。</p><img src="/posts/ccb8439b/image-20220912234736351.png" alt="image-20220912234736351" style="zoom:67%;"><p>AOF 文件是以追加的方式，逐一记录接收到的写命令的。当一个键值对被多条写命令反复修改时，AOF 文件会记录相应的多条命令。但是，在重写的时候，是根据这个键值对当前的最新状态，为它生成对应的写入命令。这样一来，一个键值对在重写日志中只用一条命令就行了，而且，在日志恢复时，只用执行这条命令，就可以直接完成这个键值对的写入了。</p><p>对一个列表先后做了 6 次修改操作后，列表的最后状态是[“D”, “C”, “N”]，此时，只用 LPUSH u:list “N”, “C”, “D”这一条命令就能实现该数据的恢复，这就节省了五条命令的空间。对于被修改过成百上千次的键值对来说，重写能节省的空间当然就更大了。</p><h3 id="AOF重写阻塞问题"><a href="#AOF重写阻塞问题" class="headerlink" title="AOF重写阻塞问题"></a>AOF重写阻塞问题</h3><p>和 AOF 日志由主线程写回不同，重写过程是由后台线程 bgrewriteaof 来完成的，这也是为了避免阻塞主线程，导致数据库性能下降。</p><p>重写的过程可以总结为“<strong>一个拷贝，两处日志</strong>”。“一个拷贝”就是指，每次执行重写时，主线程 fork 出后台的 bgrewriteaof 子进程。此时，fork 会把主线程的内存拷贝一份给 bgrewriteaof 子进程，这里面就包含了数据库的最新数据。然后，bgrewriteaof 子进程就可以在不影响主线程的情况下，逐一把拷贝的数据写成操作，记入重写日志。</p><p>“两处日志”：</p><p>因为主线程未阻塞，仍然可以处理新来的操作。此时，如果有写操作，第一处日志就是指正在使用的 AOF 日志，Redis 会把这个操作写到它的缓冲区。这样一来，即使宕机了，这个 AOF 日志的操作仍然是齐全的，可以用于恢复。</p><p>第二处日志，就是指新的 AOF 重写日志。这个操作也会被写到重写日志的缓冲区。这样，重写日志也不会丢失最新的操作。等到拷贝数据的所有操作记录重写完成后，重写日志记录的这些最新操作也会写入新的 AOF 文件，以保证数据库最新状态的记录。此时，我们就可以用新的 AOF 文件替代旧文件了。</p><img src="/posts/ccb8439b/image-20220913102736102.png" alt="image-20220913102736102" style="zoom:67%;"><p>每次 AOF 重写时，Redis 会先执行一个内存拷贝，用于重写；然后，使用两个日志保证在重写过程中，新写入的数据不会丢失。而且，因为 Redis 采用额外的线程进行数据重写，所以，这个过程并不会阻塞主线程。</p><h2 id="RDB内存快照"><a href="#RDB内存快照" class="headerlink" title="RDB内存快照"></a>RDB内存快照</h2><p>用 AOF 方法进行故障恢复的时候，需要逐一把操作日志都执行一遍。如果操作日志非常多，Redis 就会恢复得很缓慢，影响到正常使用。既可以保证可靠性，还能在宕机时实现快速恢复的一种持久化方法：<strong>内存快照</strong>。所谓内存快照，就是指内存中的数据在某一个时刻的状态记录。这就类似于照片，当你给朋友拍照时，一张照片就能把朋友一瞬间的形象完全记下来。</p><p>对 Redis 来说，它实现类似照片记录效果的方式，就是把某一时刻的状态<strong>以文件的形式写到磁盘上</strong>，也就是快照。这样一来，即使宕机，快照文件也不会丢失，数据的可靠性也得到了保证。这个快照文件就称为 RDB 文件，RDB 就是 Redis DataBase 的缩写。</p><p>和 AOF 相比，RDB 记录的是某一时刻的数据，并不是操作，所以，在做数据恢复时，可以直接把 RDB 文件读入内存，很快地完成恢复。但这也存在新的问题：</p><ul><li>对哪些数据做快照？这关系到快照的执行效率问题；</li><li>做快照时，数据还能被增删改吗？这关系到 Redis 是否被阻塞，能否同时正常处理请求。</li></ul><h3 id="给哪些内存数据做快照"><a href="#给哪些内存数据做快照" class="headerlink" title="给哪些内存数据做快照"></a>给哪些内存数据做快照</h3><p>Redis 的数据都在内存中，为了提供所有数据的可靠性保证，它执行的是<strong>全量快照</strong>，也就是说，<strong>把内存中的所有数据都记录到磁盘中</strong>，这就类似于给 100 个人拍合影，把每一个人都拍进照片里。这样做的好处是，一次性记录了所有数据，一个都不少。给内存的全量数据做快照，把它们全部写入磁盘也会花费很多时间。而且，全量数据越多，RDB 文件就越大，往磁盘上写数据的时间开销就越大。</p><p>Redis 提供了两个命令来生成 RDB 文件，分别是 save 和 bgsave：</p><ul><li>save：在主线程中执行，会导致阻塞；</li><li>bgsave：创建一个子进程，专门用于写入 RDB 文件，避免了主线程的阻塞，这也是Redis RDB 文件生成的默认配置。</li></ul><p>可以通过 bgsave 命令来执行全量快照，这既提供了数据的可靠性保证，也避免了对 Redis 的性能影响。</p><h3 id="快照时数据能否修改"><a href="#快照时数据能否修改" class="headerlink" title="快照时数据能否修改"></a>快照时数据能否修改</h3><p>在对内存数据做快照时，如果数据能被修改，那就意味着 Redis 还能正常处理写操作。否则，所有写操作都得等到快照完了才能执行，性能一下子就降低了。</p><p>可以用 bgsave 避免阻塞，但是，<strong>避免阻塞和正常处理写操作并不是一回事</strong>。此时，主线程的确没有阻塞，可以正常接收请求，但是，为了保证快照完整性，它只能处理读操作，因为不能修改正在执行快照的数据。为了快照而暂停写操作，肯定是不能接受的。Redis 借助操作系统提供的<strong>写时复制技术</strong>（Copy-On-Write, COW），在执行快照的同时，正常处理写操作。</p><img src="/posts/ccb8439b/image-20220913104541648.png" alt="image-20220913104541648" style="zoom:67%;"><p>bgsave 子进程是由主线程 fork 生成的，可以共享主线程的所有内存数据。bgsave 子进程运行后，开始读取主线程的内存数据，并把它们写入 RDB 文件。此时，如果主线程对这些数据也都是读操作（例如图中的键值对 A），那么，主线程和 bgsave 子进程相互不影响。但是，如果主线程要修改一块数据（例如图中的键值对 C），那么，这块数据就会被复制一份，生成该数据的副本。然后，bgsave 子进程会把这个副本数据写入 RDB 文件，而在这个过程中，主线程仍然可以直接修改原来的数据。</p><p>这既保证了快照的完整性，也允许主线程同时对数据进行修改，避免了对正常业务的影响。</p><p><strong>Redis 使用 bgsave 对当前内存中的所有数据做快照，这个操作是子进程在后台完成的，这就允许主线程同时可以修改数据。</strong></p><h3 id="多久做一次快照"><a href="#多久做一次快照" class="headerlink" title="多久做一次快照"></a>多久做一次快照</h3><p>虽然 bgsave 执行时不阻塞主线程，但是，<strong>如果频繁地执行全量快照，也会带来两方面的开销</strong>。</p><ul><li>频繁将全量数据写入磁盘，会给磁盘带来很大压力，多个快照竞争有限的磁盘带宽，前一个快照还没有做完，后一个又开始做了，易造成恶性循环。</li><li>bgsave 子进程需要通过 fork 操作从主线程创建出来。虽然，子进程在创建后不会再阻塞主线程，但是，fork 这个创建过程本身会阻塞主线程，而且主线程的内存越大，阻塞时间越长。如果频繁 fork 出 bgsave 子进程，这就会频繁阻塞主线程了。</li></ul><p>解决方法：可以做<strong>增量快照</strong>，做了一次全量快照后，后续的快照只对修改的数据进行快照记录，这样可以避免每次全量快照的开销。前提是，<strong>需要记住哪些数据被修改了</strong>。需要使用额外的元数据信息去记录哪些数据被修改了，这会带来额外的空间开销问题。</p><img src="/posts/ccb8439b/image-20220913110310966.png" alt="image-20220913110310966" style="zoom: 80%;"><p>能利用 RDB 的快速恢复，又能以较小的开销做到尽量少丢数据的方法：Redis 4.0 中提出了一个<strong>混合使用 AOF 日志和内存快照</strong>的方法。简单来说，内存快照以一定的频率执行，在两次快照之间，使用 AOF 日志记录这期间的所有命令操作。</p><p>这样一来，快照不用很频繁地执行，这就避免了频繁 fork 对主线程的影响。而且，AOF日志也只用记录两次快照间的操作，也就是说，不需要记录所有操作了，因此，就不会出现文件过大的情况了，也可以避免重写开销。</p><img src="/posts/ccb8439b/image-20220913110602610.png" alt="image-20220913110602610" style="zoom:80%;"><p>T1 和 T2 时刻的修改，用 AOF 日志记录，等到第二次做全量快照时，就可以清空 AOF 日志，因为此时的修改都已经记录到快照中了，恢复时就不再用日志了。</p><ul><li><p>内存快照的优势：可以快速恢复数据库，也就是只需要把 RDB 文件直接读入内存，这就避免了 AOF 需要顺序、逐一重新执行操作命令带来的低效性能问题。</p></li><li><p>内存快照的局限性：它拍的是一张内存的“大合影”，不可避免地会耗时耗力。虽然，Redis 设计了 bgsave 和写时复制方式，尽可能减少了内存快照对正常读写的影响，但是，频繁快照仍然是不太能接受的。</p></li><li><p>最优解：混合使用 RDB 和 AOF，正好可以取两者之长，避两者之短，以较小的性能开销保证数据可靠性和性能。</p></li></ul><p>关于 AOF 和 RDB 的选择问题有三点：</p><ul><li>数据不能丢失时，内存快照和 AOF 的混合使用是一个很好的选择；</li><li>如果允许分钟级别的数据丢失，可以只使用 RDB；</li><li>如果只用 AOF，优先使用 everysec 的配置选项，因为它在可靠性和性能之间取了一个平衡。</li></ul><h2 id="数据同步：主从库实现数据一致"><a href="#数据同步：主从库实现数据一致" class="headerlink" title="数据同步：主从库实现数据一致"></a>数据同步：主从库实现数据一致</h2><p> Redis 具有高可靠性体现在两方面：</p><ul><li><p><strong>数据尽量少丢失</strong>。AOF 和 RDB 保证了前者；</p></li><li><p><strong>服务尽量少中断</strong>。Redis 的做法是<strong>增加副本冗余量</strong>，将一份数据同时保存在多个实例上。即使有一个实例出现了故障，需要过一段时间才能恢复，其他实例也可以对外提供服务，不会影响业务使用。</p></li></ul><p>Redis 提供了主从库模式，以保证数据副本的一致，主从库之间采用的是<strong>读写分离</strong>的方式。</p><ul><li><strong>读操作</strong>：主库、从库都可以接收；</li><li><strong>写操作</strong>：首先到主库执行，然后，主库将写操作同步给从库。</li></ul><img src="/posts/ccb8439b/image-20220913111545067.png" alt="image-20220913111545067" style="zoom:67%;"><p>如果在不同的实例上执行，而且保持这个数据在三个实例上一致，就要涉及到加锁、实例间协商是否完成修改等一系列操作，但这会带来巨额的开销，当然是不太能接受的。而主从库模式一旦采用了读写分离，所有数据的修改只会在主库上进行，不用协调三个实例。主库有了最新的数据后，会同步给从库，这样，主从库的数据就是一致的。</p><p>主从库同步的基本原理，总结有三种模式：</p><ul><li>全量复制</li><li>基于长连接的命令传播</li><li>增量复制</li></ul><h3 id="主从库的第一次同步（全量复制）"><a href="#主从库的第一次同步（全量复制）" class="headerlink" title="主从库的第一次同步（全量复制）"></a>主从库的第一次同步（全量复制）</h3><p>当我们启动多个 Redis 实例的时候，它们相互之间就可以通过 replicaof（Redis 5.0 之前使用 slaveof）命令形成主库和从库的关系，之后会按照三个阶段完成数据的第一次同步。</p><p>例如，现在有实例 1（ip：172.16.19.3）和实例 2（ip：172.16.19.5），在实例 2 上执行以下这个命令后，实例 2 就变成了实例 1 的从库，并从实例 1 上复制数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof <span class="number">172.16</span><span class="number">.19</span><span class="number">.3</span> <span class="number">6379</span></span><br></pre></td></tr></table></figure><img src="/posts/ccb8439b/image-20220913112220438.png" alt="image-20220913112220438" style="zoom:80%;"><p>主从库间数据第一次同步的三个阶段：</p><ul><li><p>第一阶段：主从库间建立连接、协商同步的过程，主要是为全量复制做准备。<strong>从库和主库建立起连接，并告诉主库即将进行同步，主库确认回复后，主从库间就可以开始同步了</strong>。<br>具体来说，从库给主库发送 psync 命令，表示要进行数据同步，主库根据这个命令的参数来启动复制。psync 命令包含了<strong>主库的 runID</strong> 和<strong>复制进度 offset</strong> 两个参数。</p><ul><li>runID，是每个 Redis 实例启动时都会自动生成的一个随机 ID，用来唯一标记这个实例。当从库和主库第一次复制时，因为不知道主库的 runID，所以将 runID 设为“？”。</li><li>offset，此时设为 -1，表示第一次复制。</li></ul><p>主库收到 psync 命令后，会用 FULLRESYNC 响应命令带上两个参数：主库 runID 和主库目前的复制进度 offset，返回给从库。从库收到响应后，会记录下这两个参数。注意：<strong>FULLRESYNC 响应表示第一次复制采用的全量复制，也就是说，主库会把当前所有的数据都复制给从库</strong>。</p></li><li><p>第二阶段：<strong>主库将所有数据同步给从库。从库收到数据后，在本地完成数据加载</strong>。这个过程依赖于内存快照生成的 RDB 文件。<br>具体来说，主库执行 bgsave 命令，生成 RDB 文件，接着将文件发给从库。从库接收到RDB 文件后，会先清空当前数据库，然后加载 RDB 文件。这是因为从库在通过 replicaof 命令开始和主库同步前，可能保存了其他数据。为了避免之前数据的影响，从库需要先把当前数据库清空。</p><p>在主库将数据同步给从库的过程中，主库不会被阻塞，仍然可以正常接收请求。否则，Redis 的服务就被中断了。但是，这些请求中的写操作并没有记录到刚刚生成的 RDB 文件中。为了保证主从库的数据一致性，主库会在内存中用专门的 replication buffer，记录 RDB 文件生成后收到的所有写操作。</p></li><li><p>第三阶段：主库会把第二阶段执行过程中新收到的写命令，再发送给从库。<br>具体的操作是，当主库完成 RDB 文件发送后，就会把此时 replication buffer 中的修改操作发给从库，从库再重新执行这些操作。这样一来，主从库就实现同步了。</p></li></ul><h3 id="主从级联模式"><a href="#主从级联模式" class="headerlink" title="主从级联模式"></a>主从级联模式</h3><p>一次全量复制中，对于主库来说，需要完成两个耗时的操作：生成 RDB 文件和传输 RDB 文件。</p><p>如果从库数量很多，而且都要和主库进行全量复制的话，就会导致主库忙于 fork 子进程生成 RDB 文件，进行数据全量同步。fork 这个操作会阻塞主线程处理正常请求，从而导致主库响应应用程序的请求速度变慢。此外，传输 RDB 文件也会占用主库的网络带宽，同样会给主库的资源使用带来压力。</p><p>解决方法：<strong>“主 - 从 - 从”模式</strong>。分担主库压力。</p><p>在刚才的主从库模式中，所有的从库都是和主库连接，所有的全量复制也都是和主库进行的。可以<strong>通过“主 - 从 - 从”模式将主库生成 RDB 和传输 RDB 的压力，以级联的方式分散到从库上</strong>。</p><p>简单来说，我们在部署主从集群的时候，可以手动选择一个从库（比如选择内存资源配置较高的从库），用于级联其他的从库。然后，我们可以再选择一些从库（例如三分之一的从库），在这些从库上执行如下命令，让它们和刚才所选的从库，建立起主从关系。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">replicaof 所选从库的IP <span class="number">6379</span></span><br></pre></td></tr></table></figure><p>这样一来，这些从库就会知道，在进行同步时，不用再和主库进行交互了，只要和级联的从库进行写操作同步就行了，这就可以减轻主库上的压力，如下图所示：</p><img src="/posts/ccb8439b/image-20220913113401065.png" alt="image-20220913113401065" style="zoom:67%;"><p>一旦主从库完成了全量复制，它们之间就会一直维护一个网络连接，主库会通过这个连接将后续陆续收到的命令操作再同步给从库，这个过程也称为<strong>基于长连接的命令传播</strong>，可以避免频繁建立连接的开销。不过存在风险点，最常见的就是<strong>网络断连或阻塞</strong>。如果网络断连，主从库之间就无法进行命令传播了，从库的数据自然也就没办法和主库保持一致了，客户端就可能从从库读到旧数据。</p><h3 id="主从库间网络断联（增量复制）"><a href="#主从库间网络断联（增量复制）" class="headerlink" title="主从库间网络断联（增量复制）"></a>主从库间网络断联（增量复制）</h3><p>在 Redis 2.8 之前，如果主从库在命令传播时出现了网络闪断，那么，从库就会和主库重新进行一次全量复制，开销非常大。</p><p>从 Redis 2.8 开始，网络断了之后，主从库会采用<strong>增量复制</strong>的方式继续同步。它和全量复制的不同：<strong>全量复制是同步所有数据，而增量复制只会把主从库网络断连期间主库收到的命令，同步给从库。</strong></p><p>此时主从库之间保持同步，需要 repl_backlog_buffer 缓冲区。当主从库断连后，主库会把断连期间收到的写操作命令，写入 replication buffer，同时也会把这些操作命令也写入 repl_backlog_buffer 这个缓冲区。</p><p>repl_backlog_buffer 是一个环形缓冲区，<strong>主库会记录自己写到的位置，从库则会记录自己已经读到的位置</strong>。</p><p>刚开始的时候，主库和从库的写读位置在一起，二者起始位置相同。随着主库不断接收新的写操作，它在缓冲区中的写位置会逐步偏离起始位置，对主库来说，对应的偏移量就是 master_repl_offset。同样，从库在复制完写操作命令后，它在缓冲区中的读位置也开始逐步偏移刚才的起始位置，此时，从库已复制的偏移量 slave_repl_offset 也在不断增加。正常情况下，这两个偏移量基本相等。</p><img src="/posts/ccb8439b/image-20220913114021244.png" alt="image-20220913114021244" style="zoom: 80%;"><p>主从库的连接恢复之后，从库首先会给主库发送 psync 命令，并把自己当前的slave_repl_offset 发给主库，主库会判断自己的 master_repl_offset 和 slave_repl_offset 之间的差距。在网络断连阶段，主库可能会收到新的写操作命令，所以，一般来说，master_repl_offset 会大于 slave_repl_offset。此时，主库只用把 master_repl_offset 和 slave_repl_offset     之间的命令操作同步给从库就行。</p><p>示意图中，主库和从库之间相差了 put d e 和 put d f 两个操作，在增量复制时，主库只需要把它们同步给从库。</p><p>增量复制的流程：</p><img src="/posts/ccb8439b/image-20220913114257379.png" alt="image-20220913114257379" style="zoom:67%;"><p>因为 repl_backlog_buffer 是一个环形缓冲区，所以在缓冲区写满后，主库会继续写入，此时，就会覆盖掉之前写入的操作。<strong>如果从库的读取速度比较慢，就有可能导致从库还未读取的操作被主库新写的操作覆盖了，这会导致主从库间的数据不一致</strong>。</p><p>为避免这一情况，一般而言，可以调整 <strong>repl_backlog_size</strong> 这个参数。这个参数和所需的缓冲空间大小有关。缓冲空间的计算公式是：缓冲空间大小 = 主库写入命令速度 * 操作大小 - 主从库间网络传输命令速度 * 操作大小。在实际应用中，考虑到可能存在一些突发的请求压力，我们通常需要把这个缓冲空间扩大一倍，即 <strong>repl_backlog_size = 缓冲空间大小 * 2</strong>，这也就是 repl_backlog_size 的最终值。</p><p>例如，如果主库每秒写入 2000 个操作，每个操作的大小为 2KB，网络每秒能传输 1000 个操作，那么，有 1000 个操作需要缓冲起来，这就至少需要 2MB 的缓冲空间。否则，新写的命令就会覆盖掉旧操作了。为了应对可能的突发压力，最终把repl_backlog_size 设为 4MB。</p><p>这样一来，增量复制时主从库的数据不一致风险就降低了。不过，如果并发请求量非常大，连两倍的缓冲空间都存不下新操作请求的话，此时，主从库数据仍然可能不一致。</p><p>针对这种情况，一方面，你可以根据 Redis 所在服务器的内存资源再适当增加repl_backlog_size 值，比如说设置成缓冲空间大小的 4 倍，另一方面，你可以考虑使用切片集群来分担单个主库的请求压力。</p><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><p>如果主库发生故障，会直接影响从库的同步，因为从库没有相应的主库可以进行数据复制操作了。一旦有写操作请求了，按照主从库模式下的读写分离要求，需要由主库来完成写操作。此时，也没有实例可以来服务客户端的写操作请求：</p><img src="/posts/ccb8439b/image-20220913164525577.png" alt="image-20220913164525577" style="zoom:67%;"><p>如果主库挂了，我们就需要运行一个新主库，比如说把一个从库切换为主库，把它当成主库。涉及三个问题：</p><ul><li>主库真的挂了吗？</li><li>该选择哪个从库作为主库？</li><li>怎么把新主库的相关信息通知给从库和客户端呢？</li></ul><p>解决方法：<strong>哨兵机制</strong>。在 Redis 主从集群中，哨兵机制是实现主从库自动切换的关键机制，它有效地解决了主从复制模式下故障转移的这三个问题。</p><h3 id="哨兵机制的基本流程"><a href="#哨兵机制的基本流程" class="headerlink" title="哨兵机制的基本流程"></a>哨兵机制的基本流程</h3><p>哨兵其实就是一个运行在特殊模式下的 Redis 进程，主从库实例运行的同时，它也在运行。</p><p>哨兵主要负责的就是三个任务：<strong>监控、选主（选择主库）和通知。</strong></p><ul><li>监控：哨兵进程在运行时，周期性地给所有的主从库发送 PING 命令，检测它们是否仍然在线运行。如果从库没有在规定时间内响应哨兵的 PING 命令，哨兵就会把它标记为“下线状态”；</li><li>选择主库：如果主库也没有在规定时间内响应哨兵的 PING 命令，哨兵就会判定主库下线，然后开始<strong>自动切换主库</strong>的流程。主库挂了以后，哨兵就需要从很多个从库里，按照一定的规则选择一个从库实例，把它作为新的主库。</li><li>通知：在执行通知任务时，哨兵会把新主库的连接信息发给其他从库，让它们执行 replicaof 命令，和新主库建立连接，并进行数据复制。同时，哨兵会把新主库的连接信息通知给客户端，让它们把请求操作发到新主库上。</li></ul><img src="/posts/ccb8439b/image-20220913165106203.png" alt="image-20220913165106203" style="zoom:67%;"><h3 id="主观下线与客观下线"><a href="#主观下线与客观下线" class="headerlink" title="主观下线与客观下线"></a>主观下线与客观下线</h3><p>主观下线：<strong>哨兵进程会使用 PING 命令检测它自己和主、从库的网络连接情况，用来判断实例的状态</strong>。如果哨兵发现主库或从库对 PING 命令的响应超时了，那么，哨兵就会先把它标记为“主观下线”。</p><p>如果检测的是从库，那么，哨兵简单地把它标记为“主观下线”就行了，因为从库的下线影响一般不太大，集群的对外服务不会间断。</p><p>如果检测的是主库，那么，哨兵还不能简单地把它标记为“主观下线”，开启主从切换。因为很有可能存在这么一个情况：那就是哨兵误判了，其实主库并没有故障。可是，一旦启动了主从切换，后续的选主和通知操作都会带来额外的计算和通信开销。为了避免这些不必要的开销，要特别注意误判的情况。</p><p>误判一般会发生在<strong>集群网络压力较大、网络拥塞，或者是主库本身压力较大</strong>的情况下。</p><p>哨兵机制<strong>通常会采用多实例组成的集群模式进行部署，这也被称为哨兵集群</strong>。引入多个哨兵实例一起来判断，就可以避免单个哨兵因为自身网络状况不好，而误判主库下线的情况。同时，多个哨兵的网络同时不稳定的概率较小，由它们一起做决策，误判率也能降低。</p><p>客观下线：在判断主库是否下线时，不能由一个哨兵说了算，只有大多数的哨兵实例，都判断主库已经“主观下线”了，主库才会被标记为“客观下线”，这个叫法也是表明主库下线成为一个客观事实了。这个判断原则就是：少数服从多数。同时，这会进一步触发哨兵开始主从切换流程。</p><img src="/posts/ccb8439b/image-20220913165536398.png" alt="image-20220913165536398" style="zoom:67%;"><p>简单来说，“客观下线”的标准就是，当有 N 个哨兵实例时，最好要有 N/2 + 1 个实例判断主库为“主观下线”，才能最终判定主库为“客观下线”。这样一来，就可以减少误判的概率，也能避免误判带来的无谓的主从库切换。（当然，有多少个实例做出“主观下线”的判断才可以，可以由 Redis 管理员自行设定）。</p><h3 id="如何选定新主库"><a href="#如何选定新主库" class="headerlink" title="如何选定新主库"></a>如何选定新主库</h3><p>可以把哨兵选择新主库的过程称为“筛选 + 打分”。在多个从库中，先按照<strong>一定的筛选条件</strong>，把不符合条件的从库去掉。然后，我们再按照<strong>一定的规则</strong>，给剩下的从库逐个打分，将得分最高的从库选为新主库：</p><img src="/posts/ccb8439b/image-20220913165745510.png" alt="image-20220913165745510" style="zoom: 67%;"><p>筛选条件：</p><p>一般情况下，我们肯定要先保证所选的从库仍然在线运行。不过，在选主时从库正常在线，这只能表示从库的现状良好，并不代表它就是最适合做主库的。在选主时，<strong>除了要检查从库的当前在线状态，还要判断它之前的网络连接状态</strong>。如果从库总是和主库断连，而且断连次数超出了一定的阈值，我们就有理由相信，这个从库的网络状况并不是太好，就可以把这个从库筛掉了。</p><p>具体判断：使用配置项 down-after-milliseconds * 10。其中，down-after-milliseconds 是我们认定主从库断连的最大连接超时时间。如果在 down-after-milliseconds 毫秒内，主从节点都没有通过网络联系上，我们就可以认为主从节点断连了。如果发生断连的次数超过了 10 次，就说明这个从库的网络状况不好，不适合作为新主库。</p><p>分别按照三个规则依次进行三轮打分，<strong>从库优先级、从库复制进度以及从库 ID 号</strong>。只要在某一轮中，有从库得分最高，那么它就是主库了，选主过程到此结束。如果没有出现得分最高的从库，那么就继续进行下一轮。</p><ul><li><p><strong>第一轮：优先级最高的从库得分高。</strong>用户可以通过 slave-priority 配置项，给不同的从库设置不同优先级。比如，你有两个从库，它们的内存大小不一样，你可以手动给内存大的实例设置一个高优先级。在选主时，哨兵会给优先级高的从库打高分，如果有一个从库优先级最高，那么它就是新主库了。如果从库的优先级都一样，那么哨兵开始第二轮打分。</p></li><li><p><strong>第二轮：和旧主库同步程度最接近的从库得分高。</strong>如果选择和旧主库同步最接近的那个从库作为主库，那么，这个新主库上就有最新的数据。</p><p>判断从库和旧主库间的同步进度：主从库同步时有个命令传播的过程。在这个过程中，主库会用master_repl_offset 记录当前的最新写操作在 repl_backlog_buffer 中的位置，而从库会用 slave_repl_offset 这个值记录当前的复制进度。此时，我们想要找的从库，它的 slave_repl_offset 需要最接近 master_repl_offset。如果在所有从库中，有从库的 slave_repl_offset 最接近 master_repl_offset，那么它的得分就最高，可以作为新主库。</p><img src="/posts/ccb8439b/image-20220913233528320.png" alt="image-20220913233528320" style="zoom:67%;"><p>旧主库的 master_repl_offset 是 1000，从库 1、2 和 3 的 slave_repl_offset 分别是 950、990 和 900，那么，从库 2 就应该被选为新主库。如果有两个从库的 slave_repl_offset 值大小是一样的（例如，从库 1 和从库 2 的 slave_repl_offset 值都是 990），我们就需要给它们进行第三轮打分了。</p></li><li><p><strong>第三轮：ID 号小的从库得分高。</strong>每个实例都会有一个 ID，这个 ID 就类似于这里的从库的编号。目前，Redis 在选主库时，有一个默认的规定：<strong>在优先级和复制进度都相同的情况下，ID 号最小的从库得分最高，会被选为新主库</strong>。</p></li></ul><p><strong>选择主库的流程总结：</strong></p><p>首先，哨兵会按照在线状态、网络状态，筛选过滤掉一部分不符合要求的从库，然后，依次按照优先级、复制进度、ID 号大小再对剩余的从库进行打分，只要有得分最高的从库出现，就把它选为新主库。</p><h2 id="哨兵集群"><a href="#哨兵集群" class="headerlink" title="哨兵集群"></a>哨兵集群</h2><p>哨兵机制可以实现主从库的自动切换。通过部署多个实例，就形成了一个哨兵集群。哨兵集群中的多个实例共同判断，可以降低对主库下线的误判率。一旦多个实例组成了<strong>哨兵集群</strong>，即使有哨兵实例出现故障挂掉了，其他哨兵还能继续协作完成主从库切换的工作，包括判定主库是不是处于下线状态，选择新主库，以及通知从库和客户端。</p><p>在配置哨兵的信息时，我们只需要用到下面的这个配置项，设置<strong>主库的 IP</strong> 和<strong>端口</strong>，并没有配置其他哨兵的连接信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor &lt;master-name&gt; &lt;ip&gt; &lt;redis-port&gt; &lt;quorum&gt;</span><br></pre></td></tr></table></figure><h3 id="基于-pub-sub-机制的哨兵集群组成"><a href="#基于-pub-sub-机制的哨兵集群组成" class="headerlink" title="基于 pub/sub 机制的哨兵集群组成"></a>基于 pub/sub 机制的哨兵集群组成</h3><p>Redis 提供的 pub/sub 机制，也就是发布 / 订阅机制，使得哨兵实例之间可以相互发现。哨兵只要和主库建立起了连接，就可以在主库上发布消息了，比如说发布它自己的连接信息（IP 和端口）。同时，它也可以从主库上订阅消息，获得其他哨兵发布的连接信息。当多个哨兵实例都在主库上做了发布和订阅操作后，它们之间就能知道彼此的 IP 地址和端口。</p><p>为了区分不同应用的消息，Redis 会以频道的形式，对这些消息进行分门别类的管理。所谓的频道，实际上就是消息的类别。当消息类别相同时，它们就属于同一个频道。反之，就属于不同的频道。<strong>只有订阅了同一个频道的应用，才能通过发布的消息进行信息交换</strong>。</p><img src="/posts/ccb8439b/image-20220914100323975.png" alt="image-20220914100323975" style="zoom:67%;"><p>哨兵 1 把自己的 IP（172.16.19.3）和端口（26579）发布到“<code>__sentinel__:hello</code>”频道上，哨兵 2 和 3 订阅了该频道。那么此时，哨兵 2 和 3 就可以从这个频道直接获取哨兵 1 的 IP 地址和端口号。然后，哨兵 2、3 可以和哨兵 1 建立网络连接。通过这个方式，哨兵 2 和 3 也可以建立网络连接，这样一来，哨兵集群就形成了。它们相互间可以通过网络连接进行通信，哨兵除了彼此之间建立起连接形成集群外，还需要和从库建立连接。这是因为，在哨兵的监控任务中，它需要<strong>对主从库都进行心跳判断</strong>，而且在主从库切换完成后，它还需要通知从库，让它们和新主库进行同步。</p><p><strong>哨兵是如何知道从库的 IP 地址和端口</strong>：哨兵向主库发送 INFO 命令来完成的。</p><img src="/posts/ccb8439b/image-20220914100718778.png" alt="image-20220914100718778" style="zoom:67%;"><p>哨兵 2 给主库发送 INFO 命令，主库接受到这个命令后，就会把从库列表返回给哨兵。接着，哨兵就可以根据从库列表中的连接信息，和每个从库建立连接，并在这个连接上持续地对从库进行监控。哨兵 1 和 3 可以通过相同的方法和从库建立连接。</p><p>通过 <strong>pub/sub 机制</strong>，哨兵之间可以组成集群，同时，哨兵又通过 <strong>INFO 命令</strong>，获得了从库连接信息，也能和从库建立连接，并进行监控了。哨兵不能只和主、从库连接。因为，主从库切换后，客户端也需要知道新主库的连接信息，才能向新主库发送请求操作。所以，哨兵还需要完成<strong>把新主库的信息告诉客户端</strong>这个任务。</p><h3 id="基于-pub-sub-机制的客户端事件通知"><a href="#基于-pub-sub-机制的客户端事件通知" class="headerlink" title="基于 pub/sub 机制的客户端事件通知"></a>基于 pub/sub 机制的客户端事件通知</h3><p>从本质上说，哨兵就是一个运行在特定模式下的 Redis 实例，只不过它并不服务请求操作，只是完成监控、选主和通知的任务。所以，每个哨兵实例也提供 pub/sub 机制，客户端可以从哨兵订阅消息。哨兵提供的消息订阅频道有很多，不同频道包含了主从库切换过程中的不同关键事件。</p><p>重要的频道汇总，涉及几个关键事件，包括主库下线判断、新主库选定、从库重新配置。</p><img src="/posts/ccb8439b/image-20220914102009203.png" alt="image-20220914102009203" style="zoom:67%;"><p>知道了这些频道之后，就可以<strong>让客户端从哨兵这里订阅消息</strong>了。具体的操作步骤：客户端读取哨兵的配置文件后，可以获得哨兵的地址和端口，和哨兵建立网络连接。然后，我们可以在客户端执行订阅命令，来获取不同的事件消息。</p><p>例如，可以执行如下命令，来订阅“所有实例进入客观下线状态的事件”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SUBSCRIBE +odown</span><br></pre></td></tr></table></figure><p>也可以执行如下命令，订阅所有的事件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">PSUBSCRIBE *</span><br></pre></td></tr></table></figure><p>当哨兵把新主库选择出来后，客户端就会看到下面的 switch-master 事件。这个事件表示主库已经切换了，新主库的 IP 地址和端口信息已经有了。这个时候，客户端就可以用这里面的新主库地址和端口进行通信了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>-master &lt;master name&gt; &lt;oldip&gt; &lt;oldport&gt; &lt;newip&gt; &lt;newport&gt;</span><br></pre></td></tr></table></figure><p>有了这些事件通知，客户端不仅可以在主从切换后得到新主库的连接信息，还可以监控到主从库切换过程中发生的各个重要事件。这样，客户端就可以知道主从切换进行到哪一步了，有助于了解切换进度。</p><p>有了 pub/sub 机制，哨兵和哨兵之间、哨兵和从库之间、哨兵和客户端之间就都能建立起连接。</p><h3 id="由哪个哨兵执行主从切换？"><a href="#由哪个哨兵执行主从切换？" class="headerlink" title="由哪个哨兵执行主从切换？"></a>由哪个哨兵执行主从切换？</h3><p>确定由哪个哨兵执行主从切换的过程，和主库“客观下线”的判断过程类似，也是一个“投票仲裁”的过程。哨兵集群要判定主库“客观下线”，需要有一定数量的实例都认为该主库已经“主观下线”了。任何一个实例只要自身判断主库“主观下线”后，就会给其他实例发送 is-master-down-by-addr 命令。接着，其他实例会根据自己和主库的连接情况，做出 Y 或 N 的响应，Y 相当于赞成票，N 相当于反对票。</p><img src="/posts/ccb8439b/image-20220914102953991.png" alt="image-20220914102953991" style="zoom:67%;"><p>一个哨兵获得了仲裁所需的赞成票数后，就可以标记主库为“客观下线”。这个所需的赞成票数是通过哨兵配置文件中的 quorum 配置项设定的。例如，现在有 5 个哨兵，quorum 配置的是 3，那么，一个哨兵需要 3 张赞成票，就可以标记主库为“客观下线”了。这 3 张赞成票包括哨兵自己的一张赞成票和另外两个哨兵的赞成票。</p><p>这个哨兵就可以再给其他哨兵发送命令，表明希望由自己来执行主从切换，并让所有其他哨兵进行投票。这个投票过程称为“Leader 选举”。因为最终执行主从切换的哨兵称为 Leader，投票过程就是确定 Leader。</p><p>投票过程中，要成为 Leader 的哨兵，需满足两个条件：</p><ul><li>拿到半数以上的赞成票；</li><li>拿到的票数同时还需要大于等于哨兵配置文件中的 quorum 值。</li></ul><p>例如，3 个哨兵、quorum 为 2 的选举过程。</p><img src="/posts/ccb8439b/image-20220914103255201.png" alt="image-20220914103255201" style="zoom: 67%;"><p>在 T1 时刻，S1 判断主库为“客观下线”，它想成为 Leader，就先给自己投一张赞成票，然后分别向 S2 和 S3 发送命令，表示要成为 Leader。在 T2 时刻，S3 判断主库为“客观下线”，它也想成为 Leader，所以也先给自己投一张赞成票，再分别向 S1 和 S2 发送命令，表示要成为 Leader。</p><p>在 T3 时刻，S1 收到了 S3 的 Leader 投票请求。因为 S1 已经给自己投了一票 Y，所以它不能再给其他哨兵投赞成票了，所以 S1 回复 N 表示不同意。同时，S2 收到了 T2 时 S3发送的 Leader 投票请求。因为 S2 之前没有投过票，它会给第一个向它发送投票请求的哨兵回复 Y，给后续再发送投票请求的哨兵回复 N，所以，在 T3 时，S2 回复 S3，同意 S3 成为 Leader。</p><p>在 T4 时刻，S2 才收到 T1 时 S1 发送的投票命令。因为 S2 已经在 T3 时同意了 S3 的投票请求，此时，S2 给 S1 回复 N，表示不同意 S1 成为 Leader。发生这种情况，是因为S3 和 S2 之间的网络传输正常，而 S1 和 S2 之间的网络传输可能正好拥塞了，导致投票请求传输慢了。（先到先得）</p><p>最后，在 T5 时刻，S1 得到的票数是来自它自己的一票 Y 和来自 S2 的一票 N。而 S3 除了自己的赞成票 Y 以外，还收到了来自 S2 的一票 Y。此时，S3 不仅获得了半数以上的Leader 赞成票，也达到预设的 quorum 值（quorum 为 2），所以它最终成为了 Leader。接着，S3 会开始执行选主操作，而且在选定新主库后，会给其他从库和客户端通知新主库的信息。</p><p>如果 S3 没有拿到 2 票 Y，那么这轮投票就不会产生 Leader。哨兵集群会等待一段时间（也就是哨兵故障转移超时时间的 2 倍），再重新选举。这是因为，<strong>哨兵集群能够进行成功投票，很大程度上依赖于选举命令的正常网络传播</strong>。如果网络压力较大或有短时堵塞，就可能导致没有一个哨兵能拿到半数以上的赞成票。所以，等到网络拥塞好转之后，再进行投票选举，成功的概率就会增加。</p><p>注意，如果哨兵集群只有 2 个实例，此时，一个哨兵要想成为 Leader，必须获得 2 票，而不是 1 票。所以，如果有个哨兵挂掉了，那么，此时的集群是无法进行主从库切换的。因此，通常我们至少会配置 3 个哨兵实例。</p><p><strong>要保证所有哨兵实例的配置是一致的，尤其是主观下线的判断值 down-after-milliseconds</strong>。因为这个值在不同的哨兵实例上配置不一致，会导致哨兵集群一直没有对有故障的主库形成共识，也就没有及时切换主库，最终的结果就是集群服务不稳定。</p><h2 id="切片集群"><a href="#切片集群" class="headerlink" title="切片集群"></a>切片集群</h2><p>切片集群，也叫分片集群，就是指启动多个 Redis 实例组成一个集群，然后按照一定的规则，把收到的数据划分成多份，每一份用一个实例来保存。如果把 25GB 的数据平均分成 5 份（当然，也可以不做均分），使用 5 个实例来保存，每个实例只需要保存 5GB 数据。如下图所示：</p><img src="/posts/ccb8439b/image-20220914104532461.png" alt="image-20220914104532461" style="zoom: 50%;"><p>在切片集群中，实例在为 5GB 数据生成 RDB 时，数据量就小了很多，fork 子进程一般不会给主线程带来较长时间的阻塞。采用多个实例保存数据切片后，我们既能保存25GB 数据，又避免了 fork 子进程阻塞主线程而导致的响应突然变慢。</p><p>在实际应用 Redis 时，随着用户或业务规模的扩展，保存大量数据的情况通常是无法避免的。而切片集群，就是一个非常好的解决方案。</p><h3 id="如何保存更多的数据"><a href="#如何保存更多的数据" class="headerlink" title="如何保存更多的数据"></a>如何保存更多的数据</h3><p>刚刚的案例里，为了保存大量数据，我们使用了大内存云主机和切片集群两种方法。实际上，这两种方法分别对应着 Redis 应对数据量增多的两种方案：纵向扩展（scale up）和横向扩展（scale out）。</p><ul><li><strong>纵向扩展</strong>：升级单个 Redis 实例的资源配置，包括增加内存容量、增加磁盘容量、使用更高配置的 CPU。就像下图中，原来的实例内存是 8GB，硬盘是 50GB，纵向扩展后，内存增加到 24GB，磁盘增加到 150GB。</li><li><strong>横向扩展</strong>：横向增加当前 Redis 实例的个数。就像下图中，原来使用 1 个 8GB 内存、50GB 磁盘的实例，现在使用三个相同配置的实例。</li></ul><img src="/posts/ccb8439b/image-20220914104752293.png" alt="image-20220914104752293" style="zoom:50%;"><p>纵向扩展的好处是，<strong>实施起来简单、直接</strong>。不过存在两个潜在的问题：</p><ul><li>当使用 RDB 对数据进行持久化时，如果数据量增加，需要的内存也会增加，主线程 fork 子进程时就可能会阻塞。不过，如果你不要求持久化保存 Redis 数据，那么，纵向扩展会是一个不错的选择。</li><li><strong>纵向扩展会受到硬件和成本的限制</strong>。</li></ul><p>与纵向扩展相比，横向扩展是一个扩展性更好的方案。这是因为，要想保存更多的数据，采用这种方案的话，只用增加 Redis 的实例个数就行了，不用担心单个实例的硬件和成本限制。<strong>在面向百万、千万级别的用户规模时，横向扩展的 Redis 切片集群会是一个非常好的选择</strong>。</p><p>但是，切片集群不可避免地涉及到多个实例的分布式管理问题。</p><ul><li>数据切片后，在多个实例之间如何分布？</li><li>客户端怎么确定想要访问的数据在哪个实例上？</li></ul><h3 id="数据切片和实例的对应分布关系"><a href="#数据切片和实例的对应分布关系" class="headerlink" title="数据切片和实例的对应分布关系"></a>数据切片和实例的对应分布关系</h3><p><strong>Redis Cluster 方案</strong>中规定了数据和实例的对应规则。具体来说，Redis Cluster 方案采用<strong>哈希槽</strong>（Hash Slot，接下来我会直接称之为 Slot），来处理数据和实例之间的映射关系。在 Redis Cluster 方案中，一个切片集群共有 16384 个哈希槽，这些哈希槽类似于数据分区，每个键值对都会根据它的 key，被映射到一个哈希槽中。具体的映射过程分为两大步：</p><ul><li>首先根据键值对的 key，按照CRC16 算法计算一个 16 bit 的值；</li><li>然后，再用这个 16bit 值对 16384 取模，得到 0~16383 范围内的模数，每个模数代表一个相应编号的哈希槽。</li></ul><p>在部署 Redis Cluster 方案时，可以使用 cluster create 命令创建集群，此时，Redis 会自动把这些槽平均分布在集群实例上。例如，如果集群中有 N 个实例，那么，每个实例上的槽个数为 16384/N 个。也可以使用 cluster meet 命令手动建立实例间的连接，形成集群，再使用cluster addslots 命令，指定每个实例上的哈希槽个数。</p><p>假设集群中不同 Redis 实例的内存大小配置不一，如果把哈希槽均分在各个实例上，在保存相同数量的键值对时，和内存大的实例相比，内存小的实例就会有更大的容量压力。遇到这种情况时，你可以根据不同实例的资源配置情况，使用 cluster addslots 命令手动分配哈希槽。</p><p>数据、哈希槽、实例这三者的映射分布：</p><img src="/posts/ccb8439b/image-20220914111750808.png" alt="image-20220914111750808" style="zoom:67%;"><p>示意图中的切片集群一共有 3 个实例，同时假设有 5 个哈希槽，我们首先可以通过下面的命令手动分配哈希槽：实例 1 保存哈希槽 0 和 1，实例 2 保存哈希槽 2 和 3，实例 3 保存哈希槽 4。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">redis-cli -h <span class="number">172.16</span><span class="number">.19</span><span class="number">.3</span> –p <span class="number">6379</span> cluster addslots <span class="number">0</span>,<span class="number">1</span> </span><br><span class="line">redis-cli -h <span class="number">172.16</span><span class="number">.19</span><span class="number">.4</span> –p <span class="number">6379</span> cluster addslots <span class="number">2</span>,<span class="number">3</span> </span><br><span class="line">redis-cli -h <span class="number">172.16</span><span class="number">.19</span><span class="number">.5</span> –p <span class="number">6379</span> cluster addslots <span class="number">4</span></span><br></pre></td></tr></table></figure><p>在集群运行的过程中，key1 和 key2 计算完 CRC16 值后，对哈希槽总个数 5 取模，再根据各自的模数结果，就可以被映射到对应的实例 1 和实例 3 上了。<strong>在手动分配哈希槽时，需要把 16384 个槽都分配完，否则 Redis 集群无法正常工作</strong>。</p><h3 id="客户端如何定位数据"><a href="#客户端如何定位数据" class="headerlink" title="客户端如何定位数据"></a>客户端如何定位数据</h3><p>进一步定位到实例，还需要知道哈希槽分布在哪个实例上。一般来说，客户端和集群实例建立连接后，实例就会把哈希槽的分配信息发给客户端。但是，在集群刚刚创建的时候，每个实例只知道自己被分配了哪些哈希槽，是不知道其他实例拥有的哈希槽信息的。</p><p>Redis 实例会把自己的哈希槽信息发给和它相连接的其它实例，来完成哈希槽分配信息的扩散。当实例之间相互连接后，每个实例就有所有哈希槽的映射关系了。</p><p>客户端收到哈希槽信息后，会把哈希槽信息缓存在本地。当客户端请求键值对时，会先计算键所对应的哈希槽，然后就可以给相应的实例发送请求了。</p><p>但是，在集群中，实例和哈希槽的对应关系并不是一成不变的，最常见的变化有两个：</p><ul><li>在集群中，实例有新增或删除，Redis 需要重新分配哈希槽；</li><li>为了负载均衡，Redis 需要把哈希槽在所有实例上重新分布一遍。</li></ul><p>Redis Cluster 方案提供了一种<strong>重定向机制，</strong>客户端给一个实例发送数据读写操作时，这个实例上并没有相应的数据，客户端要再给一个新实例发送操作命令。</p><p>当客户端把一个键值对的操作请求发给一个实例时，如果这个实例上并没有这个键值对映射的哈希槽，那么，这个实例就会给客户端返回下面的 MOVED 命令响应结果，这个结果中就包含了新实例的访问地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:<span class="built_in">key</span> </span><br><span class="line">(error) MOVED <span class="number">13320</span> <span class="number">172.16</span><span class="number">.19</span><span class="number">.5</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure><p>其中，MOVED 命令表示，客户端请求的键值对所在的哈希槽 13320，实际是在172.16.19.5 这个实例上。通过返回的 MOVED 命令，就相当于把哈希槽所在的新实例的信息告诉给客户端了。这样一来，客户端就可以直接和 172.16.19.5 连接，并发送操作请求了。</p><img src="/posts/ccb8439b/image-20220914112545803.png" alt="image-20220914112545803" style="zoom:80%;"><p>在上图中，当客户端给实例 2 发送命令时，Slot 2 中的数据已经全部迁移到了实例 3。在实际应用时，如果 Slot 2 中的数据比较多，就可能会出现一种情况：客户端向实例 2 发送请求，但此时，Slot 2 中的数据只有一部分迁移到了实例 3，还有部分数据没有迁移。在这种迁移部分完成的情况下，客户端就会收到一条 ASK 报错信息，如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GET hello:<span class="built_in">key</span></span><br><span class="line">(error) ASK <span class="number">13320</span> <span class="number">172.16</span><span class="number">.19</span><span class="number">.5</span>:<span class="number">6379</span></span><br></pre></td></tr></table></figure><p>这个结果中的 ASK 命令就表示，客户端请求的键值对所在的哈希槽 13320，在172.16.19.5 这个实例上，但是这个哈希槽正在迁移。此时，客户端需要先给 172.16.19.5 这个实例发送一个 ASKING 命令。这个命令的意思是，让这个实例允许执行客户端接下来发送的命令。然后，客户端再向这个实例发送 GET 命令，以读取数据。</p><img src="/posts/ccb8439b/image-20220914113239238.png" alt="image-20220914113239238" style="zoom: 80%;"><p>Slot 2 正在从实例 2 往实例 3 迁移，key1 和 key2 已经迁移过去，key3 和 key4 还在实例 2。客户端向实例 2 请求 key2 后，就会收到实例 2 返回的 ASK 命令。ASK 命令表示两层含义：</p><ul><li>第一，表明 Slot 数据还在迁移中；</li><li>第二，ASK 命令把客户端所请求数据的最新实例地址返回给客户端，此时，客户端需要给实例 3 发送 ASKING 命令，然后再发送操作命令。</li></ul><p>和 MOVED 命令不同，<strong>ASK 命令并不会更新客户端缓存的哈希槽分配信息</strong>。上图中，如果客户端再次请求 Slot 2 中的数据，它还是会给实例 2 发送请求。这也就是说，ASK 命令的作用只是让客户端能给新实例发送一次请求，而不像 MOVED 命令那样，会更改本地缓存，让后续所有命令都发往新实例。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的C++项目开发：聊天室（三）</title>
      <link href="/posts/d2dacbee/"/>
      <url>/posts/d2dacbee/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="多线程客户端"><a href="#多线程客户端" class="headerlink" title="多线程客户端"></a>多线程客户端</h2><p>公用的头文件写在global.h 与global.cpp，代码如下：</p><p>global.h:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/bind.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;boost/asio.hpp&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> chrono;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,<span class="keyword">int</span>&gt; name_sock_map;<span class="comment">//记录名字和文件描述符</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;<span class="keyword">int</span>,set&lt;<span class="keyword">int</span>&gt;&gt; group_map;<span class="comment">//记录群号和对应的文件描述符集合</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,string&gt; from_to_map;<span class="comment">//key:用户名 value:key的用户想私聊的用户</span></span><br><span class="line"><span class="comment">//extern time_point&lt;system_clock&gt; begin_clock;//开始时间，用于压力测试</span></span><br><span class="line"><span class="comment">//extern clock_t begin_clock;//开始时间，用于性能测试，有bug</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> total_time;<span class="comment">//线程池处理任务的总时间</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_handle;<span class="comment">//总处理请求数，用于性能测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> top_speed;<span class="comment">//记录峰值性能</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_recv_request;<span class="comment">//接收到的请求总数，性能测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> Bloom_Filter_bitmap[<span class="number">1000000</span>];<span class="comment">//布隆过滤器所用的bitmap</span></span><br><span class="line"><span class="keyword">extern</span> queue&lt;<span class="keyword">int</span>&gt; mission_queue;<span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> mission_num;<span class="comment">//任务队列中的任务数量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_cond_t</span> mission_cond;<span class="comment">//线程池所需的条件变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> name_mutex;<span class="comment">//互斥锁，锁住需要修改name_sock_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> from_mutex;<span class="comment">//互斥锁，锁住修改from_to_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> group_mutex;<span class="comment">//互斥锁，锁住修改group_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_mutex_t</span> queue_mutex;<span class="comment">//互斥锁，锁住修改任务队列的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> count_mutex;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>global.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">unordered_map&lt;string,<span class="keyword">int</span>&gt; name_sock_map;</span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>,set&lt;<span class="keyword">int</span>&gt;&gt; group_map;</span><br><span class="line">unordered_map&lt;string,string&gt; from_to_map;<span class="comment">//key:用户名 value:key的用户想私聊的用户</span></span><br><span class="line"><span class="comment">//time_point&lt;system_clock&gt; begin_clock;</span></span><br><span class="line"><span class="keyword">double</span> total_time;<span class="comment">//线程池处理任务的总时间</span></span><br><span class="line"><span class="comment">//clock_t begin_clock;//开始时间，用于性能测试</span></span><br><span class="line"><span class="keyword">int</span> total_handle;<span class="comment">//总处理请求数，用于性能测试</span></span><br><span class="line"><span class="keyword">double</span> top_speed;<span class="comment">//记录峰值性能</span></span><br><span class="line"><span class="keyword">int</span> total_recv_request;<span class="comment">//接收到的请求总数，性能测试</span></span><br><span class="line"><span class="keyword">int</span> Bloom_Filter_bitmap[<span class="number">1000000</span>];<span class="comment">//布隆过滤器所用的bitmap</span></span><br><span class="line">queue&lt;<span class="keyword">int</span>&gt; mission_queue;<span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">int</span> mission_num;<span class="comment">//任务队列中的任务数量</span></span><br><span class="line"><span class="keyword">pthread_cond_t</span> mission_cond;<span class="comment">//线程池所需的条件变量</span></span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> name_mutex;<span class="comment">//互斥锁，锁住需要修改name_sock_map的临界区</span></span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> from_mutex;<span class="comment">//互斥锁，锁住修改from_to_map的临界区</span></span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> group_mutex;<span class="comment">//互斥锁，锁住修改group_map的临界区</span></span><br><span class="line"><span class="keyword">pthread_mutex_t</span> queue_mutex;<span class="comment">//互斥锁，锁住修改任务队列的临界区</span></span><br><span class="line"><span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">pthread_spinlock_t</span> count_mutex;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>处理客户端的头文件HandleClient.h：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HANDLECLIENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HANDLECLIENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行此函数来发送消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle_send</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行此函数来接收消息</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle_recv</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>声明两个处理函数，一个发送消息函数，一个接收消息函数。</p><p>处理客户端的程序HandleClient.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;HandleClient.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle_recv</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock=*(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">char</span> recv_buffer[<span class="number">1000</span>];</span><br><span class="line">        <span class="built_in">memset</span>(recv_buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(recv_buffer));</span><br><span class="line">        <span class="keyword">int</span> len=<span class="built_in">recv</span>(sock,recv_buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(recv_buffer),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="function">string <span class="title">str</span><span class="params">(recv_buffer)</span></span>;</span><br><span class="line">        cout&lt;&lt;str&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> *<span class="title">handle_send</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sock=*(<span class="keyword">int</span> *)arg;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        string str;</span><br><span class="line">        cin&gt;&gt;str;</span><br><span class="line">        <span class="keyword">if</span>(str==<span class="string">&quot;exit&quot;</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(sock&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=<span class="string">&quot;content:&quot;</span>+str;</span><br><span class="line">            <span class="built_in">send</span>(sock,str.<span class="built_in">c_str</span>(),str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sock&lt;<span class="number">0</span>)&#123;</span><br><span class="line">            str=<span class="string">&quot;gr_message:&quot;</span>+str;</span><br><span class="line">            <span class="built_in">send</span>(-sock,str.<span class="built_in">c_str</span>(),str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接收消息函数，接收传入的套接字描述符，读取消息到缓冲区recv_buffer，成功读取消息后输出字符串内容。</p><p>发送消息函数，传入发送数据的套接字描述符，读取输入的字符串，如果为”exit”，终止输入；如果套接字描述符的值大于0，为私聊消息，在输入的str前加上”content”前缀标记，执行数据发送；如果套接字描述符的值小于0，为群聊消息，在输入的str前加上”gr_message:”标记，执行数据发送。</p><p>多线程客户端主程序client.cpp:</p><p>头文件导入：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;fstream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HandleClient.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">hand_recv</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> *<span class="title">handle_send</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br></pre></td></tr></table></figure><p>主函数内容：</p><p>定义一个TCP协议的socket，设置服务器端的IP地址与端口号，客户端套接字描述符sock主动连接服务端，调用connect函数；choice记录用户输入的选项（0:退出，1:登录，2:注册），if_login记录是否成功登陆，如果成功登陆，记录该用户名login_name。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> sock;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line"><span class="keyword">pthread_t</span> snd_thread, rcv_thread;</span><br><span class="line">sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">memset</span>(&amp;serv_addr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr));</span><br><span class="line">serv_addr.sin_family = AF_INET;</span><br><span class="line">serv_addr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.3.202&quot;</span>);</span><br><span class="line">serv_addr.sin_port = <span class="built_in">htons</span>(<span class="number">8023</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (struct sockaddr *)&amp;serv_addr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;connect() error&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> choice;</span><br><span class="line">string name,pass,pass1;</span><br><span class="line"><span class="keyword">bool</span> if_login=<span class="literal">false</span>;<span class="comment">//记录是否登录成功</span></span><br><span class="line">string login_name;<span class="comment">//记录成功登录的用户名</span></span><br></pre></td></tr></table></figure><p><strong>新增模块：发送本地cookie，并接收服务器答复，如果答复通过就不用登录</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先检查是否存在cookie文件</span></span><br><span class="line"><span class="function">ifstream <span class="title">f</span><span class="params">(<span class="string">&quot;cookie.txt&quot;</span>)</span></span>;</span><br><span class="line">string cookie_str;</span><br><span class="line"><span class="keyword">if</span>(f.<span class="built_in">good</span>())&#123;</span><br><span class="line">    f&gt;&gt;cookie_str;</span><br><span class="line">    f.<span class="built_in">close</span>();</span><br><span class="line">    cookie_str=<span class="string">&quot;cookie:&quot;</span>+cookie_str;</span><br><span class="line">    <span class="comment">//将cookie发送到服务器</span></span><br><span class="line">    <span class="built_in">send</span>(sock,cookie_str.<span class="built_in">c_str</span>(),cookie_str.<span class="built_in">length</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//接收服务器答复</span></span><br><span class="line">    <span class="keyword">char</span> cookie_ans[<span class="number">100</span>];</span><br><span class="line">    <span class="built_in">memset</span>(cookie_ans,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(cookie_ans));</span><br><span class="line">    <span class="built_in">recv</span>(sock,cookie_ans,<span class="built_in"><span class="keyword">sizeof</span></span>(cookie_ans),<span class="number">0</span>);</span><br><span class="line">    <span class="comment">//判断服务器答复是否通过</span></span><br><span class="line">    <span class="function">string <span class="title">ans_str</span><span class="params">(cookie_ans)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(ans_str!=<span class="string">&quot;NULL&quot;</span>)&#123;<span class="comment">//redis查询到了cookie，通过</span></span><br><span class="line">        if_login=<span class="literal">true</span>;</span><br><span class="line">        login_name=ans_str;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;    </span><br></pre></td></tr></table></figure><p>初始未登录时：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(!if_login)&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; ------------------\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;|                  |\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;| 请输入你要的选项:|\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;|    0:退出        |\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;|    1:登录        |\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;|    2:注册        |\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;|                  |\n&quot;</span>;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; ------------------ \n\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>处理登录与注册事务，如果已登录，跳出该事务；输入choice，choice为0跳出循环；choice为1，输入用户账号与密码合并为字符串str，str前加入”login”前缀标记，发送登录消息，定义buffer缓存区接收服务端的接收响应，接收消息为recv_str，如果为”ok”，代表密码正确登录成功，本地建立cookie文件保存sessionid。sessionid的起始位置为recv_str的第三位，登录成功则跳出该事务，失败提示密码或用户名错误，等待输入choice选项。输入choice为2，执行注册事务，输入用户名与密码，密码需要第二次输入确认，字符串str存储用户账号+密码，发送到服务端。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//开始处理各种事务</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_login)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    cin&gt;&gt;choice;</span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">//登录</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">1</span>&amp;&amp;!if_login)&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;用户名:&quot;</span>;</span><br><span class="line">            cin&gt;&gt;name;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;密码:&quot;</span>;</span><br><span class="line">            cin&gt;&gt;pass;</span><br><span class="line">            string str=<span class="string">&quot;login&quot;</span>+name;</span><br><span class="line">            str+=<span class="string">&quot;pass:&quot;</span>;</span><br><span class="line">            str+=pass;</span><br><span class="line">            <span class="built_in">send</span>(sock,str.<span class="built_in">c_str</span>(),str.<span class="built_in">length</span>(),<span class="number">0</span>);<span class="comment">//发送登录信息</span></span><br><span class="line">            <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">            <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">            <span class="built_in">recv</span>(sock,buffer,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>);<span class="comment">//接收响应</span></span><br><span class="line">            <span class="function">string <span class="title">recv_str</span><span class="params">(buffer)</span></span>;</span><br><span class="line">            <span class="keyword">if</span>(recv_str.<span class="built_in">substr</span>(<span class="number">0</span>,<span class="number">2</span>)==<span class="string">&quot;ok&quot;</span>)&#123;</span><br><span class="line">                if_login=<span class="literal">true</span>;</span><br><span class="line">                login_name=name;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//新增：本地建立cookie文件保存sessionid</span></span><br><span class="line">                string tmpstr=recv_str.<span class="built_in">substr</span>(<span class="number">2</span>);</span><br><span class="line">                tmpstr=<span class="string">&quot;cat &gt; cookie.txt &lt;&lt;end \n&quot;</span>+tmpstr+<span class="string">&quot;\nend&quot;</span>;</span><br><span class="line">                <span class="built_in">system</span>(tmpstr.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;登陆成功\n\n&quot;</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;密码或用户名错误！\n\n&quot;</span>;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//注册</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(choice==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;注册的用户名:&quot;</span>;</span><br><span class="line">        cin&gt;&gt;name;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;密码:&quot;</span>;</span><br><span class="line">            cin&gt;&gt;pass;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;确认密码:&quot;</span>;</span><br><span class="line">            cin&gt;&gt;pass1;</span><br><span class="line">            <span class="keyword">if</span>(pass==pass1)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;两次密码不一致!\n\n&quot;</span>;</span><br><span class="line">        &#125;   </span><br><span class="line">        name=<span class="string">&quot;name:&quot;</span>+name;</span><br><span class="line">        pass=<span class="string">&quot;pass:&quot;</span>+pass;</span><br><span class="line">        string str=name+pass;</span><br><span class="line">        <span class="built_in">send</span>(sock,str.<span class="built_in">c_str</span>(),str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;注册成功！\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;\n继续输入你要的选项:&quot;</span>;     </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(if_login)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>登录成功后，输入新的选项值choice（0:退出，1:私聊，2:群聊），建立两个线程分别执行发送与接收任务。choice为0，退出登录；choice为1，执行私聊事务，输入对方的用户名target_name，发送字符串为”target:”+target_name+”from:”+login_name，标记目标用户与源用户，执行发送函数，创建发送与接收线程，执行handle_send和handle_recv；choice为2，执行群聊事务，输入群号，字符串str加上”group:”前缀标记，发送到服务端，将sock套接字描述符的值变为负值，创建发送与接收线程，执行handle_send和handle_recv。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//登陆成功</span></span><br><span class="line"><span class="keyword">while</span>(if_login&amp;&amp;<span class="number">1</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(if_login)&#123;</span><br><span class="line">        <span class="built_in">system</span>(<span class="string">&quot;clear&quot;</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;        欢迎回来,&quot;</span>&lt;&lt;login_name&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; -------------------------------------------\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|                                           |\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|          请选择你要的选项：               |\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|              0:退出                       |\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|              1:发起单独聊天               |\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|              2:发起群聊                   |\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;|                                           |\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot; ------------------------------------------- \n\n&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cin&gt;&gt;choice;</span><br><span class="line">    <span class="keyword">pthread_t</span> <span class="keyword">send_t</span>,<span class="keyword">recv_t</span>;<span class="comment">//线程ID</span></span><br><span class="line">    <span class="keyword">void</span> *thread_return;</span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入对方的用户名:&quot;</span>;</span><br><span class="line">        string target_name,content;</span><br><span class="line">        cin&gt;&gt;target_name;</span><br><span class="line">        <span class="function">string <span class="title">sendstr</span><span class="params">(<span class="string">&quot;target:&quot;</span>+target_name+<span class="string">&quot;from:&quot;</span>+login_name)</span></span>;<span class="comment">//标识目标用户+源用户</span></span><br><span class="line">        <span class="built_in">send</span>(sock,sendstr.<span class="built_in">c_str</span>(),sendstr.<span class="built_in">length</span>(),<span class="number">0</span>);<span class="comment">//先向服务器发送目标用户、源用户</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入你想说的话(输入exit退出)：\n&quot;</span>;</span><br><span class="line">        <span class="keyword">auto</span> send_thread=<span class="built_in">pthread_create</span>(&amp;<span class="keyword">send_t</span>,<span class="literal">NULL</span>,handle_send,(<span class="keyword">void</span> *)&amp;sock);<span class="comment">//创建发送线程</span></span><br><span class="line">        <span class="keyword">auto</span> recv_thread=<span class="built_in">pthread_create</span>(&amp;<span class="keyword">recv_t</span>,<span class="literal">NULL</span>,handle_recv,(<span class="keyword">void</span> *)&amp;sock);<span class="comment">//创建接收线程</span></span><br><span class="line">        <span class="built_in">pthread_join</span>(<span class="keyword">send_t</span>,&amp;thread_return);</span><br><span class="line">        <span class="comment">//pthread_join(recv_t,&amp;thread_return);</span></span><br><span class="line">        <span class="built_in">pthread_cancel</span>(<span class="keyword">recv_t</span>);</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span>(choice==<span class="number">2</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入群号:&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        cin&gt;&gt;num;</span><br><span class="line">        <span class="function">string <span class="title">sendstr</span><span class="params">(<span class="string">&quot;group:&quot;</span>+to_string(num))</span></span>;</span><br><span class="line">        <span class="built_in">send</span>(sock,sendstr.<span class="built_in">c_str</span>(),sendstr.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;请输入你想说的话(输入exit退出)：\n&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> sock1=-sock;</span><br><span class="line">        <span class="keyword">auto</span> send_thread=<span class="built_in">pthread_create</span>(&amp;<span class="keyword">send_t</span>,<span class="literal">NULL</span>,handle_send,(<span class="keyword">void</span> *)&amp;sock1);<span class="comment">//创建发送线程</span></span><br><span class="line">        <span class="keyword">auto</span> recv_thread=<span class="built_in">pthread_create</span>(&amp;<span class="keyword">recv_t</span>,<span class="literal">NULL</span>,handle_recv,(<span class="keyword">void</span> *)&amp;sock);<span class="comment">//创建接收线程</span></span><br><span class="line">        <span class="built_in">pthread_join</span>(<span class="keyword">send_t</span>,&amp;thread_return);</span><br><span class="line">        <span class="built_in">pthread_cancel</span>(<span class="keyword">recv_t</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; </span><br><span class="line"><span class="built_in">close</span>(sock);</span><br></pre></td></tr></table></figure><h2 id="线程池服务器"><a href="#线程池服务器" class="headerlink" title="线程池服务器"></a>线程池服务器</h2><p>公用头文件相同，global.h与global.cpp</p><p>处理线程池服务器的头文件HandleServerUseThreadPool.h，声明一个线程处理请求函数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HANDLE_SERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HANDLE_SERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行此函数，处理请求</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_all_request</span><span class="params">(<span class="keyword">int</span> arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>处理线程池服务器的文件HandleServerUseThreadPool.cpp，定义该线程处理请求函数。</p><p>name_sock_map记录用户名与套接字描述符（哈希表），group_map记录群号与套接字描述符集合（哈希表）。定义并创建两个互斥锁，分别用于修改name_sock_map的临界区和group_map的临界区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;HandleServerUseThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern unordered_map&lt;pair&lt;int,string&gt;,pair&lt;int,string&gt;&gt; from_to_map;//记录目标用户、源用户</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,<span class="keyword">int</span>&gt; name_sock_map;<span class="comment">//名字和套接字描述符</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;<span class="keyword">int</span>,set&lt;<span class="keyword">int</span>&gt;&gt; group_map;<span class="comment">//记录群号和套接字描述符集合</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">handle_all_request</span><span class="params">(<span class="keyword">int</span> arg)</span></span>&#123;</span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutx;<span class="comment">//互斥锁，锁住需要修改name_sock_map的临界区</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> group_mutx;<span class="comment">//互斥锁，锁住修改group_map的临界区</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutx, <span class="literal">NULL</span>); <span class="comment">//创建互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;group_mutx,<span class="literal">NULL</span>);<span class="comment">//创建互斥锁</span></span><br><span class="line">    <span class="keyword">int</span> conn=arg;</span><br><span class="line">    <span class="keyword">int</span> target_conn=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">    string name,pass;</span><br><span class="line">    <span class="keyword">bool</span> if_login=<span class="literal">false</span>;<span class="comment">//记录当前服务对象是否成功登录</span></span><br><span class="line">    string login_name;<span class="comment">//记录当前服务对象的名字</span></span><br><span class="line">    string target_name;<span class="comment">//记录发送信息时目标用户的名字</span></span><br><span class="line">    <span class="keyword">int</span> group_num;<span class="comment">//记录群号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接MYSQL数据库</span></span><br><span class="line">    MYSQL *con=<span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">mysql_real_connect</span>(con,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;test_connect&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,CLIENT_MULTI_STATEMENTS);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接redis数据库</span></span><br><span class="line">    redisContext *redis_target = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">    <span class="keyword">if</span>(redis_target-&gt;err)&#123;</span><br><span class="line">        <span class="built_in">redisFree</span>(redis_target);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;连接redis失败&quot;</span>&lt;&lt;endl;     </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//禁用nagle算法，防止粘包</span></span><br><span class="line">    <span class="comment">//int enable = 1;</span></span><br><span class="line">    <span class="comment">//setsockopt(conn, IPPROTO_TCP, TCP_NODELAY, (void*)&amp;enable, sizeof(enable));</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-----------------------------\n&quot;</span>;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//断开了连接或者发生了异常</span></span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>||len==<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="function">string <span class="title">str</span><span class="params">(buffer)</span></span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;用户&quot;&lt;&lt;inet_ntoa(clnt_adr.sin_addr)&lt;&lt;&quot;正在连接&quot;;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增：先接收cookie看看redis是否保存该用户的登录状态</span></span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;cookie:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            string cookie=str.<span class="built_in">substr</span>(<span class="number">7</span>);</span><br><span class="line">            string redis_str=<span class="string">&quot;hget &quot;</span>+cookie+<span class="string">&quot; name&quot;</span>;</span><br><span class="line">            redisReply *r = (redisReply*)<span class="built_in">redisCommand</span>(redis_target,redis_str.<span class="built_in">c_str</span>());</span><br><span class="line">            string send_res;</span><br><span class="line">            <span class="keyword">if</span>(r-&gt;str)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;查询redis结果：&quot;</span>&lt;&lt;r-&gt;str&lt;&lt;endl;</span><br><span class="line">                send_res=r-&gt;str;</span><br><span class="line">                <span class="comment">//cout&lt;&lt;sizeof(r-&gt;str)&lt;&lt;endl;</span></span><br><span class="line">                <span class="comment">// cout&lt;&lt;send_res.length()&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                send_res=<span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">            <span class="built_in">send</span>(conn,send_res.<span class="built_in">c_str</span>(),send_res.<span class="built_in">length</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//if(r-&gt;str==)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;login&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1=str.<span class="built_in">find</span>(<span class="string">&quot;login&quot;</span>),p2=str.<span class="built_in">find</span>(<span class="string">&quot;pass:&quot;</span>);</span><br><span class="line">            name=str.<span class="built_in">substr</span>(p1+<span class="number">5</span>,p2<span class="number">-5</span>);</span><br><span class="line">            pass=str.<span class="built_in">substr</span>(p2+<span class="number">5</span>,str.<span class="built_in">length</span>()-p2<span class="number">-4</span>);</span><br><span class="line">            string search=<span class="string">&quot;SELECT * FROM user WHERE NAME=\&quot;&quot;</span>;</span><br><span class="line">            search+=name;</span><br><span class="line">            search+=<span class="string">&quot;\&quot;;&quot;</span>;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;sql语句:&quot;</span>&lt;&lt;search&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">auto</span> search_res=<span class="built_in">mysql_query</span>(con,search.<span class="built_in">c_str</span>());</span><br><span class="line">            <span class="keyword">auto</span> result=<span class="built_in">mysql_store_result</span>(con);</span><br><span class="line">            <span class="keyword">int</span> col=<span class="built_in">mysql_num_fields</span>(result);<span class="comment">//获取列数</span></span><br><span class="line">            <span class="keyword">int</span> row=<span class="built_in">mysql_num_rows</span>(result);<span class="comment">//获取行数</span></span><br><span class="line">            <span class="comment">//auto info=mysql_fetch_row(result);//获取一行的信息</span></span><br><span class="line">            <span class="keyword">if</span>(search_res==<span class="number">0</span>&amp;&amp;row!=<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;查询成功\n&quot;</span>;</span><br><span class="line">                <span class="comment">//auto result=mysql_store_result(con);</span></span><br><span class="line">                <span class="comment">//int col=mysql_num_fields(result);//获取列数</span></span><br><span class="line">                <span class="comment">//int row=mysql_num_rows(result);//获取行数</span></span><br><span class="line">                <span class="keyword">auto</span> info=<span class="built_in">mysql_fetch_row</span>(result);<span class="comment">//获取一行的信息</span></span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;查询到用户名:&quot;</span>&lt;&lt;info[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; 密码:&quot;</span>&lt;&lt;info[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">if</span>(info[<span class="number">1</span>]==pass)&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;登录密码正确\n&quot;</span>;</span><br><span class="line">                    string str1=<span class="string">&quot;ok&quot;</span>;</span><br><span class="line">                    if_login=<span class="literal">true</span>;</span><br><span class="line">                    login_name=name;</span><br><span class="line">                    <span class="built_in">pthread_mutex_lock</span>(&amp;mutx); <span class="comment">//上锁</span></span><br><span class="line">                    name_sock_map[name]=conn;<span class="comment">//记录下名字和文件描述符的对应关系</span></span><br><span class="line">                    <span class="built_in">pthread_mutex_unlock</span>(&amp;mutx); <span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">                    <span class="comment">//新添加：随机生成sessionid并发送到客户端</span></span><br><span class="line">                    <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//初始化随机数种子</span></span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                        <span class="keyword">int</span> type=<span class="built_in">rand</span>()%<span class="number">3</span>;</span><br><span class="line">                        <span class="comment">//type为0代表数字，为1代表小写字母，为2代表大写字母</span></span><br><span class="line">                        <span class="keyword">if</span>(type==<span class="number">0</span>)</span><br><span class="line">                            str1+=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">rand</span>()%<span class="number">9</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">                            str1+=<span class="string">&#x27;a&#x27;</span>+<span class="built_in">rand</span>()%<span class="number">26</span>;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)</span><br><span class="line">                            str1+=<span class="string">&#x27;A&#x27;</span>+<span class="built_in">rand</span>()%<span class="number">26</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//将sessionid存入redis</span></span><br><span class="line">                    string redis_str=<span class="string">&quot;hset &quot;</span>+str1.<span class="built_in">substr</span>(<span class="number">2</span>)+<span class="string">&quot; name &quot;</span>+login_name;</span><br><span class="line">                    redisReply *r = (redisReply*)<span class="built_in">redisCommand</span>(redis_target,redis_str.<span class="built_in">c_str</span>());</span><br><span class="line">                    <span class="comment">//设置生存时间,默认300秒</span></span><br><span class="line">                    redis_str=<span class="string">&quot;expire &quot;</span>+str1.<span class="built_in">substr</span>(<span class="number">2</span>)+<span class="string">&quot; 300&quot;</span>;</span><br><span class="line">                    r=(redisReply*)<span class="built_in">redisCommand</span>(redis_target,redis_str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;随机生成的sessionid为：&quot;</span>&lt;&lt;str1.<span class="built_in">substr</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">                    <span class="comment">//cout&lt;&lt;&quot;redis指令:&quot;&lt;&lt;r-&gt;str&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">                    <span class="built_in">send</span>(conn,str1.<span class="built_in">c_str</span>(),str1.<span class="built_in">length</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;登录密码错误\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">char</span> str1[<span class="number">100</span>]=<span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">                    <span class="built_in">send</span>(conn,str1,<span class="built_in">strlen</span>(str1),<span class="number">0</span>);</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;查询失败\n&quot;</span>;</span><br><span class="line">                <span class="keyword">char</span> str1[<span class="number">100</span>]=<span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">                <span class="built_in">send</span>(conn,str1,<span class="built_in">strlen</span>(str1),<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;name:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1=str.<span class="built_in">find</span>(<span class="string">&quot;name:&quot;</span>),p2=str.<span class="built_in">find</span>(<span class="string">&quot;pass:&quot;</span>);</span><br><span class="line">            name=str.<span class="built_in">substr</span>(p1+<span class="number">5</span>,p2<span class="number">-5</span>);</span><br><span class="line">            pass=str.<span class="built_in">substr</span>(p2+<span class="number">5</span>,str.<span class="built_in">length</span>()-p2<span class="number">-4</span>);</span><br><span class="line">            string search=<span class="string">&quot;INSERT INTO user VALUES (\&quot;&quot;</span>;</span><br><span class="line">            search+=name;</span><br><span class="line">            search+=<span class="string">&quot;\&quot;,\&quot;&quot;</span>;</span><br><span class="line">            search+=pass;</span><br><span class="line">            search+=<span class="string">&quot;\&quot;);&quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;sql语句:&quot;</span>&lt;&lt;search&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">mysql_query</span>(con,search.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">//设定目标的文件描述符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;target:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos1=str.<span class="built_in">find</span>(<span class="string">&quot;from&quot;</span>);</span><br><span class="line">            string target=str.<span class="built_in">substr</span>(<span class="number">7</span>,pos1<span class="number">-7</span>),from=str.<span class="built_in">substr</span>(pos1+<span class="number">4</span>);</span><br><span class="line">            <span class="comment">//pair&lt;string,int&gt; tmp1(from,name_sock_map[from]);</span></span><br><span class="line">            <span class="comment">//pair&lt;string,int&gt; tmp2(target,name_sock_map[target]);</span></span><br><span class="line">            <span class="comment">//from_to_map[tmp1]=tmp2;</span></span><br><span class="line">            target_name=target;</span><br><span class="line">            <span class="keyword">if</span>(name_sock_map.<span class="built_in">find</span>(target)==name_sock_map.<span class="built_in">end</span>())</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;源用户为&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;,目标用户&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;仍未登陆，无法发起私聊\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;源用户&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;向目标用户&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;发起的私聊即将建立&quot;</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;,目标用户的套接字描述符为&quot;</span>&lt;&lt;name_sock_map[target]&lt;&lt;endl;</span><br><span class="line">                target_conn=name_sock_map[target];</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到消息，转发</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;content:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">if</span>(target_conn==<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;找不到目标用户&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;的套接字，将尝试重新寻找目标用户的套接字\n&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(name_sock_map.<span class="built_in">find</span>(target_name)!=name_sock_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    target_conn=name_sock_map[target_name];</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;重新查找目标用户套接字成功\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;查找仍然失败，转发失败！\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//char recv_buff[1000];</span></span><br><span class="line">            <span class="comment">//memset(recv_buff,0,sizeof(recv_buff));</span></span><br><span class="line">            <span class="comment">//int len=recv(conn,recv_buff,sizeof(recv_buff),0);</span></span><br><span class="line">            <span class="function">string <span class="title">recv_str</span><span class="params">(str)</span></span>;</span><br><span class="line">            string send_str=recv_str.<span class="built_in">substr</span>(<span class="number">8</span>);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;用户&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;向&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;发送:&quot;</span>&lt;&lt;send_str&lt;&lt;endl;</span><br><span class="line">            send_str=<span class="string">&quot;[&quot;</span>+login_name+<span class="string">&quot;]:&quot;</span>+send_str;</span><br><span class="line">            <span class="built_in">send</span>(target_conn,send_str.<span class="built_in">c_str</span>(),send_str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//绑定群聊号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;group:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            string <span class="built_in">recv_str</span>(str);</span><br><span class="line">            string num_str=recv_str.<span class="built_in">substr</span>(<span class="number">6</span>);</span><br><span class="line">            group_num=<span class="built_in">stoi</span>(num_str);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;用户&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;绑定群聊号为：&quot;</span>&lt;&lt;num_str&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">pthread_mutex_lock</span>(&amp;group_mutx);<span class="comment">//上锁</span></span><br><span class="line">            <span class="comment">//group_map[group_num].push_back(conn);</span></span><br><span class="line">            group_map[group_num].<span class="built_in">insert</span>(conn);</span><br><span class="line">            <span class="built_in">pthread_mutex_unlock</span>(&amp;group_mutx);<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播群聊信息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;gr_message:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            string <span class="built_in">send_str</span>(str);</span><br><span class="line">            send_str=send_str.<span class="built_in">substr</span>(<span class="number">11</span>);</span><br><span class="line">            send_str=<span class="string">&quot;[&quot;</span>+login_name+<span class="string">&quot;]:&quot;</span>+send_str;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;群聊信息：&quot;</span>&lt;&lt;send_str&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:group_map[group_num])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=conn)</span><br><span class="line">                    <span class="built_in">send</span>(i,send_str.<span class="built_in">c_str</span>(),send_str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="built_in">close</span>(conn);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>线程池服务器主函数serverUseThreadPool.cpp：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HandleServerUseThreadPool.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">handle_all_request</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//unordered_map&lt;pair&lt;int,string&gt;,pair&lt;int,string&gt;&gt; from_to_map;//记录源用户、目的用户</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,<span class="keyword">int</span>&gt; name_sock_map;<span class="comment">//记录名字和套接字描述符</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tmptest</span><span class="params">(<span class="keyword">int</span> a)</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;a&lt;&lt;endl;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serv_sock, clnt_sock; <span class="comment">//服务器端、客户端套接字描述符</span></span><br><span class="line">    sockaddr_in serv_adr,clnt_adr; <span class="comment">//服务器端、客户端的地址与端口号</span></span><br><span class="line">    <span class="keyword">socklen_t</span> clnt_adr_sz; <span class="comment">//记录客户端地址长度</span></span><br><span class="line">    <span class="keyword">pthread_mutex_t</span> mutx;  <span class="comment">//互斥锁</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;mutx, <span class="literal">NULL</span>); <span class="comment">//创建互斥锁</span></span><br><span class="line">    serv_sock = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);<span class="comment">//PF_INET:tcp/ip协议   SOCK_STREAM: tcp    0:默认协议</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;serv_adr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_adr));</span><br><span class="line">    serv_adr.sin_family = AF_INET;<span class="comment">//使用地址族</span></span><br><span class="line">    serv_adr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;172.29.18.134&quot;</span>);<span class="comment">//ip地址</span></span><br><span class="line">    serv_adr.sin_port = <span class="built_in">htons</span>(<span class="number">8023</span>);<span class="comment">//端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//绑定套接字与地址</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">bind</span>(serv_sock, (struct sockaddr *)&amp;serv_adr, <span class="built_in"><span class="keyword">sizeof</span></span>(serv_adr)) == <span class="number">-1</span>)</span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;bind() error&quot;</span>;</span><br><span class="line">    <span class="comment">//服务器监听</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(serv_sock, <span class="number">5</span>) == <span class="number">-1</span>)<span class="comment">//连接队列大小为5</span></span><br><span class="line">         cout&lt;&lt;<span class="string">&quot;listen() error&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//vector&lt;int&gt; sock_arr;//记录套接字描述符</span></span><br><span class="line">    clnt_adr_sz = <span class="built_in"><span class="keyword">sizeof</span></span>(clnt_adr);</span><br><span class="line">    <span class="keyword">int</span> conn; <span class="comment">//连接套接字描述符</span></span><br><span class="line">    <span class="keyword">pthread_t</span> t_id;<span class="comment">//线程id</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//新增boost库线程池</span></span><br><span class="line">    <span class="comment">/* 定义一个5线程的线程池 */</span></span><br><span class="line">    boost::<span class="function">asio::thread_pool <span class="title">tp</span><span class="params">(<span class="number">5</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收连接成功</span></span><br><span class="line">    <span class="keyword">while</span>(conn = <span class="built_in">accept</span>(serv_sock, (struct sockaddr *)&amp;clnt_adr, &amp;clnt_adr_sz))&#123;</span><br><span class="line">        <span class="comment">//HandleServer target;</span></span><br><span class="line">        <span class="comment">//HandleServer::clnt_adr=clnt_adr;</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;用户&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(clnt_adr.sin_addr)&lt;&lt;<span class="string">&quot;正在连接:\n&quot;</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;conn&lt;&lt;endl;</span></span><br><span class="line">        <span class="comment">//sock_arr.push_back((conn);</span></span><br><span class="line">        <span class="comment">//新增boost库线程池</span></span><br><span class="line">        boost::asio::<span class="built_in">post</span>(boost::<span class="built_in">bind</span>(handle_all_request,conn)); <span class="comment">// 执行函数</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//pthread_create(&amp;t_id, NULL, handle_all_request, (void *)&amp;conn); </span></span><br><span class="line">        <span class="comment">//pthread_detach(t_id);  </span></span><br><span class="line">    &#125;</span><br><span class="line">    tp.<span class="built_in">join</span>();<span class="comment">//释放线程池</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="IO复用-线程池服务器"><a href="#IO复用-线程池服务器" class="headerlink" title="IO复用+线程池服务器"></a>IO复用+线程池服务器</h2><p>服务器处理函数头文件HandleServerV2.h</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _HANDLESERVERV2_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _HANDLESERVERV2_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;netinet/tcp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;hiredis/hiredis.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//线程执行此函数，处理请求</span></span><br><span class="line"><span class="comment">//void handle_all_request(string,int);</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handle_all_request</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>服务器处理函数文件HandleServerV2.cpp</p><p>name_sock_map记录用户名与套接字描述符，group_map记录群号和套接字描述符集合，from_to_map记录用户xx要向用户yy发送信息，mission_queue为任务队列。需要创建4个互斥锁，锁住修改这四个变量的临界区。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;HandleServerV2.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,<span class="keyword">int</span>&gt; name_sock_map;<span class="comment">//名字和套接字描述符</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;<span class="keyword">int</span>,set&lt;<span class="keyword">int</span>&gt;&gt; group_map;<span class="comment">//记录群号和套接字描述符集合</span></span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,string&gt; from_to_map;<span class="comment">//记录用户xx要向用户yy发送信息</span></span><br><span class="line"><span class="comment">//extern clock_t begin_clock;//开始时间，用于性能测试</span></span><br><span class="line"><span class="comment">//extern time_point&lt;system_clock&gt; begin_clock;</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_handle;<span class="comment">//总处理请求数，用于性能测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_recv_request;<span class="comment">//接收到的请求总数，性能测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> top_speed;<span class="comment">//峰值性能</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> Bloom_Filter_bitmap[<span class="number">1000000</span>];<span class="comment">//布隆过滤器所用的bitmap</span></span><br><span class="line"><span class="keyword">extern</span> queue&lt;<span class="keyword">int</span>&gt; mission_queue;<span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> mission_num;<span class="comment">//任务队列中的任务数量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_cond_t</span> mission_cond;<span class="comment">//线程池所需的条件变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> name_mutex;<span class="comment">//互斥锁，锁住需要修改name_sock_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> group_mutex;<span class="comment">//互斥锁，锁住修改group_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> from_mutex;<span class="comment">//互斥锁，锁住修改from_to_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_mutex_t</span> queue_mutex;<span class="comment">//互斥锁，锁住修改任务队列的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> count_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">handle_all_request</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>&#123;   <span class="comment">//(string epoll_str,int conn_num,int epollfd)&#123;</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> conn_num;</span><br><span class="line">        <span class="comment">//取出任务</span></span><br><span class="line">        <span class="built_in">pthread_mutex_lock</span>(&amp;queue_mutex);</span><br><span class="line">        <span class="keyword">while</span>(mission_queue.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="built_in">pthread_cond_wait</span>(&amp;mission_cond,&amp;queue_mutex);</span><br><span class="line">        &#125;</span><br><span class="line">        conn_num=mission_queue.<span class="built_in">front</span>();</span><br><span class="line">        mission_queue.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="built_in">pthread_mutex_unlock</span>(&amp;queue_mutex);</span><br><span class="line"></span><br><span class="line">        time_point&lt;system_clock&gt; begin_clock= system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="comment">//pthread_spin_init(&amp;mutex, NULL); //创建互斥锁</span></span><br><span class="line">        <span class="comment">//pthread_spin_init(&amp;group_mutex,NULL);//创建互斥锁</span></span><br><span class="line">        <span class="keyword">int</span> conn=conn_num;</span><br><span class="line">        <span class="keyword">int</span> target_conn=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">        string name,pass;</span><br><span class="line">        <span class="keyword">bool</span> if_login=<span class="literal">false</span>;<span class="comment">//记录当前服务对象是否成功登录</span></span><br><span class="line">        string login_name;<span class="comment">//记录当前服务对象的名字</span></span><br><span class="line">        string target_name;<span class="comment">//记录发送信息时目标用户的名字</span></span><br><span class="line">        <span class="keyword">int</span> group_num;<span class="comment">//记录群号</span></span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接MYSQL数据库</span></span><br><span class="line">        MYSQL *con=<span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">mysql_real_connect</span>(con,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;test_connect&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,CLIENT_MULTI_STATEMENTS);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//连接redis数据库</span></span><br><span class="line">        redisContext *redis_target = <span class="built_in">redisConnect</span>(<span class="string">&quot;127.0.0.1&quot;</span>,<span class="number">6379</span>);</span><br><span class="line">        <span class="keyword">if</span>(redis_target-&gt;err)&#123;</span><br><span class="line">            <span class="built_in">redisFree</span>(redis_target);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;连接redis失败&quot;</span>&lt;&lt;endl;     </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//禁用nagle算法，防止粘包</span></span><br><span class="line">        <span class="comment">//int enable = 1;</span></span><br><span class="line">        <span class="comment">//setsockopt(conn, IPPROTO_TCP, TCP_NODELAY, (void*)&amp;enable, sizeof(enable));</span></span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-----------------------------\n&quot;</span>;</span><br><span class="line">        string recv_str;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">char</span> buf[<span class="number">10</span>];</span><br><span class="line">            <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(buf));</span><br><span class="line">            <span class="keyword">int</span> ret  = <span class="built_in">recv</span>(conn, buf, <span class="built_in"><span class="keyword">sizeof</span></span>(buf), <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;recv返回值小于0&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="comment">//对于非阻塞IO，下面的事件成立标识数据已经全部读取完毕</span></span><br><span class="line">                <span class="keyword">if</span>((errno == EAGAIN) || (errno == EWOULDBLOCK))&#123;</span><br><span class="line">                      <span class="built_in">printf</span>(<span class="string">&quot;数据读取完毕\n&quot;</span>);</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;接收到的完整内容为：&quot;</span>&lt;&lt;recv_str&lt;&lt;endl;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;开始处理事件&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;errno:&quot;</span>&lt;&lt;errno&lt;&lt;endl;</span><br><span class="line">                <span class="built_in">close</span>(conn);</span><br><span class="line">                <span class="built_in">mysql_close</span>(con);</span><br><span class="line">                <span class="keyword">if</span>(!redis_target-&gt;err)</span><br><span class="line">                    <span class="built_in">redisFree</span>(redis_target);</span><br><span class="line">                <span class="comment">//events[i].data.fd=-1;</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(ret == <span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;recv返回值为0&quot;</span>&lt;&lt;endl;</span><br><span class="line">                <span class="built_in">close</span>(conn);</span><br><span class="line">                <span class="built_in">mysql_close</span>(con);</span><br><span class="line">                <span class="keyword">if</span>(!redis_target-&gt;err)</span><br><span class="line">                    <span class="built_in">redisFree</span>(redis_target);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">                <span class="comment">//events[i].data.fd=-1;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;接收到内容如下: %s\n&quot;</span>,buf);</span><br><span class="line">                <span class="function">string <span class="title">tmp</span><span class="params">(buf)</span></span>;</span><br><span class="line">                recv_str+=tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        string str=recv_str;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//新增：先接收cookie看看redis是否保存该用户的登录状态</span></span><br><span class="line">        <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;cookie:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            string cookie=str.<span class="built_in">substr</span>(<span class="number">7</span>);</span><br><span class="line">            string redis_str=<span class="string">&quot;hget &quot;</span>+cookie+<span class="string">&quot; name&quot;</span>;</span><br><span class="line">            redisReply *r = (redisReply*)<span class="built_in">redisCommand</span>(redis_target,redis_str.<span class="built_in">c_str</span>());</span><br><span class="line">            string send_res;</span><br><span class="line">            <span class="keyword">if</span>(r-&gt;str)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;查询redis结果：&quot;</span>&lt;&lt;r-&gt;str&lt;&lt;endl;</span><br><span class="line">                send_res=r-&gt;str;</span><br><span class="line">                <span class="built_in">pthread_spin_lock</span>(&amp;name_mutex); <span class="comment">//上锁</span></span><br><span class="line">                name_sock_map[send_res]=conn;<span class="comment">//记录下名字和文件描述符的对应关系</span></span><br><span class="line">                <span class="built_in">pthread_spin_unlock</span>(&amp;name_mutex); <span class="comment">//解锁</span></span><br><span class="line">                <span class="comment">//cout&lt;&lt;sizeof(r-&gt;str)&lt;&lt;endl;</span></span><br><span class="line">                <span class="comment">// cout&lt;&lt;send_res.length()&lt;&lt;endl;</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                send_res=<span class="string">&quot;NULL&quot;</span>;</span><br><span class="line">            <span class="built_in">send</span>(conn,send_res.<span class="built_in">c_str</span>(),send_res.<span class="built_in">length</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">            <span class="comment">//if(r-&gt;str==)</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//登录</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;login&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1=str.<span class="built_in">find</span>(<span class="string">&quot;login&quot;</span>),p2=str.<span class="built_in">find</span>(<span class="string">&quot;pass:&quot;</span>),flag=<span class="number">0</span>;</span><br><span class="line">            name=str.<span class="built_in">substr</span>(p1+<span class="number">5</span>,p2<span class="number">-5</span>);</span><br><span class="line">            pass=str.<span class="built_in">substr</span>(p2+<span class="number">5</span>,str.<span class="built_in">length</span>()-p2<span class="number">-4</span>);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//新增布隆过滤器</span></span><br><span class="line">            <span class="comment">//对字符串使用哈希函数</span></span><br><span class="line">            <span class="keyword">int</span> hash=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> ch:name)&#123;</span><br><span class="line">                hash=hash*<span class="number">131</span>+ch;</span><br><span class="line">                <span class="keyword">if</span>(hash&gt;=<span class="number">10000000</span>)</span><br><span class="line">                    hash%=<span class="number">10000000</span>;                            </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> index=hash/<span class="number">32</span>,pos=hash%<span class="number">32</span>;</span><br><span class="line">            <span class="keyword">if</span>((Bloom_Filter_bitmap[index]&amp;(<span class="number">1</span>&lt;&lt;pos))==<span class="number">0</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;布隆过滤器查询为0，登录用户名必然不存在数据库中\n&quot;</span>;</span><br><span class="line">                <span class="keyword">char</span> str1[<span class="number">100</span>]=<span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">                <span class="built_in">send</span>(conn,str1,<span class="built_in">strlen</span>(str1),<span class="number">0</span>);</span><br><span class="line">                flag=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//布隆过滤器无法判断才要查数据库</span></span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>)&#123;</span><br><span class="line">                string search=<span class="string">&quot;SELECT * FROM user WHERE NAME=\&quot;&quot;</span>;</span><br><span class="line">                search+=name;</span><br><span class="line">                search+=<span class="string">&quot;\&quot;;&quot;</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;sql语句:&quot;</span>&lt;&lt;search&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">auto</span> search_res=<span class="built_in">mysql_query</span>(con,search.<span class="built_in">c_str</span>());</span><br><span class="line">                <span class="keyword">auto</span> result=<span class="built_in">mysql_store_result</span>(con);</span><br><span class="line">                <span class="comment">//int col=mysql_num_fields(result);//获取列数</span></span><br><span class="line">                <span class="keyword">int</span> row;</span><br><span class="line">                <span class="keyword">if</span>(result)</span><br><span class="line">                    row=<span class="built_in">mysql_num_rows</span>(result);<span class="comment">//获取行数</span></span><br><span class="line">                <span class="comment">//auto info=mysql_fetch_row(result);//获取一行的信息</span></span><br><span class="line">                <span class="keyword">if</span>(search_res==<span class="number">0</span>&amp;&amp;row!=<span class="number">0</span>)&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;查询成功\n&quot;</span>;</span><br><span class="line">                    <span class="comment">//auto result=mysql_store_result(con);</span></span><br><span class="line">                    <span class="comment">//int col=mysql_num_fields(result);//获取列数</span></span><br><span class="line">                    <span class="comment">//int row=mysql_num_rows(result);//获取行数</span></span><br><span class="line">                    <span class="keyword">auto</span> info=<span class="built_in">mysql_fetch_row</span>(result);<span class="comment">//获取一行的信息</span></span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;查询到用户名:&quot;</span>&lt;&lt;info[<span class="number">0</span>]&lt;&lt;<span class="string">&quot; 密码:&quot;</span>&lt;&lt;info[<span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">if</span>(info[<span class="number">1</span>]==pass)&#123;</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;登录密码正确\n&quot;</span>;</span><br><span class="line">                        string str1=<span class="string">&quot;ok&quot;</span>;</span><br><span class="line">                        if_login=<span class="literal">true</span>;</span><br><span class="line">                        login_name=name;</span><br><span class="line">                        <span class="built_in">pthread_spin_lock</span>(&amp;name_mutex); <span class="comment">//上锁</span></span><br><span class="line">                        name_sock_map[name]=conn;<span class="comment">//记录下名字和文件描述符的对应关系</span></span><br><span class="line">                        <span class="built_in">pthread_spin_unlock</span>(&amp;name_mutex); <span class="comment">//解锁</span></span><br><span class="line"></span><br><span class="line">                        <span class="comment">//新添加：随机生成sessionid并发送到客户端</span></span><br><span class="line">                        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">NULL</span>));<span class="comment">//初始化随机数种子</span></span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">                            <span class="keyword">int</span> type=<span class="built_in">rand</span>()%<span class="number">3</span>;<span class="comment">//type为0代表数字，为1代表小写字母，为2代表大写字母</span></span><br><span class="line">                            <span class="keyword">if</span>(type==<span class="number">0</span>)</span><br><span class="line">                                str1+=<span class="string">&#x27;0&#x27;</span>+<span class="built_in">rand</span>()%<span class="number">9</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">1</span>)</span><br><span class="line">                                str1+=<span class="string">&#x27;a&#x27;</span>+<span class="built_in">rand</span>()%<span class="number">26</span>;</span><br><span class="line">                            <span class="keyword">else</span> <span class="keyword">if</span>(type==<span class="number">2</span>)</span><br><span class="line">                                str1+=<span class="string">&#x27;A&#x27;</span>+<span class="built_in">rand</span>()%<span class="number">26</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将sessionid存入redis</span></span><br><span class="line">                        string redis_str=<span class="string">&quot;hset &quot;</span>+str1.<span class="built_in">substr</span>(<span class="number">2</span>)+<span class="string">&quot; name &quot;</span>+login_name;</span><br><span class="line">                        redisReply *r = (redisReply*)<span class="built_in">redisCommand</span>(redis_target,redis_str.<span class="built_in">c_str</span>());</span><br><span class="line">                        <span class="comment">//设置生存时间,默认300秒</span></span><br><span class="line">                        redis_str=<span class="string">&quot;expire &quot;</span>+str1.<span class="built_in">substr</span>(<span class="number">2</span>)+<span class="string">&quot; 300&quot;</span>;</span><br><span class="line">                        r=(redisReply*)<span class="built_in">redisCommand</span>(redis_target,redis_str.<span class="built_in">c_str</span>());</span><br><span class="line"></span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;随机生成的sessionid为：&quot;</span>&lt;&lt;str1.<span class="built_in">substr</span>(<span class="number">2</span>)&lt;&lt;endl;</span><br><span class="line">                        <span class="comment">//cout&lt;&lt;&quot;redis指令:&quot;&lt;&lt;r-&gt;str&lt;&lt;endl;</span></span><br><span class="line"></span><br><span class="line">                        <span class="built_in">send</span>(conn,str1.<span class="built_in">c_str</span>(),str1.<span class="built_in">length</span>()+<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;登录密码错误\n&quot;</span>;</span><br><span class="line">                        <span class="keyword">char</span> str1[<span class="number">100</span>]=<span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">                        <span class="built_in">send</span>(conn,str1,<span class="built_in">strlen</span>(str1),<span class="number">0</span>);</span><br><span class="line">                    &#125;   </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;查询失败\n&quot;</span>;</span><br><span class="line">                    <span class="keyword">char</span> str1[<span class="number">100</span>]=<span class="string">&quot;wrong&quot;</span>;</span><br><span class="line">                    <span class="built_in">send</span>(conn,str1,<span class="built_in">strlen</span>(str1),<span class="number">0</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//注册</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;name:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">int</span> p1=str.<span class="built_in">find</span>(<span class="string">&quot;name:&quot;</span>),p2=str.<span class="built_in">find</span>(<span class="string">&quot;pass:&quot;</span>);</span><br><span class="line">            name=str.<span class="built_in">substr</span>(p1+<span class="number">5</span>,p2<span class="number">-5</span>);</span><br><span class="line">            pass=str.<span class="built_in">substr</span>(p2+<span class="number">5</span>,str.<span class="built_in">length</span>()-p2<span class="number">-4</span>);</span><br><span class="line">            string search=<span class="string">&quot;INSERT INTO user VALUES (\&quot;&quot;</span>;</span><br><span class="line">            search+=name;</span><br><span class="line">            search+=<span class="string">&quot;\&quot;,\&quot;&quot;</span>;</span><br><span class="line">            search+=pass;</span><br><span class="line">            search+=<span class="string">&quot;\&quot;);&quot;</span>;</span><br><span class="line">            cout&lt;&lt;endl&lt;&lt;<span class="string">&quot;sql语句:&quot;</span>&lt;&lt;search&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">mysql_query</span>(con,search.<span class="built_in">c_str</span>());</span><br><span class="line">        &#125; </span><br><span class="line">        </span><br><span class="line">        <span class="comment">//设定目标的文件描述符</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;target:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="keyword">int</span> pos1=str.<span class="built_in">find</span>(<span class="string">&quot;from&quot;</span>);</span><br><span class="line">            string target=str.<span class="built_in">substr</span>(<span class="number">7</span>,pos1<span class="number">-7</span>),from=str.<span class="built_in">substr</span>(pos1+<span class="number">5</span>);</span><br><span class="line">            <span class="comment">//pair&lt;string,int&gt; tmp1(from,name_sock_map[from]);</span></span><br><span class="line">            <span class="comment">//pair&lt;string,int&gt; tmp2(target,name_sock_map[target]);</span></span><br><span class="line">            <span class="comment">//from_to_map[tmp1]=tmp2;</span></span><br><span class="line">            target_name=target;</span><br><span class="line">            <span class="keyword">if</span>(name_sock_map.<span class="built_in">find</span>(target)==name_sock_map.<span class="built_in">end</span>())</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;源用户为&quot;</span>&lt;&lt;from&lt;&lt;<span class="string">&quot;,目标用户&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;仍未登陆，无法发起私聊\n&quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">pthread_spin_lock</span>(&amp;from_mutex);</span><br><span class="line">                from_to_map[from]=target;</span><br><span class="line">                <span class="built_in">pthread_spin_unlock</span>(&amp;from_mutex);</span><br><span class="line">                login_name=from;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;源用户&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;向目标用户&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;发起的私聊即将建立&quot;</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;,目标用户的套接字描述符为&quot;</span>&lt;&lt;name_sock_map[target]&lt;&lt;endl;</span><br><span class="line">                target_conn=name_sock_map[target];</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收到消息，转发</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;content:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="comment">//根据两个map找出当前用户和目标用户</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:name_sock_map)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i.second==conn)&#123;</span><br><span class="line">                    login_name=i.first;</span><br><span class="line">                    target_name=from_to_map[i.first];</span><br><span class="line">                    target_conn=name_sock_map[target_name];</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;       </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(target_conn==<span class="number">-1</span>)&#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;找不到目标用户&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;的套接字，将尝试重新寻找目标用户的套接字\n&quot;</span>;</span><br><span class="line">                <span class="keyword">if</span>(name_sock_map.<span class="built_in">find</span>(target_name)!=name_sock_map.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    target_conn=name_sock_map[target_name];</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;重新查找目标用户套接字成功\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;查找仍然失败，转发失败！\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//char recv_buff[1000];</span></span><br><span class="line">            <span class="comment">//memset(recv_buff,0,sizeof(recv_buff));</span></span><br><span class="line">            <span class="comment">//int len=recv(conn,recv_buff,sizeof(recv_buff),0);</span></span><br><span class="line">            <span class="function">string <span class="title">recv_str</span><span class="params">(str)</span></span>;</span><br><span class="line">            string send_str=recv_str.<span class="built_in">substr</span>(<span class="number">8</span>);</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;用户&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;向&quot;</span>&lt;&lt;target_name&lt;&lt;<span class="string">&quot;发送:&quot;</span>&lt;&lt;send_str&lt;&lt;endl;</span><br><span class="line">            send_str=<span class="string">&quot;[&quot;</span>+login_name+<span class="string">&quot;]:&quot;</span>+send_str;</span><br><span class="line">            <span class="built_in">send</span>(target_conn,send_str.<span class="built_in">c_str</span>(),send_str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//绑定群聊号</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;group:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            string <span class="built_in">recv_str</span>(str);</span><br><span class="line">            string num_str=recv_str.<span class="built_in">substr</span>(<span class="number">6</span>);</span><br><span class="line">            group_num=<span class="built_in">stoi</span>(num_str);</span><br><span class="line">            <span class="comment">//找出当前用户</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:name_sock_map)</span><br><span class="line">                <span class="keyword">if</span>(i.second==conn)&#123;</span><br><span class="line">                    login_name=i.first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;用户&quot;</span>&lt;&lt;login_name&lt;&lt;<span class="string">&quot;绑定群聊号为：&quot;</span>&lt;&lt;num_str&lt;&lt;endl;</span><br><span class="line">            <span class="built_in">pthread_spin_lock</span>(&amp;group_mutex);<span class="comment">//上锁</span></span><br><span class="line">            <span class="comment">//group_map[group_num].push_back(conn);</span></span><br><span class="line">            group_map[group_num].<span class="built_in">insert</span>(conn);</span><br><span class="line">            <span class="built_in">pthread_spin_unlock</span>(&amp;group_mutex);<span class="comment">//解锁</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//广播群聊信息</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(str.<span class="built_in">find</span>(<span class="string">&quot;gr_message:&quot;</span>)!=str.npos)&#123;</span><br><span class="line">            <span class="comment">//找出当前用户</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:name_sock_map)</span><br><span class="line">                <span class="keyword">if</span>(i.second==conn)&#123;</span><br><span class="line">                    login_name=i.first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="comment">//找出群号</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:group_map)</span><br><span class="line">                <span class="keyword">if</span>(i.second.<span class="built_in">find</span>(conn)!=i.second.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    group_num=i.first;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="function">string <span class="title">send_str</span><span class="params">(str)</span></span>;</span><br><span class="line">            send_str=send_str.<span class="built_in">substr</span>(<span class="number">11</span>);</span><br><span class="line">            send_str=<span class="string">&quot;[&quot;</span>+login_name+<span class="string">&quot;]:&quot;</span>+send_str;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;群聊信息：&quot;</span>&lt;&lt;send_str&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> i:group_map[group_num])&#123;</span><br><span class="line">                <span class="keyword">if</span>(i!=conn)</span><br><span class="line">                    <span class="built_in">send</span>(i,send_str.<span class="built_in">c_str</span>(),send_str.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">            &#125;       </span><br><span class="line">        &#125;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;---------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//线程工作完毕后重新注册事件</span></span><br><span class="line">        epoll_event event;</span><br><span class="line">        event.data.fd=conn;</span><br><span class="line">        event.events=EPOLLIN|EPOLLET|EPOLLONESHOT;</span><br><span class="line">        <span class="built_in">epoll_ctl</span>(epollfd,EPOLL_CTL_MOD,conn,&amp;event);</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">mysql_close</span>(con);</span><br><span class="line">        <span class="keyword">if</span>(!redis_target-&gt;err)</span><br><span class="line">            <span class="built_in">redisFree</span>(redis_target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//性能测试</span></span><br><span class="line">        <span class="keyword">auto</span> end_clock   = system_clock::<span class="built_in">now</span>();</span><br><span class="line">        <span class="keyword">auto</span> duration = duration_cast&lt;microseconds&gt;(end_clock - begin_clock);</span><br><span class="line">        <span class="built_in">pthread_spin_lock</span>(&amp;count_mutex);</span><br><span class="line">        total_time+=<span class="built_in"><span class="keyword">double</span></span>(duration.<span class="built_in">count</span>()) * microseconds::period::num / microseconds::period::den; </span><br><span class="line">        total_handle++;</span><br><span class="line">        <span class="built_in">pthread_spin_unlock</span>(&amp;count_mutex);</span><br><span class="line">        <span class="comment">//double total_time=(double)(end_clock-begin_clock)/CLOCKS_PER_SEC;</span></span><br><span class="line">        <span class="comment">//cout&lt;&lt;begin_clock&lt;&lt;&quot; &quot;&lt;&lt;end_clock&lt;&lt;endl;</span></span><br><span class="line">        <span class="keyword">double</span> now_rate=total_handle/total_time;</span><br><span class="line">        <span class="keyword">if</span>(now_rate&gt;top_speed)</span><br><span class="line">            top_speed=now_rate;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;已用时&quot;</span>&lt;&lt;total_time&lt;&lt;<span class="string">&quot;秒,&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;共收到&quot;</span>&lt;&lt;total_recv_request&lt;&lt;<span class="string">&quot;个请求,&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;已处理&quot;</span>&lt;&lt;total_handle&lt;&lt;<span class="string">&quot;个请求\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;处理一个请求平均需要&quot;</span>&lt;&lt;total_time/total_handle&lt;&lt;<span class="string">&quot;秒,&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;平均一秒处理&quot;</span>&lt;&lt;now_rate&lt;&lt;<span class="string">&quot;个请求\n&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;峰值性能为一秒处理&quot;</span>&lt;&lt;top_speed&lt;&lt;<span class="string">&quot;个请求&quot;</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;---------------------------------\n&quot;</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器主函数serverV2.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;HandleServerV2.h&quot;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//#define MAXLINE 1000  </span></span><br><span class="line"><span class="comment">//#define OPEN_MAX 100</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//listen的backlog大小</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ 200</span></span><br><span class="line"><span class="comment">//监听端口号</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 8000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INFTIM 1000 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//extern void handle_all_request(string epoll_str,int conn_num,int epollfd);</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span>* <span class="title">handle_all_request</span><span class="params">(<span class="keyword">void</span> *arg)</span></span>;</span><br><span class="line"><span class="keyword">extern</span> unordered_map&lt;string,<span class="keyword">int</span>&gt; name_sock_map;<span class="comment">//记录名字和套接字描述符</span></span><br><span class="line"><span class="comment">//extern clock_t begin_clock;//开始时间，用于性能测试，有bug</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">double</span> total_time;<span class="comment">//线程池处理任务的总时间</span></span><br><span class="line"><span class="comment">//extern time_point&lt;system_clock&gt; begin_clock;//开始时间，压力测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_handle;<span class="comment">//总处理请求数，用于性能测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> total_recv_request;<span class="comment">//接收到的请求总数，性能测试</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> Bloom_Filter_bitmap[<span class="number">1000000</span>];<span class="comment">//布隆过滤器所用的bitmap</span></span><br><span class="line"><span class="keyword">extern</span> queue&lt;<span class="keyword">int</span>&gt; mission_queue;<span class="comment">//任务队列</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> mission_num;<span class="comment">//任务队列中的任务数量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_cond_t</span> mission_cond;<span class="comment">//线程池所需的条件变量</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> name_mutex;<span class="comment">//互斥锁，锁住需要修改name_sock_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> from_mutex;<span class="comment">//互斥锁，锁住修改from_to_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> group_mutex;<span class="comment">//互斥锁，锁住修改group_map的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_mutex_t</span> queue_mutex;<span class="comment">//互斥锁，锁住修改任务队列的临界区</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> epollfd;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">pthread_spinlock_t</span> count_mutex;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将参数的文件描述符设为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> sock)</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">int</span> opts;  </span><br><span class="line">    opts=<span class="built_in">fcntl</span>(sock,F_GETFL);  </span><br><span class="line">    <span class="keyword">if</span>(opts&lt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(sock,GETFL)&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">    opts = opts|O_NONBLOCK;  </span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">fcntl</span>(sock,F_SETFL,opts)&lt;<span class="number">0</span>)  </span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;fcntl(sock,SETFL,opts)&quot;</span>);  </span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">    &#125;      </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;name_mutex, <span class="number">0</span>); <span class="comment">//创建互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;group_mutex,<span class="number">0</span>);<span class="comment">//创建互斥锁</span></span><br><span class="line">    <span class="built_in">pthread_mutex_init</span>(&amp;queue_mutex,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;count_mutex,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_spin_init</span>(&amp;from_mutex,<span class="number">0</span>);</span><br><span class="line">    <span class="built_in">pthread_cond_init</span>(&amp;mission_cond,<span class="literal">NULL</span>);<span class="comment">//初始化条件变量</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> i, maxi, listenfd, connfd, sockfd,epfd,nfds;  </span><br><span class="line">    <span class="keyword">ssize_t</span> n;  </span><br><span class="line">    <span class="comment">//char line[MAXLINE];  </span></span><br><span class="line">    <span class="keyword">socklen_t</span> clilen;  </span><br><span class="line">    <span class="comment">//声明epoll_event结构体的变量,ev用于注册事件,数组用于回传要处理的事件  </span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> <span class="title">ev</span>,<span class="title">events</span>[10000];</span>  </span><br><span class="line">    <span class="comment">//生成用于处理accept的epoll专用的文件描述符  </span></span><br><span class="line">    epfd=<span class="built_in">epoll_create</span>(<span class="number">10000</span>);</span><br><span class="line">    epollfd=epfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">clientaddr</span>;</span>  </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serveraddr</span>;</span>  </span><br><span class="line">    listenfd = <span class="built_in">socket</span>(PF_INET, SOCK_STREAM, <span class="number">0</span>);  </span><br><span class="line">    <span class="comment">//把socket设置为非阻塞方式  </span></span><br><span class="line">    <span class="built_in">setnonblocking</span>(listenfd);  </span><br><span class="line">    <span class="comment">//设置与要处理的事件相关的文件描述符  </span></span><br><span class="line">    ev.data.fd=listenfd;  </span><br><span class="line">    <span class="comment">//设置要处理的事件类型  </span></span><br><span class="line">    ev.events=EPOLLIN|EPOLLET;  </span><br><span class="line">    <span class="comment">//注册epoll事件  </span></span><br><span class="line">    <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,listenfd,&amp;ev); <span class="comment">//相当于Select模型的FD_SET  </span></span><br><span class="line">    <span class="comment">//设置serveraddr</span></span><br><span class="line">    <span class="built_in">bzero</span>(&amp;serveraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(serveraddr));  </span><br><span class="line">    serveraddr.sin_family = AF_INET;  </span><br><span class="line">    serveraddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;192.168.3.202&quot;</span>);<span class="comment">//此处设为服务器的ip</span></span><br><span class="line">    serveraddr.sin_port=<span class="built_in">htons</span>(<span class="number">8023</span>);  </span><br><span class="line">    <span class="built_in">bind</span>(listenfd,(sockaddr *)&amp;serveraddr, <span class="built_in"><span class="keyword">sizeof</span></span>(serveraddr));  </span><br><span class="line">    <span class="built_in">listen</span>(listenfd, LISTENQ); </span><br><span class="line">    clilen=<span class="built_in"><span class="keyword">sizeof</span></span>(clientaddr);</span><br><span class="line">    maxi = <span class="number">0</span>;   </span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;准备连数据库\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接MYSQL数据库</span></span><br><span class="line">    MYSQL *con=<span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">mysql_real_connect</span>(con,<span class="string">&quot;127.0.0.1&quot;</span>,<span class="string">&quot;root&quot;</span>,<span class="string">&quot;&quot;</span>,<span class="string">&quot;test_connect&quot;</span>,<span class="number">0</span>,<span class="literal">NULL</span>,CLIENT_MULTI_STATEMENTS);</span><br><span class="line">    string search=<span class="string">&quot;SELECT * FROM user;&quot;</span>;</span><br><span class="line">    <span class="keyword">auto</span> search_res=<span class="built_in">mysql_query</span>(con,search.<span class="built_in">c_str</span>());</span><br><span class="line">    <span class="keyword">auto</span> result=<span class="built_in">mysql_store_result</span>(con);</span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">if</span>(result)</span><br><span class="line">        row=<span class="built_in">mysql_num_rows</span>(result);<span class="comment">//获取行数</span></span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;连接数据库成功\n准备初始化布隆过滤器\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据并完成布隆过滤器初始化</span></span><br><span class="line">    <span class="built_in">memset</span>(Bloom_Filter_bitmap,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(Bloom_Filter_bitmap));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;row;i++)&#123;</span><br><span class="line">        <span class="keyword">auto</span> info=<span class="built_in">mysql_fetch_row</span>(result);<span class="comment">//获取一行的信息</span></span><br><span class="line">        string read_name=info[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//对字符串使用哈希函数</span></span><br><span class="line">        <span class="keyword">int</span> hash=<span class="number">0</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;字符串：&quot;&lt;&lt;read_name;</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ch:read_name)&#123;</span><br><span class="line">            hash=hash*<span class="number">131</span>+ch;</span><br><span class="line">            <span class="keyword">if</span>(hash&gt;=<span class="number">10000000</span>)</span><br><span class="line">                hash%=<span class="number">10000000</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        hash%=<span class="number">32000000</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;,hash值为：&quot;&lt;&lt;hash;</span></span><br><span class="line">        <span class="comment">//调整bitmap</span></span><br><span class="line">        <span class="keyword">int</span> index=hash/<span class="number">32</span>,pos=hash%<span class="number">32</span>;</span><br><span class="line">        <span class="comment">//cout&lt;&lt;index&lt;&lt;&quot; &quot;&lt;&lt;pos&lt;&lt;endl;</span></span><br><span class="line">        Bloom_Filter_bitmap[index]|=(<span class="number">1</span>&lt;&lt;pos);</span><br><span class="line">        <span class="comment">//cout&lt;&lt;&quot;,调整后的：&quot;&lt;&lt;Bloom_Filter_bitmap[index]&lt;&lt;endl;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">mysql_close</span>(con);</span><br><span class="line">    <span class="keyword">int</span> one=<span class="number">0</span>,zero=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> i:Bloom_Filter_bitmap)&#123;</span><br><span class="line">        <span class="keyword">int</span> b=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=<span class="number">32</span>;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(b&amp;i)</span><br><span class="line">                one++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                zero++;</span><br><span class="line">            b=(b&lt;&lt;<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;布隆过滤器中共有&quot;</span>&lt;&lt;one&lt;&lt;<span class="string">&quot;位被置为1，其余&quot;</span>&lt;&lt;zero&lt;&lt;<span class="string">&quot;位仍为0&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 定义一个10线程的线程池 */</span></span><br><span class="line">    <span class="comment">//boost::asio::thread_pool tp(10);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//10个线程的线程池</span></span><br><span class="line">    <span class="keyword">pthread_t</span> tid[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">        <span class="built_in">pthread_create</span>(&amp;tid[i],<span class="literal">NULL</span>,handle_all_request,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//压力测试</span></span><br><span class="line">    total_time=<span class="number">0</span>;</span><br><span class="line">    total_handle=<span class="number">0</span>;</span><br><span class="line">    total_recv_request=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;  </span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;--------------------------&quot;</span>&lt;&lt;endl;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;epoll_wait阻塞中&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//等待epoll事件的发生  </span></span><br><span class="line">        nfds=<span class="built_in">epoll_wait</span>(epfd,events,<span class="number">10000</span>,<span class="number">-1</span>);<span class="comment">//最后一个参数是timeout，0:立即返回，-1:一直阻塞直到有事件，x:等待x毫秒</span></span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;epoll_wait返回，有事件发生&quot;</span>&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//处理所发生的所有事件  </span></span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;nfds;++i)  </span><br><span class="line">        &#123;  </span><br><span class="line">            <span class="comment">//有新客户端连接服务器</span></span><br><span class="line">            <span class="keyword">if</span>(events[i].data.fd==listenfd) </span><br><span class="line">            &#123;  </span><br><span class="line">                connfd = <span class="built_in">accept</span>(listenfd,(sockaddr *)&amp;clientaddr, &amp;clilen);  </span><br><span class="line">                <span class="keyword">if</span>(connfd&lt;<span class="number">0</span>)&#123;  </span><br><span class="line">                     <span class="built_in">perror</span>(<span class="string">&quot;connfd&lt;0&quot;</span>);  </span><br><span class="line">                     <span class="built_in">exit</span>(<span class="number">1</span>);  </span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    cout&lt;&lt;<span class="string">&quot;用户&quot;</span>&lt;&lt;<span class="built_in">inet_ntoa</span>(clientaddr.sin_addr)&lt;&lt;<span class="string">&quot;正在连接\n&quot;</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//设置用于读操作的文件描述符  </span></span><br><span class="line">                ev.data.fd=connfd;  </span><br><span class="line">                <span class="comment">//设置用于注册的读操作事件，采用ET边缘触发，为防止多个线程处理同一socket而使用EPOLLONESHOT  </span></span><br><span class="line">                ev.events=EPOLLIN|EPOLLET|EPOLLONESHOT;</span><br><span class="line">                <span class="comment">//边缘触发要将套接字设为非阻塞</span></span><br><span class="line">                <span class="built_in">setnonblocking</span>(connfd);</span><br><span class="line">                <span class="comment">//注册ev  </span></span><br><span class="line">                <span class="built_in">epoll_ctl</span>(epfd,EPOLL_CTL_ADD,connfd,&amp;ev);  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="comment">//接收到读事件</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(events[i].events&amp;EPOLLIN)  </span><br><span class="line">            &#123;  </span><br><span class="line">                total_recv_request++;</span><br><span class="line">                sockfd = events[i].data.fd;</span><br><span class="line">                events[i].data.fd=<span class="number">-1</span>;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;接收到读事件&quot;</span>&lt;&lt;endl;</span><br><span class="line">                </span><br><span class="line">                <span class="built_in">pthread_mutex_lock</span>(&amp;queue_mutex);</span><br><span class="line">                mission_queue.<span class="built_in">push</span>(sockfd);<span class="comment">//加入任务队列</span></span><br><span class="line">                <span class="built_in">pthread_cond_broadcast</span>(&amp;mission_cond);<span class="comment">//广播唤醒</span></span><br><span class="line">                <span class="built_in">pthread_mutex_unlock</span>(&amp;queue_mutex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//string recv_str;</span></span><br><span class="line">                <span class="comment">//boost::asio::post(boost::bind(handle_all_request,recv_str,sockfd,epfd)); //加入任务队列，处理事件</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125; </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">close</span>(listenfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的C++项目开发：聊天室（二）</title>
      <link href="/posts/9fc468bc/"/>
      <url>/posts/9fc468bc/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="MySQL数据库"><a href="#MySQL数据库" class="headerlink" title="MySQL数据库"></a>MySQL数据库</h2><h3 id="MySQL基础"><a href="#MySQL基础" class="headerlink" title="MySQL基础"></a>MySQL基础</h3><p>数据库一般分为关系型数据库和非关系型数据库，关系型数据库有我们常见的 MySQL、Oracle 等，非关系型数据库有 Redis 等。</p><p>关系型数据库是用二维表格模型来组织数据信息的数据库。MySQL 实际上是一个关系数据库管理系统，在这个系统里面可以有多个数据库，每个数据库中可以有多张表，每张表中可以有多列属性和多行数据。</p><p>比如我们要添加用户注册功能，就可以创建一个专用的数据库，在数据库中建一张叫 USER 的表，表中包含用户名 NAME 和密码 PASSWORD 两列属性，然后下面的若干行就是具体的数据。</p><p><strong>SQL结构化查询语言</strong>：</p><p>SQL 即结构化查询语言，是一种数据库查询语言，用来管理关系数据库系统，以及对数据进行增删查改等操作。</p><p><strong>Linux下启动MySQL</strong>：</p><p>首先启动 MySQL 服务，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service mysql start</span><br></pre></td></tr></table></figure><p>进入MySQL控制台：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mysql -u root -p</span><br><span class="line">// 输入密码</span><br></pre></td></tr></table></figure><p>接下来就可以输入各种 SQL 语句管理数据库系统了。</p><p><strong>C++连接MySQL的环境配置：</strong></p><p>更新源并安装 dev 组件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br><span class="line">sudo apt install -y libmysqlclient-dev</span><br></pre></td></tr></table></figure><p>安装完毕之后查看 <code>/usr/include/mysql</code> 目录下，是否有 <code>mysql.h</code> 文件，如果有的话就说明安装成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ls /usr/include/mysql|grep mysql.h</span><br></pre></td></tr></table></figure><h3 id="测试连接MySQL"><a href="#测试连接MySQL" class="headerlink" title="测试连接MySQL"></a>测试连接MySQL</h3><p>常用函数：</p><p>初始化MYSQL结构函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_init</span><span class="params">(MYSQL *mysql)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">分配或初始化与mysql_real_connect()相适应的MYSQL对象。如果mysql是NULL指针，该函数将分配、初始化、并返回新对象。否则，将初始化对象，并返回对象的地址。如果mysql_init()分配了新的对象，当调用mysql_close()来关闭连接时。将释放该对象。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">初始化的MYSQL*句柄。如果无足够内存以分配新的对象，返回NULL。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>连接MySQL函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MYSQL *<span class="title">mysql_real_connect</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *host, <span class="keyword">const</span> <span class="keyword">char</span> *user, <span class="keyword">const</span> <span class="keyword">char</span> *passwd, <span class="keyword">const</span> <span class="keyword">char</span> *db, <span class="keyword">unsigned</span> <span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span> *unix_socket, <span class="keyword">unsigned</span> <span class="keyword">long</span> client_flag)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">尝试与运行在主机上的MySQL数据库引擎建立连接。在你能够执行需要有效MySQL连接句柄结构的任何其他API函数之前，mysql_real_connect()必须成功完成。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">mysql：已有MYSQL结构的地址，调用mysql_real_connect()之前，必须调用mysql_init()来初始化MYSQL结构。</span></span><br><span class="line"><span class="comment">host：主机名或IP地址。如果“host”是NULL或字符串&quot;localhost&quot;，连接将被视为与本地主机的连接。</span></span><br><span class="line"><span class="comment">user：包含用户的MySQL登录ID。如果“user”是NULL或空字符串&quot;&quot;，用户将被视为当前用户。</span></span><br><span class="line"><span class="comment">passwd：包含用户的密码。如果“passwd”是NULL，仅会对该用户的（拥有1个空密码字段的）用户表中的条目进行匹配检查。</span></span><br><span class="line"><span class="comment">db：数据库名称。如果db为NULL，连接会将默认的数据库设为该值。</span></span><br><span class="line"><span class="comment">port：端口号，如果“port”不是0，其值将用作TCP/IP连接的端口号。注意，“host”参数决定了连接的类型。一般设置为0.</span></span><br><span class="line"><span class="comment">unix_socket：一般设置为NULL，如果unix_socket不是NULL，该字符串描述了应使用的套接字或命名管道。注意，“host”参数决定了连接的类型。</span></span><br><span class="line"><span class="comment">client_flag：标志位，通常为0，但也能将其设置为一些标志的组合，以允许特定功能。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">如果连接成功，返回MYSQL*连接句柄。如果连接失败，返回NULL。对于成功的连接，返回值与第1个参数的值相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>MySQL查询函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mysql_query</span><span class="params">(MYSQL *mysql, <span class="keyword">const</span> <span class="keyword">char</span> *query)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">描述：</span></span><br><span class="line"><span class="comment">执行由“Null终结的字符串”查询指向的SQL查询。正常情况下，字符串必须包含1条SQL语句，而且不应为语句添加终结分号（‘;’）或“\g”。如果允许多语句执行，字符串可包含多条由分号隔开的语句。</span></span><br><span class="line"><span class="comment">mysql_query()不能用于包含二进制数据的查询，应使用mysql_real_query()取而代之（二进制数据可能包含字符‘\0’，mysql_query()会将该字符解释为查询字符串结束）。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">mysql：指向MYSQL类型的指针</span></span><br><span class="line"><span class="comment">query：一条查询语句，一般以分号结尾</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">如果查询成功，返回0。如果出现错误，返回非0值</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_mysql.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mysql/mysql.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    MYSQL *con = <span class="built_in">mysql_init</span>(<span class="literal">NULL</span>);</span><br><span class="line">    <span class="built_in">mysql_real_connect</span>(con, <span class="string">&quot;127.0.0.1&quot;</span>, <span class="string">&quot;root&quot;</span>, <span class="string">&quot;&quot;</span>, <span class="string">&quot;test_connect&quot;</span>, <span class="number">0</span>, <span class="literal">NULL</span>, CLIENT_MULTI_STATEMENTS);</span><br><span class="line">    <span class="comment">// 标志位：通知服务器，客户端可能在单个字符串内发送多条语句（由‘;’隔开）。如果未设置该标志，将禁止多语句执行。</span></span><br><span class="line">    string str=<span class="string">&quot;INSERT INTO user VALUES (&#x27;FYL&#x27;,&#x27;abc123&#x27;);&quot;</span>;</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">mysql_query</span>(con,str.<span class="built_in">c_str</span>()))</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;success!&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="MySQL建表"><a href="#MySQL建表" class="headerlink" title="MySQL建表"></a>MySQL建表</h3><p>聊天室项目中，将用户注册的账号与密码发送到服务器端，并保存在服务器的 MySQL 数据库中。进入服务器端的MySQL控制台：</p><p>首先在 MySQL 控制台创建数据库 ChatProject，如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> database ChatProject;</span><br></pre></td></tr></table></figure><p>接下来先用 use 命令切换到新建的数据库。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">use ChatProject;</span><br></pre></td></tr></table></figure><p>然后新建一张表格叫 USER 用来保存账号信息，表中有账号 NAME 和密码 PASSWORD 两项属性，都为 VARCHAR 可变长度字符串类型，且将账号 NAME 设为 PRIMARY KEY 主键，主键不允许重复保证了账号的唯一性，而且主键能自动建立索引加快查询速度。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> <span class="keyword">USER</span>(</span><br><span class="line">    NAME <span class="type">VARCHAR</span>(<span class="number">20</span>) <span class="keyword">PRIMARY</span> KEY,</span><br><span class="line">    PASSWORD <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>建好表之后我们可以查看当前数据库中所有的表格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">show</span> tables;</span><br></pre></td></tr></table></figure><p>最后输入 <code>exit</code> 即可离开 MySQL 控制台回到终端。</p><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><h3 id="SQL语句类别"><a href="#SQL语句类别" class="headerlink" title="SQL语句类别"></a>SQL语句类别</h3><ul><li>数据定义语言 DDL（Data Definition Language）：例如<code>CREATE，DROP，ALTER</code>等，对逻辑结构等有操作的，其中包括表结构，视图和索引。</li><li>数据查询语言 DQL（Data Query Language）：即查询操作，以<code>SELECT</code>关键字为主，各种简单查询、连接查询等都属于 DQL。</li><li>数据操纵语言 DML（Data Manipulation Language）：例如<code>INSERT，UPDATE，DELETE</code>等，对数据进行操作的。DQL 与 DML共同构建了多数初级程序员常用的 增删改查 操作，而查询是较为特殊的一种，被划分到 DQL 中。</li><li>数据控制功能 DCL（Data Control Language）：例如<code>GRANT，REVOKE，COMMIT，ROLLBACK</code>等，对数据库安全性、完整性等有操作的，可以简单的理解为权限控制等。</li></ul><h3 id="超键与主键"><a href="#超键与主键" class="headerlink" title="超键与主键"></a>超键与主键</h3><ul><li><strong>超 键：</strong>在关系中，能唯一标识元组的属性集称为关系模式的超键。一个属性可以作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。</li><li><strong>候选键：</strong>是最小超键，即没有冗余元素的超键。</li><li><strong>主 键：</strong>数据库表中对储存数据对象予以<strong>唯一和完整标识的数据列或属性的组合</strong>。<strong>一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（NULL）。</strong></li><li><strong>外 键：</strong>在一个表中存在的另一个表的主键称此表的外键，<strong>外键可以有重复的, 可以是空值。外键是用来和其他表建立联系用的。</strong></li></ul><h3 id="SQL约束类型："><a href="#SQL约束类型：" class="headerlink" title="SQL约束类型："></a>SQL约束类型：</h3><p>约束是一种简单地强加于表中一列或多列的限制，从而保证表中数据一致性（准确和可靠）。以下为六大约束：</p><ul><li>非空约束（NOT NULL）：保证该字段值一定不为空；</li><li>默认约束（DEFAULT）：保证字段有默认值；</li><li>主键约束（PRIMARY KEY）：标志一列或者多列，并保证其值在表内的唯一性；</li><li>外键约束（FOREIGN KEY）：限制一列或多列中的值必须被包含在另一表的外键列中，并且在级联更新或级联删除规则建立后也可以限制其他表中的可用值；</li><li>唯一约束（UNIQUE）： 限制一列或多列的值，保证字段值在表内的唯一性，可以为空（主键约束是一种特殊类型的唯一约束）；</li><li>检查约束（CHECK）：限制一列的可用值范围。</li></ul><h3 id="char-与-varchar-的区别"><a href="#char-与-varchar-的区别" class="headerlink" title="char 与 varchar 的区别"></a>char 与 varchar 的区别</h3><ul><li>char 表示定长字符串，长度是固定的，最多能存放的字符个数为 255，和编码无关；而 varchar 表示可变长字符串，长度是可变的，最多能存放的字符个数为 65532；</li><li>使用 char 时，如果插入数据的长度小于 char 的固定长度时，则用空格填充；</li><li>因为固定长度，char 的存取速度比 varchar 快很多，同时缺点是会占用多余空间，属于空间换时间；</li></ul><h3 id="关联查询"><a href="#关联查询" class="headerlink" title="关联查询"></a>关联查询</h3><p>在项目开发过程中，使用数据库查询语句时，有很多需求都是要涉及到较为复杂或者多表的连接查询，需要关联查询实现。以下为总结的 MySQL 的五种关联查询。</p><ul><li><strong>交叉连接（CROSS JOIN）</strong></li></ul><p>除了在<code>FROM</code>子句中使用 <strong>逗号间隔连接的表</strong> 外，SQL 还支持另一种被称为交叉连接的操作，它们都返回被连接的两个表所有数据行的 <strong>笛卡尔积</strong>，返回到的数据行数等于第一个表中符合查询条件的数据行数 <strong>乘以</strong> 第二个表中符合查询条件的数据行数。惟一的不同在于，交叉连接分开列名时，使用 <code>CROSS JOIN </code>关键字而不是逗号，即以下两个表达式等价：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SELECT  *  FROM  A, B</span><br><span class="line">SELECT  *  FROM  A  CROSS JOIN  B</span><br></pre></td></tr></table></figure><ul><li><strong>内连接（INNER JOIN）</strong></li></ul><p>内连接分为三类，分别是 <strong>等值连接</strong>：<code>ON A.id = B.id</code>、<strong>不等值连接</strong>：<code>ON A.id &gt; B.id</code> 和 <strong>自连接</strong>：<code>SELECT * FROM A T1 INNER JOIN A T2 ON T1.id = T2.pid</code>。</p><ul><li><strong>外连接（LEFT JOIN/RIGHT JOIN）</strong></li></ul><p><strong>左外连接</strong>：以左表为主，先查询出左表，按照<code>ON</code>后的关联条件匹配右表，没有匹配到的用<code> NULL</code>填充，可以简写成<code> LEFT JOIN</code>；</p><p><strong>右外连接</strong>：以右表为主，先查询出右表，按照<code>ON</code>后的关联条件匹配左表，没有匹配到的用<code>NULL</code>填充，可以简写成<code> RIGHT JOIN</code>；</p><ul><li><strong>联合查询（UNION 与 UNION ALL）</strong></li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A UNION SELECT * FROM B UNION ...</span><br></pre></td></tr></table></figure><p>联合查询就是把多个结果集集中在一起，<code>UNION </code>前的结果为基准，需要注意的是联合查询的 <strong>列数要相等</strong>，相同的记录行会合并；</p><p>如果使用<code> UNION ALL</code>，不会合并重复的记录行，所以效率更高。</p><ul><li><strong>全连接（FULL JOIN）</strong></li></ul><p>MySQL 本身不支持全连接，但可以通过联合使用<code>LEFT JOIN、UNION</code>和<code>RIGHT JOIN</code>来实现。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SELECT * FROM A LEFT JOIN B ON A.id = B.id UNION SELECT * FROM A RIGHT JOIN B ON A.id = B.id</span><br></pre></td></tr></table></figure><h3 id="子查询及分类"><a href="#子查询及分类" class="headerlink" title="子查询及分类"></a>子查询及分类</h3><p>多条 MySQL 语句嵌套使用时，内部的 MySQL 查询语句称为子查询。子查询是一个<code>SELECT</code>语句，它嵌套在另一个<code>SELECT、SELECT…INTO</code>语句、<code>INSERT…INTO </code>语句、<code>DELETE </code>语句、 <code>UPDATE </code>语句或嵌套在另一子查询中。</p><p>MySQL 的子查询是多表查询的一个重要组成部分，常常和 <strong>连接查询</strong> 一起使用，是多表查询的基础。</p><p>子查询可分为四类：</p><ul><li><p><strong>标量子查询</strong></p><p>查询返回单一值的标量，如一个数字或一个字符串，是子查询中最简单的形式。</p></li><li><p><strong>列子查询</strong></p><p>子查询返回的结果集是 N 行一列，该结果通常来自对表的 <strong>某个字段</strong> 查询返回。</p></li><li><p><strong>行子查询</strong></p><p>子查询返回的结果集是一行 N 列，该结果通常是对表的 <strong>某行数据</strong> 进行查询而返回的结果集</p></li><li><p><strong>表子查询</strong></p><p>子查询返回的结果集是 N 行 N 列的一个表数据。</p></li></ul><h3 id="DROP、DELETE-与-TRUNCATE-的区别"><a href="#DROP、DELETE-与-TRUNCATE-的区别" class="headerlink" title="DROP、DELETE 与 TRUNCATE 的区别"></a>DROP、DELETE 与 TRUNCATE 的区别</h3><p>三种都可以表示删除，其中的细微区别之处如下：</p><table><thead><tr><th align="center"></th><th align="center">DROP</th><th align="center">DELETE</th><th align="center">TRUNCATE</th></tr></thead><tbody><tr><td align="center">SQL语句类型</td><td align="center">DDL</td><td align="center">DML</td><td align="center">DDL</td></tr><tr><td align="center">回滚</td><td align="center">不可回滚</td><td align="center">可回滚</td><td align="center">不可回滚</td></tr><tr><td align="center">删除内容</td><td align="center">从数据库中 <strong>删除表</strong>，<br>所有的数据行，索引和<br>权限也会被删除</td><td align="center">表结构还在，删除表的<br><strong>全部或者一部分数据行</strong></td><td align="center">表结构还在，删除表中<br>的 <strong>所有数据</strong></td></tr><tr><td align="center">删除速度</td><td align="center">删除速度最快</td><td align="center">删除速度慢，需要逐行删除</td><td align="center">删除速度快</td></tr></tbody></table><p>因此，在不再需要一张表的时候，采用 <code>DROP</code>；在想删除部分数据行时候，用 <code>DELETE</code>；在保留表而删除所有数据的时候用 <code>TRUNCATE</code>。</p><h3 id="UNION-与-UNION-ALL-的区别"><a href="#UNION-与-UNION-ALL-的区别" class="headerlink" title="UNION 与 UNION ALL 的区别"></a>UNION 与 UNION ALL 的区别</h3><p><code>UNION </code>用于把来自多个<code>SELECT</code>语句的结果组合到一个结果集合中，MySQL 会把结果集中 <strong>重复的记录删掉</strong>，而使用<code> UNION ALL</code>，MySQL 会把所有的记录返回，且效率高于<code>UNION</code>。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux下的C++项目开发：聊天室（一）</title>
      <link href="/posts/afd28464/"/>
      <url>/posts/afd28464/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="Linux-C-开发常用工具"><a href="#Linux-C-开发常用工具" class="headerlink" title="Linux C++ 开发常用工具"></a>Linux C++ 开发常用工具</h2><h3 id="使用g-编译代码"><a href="#使用g-编译代码" class="headerlink" title="使用g++编译代码"></a>使用g++编译代码</h3><h4 id="C-编译过程"><a href="#C-编译过程" class="headerlink" title="C++编译过程"></a>C++编译过程</h4><p>C++的编译过程主要有四个阶段：预处理、编译、汇编、链接：</p><ul><li>预处理：主要负责宏定义的替换、条件编译（防止重复包含头文件的宏#ifdef、#ifndef、#else、#endif等）、将include的头文件展开到正文等；</li><li>编译：负责将源代码转化为汇编代码；</li><li>汇编：负责将汇编代码转化为可重定位的目标二进制文件；<ul><li>静态重定位：即在程序装入内存的过程中完成，是指在程序开始运行前，程序中的各个地址有关的项均已完成重定位，地址变换通常是在装入时一次完成的，以后不再改变，故称为静态重定位。</li><li>动态重定位：它不是在程序装入内存时完成的，而是CPU每次访问内存时 由动态地址变换机构（硬件）自动进行把相对地址转换为绝对地址。动态重定位需要软件和硬件相互配合完成。</li></ul></li><li>链接：负责将所有的目标文件（二进制目标文件、库文件等）连接起来，进行符号解析和重定位，最后生成可执行文件。<strong>静态链接和动态链接两者最大的区别就在于链接的时机不一样。</strong><ul><li>静态链接：将多个源文件产生的目标文件进行链接，从而形成一个可以执行的程序，静态库也可以简单地看成是一组目标文件的集合，即很多目标文件经过压缩打包后形成的一个文件。<strong>静态链接是在形成可执行程序前。</strong></li><li>动态链接：解决静态链接的两个问题，空间浪费和更新困难。动态链接把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。<strong>动态链接的进行则是在程序执行时。</strong></li></ul></li></ul><h4 id="g-编译命令"><a href="#g-编译命令" class="headerlink" title="g++编译命令"></a>g++编译命令</h4><p>假设有test.cpp文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(a,b)&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>预处理阶段的结果，直接在终端输出，命令为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -E test.cpp</span><br></pre></td></tr></table></figure><p>编译阶段可以得到汇编代码（.s 文件），可由以下命令直接得到汇编代码文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -S test.cpp</span><br></pre></td></tr></table></figure><p>可重定位的目标文件（.o 文件）由以下命令直接得到：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -c test.cpp</span><br></pre></td></tr></table></figure><p>需要得到最终的可执行文件时可使用下面这条命令，需要自己指定目标文件名，下面这条命令最终得到名为 work 的可执行文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o work test.cpp</span><br><span class="line">g++ test.cpp -o work</span><br></pre></td></tr></table></figure><p>两种写法都可以，注意命令中-o后面是生成可执行文件的名字。</p><p>在实际开发过程中，往往需要使用 gdb 进行调试，可以在编译时加上-g 选项，如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o work test.cpp</span><br></pre></td></tr></table></figure><p>如果在开发过程中加入自己指定使用的动态链接库，比如我们需要使用 pthread 线程库，需要加上 -l 选项。下例中编译器会到 <code>lib</code> 目录下找 <code>libpthread.so</code> 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o work test.cpp -lpthread</span><br></pre></td></tr></table></figure><h4 id="多文件编译"><a href="#多文件编译" class="headerlink" title="多文件编译"></a>多文件编译</h4><p>多个源码文件进行一起编译，例如有三个cpp文件：a.cpp、b.h、b.cpp</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// a.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a=<span class="number">1</span>,b=<span class="number">2</span>;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">add</span>(a,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// b.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> BH</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BH</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>,<span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// b.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;b.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以采用以下的编译命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test a.cpp b.cpp</span><br></pre></td></tr></table></figure><p>使用以下命令运行程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./test</span><br></pre></td></tr></table></figure><h4 id="运行可执行文件"><a href="#运行可执行文件" class="headerlink" title="运行可执行文件"></a>运行可执行文件</h4><p>使用 g++ 编译得到的可执行文件，使用如下格式执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./可执行文件名</span><br></pre></td></tr></table></figure><p>如果程序需要传入参数，则以下述格式执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./可执行文件名 参数1 参数2</span><br></pre></td></tr></table></figure><h3 id="使用gdb进行调试"><a href="#使用gdb进行调试" class="headerlink" title="使用gdb进行调试"></a>使用gdb进行调试</h3><h4 id="安装gdb"><a href="#安装gdb" class="headerlink" title="安装gdb"></a>安装gdb</h4><p>安装分为编译安装和 <code>apt</code> 命令安装，因为 Ubuntu 的软件包仓库内置了 gdb，所以可以直接使用命令安装。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install gdb</span><br></pre></td></tr></table></figure><p>安装成功后查看gdb版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gdb -v</span><br></pre></td></tr></table></figure><h4 id="gdb常用调试命令"><a href="#gdb常用调试命令" class="headerlink" title="gdb常用调试命令"></a>gdb常用调试命令</h4><p>为了能使用 gdb 调试，在用 g++ 编译时要将 -g 参数加上，然后进行gdb调试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -o test a.cpp b.cpp</span><br><span class="line">gdb test</span><br></pre></td></tr></table></figure><p>常用的调试命令：</p><ul><li><code>l</code>：查看代码</li><li><code>b 5</code>：在程序的第 5 行添加断点</li><li><code>info break</code>：查看断点</li><li><code>r</code>：开始运行</li><li><code>s</code>：进入函数内部</li><li><code>n</code>：进入下一步</li><li><code>finish</code>：跳出函数内部</li><li><code>c</code>：运行到下一个断点</li></ul><p>最后退出调试，可以直接输入 <code>quit</code> 命令。</p><h3 id="编写-makefile-进行自动编译"><a href="#编写-makefile-进行自动编译" class="headerlink" title="编写 makefile 进行自动编译"></a>编写 makefile 进行自动编译</h3><p>在大型项目中有大量的源代码文件，不可能每次都逐个敲 g++ 命令来进行编译，而是采用编写 makefile 的方式来进行自动编译，提高效率。</p><h4 id="创建makefile"><a href="#创建makefile" class="headerlink" title="创建makefile"></a>创建makefile</h4><p>和创建源代码文件一样，可以直接用 vi 编辑器来创建 makefile：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vi makefile</span><br></pre></td></tr></table></figure><p>写好 makefile 内容后，命令模式输入 <code>wq</code> 保存离开即可。</p><h4 id="makefile基本格式"><a href="#makefile基本格式" class="headerlink" title="makefile基本格式"></a>makefile基本格式</h4><p>一般格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">目标名1：依赖文件1，依赖文件2，依赖文件3</span><br><span class="line">    g++ 编译命令</span><br><span class="line">目标名2：依赖文件4，依赖文件5</span><br><span class="line">    g++ 编译命令</span><br></pre></td></tr></table></figure><p>其中目标名可以由自己定义，也可以是一个文件的名字；依赖文件就是说要达成这个目标所需要的文件。 仍以前面的“多文件编译”代码为例，可以写出如下的 makefile 文件（注意：makefile 文件中要使用 tab 键，不能使用空格键，否则会报错）：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target:a.cpp b.o</span></span><br><span class="line">    g++ -o test a.cpp b.o</span><br><span class="line"><span class="section">b.o:b.cpp</span></span><br><span class="line">    g++ -c b.cpp</span><br></pre></td></tr></table></figure><p>target 依赖于 <code>a.cpp</code> 和 <code>b.o</code>，而 <code>b.o</code> 依赖于 <code>b.cpp</code>，因此编译时发现 <code>b.cpp</code> 更新了的话就会先执行后面的命令来更新 <code>b.o</code>。保存好 makefile 文件之后，我们用命令行输入 <code>make</code> 即可进行自动编译：</p><h4 id="快速清理目标文件"><a href="#快速清理目标文件" class="headerlink" title="快速清理目标文件"></a>快速清理目标文件</h4><p>有时候我们想要删掉 makefile 产生出来的所有目标文件，如果逐个去删显得过于麻烦，因此我们可以借助<code> make clean</code>。仍然是在前面的 makefile 文件中修改，在后面补上一个 <code>clean：</code>，以及相应的清除命令：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">target:a.cpp b.o</span></span><br><span class="line">    g++ -o test a.cpp b.o</span><br><span class="line"><span class="section">b.o:b.cpp</span></span><br><span class="line">    g++ -c b.cpp</span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm *.o</span><br><span class="line">    rm test</span><br></pre></td></tr></table></figure><p>在命令行执行 <code>make clean</code> 就可删掉所有目标文件。</p><h2 id="TCP通信"><a href="#TCP通信" class="headerlink" title="TCP通信"></a>TCP通信</h2><h3 id="传输层基本概念"><a href="#传输层基本概念" class="headerlink" title="传输层基本概念"></a>传输层基本概念</h3><p>TCP/IP 四层参考模型中，从上往下有四种层次：应用层、传输层、网络层、网络接口层，应用层包括 HTTP、FTP、DNS 等协议，而传输层包括 TCP、UDP 两种协议，网络层则包含 IP、ARP 等协议，网络接口层较为底层，一般不是我们研究的对象。其中，传输层是我们在编程开发中较为重要的一层，需要对其中的两种协议尤其是 TCP 理解透彻。</p><p><img src="/20220825/9195a5673454d7fd8f457fb1e07c7701-0" alt="图片描述"></p><h4 id="传输层的作用"><a href="#传输层的作用" class="headerlink" title="传输层的作用"></a>传输层的作用</h4><p>根本目的：在网络层提供的数据通信服务基础上，实现主机的进程间通信的可靠服务。<br>主要有以下两个要点：为位于两个主机内部的两个应用进程之间提供通信服务、提供可靠的通信服务。</p><h4 id="套接字"><a href="#套接字" class="headerlink" title="套接字"></a>套接字</h4><p>“套接字”表示一个 IP 地址与对应的一个端口号。例如，一个 IP 地址为 172.31.75.8 的客户端使用 8050 端口号，那么标识客户端的套接字为“172.31.75.8:8050”。</p><h4 id="端口号"><a href="#端口号" class="headerlink" title="端口号"></a>端口号</h4><p>端口号为 0-65535 之间的整数，有3种类型：熟知端口号、注册端口号、临时端口号。</p><ul><li><p>熟知端口号：给每种服务器分配确定的全局端口号。每个用户进程都知道相应的服务器进程的熟知端口号，范围为 0-1023，它是统一分配和控制的。</p></li><li><p>注册端口号：在 IANA 注册的端口号，数值范围为 1024-49151。</p></li><li><p>临时端口号：客户端程序使用临时端口号，它是运行在客户端上的 TCP/IP 软件随机选取的，范围为 49152-65535。</p></li></ul><p>平时进行网络编程时服务器最好使用注册端口号，而客户端的端口号则是系统随机分配的，即临时端口号。</p><h4 id="UDP用户数据协议"><a href="#UDP用户数据协议" class="headerlink" title="UDP用户数据协议"></a>UDP用户数据协议</h4><p>UDP协议的特点：</p><ul><li><strong>无连接的：</strong>发送数据之前不需要建立连接，因此减少了开销和发送数据之前的时延。</li><li><strong>尽最大努力交付：</strong>即不保证可靠交付，因此主机不需要维持复杂的连接状态表。</li><li><strong>面向报文的：</strong>UDP 对应用层传递下来的报文，既不合并，也不拆分，而是保留这些报文的边界。UDP 对于应用程序提交的报文，添加头部后就向下提交给网络层。</li><li><strong>没有拥塞控制：</strong>网络出现的拥塞时，UDP 不会使源主机的发送速率降低。这对某些实时应用是很重要的，很适合多媒体通信的要求。</li><li>支<strong>持多对多的交互通信。</strong></li></ul><p>UDP的适用场景：</p><ul><li>适用于少量（几百个字节）的数据。</li><li>对性能的要求高于对数据完整性的要求，如视频播放、P2P、DNS 等。</li><li>需要“简短快捷”的数据交换 简单的请求与应答报文交互，如在线游戏。</li><li>需要多播和广播的应用，源主机以恒定速率发送报文，拥塞发生时允许丢弃部分报文，如本地广播、隧道 VPN。</li></ul><h4 id="TCP传输控制协议"><a href="#TCP传输控制协议" class="headerlink" title="TCP传输控制协议"></a>TCP传输控制协议</h4><p>TCP协议的特点：</p><ul><li><strong>面向连接</strong>的传输服务。打电话式、会话式通信。</li><li><strong>面向字节流传输服务</strong>（而 UDP 是面向报文）。字节管道、字节按序传输和到达。</li><li><strong>全双工通信。</strong>一个应用进程可以同时接收和发送数据、捎带确认；通信双方都设置有发送和接收缓冲区，应用程序将要发送的数据字节提交给发送缓冲区，实际发送由 TCP 协议控制，接收方收到数据字节后将它存放在接收缓冲区，等待高层应用程序读取。</li><li><strong>可建立多个并发的 TCP 连接。</strong>如 Web 服务器可同时与多个客户端建立的连接会话。</li><li><strong>可靠传输服务</strong>。不丢失数据、保持数据有序、向上层不重复提交数据（通过确认机制、拥塞控制等方式实现）， 想象一下 ATM 机转帐应用就需要上述可靠性。</li></ul><p>TCP的报文结构图：</p><img src="/posts/afd28464/544e589943a8426e0f4f4c16981663e7-0" alt="图片描述"><p>重点关注的标志位：</p><table><thead><tr><th align="center">标志</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">SYN</td><td align="center">当SYN=1，ACK=0，是一个建立连接请求的报文；<br>当SYN=1，ACK=1，是一个同意建立连接请求的报文；</td></tr><tr><td align="center">ACK</td><td align="center">当ACK=1时，确认序号字段才有意义</td></tr><tr><td align="center">FIN</td><td align="center">FIN=1说明数据发送完毕，请求释放连接</td></tr><tr><td align="center">RST</td><td align="center">RST=1说明出现严重错误，必须释放连接再重新建立连接</td></tr><tr><td align="center">URG</td><td align="center">URG=1说明此报文是紧急数据，要尽快传送出去</td></tr><tr><td align="center">PSH</td><td align="center">PSH=1请求接收方TCP软件将该报文立即推送给应用程序</td></tr></tbody></table><p>TCP 连接包括连接建立、报文传输、连接释放三个阶段，其中连接建立的三次握手过程较为重要。</p><p><strong>建立连接的三次握手过程：</strong></p><p>（1）当客户端准备发起一次 TCP 连接，首先向服务器发送第一个“SYN”报文（控制位 SYN=1）。</p><p>（2）服务器收到 SYN 报文后，如果同意建立连接，则向客户端发送第二个“SYN+ACK”报文（控制位 SYN=1，ACK=1），该报文表示对第一个 SYN 报文请求的确认。</p><p>（3）接收到 SYN+ACK 报文后，客户端发送第三个 ACK 报文，表示对 SYN+ACK 报文的确认。</p><img src="/posts/afd28464/3c83420afc02fdd2a2e7639275d1d863-0" alt="图片描述" style="zoom:80%;"><h3 id="TCP套接字网络编程"><a href="#TCP套接字网络编程" class="headerlink" title="TCP套接字网络编程"></a>TCP套接字网络编程</h3><p>网络编程一般采用C/S架构，即服务器端和客户端。</p><h4 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h4><p>服务器端一般先用 socket 创建一个套接字，然后用 bind 给这个套接字绑定地址（即 ip+端口号），然后调用 listen 把这个套接字置为监听状态，随后调用 accept 函数从已完成连接队列中取出成功建立连接的套接字，以后就在这个新的套接字上调用 send、recv 来发送数据、接收数据，最后调用 close 来断开连接释放资源即可。整个过程如下：</p><img src="/posts/afd28464/e1413de95f7af4c44f7d10a2f09d49d4-0" alt="图片描述" style="zoom: 67%;"><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>与服务器不同，客户端并不需要 bind 绑定地址，因为端口号是系统自动分配的，而且客户端也不需要设置监听的套接字，因此也不需要 listen。客户端在用 socket 创建套接字后直接调用 connect 向服务器发起连接即可，connect 函数通知 Linux 内核完成 TCP 三次握手连接，最后把连接的结果作为返回值。成功建立连接后就可以调用 send 和 recv 来发送数据、接收数据，最后调用 close 来断开连接释放资源。整个过程如下：</p><img src="/posts/afd28464/e6a08660699bd4f0e26119e7de2c20bd-0" alt="图片描述" style="zoom:67%;"><h4 id="完整流程"><a href="#完整流程" class="headerlink" title="完整流程"></a>完整流程</h4><p>TCP网络编程的完整流程如下：</p><img src="/posts/afd28464/87c29545a64eed3b2b2338ef5f901fc4-0" alt="图片描述" style="zoom: 67%;"><h4 id="TCP相关的数据结构"><a href="#TCP相关的数据结构" class="headerlink" title="TCP相关的数据结构"></a>TCP相关的数据结构</h4><p>地址结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sin_family; <span class="comment">/* 地址族 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sin_port; <span class="comment">/* 端口号 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">/* ip地址 */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sin_zero[<span class="number">8</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> s_addr;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCP网络编程函数：</p><p>socket函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">( <span class="keyword">int</span> domain, <span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能：创建一个新的套接字，返回套接字描述符</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">domain：域类型，指明使用的协议栈，如TCP/IP使用的是PF_INET，其他还有AF_INET6、AF_UNIX</span></span></span><br><span class="line"><span class="comment"><span class="function">type:指明需要的服务类型, 如</span></span></span><br><span class="line"><span class="comment"><span class="function">SOCK_DGRAM:数据报服务，UDP协议</span></span></span><br><span class="line"><span class="comment"><span class="function">SOCK_STREAM:流服务，TCP协议</span></span></span><br><span class="line"><span class="comment"><span class="function">protocol:一般都取0(由系统根据服务类型选择默认的协议)</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><p>bind函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd,struct sockaddr* my_addr,<span class="keyword">int</span> addrlen)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能：为套接字绑定地址</span></span></span><br><span class="line"><span class="comment"><span class="function">TCP/IP协议使用sockaddr_in结构，包含IP地址和端口号，服务器使用它来指明熟知的端口号，然后等待连接</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">sockfd:套接字描述符，指明创建连接的套接字</span></span></span><br><span class="line"><span class="comment"><span class="function">my_addr:本地地址，IP地址和端口号</span></span></span><br><span class="line"><span class="comment"><span class="function">addrlen:地址长度</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><p>listen函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> backlog)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能：</span></span></span><br><span class="line"><span class="comment"><span class="function">将一个套接字置为监听模式，准备接收传入连接。用于服务器，指明某个套接字连接是被动的监听状态。</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">Sockfd:套接字描述符，指明创建连接的套接字</span></span></span><br><span class="line"><span class="comment"><span class="function">backlog: linux内核2.2之前，backlog参数=半连接队列长度+已连接队列长度；linux内核2.2之后，backlog参数=已连接队列（Accept队列）长度</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><p>accept函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, structsockaddr *addr, <span class="keyword">int</span> *addrlen)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能：从已完成连接队列中取出成功建立连接的套接字，返回成功连接的套接字描述符。</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">Sockfd:套接字描述符，指明正在监听的套接字</span></span></span><br><span class="line"><span class="comment"><span class="function">addr:提出连接请求的主机地址</span></span></span><br><span class="line"><span class="comment"><span class="function">addrlen:地址长度</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><p>send函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span> * data, <span class="keyword">int</span> data_len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能：在TCP连接上发送数据,返回成功传送数据的长度，出错时返回－1。send会将数据移到发送缓冲区中。</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">sockfd:套接字描述符</span></span></span><br><span class="line"><span class="comment"><span class="function">data:指向要发送数据的指针</span></span></span><br><span class="line"><span class="comment"><span class="function">data_len:数据长度</span></span></span><br><span class="line"><span class="comment"><span class="function">flags:通常为0</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><p>recv函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span> *buf, intbuf_len,<span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能：接收数据,返回实际接收的数据长度，出错时返回－1。</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">Sockfd:套接字描述符</span></span></span><br><span class="line"><span class="comment"><span class="function">Buf:指向内存块的指针</span></span></span><br><span class="line"><span class="comment"><span class="function">Buf_len:内存块大小，以字节为单位</span></span></span><br><span class="line"><span class="comment"><span class="function">flags:一般为0</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><p>close函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(<span class="keyword">int</span> sockfd)</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">功能：撤销套接字。如果只有一个进程使用，立即终止连接并撤销该套接字，如果多个进程共享该套接字，将引用数减一，如果引用数降到零，则关闭连接并撤销套接字。</span></span><br><span class="line"><span class="comment">参数说明：</span></span><br><span class="line"><span class="comment">sockfd:套接字描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>connect函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd,structsockaddr *server_addr,<span class="keyword">int</span> sockaddr_len)</span></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="comment"><span class="function">功能： 同远程服务器建立主动连接，成功时返回0，若连接失败返回－1。</span></span></span><br><span class="line"><span class="comment"><span class="function">参数说明：</span></span></span><br><span class="line"><span class="comment"><span class="function">Sockfd:套接字描述符，指明创建连接的套接字</span></span></span><br><span class="line"><span class="comment"><span class="function">Server_addr:指明远程端点：IP地址和端口号</span></span></span><br><span class="line"><span class="comment"><span class="function">sockaddr_len :地址长度</span></span></span><br><span class="line"><span class="comment"><span class="function">*/</span></span></span><br></pre></td></tr></table></figure><h3 id="服务器与客户端连接实例"><a href="#服务器与客户端连接实例" class="headerlink" title="服务器与客户端连接实例"></a>服务器与客户端连接实例</h3><p>编写两个程序：一个服务器与一个客户端，用户可以在客户端不断输入信息并发送到服务器终端上显示。</p><h4 id="服务器程序编写"><a href="#服务器程序编写" class="headerlink" title="服务器程序编写"></a>服务器程序编写</h4><p>编写<code>server.cpp</code>, 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockfd</span></span><br><span class="line">    <span class="keyword">int</span> server_sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_sockaddr</span>;</span></span><br><span class="line">    server_sockaddr.sin_family = AF_INET;<span class="comment">//TCP/IP协议族</span></span><br><span class="line">    server_sockaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8023</span>);<span class="comment">//端口号</span></span><br><span class="line">    server_sockaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);<span class="comment">//ip地址，127.0.0.1是环回地址，相当于本机ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind，成功返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(server_sockaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listen，成功返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(server_sockfd,<span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端套接字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> length = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//成功返回非负描述字，出错返回-1</span></span><br><span class="line">    <span class="keyword">int</span> conn = <span class="built_in">accept</span>(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length);</span><br><span class="line">    <span class="keyword">if</span>(conn&lt;<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;客户端成功连接\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//接收缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断接收数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//客户端发送exit或者异常结束时，退出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buffer,<span class="string">&quot;exit&quot;</span>)==<span class="number">0</span> || len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;收到客户端信息：&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(conn);</span><br><span class="line">    <span class="built_in">close</span>(server_sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="客户端程序编写"><a href="#客户端程序编写" class="headerlink" title="客户端程序编写"></a>客户端程序编写</h4><p>编写<code>client.cpp</code>, 代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockfd</span></span><br><span class="line">    <span class="keyword">int</span> sock_cli = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;<span class="comment">//TCP/IP协议族</span></span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(<span class="number">8023</span>);  <span class="comment">//服务器端口</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(<span class="string">&quot;127.0.0.1&quot;</span>);  <span class="comment">//服务器ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器，成功返回0，错误返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock_cli, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;连接服务器成功！\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">char</span> recvbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sendbuf));</span><br><span class="line">        cin&gt;&gt;sendbuf;</span><br><span class="line">        <span class="built_in">send</span>(sock_cli, sendbuf, <span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>); <span class="comment">//发送</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sendbuf,<span class="string">&quot;exit&quot;</span>)==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sock_cli);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="测试运行"><a href="#测试运行" class="headerlink" title="测试运行"></a>测试运行</h4><p>编译两个cpp文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">g++ -o server server.cpp</span><br><span class="line">g++ -o client client.cpp</span><br></pre></td></tr></table></figure><p>运行服务器程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./server</span><br></pre></td></tr></table></figure><p>另开一个新的终端，运行客户端程序：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./client</span><br></pre></td></tr></table></figure><p>连接成功，可以在客户端不断输入信息并且在服务器端显示。</p><h2 id="多线程并发服务器"><a href="#多线程并发服务器" class="headerlink" title="多线程并发服务器"></a>多线程并发服务器</h2><p>上一个实例练习编写的服务器是单线程的，只能为单个客户端服务。而要设计一个聊天室的服务器就必须能够同时为多个客户端服务，因此需要将服务器升级为多线程版本。</p><h3 id="进程与线程的基本概念"><a href="#进程与线程的基本概念" class="headerlink" title="进程与线程的基本概念"></a>进程与线程的基本概念</h3><ul><li><p>进程：是程序的一次执行过程，是操作系统资源分配的基本单位。</p><p>比如在实例中运行<code>./server</code>服务器程序，就会产生一个进程，可以使用 <code>ps -ef|grep ./server</code> 命令查看相关进程快照。其中的PID就是该进程的进程号。</p></li><li><p>线程：是任务调度和执行的基本单位，一个进程中可以有多个线程独立运行。线程没有自己独立的地址空间，会与其它属于同一进程的线程一起共享进程的资源，但是每个线程也会有自己的独立的栈和一组寄存器。在 Linux 当中，线程的实现比较特别，会把线程当做进程来实现，即将线程视为一个与其它进程共享资源的进程。</p><p>可以使用 <code>ps -T -p XXX(进程号) </code>命令来查看一个进程的所有线程。</p></li></ul><h3 id="C-11的thread线程库"><a href="#C-11的thread线程库" class="headerlink" title="C++11的thread线程库"></a>C++11的thread线程库</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><p>C++11中提供了专门的线程库，可以很方便地进行调用。</p><p>使用需要导入头文件：<code>#include&lt;thread&gt;</code></p><p>创建一个新线程来执行 run 函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(run)</span></span>;  <span class="comment">//实例化一个线程对象t，让该线程执行run函数，构造对象后线程就开始执行了</span></span><br></pre></td></tr></table></figure><p>假如 run 函数需要传入参数 a 和 b，可以这样构造：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">thread <span class="title">t</span><span class="params">(run,a,b)</span></span>;  <span class="comment">//实例化一个线程对象t，让该线程执行run函数，传入a和b作为run的参数</span></span><br></pre></td></tr></table></figure><p>需要注意的是，<strong>传入的函数必须是全局函数或者静态函数，不能是类的普通成员函数。</strong></p><p>join 函数会阻塞主线程，直到 join 函数的 thread 对象标识的线程执行完毕为止，join 函数使用方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">join</span>(); <span class="comment">//调用join后，主线程会一直阻塞，直到子线程的run函数执行完毕</span></span><br></pre></td></tr></table></figure><p>但有时候需要主线程在继续完成其它的任务，而不是一直等待子线程结束，这时候我们可以使用 detach 函数。detach 函数会让子线程变为分离状态，主线程不会再阻塞等待子线程结束，而是让系统在子线程结束时自动回收资源。使用的方法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><h4 id="代码实例"><a href="#代码实例" class="headerlink" title="代码实例"></a>代码实例</h4><p>构建两个线程，同时输出 1-10，实现简单的多线程编程：</p><p>新建一个 <code>test_thread.cpp</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_thread.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">10</span>;i++)&#123;</span><br><span class="line">        cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);   <span class="comment">//休眠1秒钟</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">t1</span><span class="params">(print)</span>,<span class="title">t2</span><span class="params">(print)</span></span>;</span><br><span class="line">    t1.<span class="built_in">join</span>();</span><br><span class="line">    t2.<span class="built_in">join</span>();</span><br><span class="line">    <span class="comment">//也可以使用detach</span></span><br><span class="line">    <span class="comment">//t1.detach();</span></span><br><span class="line">    <span class="comment">//t2.detach();</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后使用 g++ 进行编译，需要注意的是这里要用上 <code>-l</code> 来链接线程动态库，如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -o test_thread test_thread.cpp -lpthread</span><br></pre></td></tr></table></figure><h3 id="实例：多线程并发服务器"><a href="#实例：多线程并发服务器" class="headerlink" title="实例：多线程并发服务器"></a>实例：多线程并发服务器</h3><h4 id="具体要求"><a href="#具体要求" class="headerlink" title="具体要求"></a>具体要求</h4><p>编写两个程序：一个多线程服务器、一个单线程客户端程序（可和上个实验一样），用一个终端运行服务器程序，多个终端运行客户端程序，让所有客户端发送的信息都能在服务器终端上显示。</p><ol><li>编写一个服务器类 server，该类可以创建多个线程为多个客户端服务，接收所有客户端发送的消息并打印出来。</li><li>要编写多个源代码文件：<code>server.h</code> 头文件给出 server 类声明、<code>server.cpp</code> 给出类方法具体实现、<code>test_server.cpp</code> 中编写主函数创建 server 实例对象并测试。</li><li>客户端程序可继续使用上个实验的，不用做修改。</li><li>编写 Makefile 进行自动编译，使用 git 管理版本。</li></ol><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>因为需要为每个客户端创建一个线程进行服务，所以我们要在每次 accept 取出新连接之后都创建一个线程，这个线程只负责服务这个新的连接，因此我们还要将这个连接对应的套接字描述符传入线程函数中。线程函数不断地调用 recv 接收信息并打印，直到收到客户端发来的 “exit” 或者 recv 返回值小于等于 0 为止。</p><h4 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h4><p>编写 <code>server.h</code> 头文件，给出类的成员变量和成员函数声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> server_port;<span class="comment">//服务器端口号</span></span><br><span class="line">        <span class="keyword">int</span> server_sockfd;<span class="comment">//设为listen状态的套接字描述符</span></span><br><span class="line">        string server_ip;<span class="comment">//服务器ip</span></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; sock_arr;<span class="comment">//保存所有套接字描述符</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">server</span>(<span class="keyword">int</span> port,string ip);<span class="comment">//构造函数</span></span><br><span class="line">        ~<span class="built_in">server</span>();<span class="comment">//析构函数</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//服务器开始服务</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RecvMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>;<span class="comment">//子线程工作的静态函数</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在 <code>server.cpp</code> 文件中给出函数具体的定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;server.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">server::<span class="built_in">server</span>(<span class="keyword">int</span> port,string ip):<span class="built_in">server_port</span>(port),<span class="built_in">server_ip</span>(ip)&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//析构函数</span></span><br><span class="line">server::~<span class="built_in">server</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> conn:sock_arr)</span><br><span class="line">        <span class="built_in">close</span>(conn);</span><br><span class="line">    <span class="built_in">close</span>(server_sockfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//服务器开始服务</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server::run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//定义sockfd</span></span><br><span class="line">    server_sockfd = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_sockaddr</span>;</span></span><br><span class="line">    server_sockaddr.sin_family = AF_INET;<span class="comment">//TCP/IP协议族</span></span><br><span class="line">    server_sockaddr.sin_port = <span class="built_in">htons</span>(server_port);<span class="comment">//server_port;//端口号</span></span><br><span class="line">    server_sockaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());<span class="comment">//ip地址，127.0.0.1是环回地址，相当于本机ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//bind，成功返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">bind</span>(server_sockfd,(struct sockaddr *)&amp;server_sockaddr,<span class="built_in"><span class="keyword">sizeof</span></span>(server_sockaddr))==<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;bind&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//listen，成功返回0，出错返回-1</span></span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">listen</span>(server_sockfd,<span class="number">20</span>) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;listen&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//客户端套接字</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_addr</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> length = <span class="built_in"><span class="keyword">sizeof</span></span>(client_addr);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不断取出新连接并创建子线程为其服务</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">int</span> conn = <span class="built_in">accept</span>(server_sockfd, (struct sockaddr*)&amp;client_addr, &amp;length);</span><br><span class="line">        <span class="keyword">if</span>(conn&lt;<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);<span class="comment">//输出错误原因</span></span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">1</span>);<span class="comment">//结束程序</span></span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;文件描述符为&quot;</span>&lt;&lt;conn&lt;&lt;<span class="string">&quot;的客户端成功连接\n&quot;</span>;</span><br><span class="line">        sock_arr.<span class="built_in">push_back</span>(conn);</span><br><span class="line">        <span class="comment">//创建线程</span></span><br><span class="line">        <span class="function">thread <span class="title">t</span><span class="params">(server::RecvMsg,conn)</span></span>;</span><br><span class="line">        t.<span class="built_in">detach</span>();<span class="comment">//置为分离状态，不能用join，join会导致主线程阻塞</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//子线程工作的静态函数</span></span><br><span class="line"><span class="comment">//注意，前面不用加static，否则会编译报错</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server::RecvMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">//不断接收数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//客户端发送exit或者异常结束时，退出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buffer,<span class="string">&quot;exit&quot;</span>)==<span class="number">0</span> || len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;收到套接字描述符为&quot;</span>&lt;&lt;conn&lt;&lt;<span class="string">&quot;发来的信息：&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写主函数构建实例进行测试，<code>test_server.cpp</code> 文件：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test_server.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;server.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">server <span class="title">serv</span><span class="params">(<span class="number">8023</span>,<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;<span class="comment">//创建实例，传入端口号和ip作为构造函数参数</span></span><br><span class="line">    serv.<span class="built_in">run</span>();<span class="comment">//启动服务</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>利用makefile进行自动编译，makefile内容如下：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">test_server: test_server.cpp server.cpp server.h</span></span><br><span class="line">    g++ -o test_server test_server.cpp server.cpp -lpthread</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm test_server</span><br></pre></td></tr></table></figure><p>注意：makefile的缩进不能使用空格，要使用制表符（制表符长度4）。</p><h2 id="多线程客户端"><a href="#多线程客户端" class="headerlink" title="多线程客户端"></a>多线程客户端</h2><h3 id="实例：多线程客户端"><a href="#实例：多线程客户端" class="headerlink" title="实例：多线程客户端"></a>实例：多线程客户端</h3><h4 id="具体要求-1"><a href="#具体要求-1" class="headerlink" title="具体要求"></a>具体要求</h4><p>将之前的单线程客户端升级为多线程客户端（一个线程用于接收并打印信息、一个线程用于输入并发送信息），为前面实验的多线程服务器添加自动回复客户端的代码，用一个终端运行服务器程序，多个终端运行客户端程序，多个客户端都能发送信息送达服务器并收到服务器的应答，并将应答打印到客户端终端上，当用户在客户端输入 exit 时，要结束两个线程之后再结束客户端进程。</p><ol><li>编写一个客户端类 client ，有发送线程和接收线程，可以同时发送消息和接收消息。</li><li>要编写多个源代码文件：client 头文件给出 client 类声明、<code>client.cpp</code> 给出类方法具体实现、<code>test_client.cpp</code> 中编写主函数创建 client 实例对象并测试。</li><li>当用户在客户端输入 exit 时，要结束发送线程和接收线程之后才退出主线程。</li><li>服务器程序要在实验 3 的基础上进行一定修改，能够回复消息。</li><li>编写 Makefile 进行自动编译，使用 git 管理版本。</li></ol><h4 id="设计思路-1"><a href="#设计思路-1" class="headerlink" title="设计思路"></a>设计思路</h4><p>客户端应先 connect 服务器建立连接，成功连接之后就创建发送线程和接收线程，与服务器类的设计同理，我们需要将发送线程和接收线程的函数设为静态成员函数，发送线程和接收线程中都使用 while(1) 的循环结构，循环终止的条件是用户输入了 exit 或者对端关闭了连接。</p><h4 id="实现过程-1"><a href="#实现过程-1" class="headerlink" title="实现过程"></a>实现过程</h4><p>考虑到 client 类和 server 类会用到许多相同的头文件，因此我们没必要每次都重新写各种头文件，我们可以编写一个 <code>global.h</code>，在里面写上所有我们需要的头文件（甚至全局变量），让 <code>server.h</code> 和 <code>client.h</code> 都引入这个 <code>global.h</code> 即可，这样通过 <code>global.h</code> 就可以包含所有头文件，没那么容易乱。<code>global.h</code> 文件内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> _GLOBAL_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _GLOBAL_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在 <code>client.h</code> 头文件中给出 client 类的成员变量和成员函数声明，该类有三个成员变量，同时有构造函数、析构函数、run 函数、发送线程函数、接收线程函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> CLIENT_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CLIENT_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">client</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> server_port;<span class="comment">//服务器端口</span></span><br><span class="line">        string server_ip;<span class="comment">//服务器ip</span></span><br><span class="line">        <span class="keyword">int</span> sock;<span class="comment">//与服务器建立连接的套接字描述符</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">client</span>(<span class="keyword">int</span> port,string ip);</span><br><span class="line">        ~<span class="built_in">client</span>();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;<span class="comment">//启动客户端服务</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SendMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>;<span class="comment">//发送线程</span></span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RecvMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>;<span class="comment">//接收线程</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在 <code>client.cpp</code> 给出具体的函数定义。构造函数负责初始化服务器 ip 和端口号，析构函数负责关闭套接字描述符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;client.h&quot;</span></span></span><br><span class="line"></span><br><span class="line">client::<span class="built_in">client</span>(<span class="keyword">int</span> port,string ip):<span class="built_in">server_port</span>(port),<span class="built_in">server_ip</span>(ip)&#123;&#125;</span><br><span class="line">client::~<span class="built_in">client</span>()&#123;</span><br><span class="line">    <span class="built_in">close</span>(sock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// run 函数负责建立与服务器的连接并且启动发送线程和接收线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client::run</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockfd</span></span><br><span class="line">    sock = <span class="built_in">socket</span>(AF_INET,SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//定义sockaddr_in</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">servaddr</span>;</span></span><br><span class="line">    <span class="built_in">memset</span>(&amp;servaddr, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr));</span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = <span class="built_in">htons</span>(server_port);  <span class="comment">//服务器端口</span></span><br><span class="line">    servaddr.sin_addr.s_addr = <span class="built_in">inet_addr</span>(server_ip.<span class="built_in">c_str</span>());  <span class="comment">//服务器ip</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接服务器，成功返回0，错误返回-1</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sock, (struct sockaddr *)&amp;servaddr, <span class="built_in"><span class="keyword">sizeof</span></span>(servaddr)) &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">perror</span>(<span class="string">&quot;connect&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;连接服务器成功\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建发送线程和接收线程</span></span><br><span class="line">    <span class="function">thread <span class="title">send_t</span><span class="params">(SendMsg,sock)</span>,<span class="title">recv_t</span><span class="params">(RecvMsg,sock)</span></span>;</span><br><span class="line">    <span class="keyword">send_t</span>.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;发送线程已结束\n&quot;</span>;</span><br><span class="line">    <span class="keyword">recv_t</span>.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;接收线程已结束\n&quot;</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送线程负责接收用户的输入并且 send 到服务器端，如果用户输入 exit 或者出现异常时将结束线程</span></span><br><span class="line"><span class="comment">// 注意，前面不用加static！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client::SendMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> sendbuf[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(sendbuf, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(sendbuf));</span><br><span class="line">        cin&gt;&gt;sendbuf;</span><br><span class="line">        <span class="keyword">int</span> ret=<span class="built_in">send</span>(conn, sendbuf, <span class="built_in">strlen</span>(sendbuf),<span class="number">0</span>); <span class="comment">//发送</span></span><br><span class="line">        <span class="comment">//输入exit或者对端关闭时结束</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(sendbuf,<span class="string">&quot;exit&quot;</span>)==<span class="number">0</span>||ret&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收线程负责接收服务器发来的消息并且打印到终端</span></span><br><span class="line"><span class="comment">// 注意，前面不用加static！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">client::RecvMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">//不断接收数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//recv返回值小于等于0，退出</span></span><br><span class="line">        <span class="keyword">if</span>(len&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;收到服务器发来的信息：&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>客户端发送线程的结束很容易，输入 exit 之后 break 即可，但是接收线程无法得知用户是否输入了 exit，因此我们需要进行以下处理：服务器收到 exit 之后断开与客户端的连接，使得客户端接收线程的 recv 返回值为 0，这时再 break 即可退出接收线程。</p><p>对服务器代码进行修改，让服务器收到exit后立即close掉套接字描述符，因此需要将<code>sock_arr</code>改为<code>vector&lt;bool&gt;</code>类型，初始化的时候就为其分配一定大小的空间，并全部置为 false 表示“未打开”。更改后的 <code>server.h</code> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> SERVER_H</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERVER_H</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;global.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">server</span>&#123;</span></span><br><span class="line">    <span class="keyword">private</span>:</span><br><span class="line">        <span class="keyword">int</span> server_port;</span><br><span class="line">        <span class="keyword">int</span> server_sockfd;</span><br><span class="line">        string server_ip;</span><br><span class="line">        <span class="keyword">static</span> vector&lt;<span class="keyword">bool</span>&gt; sock_arr;<span class="comment">//改为了静态成员变量，且类型变为vector&lt;bool&gt;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">server</span>(<span class="keyword">int</span> port,string ip);</span><br><span class="line">        ~<span class="built_in">server</span>();</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">        <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">RecvMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure><p>在 <code>server.cpp</code> 中开头加入下面这句代码为 <code>sock_arr</code> 完成初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">server::sock_arr</span><span class="params">(<span class="number">10000</span>,<span class="literal">false</span>)</span></span>;    <span class="comment">//将10000个位置都设为false，sock_arr[i]=false表示套接字描述符i未打开（因此不能关闭）</span></span><br></pre></td></tr></table></figure><p>当然，具体的大小设为 10000 还是其它数字取决于系统能够打开的文件描述符数量，在 Linux 中我们可以使用 <code>ulimit -n</code> 命令来查看和修改文件描述符数量限制。</p><p>接下来添加服务器收到 exit 关闭套接字描述符的代码，修改后的 <code>server::RecvMsg</code> 如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意，前面不用加static！</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">server::RecvMsg</span><span class="params">(<span class="keyword">int</span> conn)</span></span>&#123;</span><br><span class="line">    <span class="comment">//接收缓冲区</span></span><br><span class="line">    <span class="keyword">char</span> buffer[<span class="number">1000</span>];</span><br><span class="line">    <span class="comment">//不断接收数据</span></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(buffer,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(buffer));</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">recv</span>(conn, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>(buffer),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//客户端发送exit或者异常结束时，退出</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">strcmp</span>(buffer,<span class="string">&quot;exit&quot;</span>)==<span class="number">0</span> || len&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(conn);</span><br><span class="line">            sock_arr[conn]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;收到套接字描述符为&quot;</span>&lt;&lt;conn&lt;&lt;<span class="string">&quot;发来的信息：&quot;</span>&lt;&lt;buffer&lt;&lt;endl;</span><br><span class="line">        <span class="comment">//回复客户端</span></span><br><span class="line">        string ans=<span class="string">&quot;收到&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">send</span>(conn,ans.<span class="built_in">c_str</span>(),ans.<span class="built_in">length</span>(),<span class="number">0</span>);</span><br><span class="line">        <span class="comment">//服务器收到exit或者异常关闭套接字描述符</span></span><br><span class="line">        <span class="keyword">if</span>(ret&lt;=<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">close</span>(conn);</span><br><span class="line">            sock_arr[conn]=<span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后，我们需要将 <code>server.cpp</code> 的析构函数改为如下形式，来关闭仍处于打开状态的套接字描述符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">server::~<span class="built_in">server</span>()&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sock_arr.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">        <span class="keyword">if</span>(sock_arr[i])</span><br><span class="line">            <span class="built_in">close</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(server_sockfd);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，对服务器的修改也完成了，我们接下来编写一个 test_client.cpp 文件来测试客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&quot;client.h&quot;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">client <span class="title">clnt</span><span class="params">(<span class="number">8023</span>,<span class="string">&quot;127.0.0.1&quot;</span>)</span></span>;</span><br><span class="line">    clnt.<span class="built_in">run</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来修改 <code>makefile</code>：</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">all: test_server.cpp server.cpp server.h test_client.cpp client.cpp client.h global.h</span></span><br><span class="line">    g++ -o test_client test_client.cpp client.cpp -lpthread</span><br><span class="line">    g++ -o test_server test_server.cpp server.cpp -lpthread</span><br><span class="line"><span class="section">test_server: test_server.cpp server.cpp server.h global.h</span></span><br><span class="line">    g++ -o test_server test_server.cpp server.cpp -lpthread</span><br><span class="line"><span class="section">test_client: test_client.cpp client.cpp client.h global.h</span></span><br><span class="line">    g++ -o test_client test_client.cpp client.cpp -lpthread</span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm test_server</span><br><span class="line">    rm test_client</span><br></pre></td></tr></table></figure><p>接下来 <code>make</code> 并且进行测试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">make</span><br><span class="line">./test_server</span><br><span class="line"><span class="comment"># 新开一个终端</span></span><br><span class="line">./test_client</span><br><span class="line"><span class="comment"># 再新开一个终端</span></span><br><span class="line">./test_client</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>大疆笔试：加权区间调度</title>
      <link href="/posts/993cd50e/"/>
      <url>/posts/993cd50e/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="加权任务区间调度"><a href="#加权任务区间调度" class="headerlink" title="加权任务区间调度"></a>加权任务区间调度</h2><p>题目描述：</p><p>有一批任务需要调度执行，每个任务的权重为w，开始时间为s，结束时间为f，只有当两个任务的执行时间区间没有重叠的情况，这两个任务才能调度先后执行，否则只能选其中一个执行。</p><p>任务：编写一个schedule函数，输入一个有n个任务信息的数组[[wi, si, fi]]  索引 i = 0 …… n-1.返回可调度的最优任务子集（该任务子集的权重和最大）对应的任务索引，输出的索引按照升序进行排列，假设最优子集组合只有一种。</p><p>例如：如果两个任务为[10 2 5]和[9 5 7]，则这两个任务执行没有重叠。如果两个任务为[10 2 5]和[9 4 7]，则这两个任务存在重叠区间。</p><p>输入：一个n*3的二维数组，n表示n个任务的权重、起始时间和终止时间</p><p>输出：一个一维数组，列出最大权重和所对应的任务索引（升序排列）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">样例输入：</span><br><span class="line">8 3</span><br><span class="line">3 0 6</span><br><span class="line">1 1 4</span><br><span class="line">4 3 5</span><br><span class="line">17 3 8</span><br><span class="line">9 4 7</span><br><span class="line">10 5 9</span><br><span class="line">8 6 10</span><br><span class="line">1 8 11</span><br><span class="line">样例输出：</span><br><span class="line">3 7</span><br></pre></td></tr></table></figure><p>解析：</p><p><strong>动态规划求解思路</strong></p><p>将任务<strong>按照结束时间升序排列</strong>，需要用一个数组p[j], 记录与任务j相兼容的最近（最大下标）的任务，如下图中，p[8] = 1, p[7] = 3, p[2] = 0. <strong>设置数组p[j]的目的是方便动态规划推导过程中的区间回退。</strong>如果当前区间采用，则向前推到最近的一个不重叠的区间号。</p><img src="/posts/993cd50e/20191104143955276.png" alt="在这里插入图片描述" style="zoom: 67%;"><p>利用dp数组记录最大权重和，dp数组的含义为：dp[i] 为对于只含有1，2…… i （前i个任务）的可相互兼容的子集的最大权重值。注意，<strong>每个区间只有取或者不取这两种状态</strong>。为了方便计算，dp数组的长度为n+1, dp[0] = 0. p数组的长度n+1。</p><p>动态规划递推过程：</p><ul><li>如果dp[i]不选择执行任务i，那么它一定是前i-1个任务的最优解，即dp[i-1]；</li><li>如果dp[i]选择执行任务i，那么它是前p[i]个任务的最优解，加上当前任务的权重wi，即dp[p[i]] + wi。</li></ul><p>综上递推式为，dp[i] = max(dp[i-1], dp[p[i]] + wi), i &gt; 0; dp[0] = 0;</p><p>求出最大权重和，还需求出原始数组中需要执行的任务索引，因为在进行按照结束时间排序后，顺序打乱了，因此需要一个哈希表记录每一个任务信息对应的原始任务索引值，key设置为string类型，value为int类型，si = “wi”+”si”+”fi”; map[si] = i;</p><p>根据求得的dp数组，需要找出最大权重和对应的子集区间是哪些，这里从dp数组倒序进行遍历，设置最大权重和为maxVal，如果一个位置k &gt; 0的dp[k] == maxVal &amp;&amp; dp[k-1] != maxVal; 说明排序后的第k个区间是执行的，因此存储k区间信息对应的原始索引值，更新maxVal值减去排序后的第k个任务的权重，maxVal -= wk; 或者向前找区间k最近的可执行区间p[k]，将maxVal更新为dp[p[k]].(个人推荐后一种更新maxVal的方法，减少运算合理利用p数组)。</p><p>整理代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// 注意，比较函数不能直接写在类内部，需加上static静态函数，否则类外调用sort无法访问cmp函数</span></span><br><span class="line">    <span class="comment">// 或者将cmp函数写在类的外部，以及用lambda表达式[&amp;](int&amp; a,int&amp; b)&#123;return a &lt; b;&#125;</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">cmp</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; a, vector&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 比较两个任务信息数组，按照结束时间进行升序排序</span></span><br><span class="line">        <span class="keyword">return</span> a[<span class="number">2</span>] &lt; b[<span class="number">2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 辅助函数 将任务信息数组转化为string类型便于哈希表存储</span></span><br><span class="line">    <span class="function">string <span class="title">help</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">        string s;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> a : arr) &#123;</span><br><span class="line">            s += <span class="built_in">to_string</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 主函数</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">schedule</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">        unordered_map&lt;string, <span class="keyword">int</span>&gt; mp;</span><br><span class="line">        <span class="comment">// 哈希表存储任务信息列表对应的原始索引值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            mp.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="built_in">help</span>(arr[i]), i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 便于计算，这里插入一个0进程的调度信息，这样排序后的第i个任务就是arr[i]</span></span><br><span class="line">        arr.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="comment">// 按照结束时间进行升序排序</span></span><br><span class="line">        <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>(), cmp);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 辅助数组p，记录当前区间之前，最近的一个不重叠区间的位置</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i<span class="number">-1</span>; j &gt; <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (arr[j][<span class="number">2</span>] &lt;= arr[i][<span class="number">1</span>]) &#123;</span><br><span class="line">                    p[i] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; res; <span class="comment">// 记录结果</span></span><br><span class="line">        </span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;<span class="comment">// dp数组，记录当前i个区间的最优解，dp[i]为当前的最大权重和</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// dp递推关系</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (dp[p[i]] + arr[i][<span class="number">0</span>] &gt;= dp[i<span class="number">-1</span>]) &#123; <span class="comment">// 执行第i个区间</span></span><br><span class="line">                dp[i] = dp[p[i]] + arr[i][<span class="number">0</span>];</span><br><span class="line">                </span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不执行第i个区间</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> maxVal = dp[n]; <span class="comment">// 区间n的最大权重和</span></span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 倒序遍历dp数组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="comment">// 找到执行的区间位置</span></span><br><span class="line">            <span class="keyword">if</span> (dp[i] == maxVal &amp;&amp; dp[i - <span class="number">1</span>] != maxVal) &#123;</span><br><span class="line">                index = i;</span><br><span class="line">                res.<span class="built_in">push_back</span>(mp[<span class="built_in">help</span>(arr[index])]);</span><br><span class="line">                maxVal = dp[p[index]];</span><br><span class="line">                <span class="comment">//maxVal -= arr[index][0];</span></span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">sort</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()); <span class="comment">// 注意结果要求升序排序</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n, num;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; num;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">arr</span>(n);</span><br><span class="line">    <span class="keyword">int</span> len  = n;</span><br><span class="line">    <span class="keyword">int</span> wi = <span class="number">0</span>, si = <span class="number">0</span>, fi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (n--) &#123;</span><br><span class="line">        cin &gt;&gt; wi &gt;&gt; si &gt;&gt; fi;</span><br><span class="line">        arr[len - n - <span class="number">1</span>].<span class="built_in">push_back</span>(wi);</span><br><span class="line">        arr[len - n - <span class="number">1</span>].<span class="built_in">push_back</span>(si);</span><br><span class="line">        arr[len - n - <span class="number">1</span>].<span class="built_in">push_back</span>(fi);    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    arr1 = &#123;&#123;2,0,4&#125;, &#123;4,1,6&#125;, &#123;4,5,7&#125;, &#123;7,2,9&#125;, &#123;2,8,10&#125;, &#123;1,8,11&#125;&#125;;</span></span><br><span class="line"><span class="comment">    输出：0 2 4</span></span><br><span class="line"><span class="comment">    arr2 = &#123;&#123;3,0,6&#125;,&#123;1,1,4&#125;,&#123;4,3,5&#125;,&#123;17,3,8&#125;,&#123;9,4,7&#125;,&#123;10,5,9&#125;,&#123;8,6,10&#125;,&#123;1,8,11&#125;&#125;;</span></span><br><span class="line"><span class="comment">    输出：3 7</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    solution test;</span><br><span class="line">    res = test.<span class="built_in">schedule</span>(arr);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : res) &#123;</span><br><span class="line">        cout &lt;&lt; v &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>备战华为刷题笔记</title>
      <link href="/posts/1d3d6b4e/"/>
      <url>/posts/1d3d6b4e/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><h3 id="爱吃香蕉的珂珂"><a href="#爱吃香蕉的珂珂" class="headerlink" title="爱吃香蕉的珂珂"></a>爱吃香蕉的珂珂</h3><p><a href="https://leetcode.cn/problems/koko-eating-bananas/">875. 爱吃香蕉的珂珂</a></p><p>珂珂喜欢吃香蕉。这里有<code>n</code>堆香蕉，第<code>i</code>堆中有<code>piles[i]</code>根香蕉。警卫已经离开了，将在<code>h</code>小时后回来。<br>珂珂可以决定她吃香蕉的速度<code>k</code>（单位：根/小时）。每个小时，她将会选择一堆香蕉，从中吃掉k根。如果这堆香蕉少于<code>k</code>根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。<br>珂珂喜欢慢慢吃，但仍然想在警卫回来前吃掉所有的香蕉。<br>返回她可以在<code>h</code>小时内吃掉所有香蕉的最小速度<code>k</code>（<code>k</code>为整数）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：piles = [3,6,7,11], h = 8</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：piles = [30,11,23,4,20], h = 5</span><br><span class="line">输出：30</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：piles = [30,11,23,4,20], h = 6</span><br><span class="line">输出：23</span><br></pre></td></tr></table></figure><p>解析：</p><p>设吃香蕉的速度为x，二分查找的下界为1，每小时最少吃一根；上界为一堆香蕉最多的总数目。当一堆香蕉的个数是pile，吃掉这堆香蕉需要[pile/x]小时，计算出吃掉所有香蕉的时间。如果在速度为x的情况下可以在h小时内吃完，则最小速度小于或等于x，调整上界为x；否则最小速度一定大于x，因此将下界调整为x+1。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minEatingSpeed</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="number">1000000001</span>;</span><br><span class="line">    <span class="comment">// 寻找最小速度，找左边界</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">f</span>(piles, mid, h)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：速度为 x 时，需要 f(x) 小时吃完所有香蕉</span></span><br><span class="line"><span class="comment">// 判断当前速度能否在h小时内完成</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">f</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> x, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hours = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; piles.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        hours += piles[i] / x;</span><br><span class="line">        <span class="keyword">if</span> (piles[i] % x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            hours++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hours &lt;= h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序矩阵中第-K-小的元素"><a href="#有序矩阵中第-K-小的元素" class="headerlink" title="有序矩阵中第 K 小的元素"></a>有序矩阵中第 K 小的元素</h3><p><a href="https://leetcode.cn/problems/kth-smallest-element-in-a-sorted-matrix/">378. 有序矩阵中第 K 小的元素</a></p><p>给你一个<code>n x n</code>矩阵<code>matrix</code>，其中每行和每列元素均按升序排序，找到矩阵中第<code>k</code>小的元素。<br>请注意，它是<strong>排序后</strong>的第<code>k</code>小元素，而不是第<code>k</code>个<strong>不同</strong>的元素。<br>你必须找到一个内存复杂度优于 O(n^2) 的解决方案。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：matrix = [[1,5,9],[10,11,13],[12,13,15]], k = 8</span><br><span class="line">输出：13</span><br><span class="line">解释：矩阵中的元素为 [1,5,9,10,11,12,13,13,15]，第 8 小元素是 13</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：matrix = [[-5]], k = 1</span><br><span class="line">输出：-5</span><br></pre></td></tr></table></figure><p>解析：</p><p>二分查找，矩阵内元素从左上到右下递增。<code>matrix[0][0]</code> 为最小值，<code>matrix[n-1][n-1]</code>为最大值，现在我们将其分别记作l和r。可以发现一个性质：任取一个数 mid 满足 l ≤ mid ≤ r，那么矩阵中不大于mid的数，肯定全部分布在矩阵的左上角。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">kthSmallest</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = matrix[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> right = matrix[n<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    <span class="comment">// 寻找左边界</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - mid) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(matrix, k, mid)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 判断不大于mid的总数，是否大于k；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> k, <span class="keyword">int</span> mid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = matrix.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> tmp = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (tmp &gt;= <span class="number">0</span> &amp;&amp; matrix[tmp][i] &gt; mid) &#123;</span><br><span class="line">            tmp--;</span><br><span class="line">        &#125;</span><br><span class="line">        count += (tmp + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count &gt;= k;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="搜索旋转排序数组"><a href="#搜索旋转排序数组" class="headerlink" title="搜索旋转排序数组"></a>搜索旋转排序数组</h3><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array/">33. 搜索旋转排序数组</a></p><p>整数数组<code>nums</code>按升序排列，数组中的值<strong>互不相同</strong> 。<br>在传递给函数之前，<code>nums </code>在预先未知的某个下标<code> k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转，使数组变为<code> [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code>[0,1,2,4,5,6,7]</code>在下标 3 处经旋转后可能变为<code>[4,5,6,7,0,1,2]</code>。<br>给你 旋转后 的数组<code>nums</code>和一个整数<code>target</code>，如果<code>nums</code>中存在这个目标值<code>target</code>，则返回它的下标，否则返回 -1 。<br>你必须设计一个时间复杂度为 O(log n) 的算法解决此问题。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 0</span><br><span class="line">输出：4</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [4,5,6,7,0,1,2], target = 3</span><br><span class="line">输出：-1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1], target = 0</span><br><span class="line">输出：-1</span><br></pre></td></tr></table></figure><p>解析：</p><p>数组局部有序，可以在常规二分查找的时候查看当前 mid 为分割位置分割出来的两个部分 [l, mid] 和 [mid + 1, r] 哪个部分是有序的，并根据有序的那个部分确定我们该如何改变二分查找的上下界，因为我们能够根据有序的那部分判断出 target 在不在这个部分。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &gt;= nums[<span class="number">0</span>]) &#123; <span class="comment">// 左半区域有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[<span class="number">0</span>] &amp;&amp; nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右半区域有序</span></span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[n<span class="number">-1</span>] &amp;&amp; nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/search-in-rotated-sorted-array-ii/">81. 搜索旋转排序数组 II</a></p><p>已知存在一个按非降序排列的整数数组 nums ，数组中的值不必互不相同。<br>在传递给函数之前，<code>nums </code>在预先未知的某个下标<code>k（0 &lt;= k &lt; nums.length）</code>上进行了 旋转 ，使数组变为<code> [nums[k], nums[k+1], ..., nums[n-1], nums[0], nums[1], ..., nums[k-1]]</code>（下标 从 0 开始 计数）。例如，<code>[0,1,2,4,4,4,5,6,6,7]</code>在下标 5 处经旋转后可能变为<code>[4,5,6,6,7,0,1,2,4,4]</code>。<br>给你 旋转后 的数组<code>nums</code>和一个整数<code>target</code>，请你编写一个函数来判断给定的目标值是否存在于数组中。如果<code>nums</code>中存在这个目标值<code>target</code>，则返回<code>true</code>，否则返回<code> false</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 0</span><br><span class="line">输出：true</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [2,5,6,0,0,1,2], target = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>解析：</p><p>对于数组中有重复元素的情况，二分查找时可能会有<code> a[l]=a[mid]=a[r]</code>，此时无法判断区间 <code>[l,mid] </code>和区间<code>[mid+1,r]</code>哪个是有序的。例如<code>nums=[3,1,2,3,3,3,3]</code>，<code>target=2</code>，首次二分时无法判断区间<code>[0,3]</code>和区间<code>[4,6]</code>哪个是有序的。<br>对于这种情况，我们只能将当前二分区间的左边界加一，右边界减一，然后在新区间上继续二分查找。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = n;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nums[left] == nums[mid] &amp;&amp; nums[mid] == nums[right<span class="number">-1</span>]) &#123;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt;= nums[left]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &gt;= nums[left] &amp;&amp; nums[mid] &gt; target) &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt;= nums[right<span class="number">-1</span>] &amp;&amp; nums[mid] &lt; target) &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在-D-天内送达包裹的能力"><a href="#在-D-天内送达包裹的能力" class="headerlink" title="在 D 天内送达包裹的能力"></a>在 D 天内送达包裹的能力</h3><p><a href="https://leetcode.cn/problems/capacity-to-ship-packages-within-d-days/">1011. 在 D 天内送达包裹的能力</a></p><p>传送带上的包裹必须在 days 天内从一个港口运送到另一个港口。<br>传送带上的第 i 个包裹的重量为 weights[i]。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。<br>返回能在 days 天内将传送带上的所有包裹送达的船的最低运载能力。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br><span class="line"></span><br><span class="line">请注意，货物必须按照给定的顺序装运，因此使用载重能力为 14 的船舶并将包装分成 (2, 3, 4, 5), (1, 6, 7), (8), (9), (10) 是不允许的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：weights = [3,2,2,4,1,4], days = 3</span><br><span class="line">输出：6</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 6 就能够在 3 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：3, 2</span><br><span class="line">第 2 天：2, 4</span><br><span class="line">第 3 天：1, 4</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：weights = [1,2,3,1,1], days = 4</span><br><span class="line">输出：3</span><br><span class="line">解释：</span><br><span class="line">第 1 天：1</span><br><span class="line">第 2 天：2</span><br><span class="line">第 3 天：3</span><br><span class="line">第 4 天：1, 1</span><br></pre></td></tr></table></figure><p>解析：</p><p>二分查找转化为判定问题。假设当船的运载能力为x时，我们可以在days天内运送完所有包裹，那么只要运载能力大于x，我们同样可以在days天内运送完所有包裹：我们只需要使用运载能力为x时的运送方法即可。</p><p>二分查找的左边界为一个包裹重量的最大值，即weights数组中的最大值；右边界为weights数组之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; w : weights) &#123;</span><br><span class="line">        left = <span class="built_in">max</span>(left, w);</span><br><span class="line">        right += w;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getDays</span>(weights, mid) &lt;= days) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> days = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; weights.<span class="built_in">size</span>();) &#123;</span><br><span class="line">        <span class="keyword">int</span> cap = x;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; weights.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cap &lt; weights[i]) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                cap -= weights[i++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        days++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> days;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="找出第-K-小的数对距离"><a href="#找出第-K-小的数对距离" class="headerlink" title="找出第 K 小的数对距离"></a>找出第 K 小的数对距离</h3><p><a href="https://leetcode.cn/problems/find-k-th-smallest-pair-distance/">719. 找出第 K 小的数对距离</a></p><p>数对<code> (a,b)</code>由整数 a 和 b 组成，其数对距离定义为 a 和 b 的绝对差值。<br>给你一个整数数组<code>nums</code>和一个整数 k ，数对由<code>nums[i]</code>和<code>nums[j]</code>组成且满足<code>0 &lt;= i &lt; j &lt; nums.length</code>。返回<strong>所有数对距离中</strong>第 k 小的数对距离。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,3,1], k = 1</span><br><span class="line">输出：0</span><br><span class="line">解释：数对和对应的距离如下：</span><br><span class="line">(1,3) -&gt; 2</span><br><span class="line">(1,1) -&gt; 0</span><br><span class="line">(3,1) -&gt; 2</span><br><span class="line">距离第 1 小的数对是 (1,1) ，距离为 0 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,1,1], k = 2</span><br><span class="line">输出：0</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1,6,1], k = 3</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>解析：</p><p>排序+二分+双指针</p><p>先将数组排序，第k小的数对距离在区间[0, max(nums) - min(nums)]，令left = 0，right = max(nums) - min(nums)，在该区间内进行二分。对于当前搜索距离mid，计算所有距离小于等于mid的数对数目count，使用双指针：初始左端点i=0，从小到大枚举所有数对的右端点j，移动左端点直到nums[j] - nums[i] &lt;= mid，那么右端点为j且距离小于等于mid的数对数目为j-i，计算这些数目之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallestDistancePair</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums[n<span class="number">-1</span>] - nums[<span class="number">0</span>] + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (nums[j] - nums[i] &gt; mid) &#123;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += j - i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &gt;= k) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="分割数组的最大值"><a href="#分割数组的最大值" class="headerlink" title="分割数组的最大值"></a>分割数组的最大值</h3><p><a href="https://leetcode.cn/problems/split-array-largest-sum/">410. 分割数组的最大值</a></p><p>给定一个非负整数数组<code>nums</code>和一个整数<code>m</code>，你需要将这个数组分成<code>m</code>个非空的连续子数组。</p><p>设计一个算法使得这<code>m</code>个子数组各自和的最大值最小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [7,2,5,10,8], m = 2</span><br><span class="line">输出：18</span><br><span class="line">解释：</span><br><span class="line">一共有四种方法将 nums 分割为 2 个子数组。 </span><br><span class="line">其中最好的方式是将其分为 [7,2,5] 和 [10,8] 。</span><br><span class="line">因为此时这两个子数组各自的和的最大值为18，在所有情况中最小。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3,4,5], m = 2</span><br><span class="line">输出：9</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1,4,4], m = 3</span><br><span class="line">输出：4</span><br></pre></td></tr></table></figure><p>解析：</p><p>二分查找+贪心（使……最大值尽可能的小）</p><p>选定一个值x，线性的验证是否存在一种分割方案，满足最大分割子数组的和不超过x。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">splitArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>(), left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : nums) &#123;</span><br><span class="line">        left = <span class="built_in">max</span>(left, a);</span><br><span class="line">        right += a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;) &#123;</span><br><span class="line">            <span class="keyword">int</span> sum = mid;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] &gt; sum) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    sum -= nums[i++];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (count &lt;= m) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两球之间的磁力"><a href="#两球之间的磁力" class="headerlink" title="两球之间的磁力"></a>两球之间的磁力</h3><p><a href="https://leetcode.cn/problems/magnetic-force-between-two-balls/">1552. 两球之间的磁力</a></p><p>在代号为 C-137 的地球上，Rick 发现如果他将两个球放在他新发明的篮子里，它们之间会形成特殊形式的磁力。Rick 有<code>n</code>个空的篮子，第<code>i</code>个篮子的位置在<code>position[i]</code>，Morty 想把<code>m</code>个球放到这些篮子里，使得任意两球间 <strong>最小磁力</strong> 最大。<br>已知两个球如果分别位于<code>x</code>和<code>y</code>，那么它们之间的磁力为<code>|x - y|</code>。<br>给你一个整数数组<code>position</code>和一个整数<code>m</code>，请你返回最大化的最小磁力。</p><img src="/posts/1d3d6b4e/image-20220807181250174.png" alt="image-20220807181250174" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：position = [1,2,3,4,7], m = 3</span><br><span class="line">输出：3</span><br><span class="line">解释：将 3 个球分别放入位于 1，4 和 7 的三个篮子，两球间的磁力分别为 [3, 3, 6]。最小磁力为 3 。我们没办法让最小磁力大于 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：position = [5,4,3,2,1,1000000000], m = 2</span><br><span class="line">输出：999999999</span><br><span class="line">解释：我们使用位于 1 和 1000000000 的篮子时最小磁力最大。</span><br></pre></td></tr></table></figure><p>解析：</p><p>假定最小磁力为ans，小于ans的答案也一定合法。既然我们存在一种放置的方法使得相邻小球间距的最小值大于等于 ans，那么也一定大于 [1,ans−1] 中的任意一个值，而大于 ans 的均不合法，因此我们可以对答案进行二分查找。在区间[left, right]之间查找，每次取mid为平均值：</p><ul><li>如果当前mid合法，令ans = mid，并将区间缩小为[mid + 1, right];</li><li>如果当前mid不合法，则将区间缩小为[left, mid - 1].</li></ul><p>预先对给定的篮子的位置进行排序，那么从贪心的角度考虑，第一个小球放置的篮子一定是 position 最小的篮子，即排序后的第一个篮子。那么为了满足上述条件，第二个小球放置的位置一定要大于等于 position[0]+x，接下来同理。因此我们从前往后扫 position 数组，看在当前答案 x 下我们最多能在篮子里放多少个小球，我们记这个数量为 cnt，如果 cnt 大于等于 m，那么说明当前答案下我们的贪心策略能放下 m 个小球且它们间距均大于等于 x ，为合法的答案，否则不合法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(position.<span class="built_in">begin</span>(), position.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> n = position.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = position[n<span class="number">-1</span>] - position[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 寻找满足成立条件的右边界</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">check</span>(position, mid, m)) &#123;</span><br><span class="line">            ans = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查以x为最小磁力，得到的分组cnt是否大于等于m</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; position, <span class="keyword">int</span> x, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pre = position[<span class="number">0</span>], cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; position.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (position[i] - pre &gt;= x) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            pre = position[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> cnt &gt;= m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="小张刷题计划"><a href="#小张刷题计划" class="headerlink" title="小张刷题计划"></a>小张刷题计划</h3><p><a href="https://leetcode.cn/problems/xiao-zhang-shua-ti-ji-hua/">LCP 12. 小张刷题计划</a></p><p>为了提高自己的代码能力，小张制定了 LeetCode 刷题计划，他选中了 LeetCode 题库中的 n 道题，编号从 0 到 n-1，并计划在 m 天内按照题目编号顺序刷完所有的题目（注意，小张不能用多天完成同一题）。</p><p>在小张刷题计划中，小张需要用 time[i] 的时间完成编号 i 的题目。此外，小张还可以使用场外求助功能，通过询问他的好朋友小杨题目的解法，可以省去该题的做题时间。为了防止“小张刷题计划”变成“小杨刷题计划”，小张每天最多使用一次求助。</p><p>我们定义 m 天中做题时间最多的一天耗时为 T（小杨完成的题目不计入做题总时间）。请你帮小张求出最小的 T是多少。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line"></span><br><span class="line">输入：time = [1,2,3,3], m = 2</span><br><span class="line">输出：3</span><br><span class="line">解释：第一天小张完成前三题，其中第三题找小杨帮忙；第二天完成第四题，并且找小杨帮忙。这样做题时间最多的一天花费了 3 的时间，并且这个值是最小的。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line"></span><br><span class="line">输入：time = [999,999,999], m = 4</span><br><span class="line">输出：0</span><br><span class="line">解释：在前三天中，小张每天求助小杨一次，这样他可以在三天内完成所有的题目并不花任何时间。</span><br></pre></td></tr></table></figure><p>解析：</p><p>题意解析为：给定一个数组，将其划分为M份，使得每份元素之和的最大值最小，每份可以任意减去其中一个元素。</p><p>如果不考虑每份可以任意减去一个元素，就是一个经典的二分问题，具有单调最优的性质：如果最大值为 t 可以满足条件划分，那么最大值为 t+1 也可以。所以就直接二分最大值 t，找到最小满足条件的 t 即可。</p><p>本题加了一个条件：每份可以删除任意一个数组。为了能够让最大值最小，显然每份中删去的一定是最大元素，所以在二分判定可行性时，维护当前序列的最大值，然后记录删除最大值的结果，也就是说二分的判定是：是否可以让每组删除最大值之后，总和都小于等于 t。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minTime</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; time, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = time.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; t : time) &#123;</span><br><span class="line">        right += t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">getDays</span>(time, mid) &lt;= m) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; time, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> useday = <span class="number">1</span>, totaltime = <span class="number">0</span>, maxtime = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; time.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextime = <span class="built_in">min</span>(maxtime, time[i]);</span><br><span class="line">        <span class="keyword">if</span> (nextime + totaltime &lt;= x) &#123;</span><br><span class="line">            totaltime += nextime;</span><br><span class="line">            maxtime = <span class="built_in">max</span>(maxtime, time[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            useday++;</span><br><span class="line">            totaltime = <span class="number">0</span>;</span><br><span class="line">            maxtime = time[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> useday;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h2><h3 id="航班预订统计"><a href="#航班预订统计" class="headerlink" title="航班预订统计"></a>航班预订统计</h3><p><a href="https://leetcode.cn/problems/corporate-flight-bookings/">1109. 航班预订统计</a></p><p>这里有 n 个航班，它们分别从 1 到 n 进行编号。</p><p>有一份航班预订表 bookings ，表中第 i 条预订记录 bookings[i] = [firsti, lasti, seatsi] 意味着在从 firsti 到 lasti （包含 firsti 和 lasti ）的 每个航班 上预订了 seatsi 个座位。</p><p>请你返回一个长度为 n 的数组 answer，里面的元素是每个航班预定的座位总数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：bookings = [[1,2,10],[2,3,20],[2,5,25]], n = 5</span><br><span class="line">输出：[10,55,45,25,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2   3   4   5</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       20  20</span><br><span class="line">预订记录 3 ：       25  25  25  25</span><br><span class="line">总座位数：      10  55  45  25  25</span><br><span class="line">因此，answer = [10,55,45,25,25]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：bookings = [[1,2,10],[2,2,15]], n = 2</span><br><span class="line">输出：[10,25]</span><br><span class="line">解释：</span><br><span class="line">航班编号        1   2</span><br><span class="line">预订记录 1 ：   10  10</span><br><span class="line">预订记录 2 ：       15</span><br><span class="line">总座位数：      10  25</span><br><span class="line">因此，answer = [10,25]</span><br></pre></td></tr></table></figure><p>解析：</p><p>差分数组：第i个数即为原数组第i-1个元素和第i个元素的差值，也就是说对差分数组求前缀和即可得到原始数组。<br>遍历给定的预定数组，对差分数据进行更新，完成修改。对于预定记录booking=[l,r,inc]，我们需要让d[l−1] 增加 inc，d[r] 减少inc。特别地，当 r 为 n 时，我们无需修改d[r]，因为这个位置溢出了下标范围。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">corpFlightBookings</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; bookings, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; bookings.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = bookings[i][<span class="number">0</span>] - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> last = bookings[i][<span class="number">1</span>];</span><br><span class="line">        res[first] += bookings[i][<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">if</span> (last &lt; n) &#123;</span><br><span class="line">            res[last] -= bookings[i][<span class="number">2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        res[i] += res[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="所有排列中的最大和"><a href="#所有排列中的最大和" class="headerlink" title="所有排列中的最大和"></a>所有排列中的最大和</h3><p><a href="https://leetcode.cn/problems/maximum-sum-obtained-of-any-permutation/">1589. 所有排列中的最大和</a></p><p>有一个整数数组 nums ，和一个查询数组 requests ，其中 requests[i] = [starti, endi] 。第 i 个查询求 nums[starti] + nums[starti + 1] + … + nums[endi - 1] + nums[endi] 的结果 ，starti 和 endi 数组索引都是 从 0 开始 的。</p><p>你可以任意排列 nums 中的数字，请你返回所有查询结果之和的最大值。</p><p>由于答案可能会很大，请你将它对 10^9 + 7 取余 后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,3,4,5], requests = [[1,3],[0,1]]</span><br><span class="line">输出：19</span><br><span class="line">解释：一个可行的 nums 排列为 [2,1,3,4,5]，并有如下结果：</span><br><span class="line">requests[0] -&gt; nums[1] + nums[2] + nums[3] = 1 + 3 + 4 = 8</span><br><span class="line">requests[1] -&gt; nums[0] + nums[1] = 2 + 1 = 3</span><br><span class="line">总和为：8 + 3 = 11。</span><br><span class="line">一个总和更大的排列为 [3,5,4,2,1]，并有如下结果：</span><br><span class="line">requests[0] -&gt; nums[1] + nums[2] + nums[3] = 5 + 4 + 2 = 11</span><br><span class="line">requests[1] -&gt; nums[0] + nums[1] = 3 + 5  = 8</span><br><span class="line">总和为： 11 + 8 = 19，这个方案是所有排列中查询之和最大的结果。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3,4,5,6], requests = [[0,1]]</span><br><span class="line">输出：11</span><br><span class="line">解释：一个总和最大的排列为 [6,5,4,3,2,1] ，查询和为 [11]。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [1,2,3,4,5,10], requests = [[0,2],[1,3],[1,1]]</span><br><span class="line">输出：47</span><br><span class="line">解释：一个和最大的排列为 [4,10,5,3,2,1] ，查询结果分别为 [19,18,10]。</span><br></pre></td></tr></table></figure><p>解析：</p><p>利用差分数组，求解区间内每个下标被查询的次数，count数组记录每个下标的数据被查询的次数，在得到数组 counts 之后，对数组nums 和数组 counts 排序。倒序遍历数组，当查询次数大于0时，计算最大和 sum += nums[i] * count[i]。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSumRangeQuery</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; requests)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; req : requests) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = req[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> last = req[<span class="number">1</span>];</span><br><span class="line">        count[first]++;</span><br><span class="line">        <span class="keyword">if</span> (last + <span class="number">1</span> &lt; n) count[last+<span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        count[i] += count[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(count.<span class="built_in">begin</span>(), count.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Mod = <span class="number">1000000007</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">0</span> &amp;&amp; count[i] &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        sum += (<span class="keyword">long</span> <span class="keyword">long</span>) nums[i] * count[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">int</span>)(sum % Mod);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="拼车"><a href="#拼车" class="headerlink" title="拼车"></a>拼车</h3><p><a href="https://leetcode.cn/problems/car-pooling/">1094. 拼车</a></p><p>车上最初有 capacity 个空座位。车 只能 向一个方向行驶（也就是说，不允许掉头或改变方向）</p><p>给定整数 capacity 和一个数组 trips ,  trip[i] = [numPassengersi, fromi, toi] 表示第 i 次旅行有 numPassengersi 乘客，接他们和放他们的位置分别是 fromi 和 toi 。这些位置是从汽车的初始位置向东的公里数。</p><p>当且仅当你可以在所有给定的行程中接送所有乘客时，返回 true，否则请返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：trips = [[2,1,5],[3,3,7]], capacity = 4</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：trips = [[2,1,5],[3,3,7]], capacity = 5</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>解析：</p><p>构建差分数组，对原始数组进行频繁的区间增减操作，根据trips数组对区间进行增减，1 &lt;= trips.length &lt;= 1000，因此差分数组的长度设为1001.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">carPooling</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; trips, <span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(<span class="number">1001</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; trip : trips) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = trip[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> last = trip[<span class="number">2</span>];</span><br><span class="line">        res[first] += trip[<span class="number">0</span>];</span><br><span class="line">        res[last] -= trip[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; res.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span>) res[i] += res[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">if</span> (res[i] &gt; capacity) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="会议室"><a href="#会议室" class="headerlink" title="会议室"></a>会议室</h3><p>给定一个会议时间安排的数组，每个会议时间都会包括开始和结束的时间 [[s1,e1],[s2,e2],…] (si &lt; ei)， 为避免会议冲突，同时要考虑充分利用会议室资源，请你计算<strong>至少需要</strong>多少间会议室，才能满足这些会议安排。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[0, 30],[5, 10],[15, 20]]</span><br><span class="line">输出: 2</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [[7,10],[2,4]]</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>解析：</p><p><strong>如果把每个会议的起始时间看做一个线段区间，那么题目就是让你求最多有几个重叠区间</strong></p><p>把时间线想象成一个初始值为 0 的数组，每个时间区间 <code>[i, j]</code> 就相当于一个子数组，这个时间区间有一个会议，那我就把这个子数组中的元素都加一。最后遍历数组，求最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minMeetingRooms</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; intervals)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = intervals.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">begin</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">end</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        begin[i] = intervals[i][<span class="number">0</span>];</span><br><span class="line">        end[i] = intervals[i][<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(begin.<span class="built_in">begin</span>(), begin.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(begin.<span class="built_in">begin</span>(), begin.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (begin[i] &lt; end[j]) &#123;</span><br><span class="line">            count++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            count--;</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, count);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="买卖股票的最佳时机-II"><a href="#买卖股票的最佳时机-II" class="headerlink" title="买卖股票的最佳时机 II"></a>买卖股票的最佳时机 II</h3><p><a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">122. 买卖股票的最佳时机 II</a></p><p>给你一个整数数组 prices ，其中 prices[i] 表示某支股票第 i 天的价格。</p><p>在每一天，你可以决定是否购买和/或出售股票。你在任何时候 最多 只能持有 一股 股票。你也可以先购买，然后在 同一天 出售。</p><p>返回 你能获得的 最大 利润 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：prices = [7,1,5,3,6,4]</span><br><span class="line">输出：7</span><br><span class="line">解释：在第 2 天（股票价格 = 1）的时候买入，在第 3 天（股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     随后，在第 4 天（股票价格 = 3）的时候买入，在第 5 天（股票价格 = 6）的时候卖出, 这笔交易所能获得利润 = 6 - 3 = 3 。</span><br><span class="line">     总利润为 4 + 3 = 7 。</span><br><span class="line">     </span><br><span class="line">示例 2：</span><br><span class="line">输入：prices = [1,2,3,4,5]</span><br><span class="line">输出：4</span><br><span class="line">解释：在第 1 天（股票价格 = 1）的时候买入，在第 5 天 （股票价格 = 5）的时候卖出, 这笔交易所能获得利润 = 5 - 1 = 4 。</span><br><span class="line">     总利润为 4 。</span><br><span class="line">     </span><br><span class="line">示例 3：</span><br><span class="line">输入：prices = [7,6,4,3,1]</span><br><span class="line">输出：0</span><br><span class="line">解释：在这种情况下, 交易无法获得正利润，所以不参与交易可以获得最大利润，最大利润为 0 。</span><br></pre></td></tr></table></figure><p>解析：</p><p>构建差分数组，count记录获得利润，只加差分为正的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> diff = prices[i] - prices[i - <span class="number">1</span>]; </span><br><span class="line">        <span class="keyword">if</span> (diff &gt; <span class="number">0</span>) &#123;</span><br><span class="line">           count += diff;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h2><h3 id="省份数量"><a href="#省份数量" class="headerlink" title="省份数量"></a>省份数量</h3><p><a href="https://leetcode.cn/problems/number-of-provinces/">547. 省份数量</a></p><p>有 <code>n</code> 个城市，其中一些彼此相连，另一些没有相连。如果城市 <code>a</code> 与城市 <code>b</code> 直接相连，且城市 <code>b</code> 与城市 <code>c</code> 直接相连，那么城市 <code>a</code> 与城市 <code>c</code> 间接相连。</p><p><strong>省份</strong> 是一组直接或间接相连的城市，组内不含其他没有相连的城市。</p><p>给你一个 <code>n x n</code> 的矩阵 <code>isConnected</code> ，其中 <code>isConnected[i][j] = 1</code> 表示第 <code>i</code> 个城市和第 <code>j</code> 个城市直接相连，而 <code>isConnected[i][j] = 0</code> 表示二者不直接相连。</p><p>返回矩阵中 <strong>省份</strong> 的数量。</p><img src="/posts/1d3d6b4e/image-20220808115241997.png" alt="image-20220808115241997"><p>解析：</p><p>可以把 n 个城市和它们之间的相连关系看成图，城市是图中的节点，相连关系是图中的边，给定的矩阵 isConnected 即为图的邻接矩阵，省份即为图中的连通分量。</p><p>使用并查集计算连通分量数，初始时，每个城市都属于不同的连通分量。遍历矩阵 isConnected，如果两个城市之间有相连关系，则它们属于同一个连通分量，对它们进行合并。遍历矩阵 isConnected 的全部元素之后，计算连通分量的总数，即为省份的总数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">// 寻找根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]); </span><br><span class="line">        <span class="comment">// 递归进行路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123; <span class="comment">// 建立连通性</span></span><br><span class="line">    parent[<span class="built_in">Find</span>(parent, index1)] = <span class="built_in">Find</span>(parent, index2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; isConnected)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cities = isConnected.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(cities, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cities; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cities; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; cities; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (isConnected[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="built_in">Union</span>(parent, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> provinces = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; cities; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parent[i] == i) &#123;</span><br><span class="line">            provinces++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> provinces;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行交换操作后的最小汉明距离"><a href="#执行交换操作后的最小汉明距离" class="headerlink" title="执行交换操作后的最小汉明距离"></a>执行交换操作后的最小汉明距离</h3><p><a href="https://leetcode.cn/problems/minimize-hamming-distance-after-swap-operations/">1722. 执行交换操作后的最小汉明距离</a></p><p>给你两个整数数组 <code>source</code> 和 <code>target</code> ，长度都是 <code>n</code> 。还有一个数组 <code>allowedSwaps</code> ，其中每个 <code>allowedSwaps[i] = [ai, bi]</code> 表示你可以交换数组 <code>source</code> 中下标为 <code>ai</code> 和 <code>bi</code>（<strong>下标从 0 开始</strong>）的两个元素。注意，你可以按 <strong>任意</strong> 顺序 <strong>多次</strong> 交换一对特定下标指向的元素。</p><p>相同长度的两个数组 <code>source</code> 和 <code>target</code> 间的 <strong>汉明距离</strong> 是元素不同的下标数量。形式上，其值等于满足 <code>source[i] != target[i]</code> （<strong>下标从 0 开始</strong>）的下标 <code>i</code>（<code>0 &lt;= i &lt;= n-1</code>）的数量。</p><p>在对数组 <code>source</code> 执行 <strong>任意</strong> 数量的交换操作后，返回 <code>source</code> 和 <code>target</code> 间的 <strong>最小汉明距离</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：source = [1,2,3,4], target = [2,1,4,5], allowedSwaps = [[0,1],[2,3]]</span><br><span class="line">输出：1</span><br><span class="line">解释：source 可以按下述方式转换：</span><br><span class="line">- 交换下标 0 和 1 指向的元素：source = [2,1,3,4]</span><br><span class="line">- 交换下标 2 和 3 指向的元素：source = [2,1,4,3]</span><br><span class="line">source 和 target 间的汉明距离是 1 ，二者有 1 处元素不同，在下标 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：source = [1,2,3,4], target = [1,3,2,4], allowedSwaps = []</span><br><span class="line">输出：2</span><br><span class="line">解释：不能对 source 执行交换操作。</span><br><span class="line">source 和 target 间的汉明距离是 2 ，二者有 2 处元素不同，在下标 1 和下标 2 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：source = [5,1,2,4,3], target = [1,5,4,2,3], allowedSwaps = [[0,4],[4,2],[1,3],[1,4]]</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p>解析：</p><p>利用并查集建立连通性关系，遍历 allowedSwaps 数组中所有元素，从而构建 source 数组中位置之间的联通关系。需要使用哈希表记录为每个联通分支维护位置的集合，为每个联通分支 k 维护 target 中对应位置元素的集合。随后，汉明距离的最小值，就是这两个集合之间不同的元素的数量。<br>注意：<strong>允许集合中的元素出现重复</strong>，因此使用<code>C++</code>中的<code>unordered_multiset</code>数据结构。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Find</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index)</span> </span>&#123; <span class="comment">// 寻找根节点</span></span><br><span class="line">    <span class="keyword">if</span> (parent[index] != index) &#123;</span><br><span class="line">        parent[index] = <span class="built_in">Find</span>(parent, parent[index]); </span><br><span class="line">        <span class="comment">// 递归进行路径压缩</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Union</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; parent, <span class="keyword">int</span> index1, <span class="keyword">int</span> index2)</span> </span>&#123; <span class="comment">// 建立连通性</span></span><br><span class="line">    parent[<span class="built_in">Find</span>(parent, index1)] = <span class="built_in">Find</span>(parent, index2);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minimumHammingDistance</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; source, vector&lt;<span class="keyword">int</span>&gt;&amp; target, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; allowedSwaps)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = source.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">parent</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        parent[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; allowed : allowedSwaps) &#123;</span><br><span class="line">        <span class="built_in">Union</span>(parent, allowed[<span class="number">0</span>], allowed[<span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, unordered_multiset&lt;<span class="keyword">int</span>&gt;&gt; s, t;</span><br><span class="line">    <span class="comment">// 为每个联通分支维护位置的集合</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> fa = <span class="built_in">Find</span>(parent, i);</span><br><span class="line">        s[fa].<span class="built_in">insert</span>(source[i]);</span><br><span class="line">        <span class="comment">//t[fa].insert(target[i]);</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123; </span><br><span class="line">        <span class="keyword">auto</span>&amp; m = s[<span class="built_in">Find</span>(parent, i)];</span><br><span class="line">        <span class="comment">// 如果通过下标找到的连通块中,有target[i]这个元素,那么将其删掉,反之res++</span></span><br><span class="line">        <span class="keyword">auto</span> t = m.<span class="built_in">find</span>(target[i]);</span><br><span class="line">        <span class="comment">// 不能使用 m.erase(x),不然会删掉所有的x,应该先定位到其具体位置,再删除</span></span><br><span class="line">        <span class="comment">//（因为该元素已经被用来对应了，后续无法再使用，所以要删除）</span></span><br><span class="line">        <span class="keyword">if</span> (t != m.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            m.<span class="built_in">erase</span>(t);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//if (s.find(i) == s.end()) continue;</span></span><br><span class="line">        <span class="comment">// for (int x : s[i]) &#123;</span></span><br><span class="line">        <span class="comment">//     if (t[i].find(x) == t[i].end()) &#123;</span></span><br><span class="line">        <span class="comment">//         res++;</span></span><br><span class="line">        <span class="comment">//     &#125; else &#123;</span></span><br><span class="line">        <span class="comment">//         t[i].erase(t[i].find(x));</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="双指针"><a href="#双指针" class="headerlink" title="双指针"></a>双指针</h2><h3 id="替换后的最长重复字符"><a href="#替换后的最长重复字符" class="headerlink" title="替换后的最长重复字符"></a>替换后的最长重复字符</h3><p><a href="https://leetcode.cn/problems/longest-repeating-character-replacement/">424. 替换后的最长重复字符</a></p><p>给你一个字符串 <code>s</code> 和一个整数 <code>k</code> 。你可以选择字符串中的任一字符，并将其更改为任何其他大写英文字符。该操作最多可执行 <code>k</code> 次。</p><p>在执行上述操作后，返回包含相同字母的最长子字符串的长度。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;ABAB&quot;, k = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：用两个&#x27;A&#x27;替换为两个&#x27;B&#x27;,反之亦然。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;AABABBA&quot;, k = 1</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">将中间的一个&#x27;A&#x27;替换为&#x27;B&#x27;,字符串变为 &quot;AABBBBA&quot;。</span><br><span class="line">子串 &quot;BBBB&quot; 有最长重复字母, 答案为 4。</span><br></pre></td></tr></table></figure><p>解析：</p><p>双指针加滑动窗口：</p><p>right指针指向区间右端点，然后找到其最远的left左端点的位置，满足该区间内，出现次数最多的字符数量为maxCnt，区间长度减去maxCnt为剩余的字符数（即非最长重复字符）数量不超过k个。</p><p>实际代码中，由于字符串中仅包含大写字母，我们可以使用一个长度为 26 的数组维护每一个字符的出现次数。每次区间右移，我们更新右移位置的字符出现的次数，然后尝试用它更新重复字符出现次数的历史最大值，最后我们使用该最大值计算出区间内非最长重复字符的数量，以此判断左指针是否需要右移即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">characterReplacement</span><span class="params">(string s, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        count[s[right] - <span class="string">&#x27;A&#x27;</span>]++;</span><br><span class="line">        maxCnt = <span class="built_in">max</span>(maxCnt, count[s[right] - <span class="string">&#x27;A&#x27;</span>]);</span><br><span class="line">        <span class="keyword">if</span> (right - left + <span class="number">1</span> &gt; maxCnt + k) &#123;</span><br><span class="line">            count[s[left] - <span class="string">&#x27;A&#x27;</span>]--;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">        right++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="字符串的排列"><a href="#字符串的排列" class="headerlink" title="字符串的排列"></a>字符串的排列</h3><p><a href="https://leetcode.cn/problems/permutation-in-string/">567. 字符串的排列</a></p><p>给你两个字符串 <code>s1</code> 和 <code>s2</code> ，写一个函数来判断 <code>s2</code> 是否包含 <code>s1</code> 的排列。如果是，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>换句话说，<code>s1</code> 的排列之一是 <code>s2</code> 的 <strong>子串</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s1 = &quot;ab&quot; s2 = &quot;eidbaooo&quot;</span><br><span class="line">输出：true</span><br><span class="line">解释：s2 包含 s1 的排列之一 (&quot;ba&quot;).</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s1= &quot;ab&quot; s2 = &quot;eidboaoo&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>解析：</p><p>双指针+滑动窗口，保证窗口的大小为s1的长度n，用一个cnt数组记录s1中各个字符出现的次数，两个指针left和right， right每次右移动一次，统计一次进入区间的字符x，若此时cnt[x] &lt; 0，则向右移动左指针，增加离开区间的字符cnt值直到cnt[x] &gt;= 0。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkInclusion</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = s1.<span class="built_in">size</span>(), m = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &gt; m) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; c : s1) &#123;</span><br><span class="line">        count[c-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s2.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = (s2[right] - <span class="string">&#x27;a&#x27;</span>);</span><br><span class="line">        right++;</span><br><span class="line">        count[x]--;</span><br><span class="line">        <span class="keyword">while</span> (count[x] &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            count[s2[left] - <span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">            left++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (right - left == n) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="划分字母区间"><a href="#划分字母区间" class="headerlink" title="划分字母区间"></a>划分字母区间</h3><p><a href="https://leetcode.cn/problems/partition-labels/">763. 划分字母区间</a></p><p>字符串 <code>S</code> 由小写字母组成。我们要把这个字符串划分为尽可能多的片段，同一字母最多出现在一个片段中。返回一个表示每个字符串片段的长度的列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：S = &quot;ababcbacadefegdehijhklij&quot;</span><br><span class="line">输出：[9,7,8]</span><br><span class="line">解释：</span><br><span class="line">划分结果为 &quot;ababcbaca&quot;, &quot;defegde&quot;, &quot;hijhklij&quot;。</span><br><span class="line">每个字母最多出现在一个片段中。</span><br><span class="line">像 &quot;ababcbacadefegde&quot;, &quot;hijhklij&quot; 的划分是错误的，因为划分的片段数较少。</span><br></pre></td></tr></table></figure><p>解析：</p><p>遍历字符串，count数组记录每个字符最后一次出现的位置，即出现最远的位置。双指针left和right初始指向0，对于right访问到的字符，更新right为该字符最后一次出现的位置，遍历left到right之间的窗口，如果窗口内的字符最后一次出现的位置更远则更新右端点right。窗口内的字符检查完毕后，计算窗口长度并记录在res中，将left和right更新到right+1的位置，重复以上步骤直到right到达末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">partitionLabels</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">26</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        count[s[i]-<span class="string">&#x27;a&#x27;</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        right = count[s[right] - <span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">        <span class="keyword">int</span> index = left + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (index &lt; right) &#123;</span><br><span class="line">            <span class="keyword">if</span> (count[s[index]-<span class="string">&#x27;a&#x27;</span>] &gt; right) &#123;</span><br><span class="line">                right = count[s[index]-<span class="string">&#x27;a&#x27;</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        right++;</span><br><span class="line">        res.<span class="built_in">push_back</span>(right - left);</span><br><span class="line">        left = right;        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h2><h3 id="连续的子数组和"><a href="#连续的子数组和" class="headerlink" title="连续的子数组和"></a>连续的子数组和</h3><p><a href="https://leetcode.cn/problems/continuous-subarray-sum/">523. 连续的子数组和</a></p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> ，编写一个函数来判断该数组是否含有同时满足下述条件的连续子数组：</p><ul><li>子数组大小 <strong>至少为 2</strong> ，且</li><li>子数组元素总和为 <code>k</code> 的倍数。</li></ul><p>如果存在，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>如果存在一个整数 <code>n</code> ，令整数 <code>x</code> 符合 <code>x = n * k</code> ，则称 <code>x</code> 是 <code>k</code> 的一个倍数。<code>0</code> 始终视为 <code>k</code> 的一个倍数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [23,2,4,6,7], k = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[2,4] 是一个大小为 2 的子数组，并且和为 6 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [23,2,6,4,7], k = 6</span><br><span class="line">输出：true</span><br><span class="line">解释：[23, 2, 6, 4, 7] 是大小为 5 的子数组，并且和为 42 。 </span><br><span class="line">42 是 6 的倍数，因为 42 = 7 * 6 且 7 是一个整数。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [23,2,6,4,7], k = 13</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>解析：</p><p>前缀和+哈希表</p><p>计算前缀和数组元素与k的余数，当更新后的前缀和数组，出现两个元素的值（前缀和余数）相等，计算两个元素的距离如果大于2，表示存在子数组之和为k的整数倍。利用哈希表存储前缀和余数对应的位置索引。注意：哈希表中设置余数为0的下标为-1，方便计算子数组长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSubarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    map[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> remain = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        remain = (nums[i] + remain) % k;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(remain) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> index = map[remain];</span><br><span class="line">            <span class="keyword">if</span> (i - index &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[remain] = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和相同的二元子数组"><a href="#和相同的二元子数组" class="headerlink" title="和相同的二元子数组"></a>和相同的二元子数组</h3><p><a href="https://leetcode.cn/problems/binary-subarrays-with-sum/">930. 和相同的二元子数组</a></p><p>给你一个二元数组<code>nums</code>，和一个整数<code>goal</code>，请你统计并返回有多少个和为<code>goal</code> 的<strong>非空</strong>子数组。</p><p><strong>子数组</strong> 是数组的一段连续部分。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,0,1,0,1], goal = 2</span><br><span class="line">输出：4</span><br><span class="line">解释：</span><br><span class="line">有 4 个满足题目要求的子数组：[1,0,1]、[1,0,1,0]、[0,1,0,1]、[1,0,1]</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [0,0,0,0,0], goal = 0</span><br><span class="line">输出：15</span><br></pre></td></tr></table></figure><p>解析：</p><p>哈希表存储每一种前缀和出现的次数，假设原数组前缀和数组为sum，且子数组(i,j]的区间和为goal，那么sum[j] - sum[i] = goal; 因此可枚举j，查询满足条件的i的数量。假设当前枚举到元素nums[j]，只需要查询哈希表中元素sum[j] - goal的数量即可。最后这些元素的总数量即为所有和为 goal的子数组数量。</p><h3 id="构建回文串检测"><a href="#构建回文串检测" class="headerlink" title="构建回文串检测"></a>构建回文串检测</h3><p><a href="https://leetcode.cn/problems/can-make-palindrome-from-substring/">1177. 构建回文串检测</a></p><p>给你一个字符串 <code>s</code>，请你对 <code>s</code> 的子串进行检测。</p><p>每次检测，待检子串都可以表示为 <code>queries[i] = [left, right, k]</code>。我们可以 <strong>重新排列</strong> 子串 <code>s[left], ..., s[right]</code>，并从中选择 <strong>最多</strong> <code>k</code> 项替换成任何小写英文字母。 </p><p>如果在上述检测过程中，子串可以变成回文形式的字符串，那么检测结果为 <code>true</code>，否则结果为 <code>false</code>。</p><p>返回答案数组 <code>answer[]</code>，其中 <code>answer[i]</code> 是第 <code>i</code> 个待检子串 <code>queries[i]</code> 的检测结果。</p><p>注意：在替换时，子串中的每个字母都必须作为 <strong>独立的</strong> 项进行计数，也就是说，如果 <code>s[left..right] = &quot;aaa&quot;</code> 且 <code>k = 2</code>，我们只能替换其中的两个字母。（另外，任何检测都不会修改原始字符串 <code>s</code>，可以认为每次检测都是独立的）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：s = &quot;abcda&quot;, queries = [[3,3,0],[1,2,0],[0,3,1],[0,3,2],[0,4,1]]</span><br><span class="line">输出：[true,false,false,true,true]</span><br><span class="line">解释：</span><br><span class="line">queries[0] : 子串 = &quot;d&quot;，回文。</span><br><span class="line">queries[1] : 子串 = &quot;bc&quot;，不是回文。</span><br><span class="line">queries[2] : 子串 = &quot;abcd&quot;，只替换 1 个字符是变不成回文串的。</span><br><span class="line">queries[3] : 子串 = &quot;abcd&quot;，可以变成回文的 &quot;abba&quot;。 也可以变成 &quot;baab&quot;，先重新排序变成 &quot;bacd&quot;，然后把 &quot;cd&quot; 替换为 &quot;ab&quot;。</span><br><span class="line">queries[4] : 子串 = &quot;abcda&quot;，可以变成回文的 &quot;abcba&quot;。</span><br></pre></td></tr></table></figure><p>解析：</p><p>前缀和暴力求解：</p><p>记录某一个区间内的字符出现频率，出现奇数次的字母记录下来，根据奇数次字符出现次数再进行操作，使用一个二维数组<code>pre[i][j]</code>来保存字符串s前i个字符中字符’a’+j(0&lt;=j&lt;=26)出现的次数，最后在区间 [l,r] 中可通过<code>pre[r+1][j]-pre[l][j]</code>来得到某个区间内某字符的出现次数。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">canMakePaliQueries</span><span class="params">(string s, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; queries)</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pre</span>(<span class="number">100005</span>, vector&lt;<span class="keyword">int</span>&gt;(<span class="number">26</span>, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pre[i][s[i<span class="number">-1</span>]-<span class="string">&#x27;a&#x27;</span>]++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">26</span>; j++) &#123;</span><br><span class="line">            pre[i][j] += pre[i<span class="number">-1</span>][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> odd = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">bool</span>&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; q : queries) &#123;</span><br><span class="line">        odd = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">26</span>; i++) &#123;</span><br><span class="line">            odd += (pre[q[<span class="number">1</span>]+<span class="number">1</span>][i] - pre[q[<span class="number">0</span>]][i]) % <span class="number">2</span>;</span><br><span class="line">            <span class="comment">// 字符出现奇数次则++</span></span><br><span class="line">        &#125;</span><br><span class="line">        odd /= <span class="number">2</span>;</span><br><span class="line">        res.<span class="built_in">push_back</span>(odd &lt;= q[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最大的幻方"><a href="#最大的幻方" class="headerlink" title="最大的幻方"></a>最大的幻方</h3><p><a href="https://leetcode.cn/problems/largest-magic-square/">1895. 最大的幻方</a></p><p>一个 <code>k x k</code> 的 <strong>幻方</strong> 指的是一个 <code>k x k</code> 填满整数的方格阵，且每一行、每一列以及两条对角线的和 <strong>全部****相等</strong> 。幻方中的整数 <strong>不需要互不相同</strong> 。显然，每个 <code>1 x 1</code> 的方格都是一个幻方。</p><p>给你一个 <code>m x n</code> 的整数矩阵 <code>grid</code> ，请你返回矩阵中 <strong>最大幻方</strong> 的 <strong>尺寸</strong> （即边长 <code>k</code>）。</p><p><strong>示例 1：</strong></p><p><img src="/20220806/magicsquare-grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[7,1,4,5,6],[2,5,1,6,4],[1,5,4,3,2],[1,2,7,3,4]]</span><br><span class="line">输出：3</span><br><span class="line">解释：最大幻方尺寸为 3 。</span><br><span class="line">每一行，每一列以及两条对角线的和都等于 12 。</span><br><span class="line">- 每一行的和：5+1+6 = 5+4+3 = 2+7+3 = 12</span><br><span class="line">- 每一列的和：5+5+2 = 1+4+7 = 6+3+3 = 12</span><br><span class="line">- 对角线的和：5+4+3 = 6+4+2 = 12</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/20220806/magicsquare2-grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：grid = [[5,1,3,1],[9,3,3,1],[1,3,3,8]]</span><br><span class="line">输出：2</span><br></pre></td></tr></table></figure><p>解析：</p><p>枚举正方形+前缀和优化</p><p>按照从大到小的顺序枚举正方形的边长edge，再枚举给定的矩阵grid所有的边长为edge的正方形，并依次判断它们是否满足幻方的要求。可以预处理出矩阵grid每一行与每一列的前缀和，这样每一行或每一列的区间内求和可在O(1)的时间内完成，假设l=min(m, n),egde的范围[1, l]，那么，求和的时间复杂度为O(l)，总时间的复杂度为O(mnl^2)。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">largestMagicSquare</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = grid.<span class="built_in">size</span>(), n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 每一行的前缀和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">rowsum</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        rowsum[i][<span class="number">0</span>] = grid[i][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; n; j++) &#123;</span><br><span class="line">            rowsum[i][j] = rowsum[i][j<span class="number">-1</span>] + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 每一列的前缀和</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">colsum</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">        colsum[<span class="number">0</span>][j] = grid[<span class="number">0</span>][j];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; m; i++) &#123;</span><br><span class="line">            colsum[i][j] = colsum[i<span class="number">-1</span>][j] + grid[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 从大到小枚举正方形边长edge</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> edge = <span class="built_in">min</span>(m, n); edge &gt;= <span class="number">2</span>; edge--) &#123;</span><br><span class="line">        <span class="comment">// 枚举左上角位置（i，j）</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i + edge &lt;= m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j + edge &lt;= n; j++) &#123;</span><br><span class="line">                <span class="comment">// 计算每一行、列、对角线的的值</span></span><br><span class="line">                <span class="keyword">int</span> stdsum = rowsum[i][j+edge<span class="number">-1</span>] - (j ? rowsum[i][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">bool</span> check = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> ii = i+<span class="number">1</span>; ii &lt; i + edge; ii++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = rowsum[ii][j+edge<span class="number">-1</span>] - (j ? rowsum[ii][j<span class="number">-1</span>] : <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (num != stdsum) &#123;</span><br><span class="line">                        check = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!check) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> jj = j; jj &lt; j + edge; jj++) &#123;</span><br><span class="line">                    <span class="keyword">int</span> num = colsum[i+edge<span class="number">-1</span>][jj] - (i ? colsum[i<span class="number">-1</span>][jj] : <span class="number">0</span>);</span><br><span class="line">                    <span class="keyword">if</span> (num != stdsum) &#123;</span><br><span class="line">                        check = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;  </span><br><span class="line">                <span class="keyword">if</span> (!check) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">int</span> d1 = <span class="number">0</span>, d2 = <span class="number">0</span>; <span class="comment">// 两条对角线的和</span></span><br><span class="line">                <span class="comment">// 不使用前缀和，直接遍历求和</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; edge; k++) &#123;</span><br><span class="line">                    d1 += grid[i+k][j+k];</span><br><span class="line">                    d2 += grid[i+k][j+edge-k<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (d1 == stdsum &amp;&amp; d2 == stdsum) &#123;</span><br><span class="line">                    <span class="keyword">return</span> edge;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="和为目标值且不重叠的非空子数组的最大数目"><a href="#和为目标值且不重叠的非空子数组的最大数目" class="headerlink" title="和为目标值且不重叠的非空子数组的最大数目"></a>和为目标值且不重叠的非空子数组的最大数目</h3><p><a href="https://leetcode.cn/problems/maximum-number-of-non-overlapping-subarrays-with-sum-equals-target/">1546. 和为目标值且不重叠的非空子数组的最大数目</a></p><p>给你一个数组 <code>nums</code> 和一个整数 <code>target</code> 。</p><p>请你返回 <strong>非空不重叠</strong> 子数组的最大数目，且每个子数组中数字和都为 <code>target</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,1,1,1], target = 2</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 2 个不重叠子数组（加粗数字表示） [1,1,1,1,1] ，它们的和为目标值 2 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [-1,3,5,1,4,2,-9], target = 6</span><br><span class="line">输出：2</span><br><span class="line">解释：总共有 3 个子数组和为 6 。</span><br><span class="line">([5,1], [4,2], [3,5,1,4,2,-9]) 但只有前 2 个是不重叠的。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [-2,6,6,3,5,4,1,2,8], target = 10</span><br><span class="line">输出：3</span><br><span class="line"></span><br><span class="line">示例 4：</span><br><span class="line">输入：nums = [0,0,0], target = 0</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>解析：</p><p>贪心解法，满足条件的子数组互不重叠，如果其右端点所有满足条件的子数组的右端点中最小的哪一个，则该子数组一定会被选择。从左到右遍历数组，如果发现有某个以当前下标i为右端点的子数组和为target，就给计数器加一，并从nums数组的下标i+1位置开始，进行下一次寻找。</p><p>为了判断是否存在和为target的子数组，在遍历的过程中记录数组的前缀和，并将它们保存在哈希表中。如果位置i对应的前缀和为sum，而sum−target已经存在于哈希表中，就说明找到了一个和为target的子数组。</p><p>如果找到一个符合条件的子数组，下一次遍历过程中需要用一个新的哈希表，而不是使用原有的哈希表，需要确保每次找到的子数组的区间不重合。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxNonOverlapping</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        unordered_set&lt;<span class="keyword">int</span>&gt; s&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span> (s.<span class="built_in">find</span>(sum - target) != s.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                s.<span class="built_in">insert</span>(sum);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        i++;          </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="最高频元素的频数"><a href="#最高频元素的频数" class="headerlink" title="最高频元素的频数"></a>最高频元素的频数</h3><p><a href="https://leetcode.cn/problems/frequency-of-the-most-frequent-element/">1838. 最高频元素的频数</a></p><p>元素的 <strong>频数</strong> 是该元素在一个数组中出现的次数。</p><p>给你一个整数数组 <code>nums</code> 和一个整数 <code>k</code> 。在一步操作中，你可以选择 <code>nums</code> 的一个下标，并将该下标对应元素的值增加 <code>1</code> 。</p><p>执行最多 <code>k</code> 次操作后，返回数组中最高频元素的 <strong>最大可能频数</strong> <em>。</em></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,2,4], k = 5</span><br><span class="line">输出：3</span><br><span class="line">解释：对第一个元素执行 3 次递增操作，对第二个元素执 2 次递增操作，此时 nums = [4,4,4] 。</span><br><span class="line">4 是数组中最高频元素，频数是 3 。</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,4,8,13], k = 5</span><br><span class="line">输出：2</span><br><span class="line">解释：存在多种最优解决方案：</span><br><span class="line">- 对第一个元素执行 3 次递增操作，此时 nums = [4,4,8,13] 。4 是数组中最高频元素，频数是 2 。</span><br><span class="line">- 对第二个元素执行 4 次递增操作，此时 nums = [1,8,8,13] 。8 是数组中最高频元素，频数是 2 。</span><br><span class="line">- 对第三个元素执行 5 次递增操作，此时 nums = [1,4,13,13] 。13 是数组中最高频元素，频数是 2 。</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：nums = [3,9,6], k = 2</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>解析：</p><p>前缀和+二分</p><p>对nums先排序，计算nums对应的前缀和sum。假设右端点为i，区间左侧了l=0，右侧r=i，在区间[l. r]内进行二分，选取合适的mid值，mid=l+(r-l)/2，i固定不变。假设ans=nums[i]*(i-mid+1) - (sum[i]-sum[mid-1]); 假设ans&gt;k; 说明此时该区间不满足条件，需要l=mid+1；假设ans&lt;=k，说明此时该区间满足条件，需要r=mid-1，以求解最优的mid。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; <span class="title">sum</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    sum[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        sum[i] = sum[i - <span class="number">1</span>] + nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = i, res = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] * (<span class="keyword">long</span> <span class="keyword">long</span>)(i - mid + <span class="number">1</span>) - </span><br><span class="line">                (sum[i] - (mid &gt; <span class="number">0</span> ? sum[mid - <span class="number">1</span>] : <span class="number">0</span>)) &lt;= k) &#123;</span><br><span class="line">                res = mid;</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res != <span class="number">-1</span>) ans = <span class="built_in">max</span>(ans, i - res + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优化：滑动窗口</p><p>令左边界l=0，依次遍历右边界r，每次求相邻柱子的阴影距离sum[i]，计算得到的sum与k比较，如果sum&gt;k，则移动左指针l，直到sum&lt;=k。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxFrequency</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> right = <span class="number">1</span>; right &lt; n; right++) &#123;</span><br><span class="line">        sum += (<span class="keyword">long</span> <span class="keyword">long</span>) (nums[right] - nums[right<span class="number">-1</span>]) * (right - left);</span><br><span class="line">        <span class="keyword">while</span> (sum &gt; k) &#123;</span><br><span class="line">            sum -= nums[right] - nums[left++];</span><br><span class="line">        &#125;</span><br><span class="line">        res = <span class="built_in">max</span>(res, right - left + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h2><h3 id="矩阵中的最长递增路径"><a href="#矩阵中的最长递增路径" class="headerlink" title="矩阵中的最长递增路径"></a>矩阵中的最长递增路径</h3><p><a href="https://leetcode.cn/problems/longest-increasing-path-in-a-matrix/">329. 矩阵中的最长递增路径</a></p><p>给定一个 <code>m x n</code> 整数矩阵 <code>matrix</code> ，找出其中 <strong>最长递增路径</strong> 的长度。</p><p>对于每个单元格，你可以往上，下，左，右四个方向移动。 你 <strong>不能</strong> 在 <strong>对角线</strong> 方向上移动或移动到 <strong>边界外</strong>（即不允许环绕）。</p><p><strong>示例 1：</strong></p><p><img src="/20220806/grid1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/20220806/tmp-grid.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[1]]</span><br><span class="line">输出：1</span><br></pre></td></tr></table></figure><p>解析：</p><p>将矩阵看作一个有向图，每个单元格对应图中一个节点，若相邻的两个单元格的节点值不相等，则在相邻的两个单元格之间存在一条从较小值指向较大值的有向边。问题转化为在有向图中寻找最长的路径。如果使用朴素深度优先搜索，时间复杂度是指数级，会超出时间限制，因此必须加以优化。</p><p>优化方法：记忆化搜索。用矩阵memo作为缓存矩阵，已经计算过的单元格的结果存储到缓存矩阵中。当访问到一个单元格（i，j）时，如果<code>memo[i][j] == 0</code>，说明该单元格还未被计算过，进行搜索将计算结果存入缓存；如果<code>memo[i][j] ！= 0</code>，说明该单元格已经计算过，直接从缓存中读取结果。</p><p>遍历完矩阵中的所有单元格之后，即可得到矩阵中的最长递增路径的长度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; dirs = &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; memo;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">    m = matrix.<span class="built_in">size</span>();</span><br><span class="line">    n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    memo = vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;(m, vector&lt;<span class="keyword">int</span>&gt;(n, <span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            res = <span class="built_in">max</span>(res, <span class="built_in">dfs</span>(matrix, i, j));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (memo[r][c] != <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[r][c];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxLen = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = r + dirs[k];</span><br><span class="line">        <span class="keyword">int</span> y = c + dirs[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || matrix[x][y] &lt;= matrix[r][c]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="built_in">dfs</span>(matrix, x, y) + <span class="number">1</span>;</span><br><span class="line">        maxLen = <span class="built_in">max</span>(maxLen, len);</span><br><span class="line">    &#125;</span><br><span class="line">    memo[r][c] = maxLen;</span><br><span class="line">    <span class="keyword">return</span> maxLen;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="岛屿数量"><a href="#岛屿数量" class="headerlink" title="岛屿数量"></a>岛屿数量</h3><p><a href="https://leetcode.cn/problems/number-of-islands/">200. 岛屿数量</a></p><p>给你一个由 <code>&#39;1&#39;</code>（陆地）和 <code>&#39;0&#39;</code>（水）组成的的二维网格，请你计算网格中岛屿的数量。</p><p>岛屿总是被水包围，并且每座岛屿只能由水平方向和/或竖直方向上相邻的陆地连接形成。</p><p>此外，你可以假设该网格的四条边均被水包围。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;]</span><br><span class="line">]</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：grid = [</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;1&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;0&quot;,&quot;0&quot;],</span><br><span class="line">  [&quot;0&quot;,&quot;0&quot;,&quot;0&quot;,&quot;1&quot;,&quot;1&quot;]</span><br><span class="line">]</span><br><span class="line">输出：3</span><br></pre></td></tr></table></figure><p>解析：</p><p>dfs深度优先搜索，将二维网格看成一个无向图，竖直或水平相邻的1之间有边相连。为了求岛屿的数量，扫描二维网格，遇到位置为1的开始进行dfs搜索，再dfs搜索过程中，每个搜到的1都重新标记为0。最终搜索的次数即为岛屿的数量。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; dirs &#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numIslands</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">    m = grid.<span class="built_in">size</span>();</span><br><span class="line">    n = grid[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="string">&#x27;1&#x27;</span>) &#123;</span><br><span class="line">                res++;</span><br><span class="line">                <span class="built_in">dfs</span>(grid, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; grid, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">    grid[r][c] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = r + dirs[k], y = c + dirs[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n || grid[x][y] == <span class="string">&#x27;0&#x27;</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">dfs</span>(grid, x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单词搜索"><a href="#单词搜索" class="headerlink" title="单词搜索"></a>单词搜索</h3><p><a href="https://leetcode.cn/problems/word-search/">79. 单词搜索</a></p><p>给定一个 <code>m x n</code> 二维字符网格 <code>board</code> 和一个字符串单词 <code>word</code> 。如果 <code>word</code> 存在于网格中，返回 <code>true</code> ；否则，返回 <code>false</code> 。</p><p>单词必须按照字母顺序，通过相邻的单元格内的字母构成，其中“相邻”单元格是那些水平相邻或垂直相邻的单元格。同一个单元格内的字母不允许被重复使用。</p><p><strong>示例 1：</strong></p><p><img src="/20220806/word2.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;ABCCED&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/20220806/word-1.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：board = [[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;E&quot;],[&quot;S&quot;,&quot;F&quot;,&quot;C&quot;,&quot;S&quot;],[&quot;A&quot;,&quot;D&quot;,&quot;E&quot;,&quot;E&quot;]], word = &quot;SEE&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>解析：</p><p>dfs回溯，从网格（i，j）位置出发，能否搜索到单词word[index…]，如果可以搜到word末尾，返回true，反之返回false，字符串不匹配之间返回false；遍历当前位置的所有相邻位置，如果可以搜到word[index+1]，则返回true，否则返回false。为了防止重复遍历相同的位置，需要额外维护一个与原数组board大小相同的访问数组visited，标识每个位置是否已经访问过，dfs过程中不走回头路。注意dfs访问结束后将当前位置标志为false回溯。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; dirs&#123;<span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>&#125;;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; visited;</span><br><span class="line"><span class="keyword">int</span> m = <span class="number">0</span>, n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word)</span> </span>&#123;</span><br><span class="line">    m = board.<span class="built_in">size</span>();</span><br><span class="line">    n = board[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (m == <span class="number">0</span> || n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    visited = vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt;(m, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (board[i][j] != word[<span class="number">0</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            flag = <span class="built_in">dfs</span>(board, word, i, j, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, string word, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (board[i][j] != word[index]) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index == word.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> x = i + dirs[k];</span><br><span class="line">        <span class="keyword">int</span> y = j + dirs[k+<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || x &gt;= m || y &lt; <span class="number">0</span> || y &gt;= n) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!visited[x][y]) &#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="built_in">dfs</span>(board, word, x, y, index + <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">if</span> (flag) &#123;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    visited[i][j] = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="回溯"><a href="#回溯" class="headerlink" title="回溯"></a>回溯</h2><h3 id="字母大小写全排列"><a href="#字母大小写全排列" class="headerlink" title="字母大小写全排列"></a>字母大小写全排列</h3><p><a href="https://leetcode.cn/problems/letter-case-permutation/">784. 字母大小写全排列</a></p><p>给定一个字符串 <code>s</code> ，通过将字符串 <code>s</code> 中的每个字母转变大小写，我们可以获得一个新的字符串。</p><p>返回 <em>所有可能得到的字符串集合</em> 。以 <strong>任意顺序</strong> 返回输出。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;a1b2&quot;</span><br><span class="line">输出：[&quot;a1b2&quot;, &quot;a1B2&quot;, &quot;A1b2&quot;, &quot;A1B2&quot;]</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: s = &quot;3z4&quot;</span><br><span class="line">输出: [&quot;3z4&quot;,&quot;3Z4&quot;]</span><br></pre></td></tr></table></figure><p>解析：<br>递归求解，从左至右遍历字符，如果字符为字母，将当前已遍历的字符串全排列复制两份，在第一份字符串末尾添加toupper(s[index]), 在第二份字符串末尾添加tolower(s[index])。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">letterCasePermutation</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    vector&lt;string&gt; ans;</span><br><span class="line">    <span class="built_in">slove</span>(s, ans, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(string s, vector&lt;string&gt;&amp; ans, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(s);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isalpha</span>(s[index])) &#123;</span><br><span class="line">        s[index] = <span class="built_in">toupper</span>(s[index]);</span><br><span class="line">        <span class="built_in">slove</span>(s, ans, index + <span class="number">1</span>);</span><br><span class="line">        s[index] = <span class="built_in">tolower</span>(s[index]);</span><br><span class="line">        <span class="built_in">slove</span>(s, ans, index + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">slove</span>(s, ans, index + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="全排列-II"><a href="#全排列-II" class="headerlink" title="全排列 II"></a>全排列 II</h3><p><a href="https://leetcode.cn/problems/permutations-ii/">47. 全排列 II</a></p><p>给定一个可包含重复数字的序列 <code>nums</code> ，<em><strong>按任意顺序</strong></em> 返回所有不重复的全排列。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br><span class="line"> </span><br><span class="line">示例 2：</span><br><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>解析：</p><p>回溯搜索，序列中包含了重复的数字，要求我们返回不重复的全排列。将这个问题看作有 n 个排列成一行的空格，我们需要从左往右依次填入题目给定的 n 个数，每个数只能使用一次。先对原始数组进行排序，需要一个visited数组记录已经使用过的数，index记录path待填入的位置，如果index==n说明已经填完，找到可行解将path存入res中，递归结束。递归过程中，如果这个数还未使用过，尝试填入继续填下一位置，需要注意的是，数组中存在重复的元素，因此需要先排序，需要保证重复的数字只被填入一次，如果两个相邻的数相同，而且第一个数并未被使用过，则后续相同的数应该跳过循环不填入。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">    visited = vector&lt;<span class="keyword">bool</span>&gt;(nums.<span class="built_in">size</span>(), <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">slove</span>(nums, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slove</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !visited[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="built_in">slove</span>(nums, index + <span class="number">1</span>);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            visited[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="出现次数最多的子树元素和"><a href="#出现次数最多的子树元素和" class="headerlink" title="出现次数最多的子树元素和"></a>出现次数最多的子树元素和</h3><p><a href="https://leetcode.cn/problems/most-frequent-subtree-sum/">508. 出现次数最多的子树元素和</a></p><p>给你一个二叉树的根结点 <code>root</code> ，请返回出现次数最多的子树元素和。如果有多个元素出现的次数相同，返回所有出现次数最多的子树元素和（不限顺序）。</p><p>一个结点的 <strong>「子树元素和」</strong> 定义为以该结点为根的二叉树上所有结点的元素之和（包括结点本身）。</p><p><strong>示例 1：</strong></p><p><img src="/20220806/freq1-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,2,-3]</span><br><span class="line">输出: [2,-3,4]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><img src="/20220806/freq2-tree.jpg" alt="img"></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [5,2,-5]</span><br><span class="line">输出: [2]</span><br></pre></td></tr></table></figure><p>解析：</p><p>从根节点出发dfs遍历，对于每棵子树，其子树元素和等于子树根结点的元素值，加上左子树的元素和，以及右子树的元素和。用哈希表统计每棵子树的元素和的出现次数，计算出现次数的最大值maxCnt，最后将出现次数等于maxCnt的所有元素返回。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; count;</span><br><span class="line"><span class="keyword">int</span> maxCnt = <span class="number">0</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findFrequentTreeSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">sum</span>(root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it : count) &#123;</span><br><span class="line">        <span class="keyword">if</span> (it.second == maxCnt) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(it.first);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">sum</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">sum</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">int</span> res = left + right + root-&gt;val;</span><br><span class="line">    count[res]++;</span><br><span class="line">    maxCnt = <span class="built_in">max</span>(maxCnt, count[res]);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="在每个树行中找最大值"><a href="#在每个树行中找最大值" class="headerlink" title="在每个树行中找最大值"></a>在每个树行中找最大值</h3><p><a href="https://leetcode.cn/problems/find-largest-value-in-each-tree-row/">515. 在每个树行中找最大值</a></p><p>给定一棵二叉树的根节点 <code>root</code> ，请找出该二叉树中每一层的最大值。</p><p><strong>示例1：</strong></p><img src="/posts/1d3d6b4e/largest_e1.jpg" alt="img" style="zoom:50%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,3,2,5,3,null,9]</span><br><span class="line">输出: [1,3,9]</span><br></pre></td></tr></table></figure><p><strong>示例2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: root = [1,2,3]</span><br><span class="line">输出: [1,3]</span><br></pre></td></tr></table></figure><p>解析：</p><p>两种方法：深度优先搜索与广度优先搜索。</p><p>深度优先：用树的「先序遍历」来进行「深度优先搜索」处理，用depth标记遍历到的当前节点的高度，当遍历到depth高度的节点就判断是否更新该层节点的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line">    <span class="built_in">dfs</span>(root, res, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, vector&lt;<span class="keyword">int</span>&gt;&amp; res, <span class="keyword">int</span> depth)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (depth == res.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        res[depth] = <span class="built_in">max</span>(res[depth], root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, res, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, res, depth + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>广度优先：队列中存放的是当前层的所有节点，把当前队列中的全部节点拿出来进行拓展，这样能保证每次拓展完的时候队列里存放的是下一层的所有节点，即我们是一层一层地进行拓展，然后每一层我们用maxVal记录该层节点的最大值。当该层全部节点都处理完后，maxVal就是该层全部节点中的最大值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">largestValues</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> maxVal = INT_MIN;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal, cur-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">push_back</span>(maxVal);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉搜索树中的插入操作"><a href="#二叉搜索树中的插入操作" class="headerlink" title="二叉搜索树中的插入操作"></a>二叉搜索树中的插入操作</h3><p><a href="https://leetcode.cn/problems/insert-into-a-binary-search-tree/">701. 二叉搜索树中的插入操作</a></p><p>给定二叉搜索树（BST）的根节点 <code>root</code> 和要插入树中的值 <code>value</code> ，将值插入二叉搜索树。 返回插入后二叉搜索树的根节点。 输入数据 <strong>保证</strong> ，新值和原始二叉搜索树中的任意节点值都不同。</p><p><strong>注意</strong>，可能存在多种有效的插入方式，只要树在插入后仍保持为二叉搜索树即可。 你可以返回 <strong>任意有效的结果</strong> 。</p><p><strong>示例 1：</strong></p><img src="/posts/1d3d6b4e/insertbst.jpg" alt="img" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br><span class="line">解释：另一个满足题目要求可以通过的树是：</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [40,20,60,10,30,50,70], val = 25</span><br><span class="line">输出：[40,20,60,10,30,50,70,null,null,25]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [4,2,7,1,3,null,null,null,null,null,null], val = 5</span><br><span class="line">输出：[4,2,7,1,3,5]</span><br></pre></td></tr></table></figure><p>解析：</p><p>深度优先搜索，对于任意节点root，左子树的节点值小于root的值，右子树的节点值大于root的值。将val插入到以root为根的子树上，根据val与root-&gt;val的大小关系，确定将val插入到哪个子树中。如果子树不为空，将val插入到对应的子树上；如果子树为空，在此处新建一个以val为值的节点，连接到父节点root上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">insertIntoBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        TreeNode* cur = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &gt; val) &#123;</span><br><span class="line">        root-&gt;left = <span class="built_in">insertIntoBST</span>(root-&gt;left, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; val) &#123;</span><br><span class="line">        root-&gt;right = <span class="built_in">insertIntoBST</span>(root-&gt;right, val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h3><p><a href="https://leetcode.cn/problems/binary-tree-maximum-path-sum/">124. 二叉树中的最大路径和</a></p><p><strong>路径</strong> 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 <strong>至多出现一次</strong> 。该路径 <strong>至少包含一个</strong> 节点，且不一定经过根节点。</p><p><strong>路径和</strong> 是路径中各节点值的总和。</p><p>给你一个二叉树的根节点 <code>root</code> ，返回其 <strong>最大路径和</strong> 。</p><p><strong>示例 1：</strong></p><img src="/posts/1d3d6b4e/exx1.jpg" alt="img" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3]</span><br><span class="line">输出：6</span><br><span class="line">解释：最优路径是 2 -&gt; 1 -&gt; 3 ，路径和为 2 + 1 + 3 = 6</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><img src="/posts/1d3d6b4e/exx2.jpg" alt="img" style="zoom:67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [-10,9,20,null,null,15,7]</span><br><span class="line">输出：42</span><br><span class="line">解释：最优路径是 15 -&gt; 20 -&gt; 7 ，路径和为 15 + 20 + 7 = 42</span><br></pre></td></tr></table></figure><p>解析：</p><p>后序遍历，dfs遍历计算单边的最大路径和，最终的最长路径为根节点+左子树的最长单边路径+右子树的单边最长路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;       </span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ans = INT_MIN;</span><br><span class="line">    <span class="built_in">dfs</span>(root, ans);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义：计算从根节点 root 为起点的最大单边路径和</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span>&amp; ans)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left_sum = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dfs</span>(root-&gt;left, ans));</span><br><span class="line">    <span class="keyword">int</span> right_sum = <span class="built_in">max</span>(<span class="number">0</span>, <span class="built_in">dfs</span>(root-&gt;right, ans));</span><br><span class="line"><span class="comment">// 后序遍历位置，顺便更新最大路径和</span></span><br><span class="line">    <span class="keyword">int</span> path_sum = root-&gt;val + left_sum + right_sum;</span><br><span class="line">    ans = <span class="built_in">max</span>(ans, path_sum);</span><br><span class="line">    <span class="comment">// 实现函数定义，左右子树的最大单边路径和加上根节点的值</span></span><br><span class="line">    <span class="comment">// 就是从根节点 root 为起点的最大单边路径和</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(left_sum, right_sum) + root-&gt;val;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="路径总和-II"><a href="#路径总和-II" class="headerlink" title="路径总和 II"></a>路径总和 II</h3><p><a href="https://leetcode.cn/problems/path-sum-ii/">113. 路径总和 II</a></p><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p><p><strong>叶子节点</strong> 是指没有子节点的节点。</p><p><strong>示例 1：</strong></p><img src="/posts/1d3d6b4e/pathsumii1.jpg" alt="img" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22</span><br><span class="line">输出：[[5,4,11,2],[5,8,4,5]]</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><img src="/posts/1d3d6b4e/pathsum2.jpg" alt="img" style="zoom: 67%;"><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2,3], targetSum = 5</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：root = [1,2], targetSum = 0</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>解析：</p><p>深度优先dfs搜索，对树进行一次遍历，在遍历时记录从根节点到当前节点的路径和，以防止重复计算。当遍历到叶子节点，且此时路径和恰好为目标和，就找到一条可行路径。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">pathSum</span>(TreeNode* root, <span class="keyword">int</span> targetSum) &#123;</span><br><span class="line">    <span class="built_in">dfs</span>(root, targetSum);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    path.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left == <span class="literal">nullptr</span> &amp;&amp; root-&gt;right == <span class="literal">nullptr</span> &amp;&amp; target == root-&gt;val) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;left) <span class="built_in">dfs</span>(root-&gt;left, target - root-&gt;val);</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right) <span class="built_in">dfs</span>(root-&gt;right, target - root-&gt;val);</span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取你好友已观看的视频"><a href="#获取你好友已观看的视频" class="headerlink" title="获取你好友已观看的视频"></a>获取你好友已观看的视频</h3><p><a href="https://leetcode.cn/problems/get-watched-videos-by-your-friends/">1311. 获取你好友已观看的视频</a></p><p>有 <code>n</code> 个人，每个人都有一个 <code>0</code> 到 <code>n-1</code> 的唯一 <em>id</em> 。</p><p>给你数组 <code>watchedVideos</code> 和 <code>friends</code> ，其中 <code>watchedVideos[i]</code> 和 <code>friends[i]</code> 分别表示 <code>id = i</code> 的人观看过的视频列表和他的好友列表。</p><p>Level <strong>1</strong> 的视频包含所有你好友观看过的视频，level <strong>2</strong> 的视频包含所有你好友的好友观看过的视频，以此类推。一般的，Level 为 <strong>k</strong> 的视频包含所有从你出发，最短距离为 <strong>k</strong> 的好友观看过的视频。</p><p>给定你的 <code>id</code> 和一个 <code>level</code> 值，请你找出所有指定 <code>level</code> 的视频，并将它们按观看频率升序返回。如果有频率相同的视频，请将它们按字母顺序从小到大排列。</p><p><strong>示例 1：</strong></p><p><strong><img src="/20220806/leetcode_friends_1.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 1</span><br><span class="line">输出：[&quot;B&quot;,&quot;C&quot;] </span><br><span class="line">解释：</span><br><span class="line">你的 id 为 0（绿色），你的朋友包括（黄色）：</span><br><span class="line">id 为 1 -&gt; watchedVideos = [&quot;C&quot;] </span><br><span class="line">id 为 2 -&gt; watchedVideos = [&quot;B&quot;,&quot;C&quot;] </span><br><span class="line">你朋友观看过视频的频率为：</span><br><span class="line">B -&gt; 1 </span><br><span class="line">C -&gt; 2</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><p><strong><img src="/20220806/leetcode_friends_2.png" alt="img"></strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：watchedVideos = [[&quot;A&quot;,&quot;B&quot;],[&quot;C&quot;],[&quot;B&quot;,&quot;C&quot;],[&quot;D&quot;]], friends = [[1,2],[0,3],[0,3],[1,2]], id = 0, level = 2</span><br><span class="line">输出：[&quot;D&quot;]</span><br><span class="line">解释：</span><br><span class="line">你的 id 为 0（绿色），你朋友的朋友只有一个人，他的 id 为 3（黄色）。</span><br></pre></td></tr></table></figure><p>解析：</p><p>广度优先搜索+set/map应用+排序</p><ul><li>找出所有 Level k 的好友：使用广度优先的方法，从编号为id的节点开始，得到从id到其余所有节点的最短路径，则所有到id的最短路径为k的节点都是level K的好友</li><li>统计好友观看过的视频：哈希表来统计level K的好友观看过的视频，key为视频的名称，value为视频被好友观看过的次数，对于队列中的每个节点x，将watchedVedios[x]中的所有视频依次加入到哈希表中。</li><li>将视频按照要求排序：在统计完成之后，我们将哈希映射中的所有键值对存储进数组中，并将它们按照观看次数为第一关键字、视频名称为第二关键字生序排序，即可得到最终的结果。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;string&gt; <span class="title">watchedVideosByFriends</span><span class="params">(vector&lt;vector&lt;string&gt;&gt;&amp; watchedVideos, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; friends, <span class="keyword">int</span> id, <span class="keyword">int</span> level)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = friends.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(id);</span><br><span class="line">    used[id] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 寻找id的第level级别的好友将其入队</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= level; k++) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> v : friends[u]) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!used[v]) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(v);</span><br><span class="line">                    used[v] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    unordered_map&lt;string, <span class="keyword">int</span>&gt; freq;</span><br><span class="line">    <span class="comment">// 哈希表存储队列中出现的电影名字与其出现次数</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> u = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> string&amp; watched : watchedVideos[u]) &#123;</span><br><span class="line">            freq[watched]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;string, <span class="keyword">int</span>&gt;&gt; <span class="built_in">videos</span>(freq.<span class="built_in">begin</span>(), freq.<span class="built_in">end</span>());</span><br><span class="line">    <span class="comment">// 按照出现次数，影片的名字进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(videos.<span class="built_in">begin</span>(), videos.<span class="built_in">end</span>(), </span><br><span class="line">         [&amp;](<span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; a, <span class="keyword">const</span> pair&lt;string, <span class="keyword">int</span>&gt;&amp; b) &#123;</span><br><span class="line">         <span class="keyword">return</span> a.second &lt; b.second || (a.second == b.second &amp;&amp; a.first &lt; b.first);</span><br><span class="line">    &#125;);</span><br><span class="line">    vector&lt;string&gt; res;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; v : videos) &#123;</span><br><span class="line">        res.<span class="built_in">push_back</span>(v.first);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓补"><a href="#拓补" class="headerlink" title="拓补"></a>拓补</h2><p><a href="https://leetcode.cn/problems/employee-importance/">690. 员工的重要性</a></p><p>给定一个保存员工信息的数据结构，它包含了员工 <strong>唯一的 id</strong> ，<strong>重要度</strong> 和 <strong>直系下属的 id</strong> 。</p><p>比如，员工 1 是员工 2 的领导，员工 2 是员工 3 的领导。他们相应的重要度为 15 , 10 , 5 。那么员工 1 的数据结构是 [1, 15, [2]] ，员工 2的 数据结构是 [2, 10, [3]] ，员工 3 的数据结构是 [3, 5, []] 。注意虽然员工 3 也是员工 1 的一个下属，但是由于 <strong>并不是直系</strong> 下属，因此没有体现在员工 1 的数据结构中。</p><p>现在输入一个公司的所有员工信息，以及单个员工 id ，返回这个员工和他所有下属的重要度之和。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例：</span><br><span class="line"></span><br><span class="line">输入：[[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1</span><br><span class="line">输出：11</span><br><span class="line">解释：</span><br><span class="line">员工 1 自身的重要度是 5 ，他有两个直系下属 2 和 3 ，而且 2 和 3 的重要度均为 3 。因此员工 1 的总重要度是 5 + 3 + 3 = 11 。</span><br></pre></td></tr></table></figure><p>解析：</p><p>由于一个员工最多有一个直系领导，可以有零个或若干个直系下属，因此员工之间的领导和下属关系构成树的结构。给定一个员工编号，要求计算这个员工及其所有下属的重要性之和，即为找到以该员工为根节点的子树的结构中，每个员工的重要性之和。</p><ol><li>深度优先搜索dfs</li></ol><p>根据给定的员工编号找到员工，从该员工开始遍历，对于每个员工，将其重要性加到总和中，然后对该员工的每个直系下属继续遍历，直到所有下属遍历完毕，此时的总和即为给定的员工及其所有下属的重要性之和。实现过程中，每个员工的编号都不相同，利用哈希表存储每个id对应的员工，即可通过编号找到对应的员工。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(vector&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, Employee*&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : employees) &#123;</span><br><span class="line">        map[e-&gt;id] = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">dfs</span>(id, map);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> id, unordered_map&lt;<span class="keyword">int</span>, Employee*&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    Employee* cur = map[id];</span><br><span class="line">    <span class="keyword">int</span> total = cur-&gt;importance;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : cur-&gt;subordinates) &#123;</span><br><span class="line">        total += <span class="built_in">dfs</span>(i, map);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>广度优先搜索bfs</li></ol><p>和深度优先搜索一样，使用哈希表存储每个员工编号和对应的员工，即可通过员工编号得到对应的员工。根据给定的员工编号找到员工，从该员工开始广度优先搜索，对于每个遍历到的员工，将其重要性加到总和中，最终得到的总和即为给定的员工及其所有下属的重要性之和。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(vector&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, Employee*&gt; map;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; e : employees) &#123;</span><br><span class="line">        map[e-&gt;id] = e;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(id);</span><br><span class="line">    <span class="comment">//total += map[id]-&gt;importance;</span></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> cur_id = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        Employee* cur = map[cur_id];</span><br><span class="line">        total += cur-&gt;importance;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; i : cur-&gt;subordinates) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(i);</span><br><span class="line">            <span class="comment">//total += map[i]-&gt;importance;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> total;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><h3 id="基本计算器-II"><a href="#基本计算器-II" class="headerlink" title="基本计算器 II"></a>基本计算器 II</h3><p><a href="https://leetcode.cn/problems/basic-calculator-ii/">227. 基本计算器 II</a></p><p>给你一个字符串表达式 <code>s</code> ，请你实现一个基本计算器来计算并返回它的值。</p><p>整数除法仅保留整数部分。</p><p>你可以假设给定的表达式总是有效的。所有中间结果将在 <code>[-2^31, 2^31 - 1]</code> 的范围内。</p><p><strong>注意：</strong>不允许使用任何将字符串作为数学表达式计算的内置函数，比如 <code>eval()</code> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;3+2*2&quot;</span><br><span class="line">输出：7</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot; 3/2 &quot;</span><br><span class="line">输出：1</span><br><span class="line"></span><br><span class="line">示例 3：</span><br><span class="line">输入：s = &quot; 3+5 / 2 &quot;</span><br><span class="line">输出：5</span><br></pre></td></tr></table></figure><p>解析：</p><p>栈模拟，用一个栈，保存这些（进行乘除运算后的）整数的值。对于加减号后的数字，将其直接压入栈中；对于乘除号后的数字，可以直接与栈顶元素计算，并替换栈顶元素为计算后的结果。遍历字符串s，用变量sign记录每个数字之前的运算符，对于第一个数字，其之前的运算符视为加号，每次遍历到数字末尾时，根据sign确定计算方式，遇到减号则将数字的相反数入栈。代码实现中，若读到一个运算符，或者遍历到字符串末尾，即认为是遍历到了数字末尾。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>, d = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> sign = <span class="string">&#x27;+&#x27;</span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; cal;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isdigit</span>(s[i])) &#123;</span><br><span class="line">            d = d * <span class="number">10</span> + (s[i] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">isdigit</span>(s[i]) &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span> || i == s.<span class="built_in">size</span>() - <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sign == <span class="string">&#x27;+&#x27;</span>) &#123;</span><br><span class="line">                cal.<span class="built_in">push</span>(d);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;-&#x27;</span>) &#123;</span><br><span class="line">                cal.<span class="built_in">push</span>(-d);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;*&#x27;</span>) &#123;</span><br><span class="line">                cal.<span class="built_in">top</span>() *= d;</span><br><span class="line">                <span class="comment">//int tmp = cal.top() * d;</span></span><br><span class="line">                <span class="comment">// cal.pop();</span></span><br><span class="line">                <span class="comment">// cal.push(tmp);</span></span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sign == <span class="string">&#x27;/&#x27;</span>) &#123;</span><br><span class="line">                cal.<span class="built_in">top</span>() /= d;</span><br><span class="line">                <span class="comment">// int tmp = cal.top() / d;</span></span><br><span class="line">                <span class="comment">// cal.pop();</span></span><br><span class="line">                <span class="comment">// cal.push(tmp);</span></span><br><span class="line">            &#125;</span><br><span class="line">            sign = s[i];</span><br><span class="line">            d = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!cal.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        res += cal.<span class="built_in">top</span>();</span><br><span class="line">        cal.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="去除重复字母"><a href="#去除重复字母" class="headerlink" title="去除重复字母"></a>去除重复字母</h3><p><a href="https://leetcode.cn/problems/remove-duplicate-letters/">316. 去除重复字母</a></p><p>给你一个字符串 <code>s</code> ，请你去除字符串中重复的字母，使得每个字母只出现一次。需保证 <strong>返回结果的字典序最小</strong>（要求不能打乱其他字符的相对位置）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例 1：</span><br><span class="line">输入：s = &quot;bcabc&quot;</span><br><span class="line">输出：&quot;abc&quot;</span><br><span class="line"></span><br><span class="line">示例 2：</span><br><span class="line">输入：s = &quot;cbacdcbc&quot;</span><br><span class="line">输出：&quot;acdb&quot;</span><br></pre></td></tr></table></figure><p>​         </p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux多进程编程</title>
      <link href="/posts/38e1db9d/"/>
      <url>/posts/38e1db9d/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="fork系统调用"><a href="#fork系统调用" class="headerlink" title="fork系统调用"></a>fork系统调用</h2><p>fork系统调用：创建新进程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">fork</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">每次调用返回两次，在父进程中返回子进程的PID，在子进程中返回0。</span></span><br><span class="line"><span class="comment">该返回值是判断当前进程是父进程还是子进程的依据。</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>fork函数复制当前进程，在内核进程表中创建一个新的进程表项。新的进程表项有很多属性与原进程相同，比如堆栈指针、标志寄存器的值。不同的属性有：该进程的PPID被设置成原进程的PID，信号位图被清除（原进程设置的信号处理函数不再对新进程起作用）。</p><p>子进程的代码与父进程完全相同，同时会复制父进程的数据（堆数据、栈数据、静态数据）。数据的复制采用<strong>写时复制，读时共享</strong>。只有在任一进程（父进程或子进程）对数据执行了写操作时，复制才会发生（先是缺页中断，然后操作系统给子进程分配内存并复制父进程的数据）</p><p>子进程fork创建后，父进程打开的文件描述符默认在子进程中也是打开的，而且文件描述符的引用计数加一。不仅如此，父进程的用户根目录、当前工作目录等变量的引用计数均会加1。</p><h2 id="exec系列系统调用"><a href="#exec系列系统调用" class="headerlink" title="exec系列系统调用"></a>exec系列系统调用</h2><p>exec系列函数：在子进程中执行其他程序，即替换当前进程映像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">char</span>**environ;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execl</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execlp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execle</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">const</span> <span class="keyword">char</span>*arg,...,<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execv</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execvp</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*file,<span class="keyword">char</span>*<span class="keyword">const</span> argv[])</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execve</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*path,<span class="keyword">char</span>*<span class="keyword">const</span> argv[],<span class="keyword">char</span>*<span class="keyword">const</span> envp[])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">path：指定可执行文件的完整路径</span></span><br><span class="line"><span class="comment">file：接受文件名，该文件的具体位置则在环境变量PATH中搜寻</span></span><br><span class="line"><span class="comment">arg：接受可变参数</span></span><br><span class="line"><span class="comment">argv：接受参数数组，传递给新程序（path或file指定的程序）的main函数</span></span><br><span class="line"><span class="comment">envp：设置新程序的环境变量；未设置则新程序将使用全局变量environ指定的环境变量</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">一般情况下，exec函数是不返回的，除非出错。它出错时返回-1，并设置errno。</span></span><br><span class="line"><span class="comment">如果没出错，则原程序中exec调用之后的代码都不会执行，</span></span><br><span class="line"><span class="comment">因为此时原程序已经被exec的参数指定的程序完全替换（包括代码和数据）。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>exec函数不会关闭原程序打开的文件描述符，除非该文件描述符被设置了类似SOCK_CLOEXEC的属性。</p><h2 id="处理僵尸进程"><a href="#处理僵尸进程" class="headerlink" title="处理僵尸进程"></a>处理僵尸进程</h2><p>子进程处于僵尸态：</p><ul><li>在子进程结束运行之后，父进程读取其退出状态之前，该子进程处于僵尸态。</li><li>父进程结束或者异常终止，而子进程继续运行。此时子进程的PPID将被操作系统设置为1，即init进程。<br>init进程接管了该子进程，并等待它结束。在父进程退出之后，子进程退出之前，该子进程处于僵尸态。</li></ul><p>父进程未正确地处理子进程的返回信息，子进程都会停留在僵尸态，并占据着内核资源。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/wait.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">wait</span><span class="params">(<span class="keyword">int</span>* stat_loc)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：阻塞进程，直到该进程的某个子进程结束运行为止。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">stat_loc：存储子进程的退出状态信息。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回结束运行的子进程的PID。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">waitpid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span>* stat_loc, <span class="keyword">int</span> options)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：只等待pid参数指定的子进程。pid为-1则与wait函数相同，等待任意一个子进程结束。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">pid：进程pid</span></span><br><span class="line"><span class="comment">stat_loc：存储子进程的退出状态信息。</span></span><br><span class="line"><span class="comment">options：控制waitpid函数的行为。常用取值WNOHANG，waitpid调用将是非阻塞的。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">如果pid指定的目标子进程 还没有结束或意外终止，则waitpid立即返回0；</span></span><br><span class="line"><span class="comment">如果目标子进程确实正常退出了，则waitpid返回该子进程的PID。</span></span><br><span class="line"><span class="comment">waitpid调用失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在事件已经发生的情况下执行非阻塞调用才能提高程序的效率。waitpid函数最好在某个子进程退出之后再调用它。</p><p>利用SIGCHLD信号，父进程可以得知某个子进程已经退出。当一个进程结束时，它将给其父进程发送一个SIGCHLD信号。可以在父进程中捕获SIGCHLD信号，并在信号处理函数中调用waitpid函数以“彻底结束”一个子进程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_child</span><span class="params">(<span class="keyword">int</span> sig)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid; </span><br><span class="line">    <span class="keyword">int</span> stat; </span><br><span class="line">    <span class="keyword">while</span>((pid = <span class="built_in">waitpid</span>(<span class="number">-1</span>, ＆stat, WNOHANG)) ＞ <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*对结束的子进程进行善后处理*/</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>父进程与子进程间通信的常用手段：管道。</p><p>管道能在父、子进程间传递数据，利用的是fork调用之后两个管道文件描述符（fd[0]和fd[1]）都保持打开。一对这样的文件描述符只能保证父、子进程间一个方向的数据传输，父进程和子进程必须有一个关闭 fd[0]，另一个关闭fd[1]。</p><p>如果要实现父、子进程之间的双向数据传输，就必须使用两个管道。</p><p>父进程通过管道向子进程写数据：</p><img src="/posts/38e1db9d/image-20220802155324367.png" alt="image-20220802155324367" style="zoom: 67%;"><p>socket编程接口提供了一个创建全双工管道的系统调用：socketpair。</p><p>管道只能用于有关联的两个进程（比如父、子进程）间的通信。System V IPC能用于无关联的多个进程之间的通信，因为它们都使用一个全局唯一的键值来标识一条信道。</p><p>FIFO管道（First In First Out，先进先出），特殊的管道，也能用于无关联进程之间的通信。</p><h2 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h2><p>临界区/关键代码段：程序对共享资源的访问的代码，这段代码引发了进程之间的竞态条件。</p><p>信号量是一种特殊的变量，它只能取自然数值并且只支持两种操作：等待（wait）和信号（signal）。在Linux/UNIX中，“等待”和“信号”都已经具有特殊的含义，所以对信号量的这两种操作更常用的称呼是P、V操作。P：传递，进入临界区；V：释放，退出临界区。假设有信号量SV，则对它的P、V操作含义如下：</p><ul><li>P(SV)，如果SV的值大于0，就将它减1；如果SV的值为0，则挂起进程的执行。</li><li>V(SV)，如果有其他进程因为等待SV而挂起，则唤醒之；如果没有，则将SV加1。</li></ul><p>最常用的、最简单的信号量是二进制信号量，它只能取0和1这两个值。</p><img src="/posts/38e1db9d/image-20220803103612426.png" alt="image-20220803103612426" style="zoom:67%;"><p>当关键代码段可用时，二进制信号量SV的值为1，进程A和B都有机会进入关键代码段。如果此时进程A执行了P(SV)操作将SV减1，则进程B若再执行P(SV)操作就会被挂起。直到进程A离开关键代码段，并执行V(SV)操作将SV加1，关键代码段才重新变得可用。如果此时进程B因为等待SV而处于挂起状态，则它将被唤醒，并进入关键代码段。同样，这时进程A如果再执行P(SV)操作，则也只能被操作系统挂起以等待进程B退出关键代码段。</p><p>Linux信号量的API都定义在sys/sem.h头文件中，主要包含3个系统调用：semget、semop和semctl。</p><h3 id="semget系统调用"><a href="#semget系统调用" class="headerlink" title="semget系统调用"></a>semget系统调用</h3><p>semget系统调用创建一个新的信号量集，或者获取一个已经存在的信号量集。其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> num_sems,<span class="keyword">int</span> sem_flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">key：一个键值，标识一个全局唯一的信号量集。</span></span><br><span class="line"><span class="comment">通过信号量通信的进程需要使用相同的键值来创建/获取该信号量。</span></span><br><span class="line"><span class="comment">    num_sems：指定要创建/获取的信号量集中信号量的数目。</span></span><br><span class="line"><span class="comment">    如果是创建信号量，则该值必须被指定；如果是获取已经存在的信号量，则可以把它设置为0</span></span><br><span class="line"><span class="comment">    sem_flags：指定一组标志。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回一个正整数值，它是信号量集的标识符；失败返回-1.</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="semop系统调用"><a href="#semop系统调用" class="headerlink" title="semop系统调用"></a>semop系统调用</h3><p>semop系统调用改变信号量的值，即执行P、V操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 与每个信号量关联的一些重要的内核变量：</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semval; <span class="comment">/*信号量的值*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semzcnt; <span class="comment">/*等待信号量值变为0的进程数量*/</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">short</span> semncnt; <span class="comment">/*等待信号量值增加的进程数量*/</span></span><br><span class="line"><span class="keyword">pid_t</span> sempid; <span class="comment">/*最后一次执行semop操作的进程ID*/</span></span><br></pre></td></tr></table></figure><p>semop对信号量的操作实际上就是对内核变量的操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semop</span><span class="params">(<span class="keyword">int</span> sem_id,struct sembuf*sem_ops,<span class="keyword">size_t</span> num_sem_ops)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sem_id：由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集。</span></span><br><span class="line"><span class="comment">sem_ops：指向一个sembuf结构体类型的数组。</span></span><br><span class="line"><span class="comment">num_sem_ops：指定要执行的操作个数，即sem_ops数组中元素的个数。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment">失败的时候，sem_ops数组中指定的所有操作都不被执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// sembuf结构体：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span>&#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> sem_num; <span class="comment">// 信号量集中信号量的编号，0表示信号量集中的第一个信号量</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_op; <span class="comment">// 指定操作类型，其可选值为正整数、0和负整数。</span></span><br><span class="line">    <span class="keyword">short</span> <span class="keyword">int</span> sem_flg; <span class="comment">// 标志位。</span></span><br><span class="line">    <span class="comment">// IPC_NOWAIT：无论信号量操作是否成功，semop调用都将立即返回，这类似于非阻塞I/O</span></span><br><span class="line">    <span class="comment">// SEM_UNDO：当进程退出时取消正在进行的semop操作。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="semctl系统调用"><a href="#semctl系统调用" class="headerlink" title="semctl系统调用"></a>semctl系统调用</h3><p>semctl系统调用允许调用者对信号量进行直接控制。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sem.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">semctl</span><span class="params">(<span class="keyword">int</span> sem_id,<span class="keyword">int</span> sem_num,<span class="keyword">int</span> command,...)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sem_id：由semget调用返回的信号量集标识符，用以指定被操作的目标信号量集。</span></span><br><span class="line"><span class="comment">sem_num：指定被操作的信号量在信号量集中的编号。</span></span><br><span class="line"><span class="comment">command：指定要执行的命令。有的命令需要调用者传递第4个参数。</span></span><br><span class="line"><span class="comment">第4个参数的类型由用户自己定义，但sys/sem.h头文件给出了它的推荐格式，</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时的返回值取决于command参数；失败时返回-1，并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="共享内存"><a href="#共享内存" class="headerlink" title="共享内存"></a>共享内存</h2><p>共享内存是最高效的IPC机制，因为它不涉及进程之间的任何数据传输。</p><p>缺点：必须用其他辅助手段来同步进程对共享内存的访问，否则会产生竞态条件。因此，共享内存通常和其他进程间通信方式一起使用。</p><p>Linux共享内存的API都定义在sys/shm.h头文件中，包括4个系统调用：shmget、shmat、shmdt和shmctl。</p><h3 id="shmget系统调用"><a href="#shmget系统调用" class="headerlink" title="shmget系统调用"></a>shmget系统调用</h3><p>shmget系统调用创建一段新的共享内存，或者获取一段已经存在的共享内存。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">size_t</span> size,<span class="keyword">int</span> shmflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">key：一个键值，标识一个全局唯一的共享内存。</span></span><br><span class="line"><span class="comment">size：指定共享内存的大小，单位字节。</span></span><br><span class="line"><span class="comment">创建新的共享内存，size需指定大小；获取已存在的共享内存，size设置为0</span></span><br><span class="line"><span class="comment">shmflg：标志位。</span></span><br><span class="line"><span class="comment">SHM_HUGETLB，类似于mmap的MAP_HUGETLB标志，系统将使用“大页面”来为共享内存分配空间。</span></span><br><span class="line"><span class="comment">SHM_NORESERVE，类似于mmap的MAP_NORESERVE标志，不为共享内存保留交换分区（swap空间）。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回一个正整数值，它是共享内存的标识符。</span></span><br><span class="line"><span class="comment">失败时返回-1，并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="shmat和shmdt系统调用"><a href="#shmat和shmdt系统调用" class="headerlink" title="shmat和shmdt系统调用"></a>shmat和shmdt系统调用</h3><p>共享内存被创建/获取之后，还不能立即访问它，而是需要先将它关联到进程的地址空间中。</p><p>使用完共享内存之后，需要将它从进程地址空间中分离。这两项任务分别由如下两个系统调用实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">shmat</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr,<span class="keyword">int</span> shmflg)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">shm_id：由shmget调用返回的共享内存标识符。</span></span><br><span class="line"><span class="comment">shm_addr：指定将共享内存关联到进程的哪块地址空间。</span></span><br><span class="line"><span class="comment">NULL，则被关联的地址由操作系统选择。（推荐）</span></span><br><span class="line"><span class="comment">非空，并且SHM_RND标志未被设置，则共享内存被关联到addr指定的地址处。</span></span><br><span class="line"><span class="comment">非空，设置了SHM_RND标志，关联地址向下圆整到离shm_addr最近的SHMLBA的整数倍地址处。</span></span><br><span class="line"><span class="comment">shmflg：可选标志。</span></span><br><span class="line"><span class="comment">SHM_RDONLY。进程仅能读取共享内存中的内容。</span></span><br><span class="line"><span class="comment">若没有指定该标志，则进程可同时对共享内存进行读写操作。</span></span><br><span class="line"><span class="comment">SHM_REMAP。如果地址shmaddr已经被关联到一段共享内存上，则重新关联。</span></span><br><span class="line"><span class="comment">SHM_EXEC。它指定对共享内存段的执行权限。执行权限实际上和读权限是一样的。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回共享内存被关联到的地址，失败则返回(void*)-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmdt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>*shm_addr)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：</span></span><br><span class="line"><span class="comment">将关联到shm_addr处的共享内存从进程中分离。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="shmctl系统调用"><a href="#shmctl系统调用" class="headerlink" title="shmctl系统调用"></a>shmctl系统调用</h3><p>shmctl系统调用控制共享内存的某些属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/shm.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shmctl</span><span class="params">(<span class="keyword">int</span> shm_id,<span class="keyword">int</span> command,struct shmid_ds*buf)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">shm_id：是由shmget调用返回的共享内存标识符</span></span><br><span class="line"><span class="comment">command：指定要执行的命令</span></span><br><span class="line"><span class="comment">buf：与之关联的内核数据结构</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时的返回值取决于command参数，失败时返回-1，并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="共享内存的POSIX方法"><a href="#共享内存的POSIX方法" class="headerlink" title="共享内存的POSIX方法"></a>共享内存的POSIX方法</h3><p>mmap函数，利用MAP_ANONYMOUS标志可以实现父、子进程之间的匿名内存共享。通过打开同一个文件，mmap也可以实现无关进程之间的内存共享。Linux提供了另外一种利用mmap在无关进程之间共享内存的方式。这种方式无须任何文件的支持，但它需要先使用如下函数来创建或打开一个POSIX共享内存对象：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/stat.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name,<span class="keyword">int</span> oflag,<span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用：与open系统调用完全相同</span></span><br><span class="line"><span class="comment">name：指定要创建/打开的共享内存对象。</span></span><br><span class="line"><span class="comment">oflag：指定创建方式。一个或多个标志按位与。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回一个文件描述符。该文件描述符可用于后续的mmap调用，从而将共享内存关联到调用进程。</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>和打开的文件最后需要关闭一样，由shm_open创建的共享内存对象使用完之后也需要被删除。这个过程是通过如下函数实现的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/stat.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shm_unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*name)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：将name参数指定的共享内存对象标记为等待删除。</span></span><br><span class="line"><span class="comment">当所有使用该共享内存对象的进程都使用ummap将它从进程中分离之后，</span></span><br><span class="line"><span class="comment">系统将销毁这个共享内存对象所占据的资源。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果代码中使用了上述POSIX共享内存函数，则编译的时候需要指定链接选项-lrt。</p><h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列是在两个进程之间传递二进制块数据的一种简单有效的方式。每个数据块都有一个特定的类型，接收方可以根据类型来有选择地接收数据，而不一定像管道和命名管道那样必须以先进先出的方式接收数据。</p><p>Linux消息队列的API都定义在sys/msg.h头文件中，包括4个系统调用：msgget、msgsnd、msgrcv和msgctl。</p><h3 id="msgget系统调用"><a href="#msgget系统调用" class="headerlink" title="msgget系统调用"></a>msgget系统调用</h3><p>msgget系统调用创建一个消息队列，或者获取一个已有的消息队列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgget</span><span class="params">(<span class="keyword">key_t</span> key,<span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">key：一个键值，用来标识一个全局唯一的消息队列。</span></span><br><span class="line"><span class="comment">msgflg：与semget系统调用的sem_flags参数相同。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回一个正整数值，它是消息队列的标识符。</span></span><br><span class="line"><span class="comment">失败时返回-1，并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果msgget用于创建消息队列，则与之关联的内核数据结构msqid_ds将被创建并初始化。</p><h3 id="msgsnd系统调用"><a href="#msgsnd系统调用" class="headerlink" title="msgsnd系统调用"></a>msgsnd系统调用</h3><p>msgsnd系统调用把一条消息添加到消息队列中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgsnd</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">const</span> <span class="keyword">void</span>*msg_ptr,<span class="keyword">size_t</span> msg_sz,<span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">msqid：由msgget调用返回的消息队列标识符。</span></span><br><span class="line"><span class="comment">msg_ptr：指向一个准备发送的消息。</span></span><br><span class="line"><span class="comment">msg_sz：消息的数据部分（mtext）的长度。这个长度可以为0，表示没有消息数据。</span></span><br><span class="line"><span class="comment">msgflg：控制msgsnd的行为。通常仅支持IPC_NOWAIT标志，即以非阻塞的方式发送消息。</span></span><br><span class="line"><span class="comment">默认情况下，发送消息时如果消息队列满了，则msgsnd将阻塞。</span></span><br><span class="line"><span class="comment">若IPC_NOWAIT标志被指定，则msgsnd将立即返回并设置errno为EAGAIN。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 消息定义类型</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msgbuf</span> &#123;</span></span><br><span class="line"><span class="keyword">long</span> mtype;<span class="comment">/*消息类型*/</span> </span><br><span class="line">    <span class="keyword">char</span> mtext[<span class="number">512</span>];<span class="comment">/*消息数据*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="msgrcv系统调用"><a href="#msgrcv系统调用" class="headerlink" title="msgrcv系统调用"></a>msgrcv系统调用</h3><p>msgrcv系统调用从消息队列中获取消息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg·h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgrcv</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">void</span>*msg_ptr,<span class="keyword">size_t</span> msg_sz,<span class="keyword">long</span> <span class="keyword">int</span> msgtype,<span class="keyword">int</span> msgflg)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">msqid：由msgget调用返回的消息队列标识符。</span></span><br><span class="line"><span class="comment">msg_ptr：用于存储接收的消息。</span></span><br><span class="line"><span class="comment">msg_sz：消息数据部分的长度。</span></span><br><span class="line"><span class="comment">msgtype：指定接收何种类型的消息。</span></span><br><span class="line"><span class="comment">等于0。读取消息队列中的第一个消息。</span></span><br><span class="line"><span class="comment">大于0。读取消息队列中第一个类型为msgtype的消息。</span></span><br><span class="line"><span class="comment">小于0。读取消息队列中第一个类型值比msgtype的绝对值小的消息。</span></span><br><span class="line"><span class="comment">msgflg：控制msgrcv函数的行为。</span></span><br><span class="line"><span class="comment">IPC_NOWAIT。如果消息队列中没有消息，则msgrcv调用立即返回并设置errno为ENOMSG。 MSG_EXCEPT。如果msgtype大于0，则接收消息队列中第一个非msgtype类型的消息。 MSG_NOERROR。如果消息数据部分的长度超过了msg_sz，就将它截断。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="msgctl系统调用"><a href="#msgctl系统调用" class="headerlink" title="msgctl系统调用"></a>msgctl系统调用</h3><p>msgctl系统调用控制消息队列的某些属性。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/msg.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">msgctl</span><span class="params">(<span class="keyword">int</span> msqid,<span class="keyword">int</span> command,struct msqid_ds*buf)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">msqid：由msgget调用返回的消息队列标识符。</span></span><br><span class="line"><span class="comment">command：指定要执行的命令。</span></span><br><span class="line"><span class="comment">buf：指向内核数据结构msqid_ds</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时的返回值取决于command参数。</span></span><br><span class="line"><span class="comment">失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="IPC命令"><a href="#IPC命令" class="headerlink" title="IPC命令"></a>IPC命令</h2><p>信号量、共享内存、消息队列，这三种System V IPC进程间通信方式都使用一个全局唯一的键值（key）来描述一个共享资源。当程序调用semget、shmget或者msgget时，就创建了这些共享资源的一个实例。</p><p>Linux提供了ipcs命令，以观察当前系统上拥有哪些共享资源实例。</p><p>可以使用ipcrm命令来删除遗留在系统中的共享资源。</p><h2 id="在进程间传递文件描述符"><a href="#在进程间传递文件描述符" class="headerlink" title="在进程间传递文件描述符"></a>在进程间传递文件描述符</h2><p>由于fork调用之后，父进程中打开的文件描述符在子进程中仍然保持打开，所以文件描述符可以很方便地从父进程传递到子进程。传递一个文件描述符并不是传递一个文件描述符的值，而是要在接收进程中创建一个新的文件描述符，并且该文件描述符和发送进程中被传递的文件描述符指向内核中相同的文件表项。</p><p>如何把子进程中打开的文件描述符传递给父进程，或者说，如何在两个不相干的进程之间传递文件描述符，可以利用UNIX域socket在进程间传递特殊的辅助数据，以实现文件描述符的传递。</p><p>在进程间传递文件描述符：子进程中打开一个文件描述符，然后将它传递给父进程，父进程则通过读取该文件描述符来获得文件的内容。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 13-5passfd.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">int</span> CONTROL_LEN = <span class="built_in">CMSG_LEN</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 发送文件描述符，fd为传递信息的UNIX域socket，fd_to_send为待发送的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">send_fd</span><span class="params">( <span class="keyword">int</span> fd, <span class="keyword">int</span> fd_to_send )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name    = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_iov     = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cmsghdr cm;</span><br><span class="line">    cm.cmsg_len = CONTROL_LEN;</span><br><span class="line">    cm.cmsg_level = SOL_SOCKET;</span><br><span class="line">    cm.cmsg_type = SCM_RIGHTS;</span><br><span class="line">    *(<span class="keyword">int</span> *)<span class="built_in">CMSG_DATA</span>( &amp;cm ) = fd_to_send;</span><br><span class="line">    msg.msg_control = &amp;cm; <span class="comment">// 设置辅助数据</span></span><br><span class="line">    msg.msg_controllen = CONTROL_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sendmsg</span>( fd, &amp;msg, <span class="number">0</span> );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接收目标文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">recv_fd</span><span class="params">( <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iov</span>[1];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> <span class="title">msg</span>;</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    iov[<span class="number">0</span>].iov_base = buf;</span><br><span class="line">    iov[<span class="number">0</span>].iov_len = <span class="number">1</span>;</span><br><span class="line">    msg.msg_name    = <span class="literal">NULL</span>;</span><br><span class="line">    msg.msg_namelen = <span class="number">0</span>;</span><br><span class="line">    msg.msg_iov     = iov;</span><br><span class="line">    msg.msg_iovlen = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    cmsghdr cm;</span><br><span class="line">    msg.msg_control = &amp;cm;</span><br><span class="line">    msg.msg_controllen = CONTROL_LEN;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">recvmsg</span>( fd, &amp;msg, <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> fd_to_read = *(<span class="keyword">int</span> *)<span class="built_in">CMSG_DATA</span>( &amp;cm );</span><br><span class="line">    <span class="keyword">return</span> fd_to_read;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">    <span class="keyword">int</span> fd_to_pass = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建父、子进程之间的管道，文件描述符pipefd[0]和pipefd[1]都是UNIX域socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">socketpair</span>( PF_UNIX, SOCK_DGRAM, <span class="number">0</span>, pipefd );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="built_in">assert</span>( pid &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( pid == <span class="number">0</span> ) <span class="comment">// 子进程</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">close</span>( pipefd[<span class="number">0</span>] );</span><br><span class="line">        fd_to_pass = <span class="built_in">open</span>( <span class="string">&quot;test.txt&quot;</span>, O_RDWR, <span class="number">0666</span> );</span><br><span class="line">        <span class="comment">// 子进程通过管道将文件描述符发送到父进程。</span></span><br><span class="line">        <span class="comment">// 如果文件test.txt打开失败，则子进程将标准输入文件描述符发送到父进程</span></span><br><span class="line">        <span class="built_in">send_fd</span>( pipefd[<span class="number">1</span>], ( fd_to_pass &gt; <span class="number">0</span> ) ? fd_to_pass : <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">close</span>( fd_to_pass );</span><br><span class="line">        <span class="built_in">exit</span>( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( pipefd[<span class="number">1</span>] );</span><br><span class="line">    fd_to_pass = <span class="built_in">recv_fd</span>( pipefd[<span class="number">0</span>] ); <span class="comment">// 父进程从管道接收目标文件描述</span></span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">    <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, <span class="number">1024</span> );</span><br><span class="line">    <span class="built_in">read</span>( fd_to_pass, buf, <span class="number">1024</span> ); <span class="comment">// 读目标文件描述符，以验证其有效性</span></span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;I got fd %d and data %s\n&quot;</span>, fd_to_pass, buf );</span><br><span class="line">    <span class="built_in">close</span>( fd_to_pass );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>I/O复用</title>
      <link href="/posts/bbbdabf8/"/>
      <url>/posts/bbbdabf8/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>I/O复用使得程序能同时监听多个文件描述符，使用I/O复用的情况：</p><ul><li>客户端程序要同时处理多个socket。</li><li>客户端程序要同时处理用户输入和网络连接。</li><li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使用最多的场合。</li><li>服务器要同时处理TCP请求和UDP请求。</li><li>服务器要同时监听多个端口，或者处理多种服务。</li></ul><p>I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。</p><p>Linux下实现I/O复用的系统调用主要有<strong>select、poll和epoll</strong></p><h2 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a>select系统调用</h2><p>select系统调用：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p><h3 id="select-API"><a href="#select-API" class="headerlink" title="select API"></a>select API</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">nfds：指定被监听的文件描述符总数。通常被设置为select监听的所有文件描述符中的最大值加1。</span></span><br><span class="line"><span class="comment">readfds：指向可读事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">writefds：指向可写事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">exceptfds：指向异常事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">timeout：设置select函数的超时时间，指针类型可以内核将修改它以告诉应用程序select等待了多久。</span></span><br><span class="line"><span class="comment">如果给timeout变量的tv_sec成员和tv_usec成员都传递0，则select将立即返回。</span></span><br><span class="line"><span class="comment">如果给timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回就绪（可读、可写和异常）文件描述符的总数；</span></span><br><span class="line"><span class="comment">如果在超时时间内没有任何文件描述符就绪，select将返回0；</span></span><br><span class="line"><span class="comment">select失败时返回-1并设置errno；</span></span><br><span class="line"><span class="comment">如果在select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeval结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;<span class="comment">/*秒数*/</span> </span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">/*微秒数*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h3><p>socket可读的情况：</p><ul><li>socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</li><li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li><li>监听socket上有新的连接请求。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。 </li></ul><p>socket可写的情况：</p><ul><li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</li><li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</li><li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</li></ul><p>socket异常情况：</p><ul><li>socket上接收到带外数据。</li></ul><h3 id="处理带外数据"><a href="#处理带外数据" class="headerlink" title="处理带外数据"></a>处理带外数据</h3><p>socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。</p><p>同时接收普通数据和带外数据:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9-1use_select.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;ip is %s and port is %d\n&quot;</span>, ip, port );</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">        <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">        address.sin_family = AF_INET;</span><br><span class="line">        <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">        address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line"><span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line"><span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line"><span class="built_in">close</span>( listenfd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> remote_addr[INET_ADDRSTRLEN];</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>( AF_INET, &amp;client_address.sin_addr, remote_addr, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client_address.sin_port ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        fd_set read_fds;</span><br><span class="line">        fd_set exception_fds;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FD_ZERO</span>( &amp;read_fds );</span><br><span class="line">        <span class="built_in">FD_ZERO</span>( &amp;exception_fds );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nReuseAddr = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>( connfd, SOL_SOCKET, SO_OOBINLINE, &amp;nReuseAddr, <span class="built_in"><span class="keyword">sizeof</span></span>( nReuseAddr ) );</span><br><span class="line"><span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，</span></span><br><span class="line">        <span class="comment">// 因为事件发生之后，文件描述符集合将被内核修改</span></span><br><span class="line"><span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>( buf ) );</span><br><span class="line"><span class="built_in">FD_SET</span>( connfd, &amp;read_fds );</span><br><span class="line"><span class="built_in">FD_SET</span>( connfd, &amp;exception_fds );</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">select</span>( connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span> );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;select one\n&quot;</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;selection failure\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">FD_ISSET</span>( connfd, &amp;read_fds ) )</span><br><span class="line">&#123; <span class="comment">// 对于可读事件，采用普通的recv函数读取数据</span></span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>( buf )<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of normal data: %s\n&quot;</span>, ret, buf );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="built_in">FD_ISSET</span>( connfd, &amp;exception_fds ) )</span><br><span class="line">        &#123; <span class="comment">// 对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据</span></span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>( buf )<span class="number">-1</span>, MSG_OOB );</span><br><span class="line"><span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of oob data: %s\n&quot;</span>, ret, buf );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>( connfd );</span><br><span class="line"><span class="built_in">close</span>( listenfd );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll系统调用"><a href="#poll系统调用" class="headerlink" title="poll系统调用"></a>poll系统调用</h2><p>poll系统调用：在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜poll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fds：pollfd结构类型的数组，它指定所有感兴趣的文件描述符上发生的可读、可写和异常等事件。</span></span><br><span class="line"><span class="comment">nfds：指定被监听事件集合fds的大小，无符号长整数unsigned long int</span></span><br><span class="line"><span class="comment">timeout：指定poll的超时值，单位是毫秒；</span></span><br><span class="line"><span class="comment">timeout为-1，poll调用将永远阻塞，直到某个事件发生；</span></span><br><span class="line"><span class="comment">timeout为0，poll调用将立即返回。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回值的含义与select相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span> </span><br><span class="line">    <span class="keyword">short</span> events;<span class="comment">/*注册的事件，告诉poll监听fd上的哪些事件，一系列事件的按位或*/</span></span><br><span class="line">    <span class="keyword">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>poll支持的事件类型：</p><img src="/posts/bbbdabf8/image-20220728115950782.png" alt="image-20220728115950782" style="zoom: 80%;"><h2 id="epoll系列系统调用"><a href="#epoll系列系统调用" class="headerlink" title="epoll系列系统调用"></a>epoll系列系统调用</h2><h3 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h3><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。</p><ul><li>epoll使用一组函数来完成任务，而不是单个函数。</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。</li><li>需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</li></ul><p>创建epoll一个额外的文件描述符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">size：现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回一个文件描述符，将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>操作epoll的内核事件表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">epfd：epoll_create返回的文件描述符，指定要访问的内核事件表</span></span><br><span class="line"><span class="comment">fd：要操作的文件描述符</span></span><br><span class="line"><span class="comment">op：指定操作类型。</span></span><br><span class="line"><span class="comment">EPOLL_CTL_ADD，往事件表中注册fd上的事件。</span></span><br><span class="line"><span class="comment">EPOLL_CTL_MOD，修改fd上的注册事件。</span></span><br><span class="line"><span class="comment">EPOLL_CTL_DEL，删除fd上的注册事件。</span></span><br><span class="line"><span class="comment">event：指定事件，epoll_event结构指针类型</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;<span class="comment">/*epoll事件*/</span> </span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;<span class="comment">/*用户数据*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">epfd：epoll_create返回的文件描述符，指定要访问的内核事件表</span></span><br><span class="line"><span class="comment">events：指定事件，epoll_event结构指针类型</span></span><br><span class="line"><span class="comment">maxevents：指定最多监听多少个事件，它必须大于0。</span></span><br><span class="line"><span class="comment">timeout：指定超时值，单位是毫秒；</span></span><br><span class="line"><span class="comment">timeout为-1，调用将永远阻塞，直到某个事件发生；</span></span><br><span class="line"><span class="comment">timeout为0，调用将立即返回。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。这个数组只用于<strong>输出epoll_wait检测到的就绪事件</strong>，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。</p><p>poll和epoll在使用上的差别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何索引poll返回的就绪文件描述符*/</span> </span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">poll</span>(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>); </span><br><span class="line"><span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i ＜ MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fds[i].revents＆POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd=fds[i].fd; </span><br><span class="line">        <span class="comment">/*处理sockfd*/</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如何索引epoll返回的就绪文件描述符*/</span> </span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*仅遍历就绪的ret个文件描述符*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i ＜ ret; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = events[i].data.fd; </span><br><span class="line">    <span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h3><p>epoll对文件描述符的操作有两种模式：</p><ul><li>LT（Level Trigger，电平触发）模式。epoll的默认的工作模式，epoll相当于一个效率较高的poll。</li><li>ET（Edge Trigger，边沿触发）模式。epoll的高效工作模式，当epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。</li></ul><p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</p><p>对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</p><p><strong>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。</strong></p><p>LT和ET在工作方式上的差异：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9-3mtlt.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符设置成非阻塞的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中</span></span><br><span class="line"><span class="comment">// 参数 enable_et指定是否对fd启用ET模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>( enable_et )</span><br><span class="line">    &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LT模式的工作流程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">( epoll_event* events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> ( sockfd == listenfd )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">            <span class="built_in">addfd</span>( epollfd, connfd, <span class="literal">false</span> ); <span class="comment">// 调用addfd函数，对connfd禁用ET模式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;<span class="comment">// 只要socket读缓存中还有未读出的数据，这段代码就被触发</span></span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;event trigger once\n&quot;</span> );</span><br><span class="line">            <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">close</span>( sockfd );</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;something else happened \n&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ET模式的工作流程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">( epoll_event* events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> ( sockfd == listenfd )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">            <span class="built_in">addfd</span>( epollfd, connfd, <span class="literal">true</span> ); <span class="comment">// 对connfd开启ET模式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;<span class="comment">// 这段代码不会被重复触发，所以循环读取数据，以确保把socket读缓存中的所有数据读出</span></span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;event trigger once\n&quot;</span> );</span><br><span class="line">            <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">                <span class="keyword">int</span> ret = <span class="built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">if</span>( ret &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;<span class="comment">// 对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。</span></span><br><span class="line">                    <span class="comment">// 此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line">                    <span class="keyword">if</span>( ( errno == EAGAIN ) || ( errno == EWOULDBLOCK ) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>( <span class="string">&quot;read later\n&quot;</span> );</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>( sockfd );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>( sockfd );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;something else happened \n&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="keyword">int</span> epollfd = <span class="built_in">epoll_create</span>( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( epollfd != <span class="number">-1</span> );</span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, listenfd, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">lt</span>( events, ret, epollfd, listenfd ); <span class="comment">// 使用LT模式</span></span><br><span class="line">        <span class="comment">//et( events, ret, epollfd, listenfd ); // 使用ET模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( listenfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器程序运行该代码，然后telnet到这个服务器程序上并一次传输超过10字节（BUFFER_SIZE的大小）的数据，会发现ET模式下事件被触发的次数要比LT模式下少很多。</p><p>注意：每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。</p><h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>并发程序中，一个线程（或进程），在读取完某个socket上的数据数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。</p><p>EPOLLONESHOT事件：使得一个socket连接在任一时刻都只被一个线程处理。</p><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。</p><p>注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的 EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p><p>EPOLLONESHOT事件的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9-4oneshot.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放内核事件表fd和socket连接fd</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> epollfd;</span><br><span class="line">   <span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将socket连接fd设置为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中 </span></span><br><span class="line"><span class="comment">// 参数oneshot指定是否注册fd上的EPOLLONESHOT事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="keyword">if</span>( oneshot )</span><br><span class="line">    &#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，</span></span><br><span class="line"><span class="comment">// 但是操作系统仍然会触发fd上的EPOLLIN事件，且只触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = ( (fds*)arg )-&gt;sockfd;</span><br><span class="line">    <span class="keyword">int</span> epollfd = ( (fds*)arg )-&gt;epollfd;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, sockfd );</span><br><span class="line">    <span class="keyword">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环读取sockfd上的数据，直到遇到EAGAIN错误</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>( sockfd );</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;foreiner closed the connection\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( errno == EAGAIN )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reset_oneshot</span>( epollfd, sockfd );</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;read later\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;get content: %s\n&quot;</span>, buf );</span><br><span class="line">            <span class="built_in">sleep</span>( <span class="number">5</span> ); <span class="comment">// 休眠5s。模拟数据处理过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;end thread receiving data on fd: %d\n&quot;</span>, sockfd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="keyword">int</span> epollfd = <span class="built_in">epoll_create</span>( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( epollfd != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">// 注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序只能处理一个客户连接</span></span><br><span class="line">    <span class="comment">// 因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span></span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, listenfd, <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> ( sockfd == listenfd )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line">                <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">                <span class="comment">// 对每个非监听文件描述符都注册POLLONESHOT事件</span></span><br><span class="line">                <span class="built_in">addfd</span>( epollfd, connfd, <span class="literal">true</span> ); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">pthread_t</span> thread;</span><br><span class="line">                fds fds_for_new_worker;</span><br><span class="line">                fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">                fds_for_new_worker.sockfd = sockfd;</span><br><span class="line">                <span class="comment">// 新启动一个工作线程为sockfd服务</span></span><br><span class="line">                <span class="built_in">pthread_create</span>( &amp;thread, <span class="literal">NULL</span>, worker, ( <span class="keyword">void</span>* )&amp;fds_for_new_worker );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;something else happened \n&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( listenfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程函数worker中，如果一个工作线程处理完某个socket上的一次请求（用休眠5s来模拟这个过程）之后，又接收到该socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该 socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个socket，如果工作线程等待5s后仍然没收到该socket上的下一批客户数据，则它将放弃为该socket服务。同时，它调用reset_oneshot函数来重置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p><p>尽管一个socket在不同时间可能被不同的线程处理，但同一时刻肯定只有一个线程在为它服务。这就保证了连接的完整性，从而避免了很多可能的竞态条件。</p><h2 id="三组I-O复用函数的比较"><a href="#三组I-O复用函数的比较" class="headerlink" title="三组I/O复用函数的比较"></a>三组I/O复用函数的比较</h2><p>select、poll、epoll三组I/O复用系统调用。</p><p>这三组系统调用都能同时监听多个文件描述符，等待由timeout参数指定的超时时间，直到一个或者多个文件描述符上有事件发生时返回，返回值是就绪的文件描述符的数量。返回0表示没有事件发生。</p><p>select特点：select的参数类型fd_set没有将文件描述符和事件绑定，它仅仅是一个文件描述符集合，因此select需要提供3个这种类型的参数来分别传入和输出可读、可写及异常等事件。因此，select不能处理更多类型的事件，另一方面由于内核对fd_set集合的在线修改，应用程序下次调用select前不得不重置这3个fd_set集合。</p><p>poll特点：把文件描述符和事件都定义其中，任何事件都被统一处 理，从而使得编程接口简洁得多。并且内核每次修改的是pollfd结构体的revents成员，而events成员保持不变，因此下次调用poll时应用程序无须重置pollfd类型的事件集参数。</p><p>select和poll的时间复杂度：由于每次<strong>select和poll调用都返回整个用户注册的事件集合（其中包括就绪的和未就绪的）</strong>，所以应用程序索引就绪文件描述符的时间复杂度为O（n）。</p><p>epoll特点：在内核中维护一个事件表，并提供了一个独立的系统调用epoll_ctl来控制往其中添加、删除、修改事件。这样，<strong>每次epoll_wait调用都直接从该内核事件表中取得用户注册的事件，而无须反复从用户空间读入这些事件</strong>。</p><p>epoll的时间复杂度：epoll_wait系统调用的events参数仅用来返回就绪的事件，这使得应用程序索引就绪文件描述符的时间复杂度达到O（1）。</p><p>最大文件描述符数量：poll和epoll_wait分别用nfds和maxevents参数指定最多监听多少个文件描述符和事件。这两个数值都能达到系统允许打开的最大文件描述符数目，即65535<br>（cat/proc/sys/fs/file-max）。select允许监听的最大文件描述符数量通常有限制。虽然用户可以修改这个限制，但这可能导致不可预期的后果。</p><p>工作模式：select和poll都只能工作在相对低效的LT模式，而epoll则可以工作在ET高效模式。并且epoll还支持EPOLLONESHOT事件。该事件能进一步减少可读、可写和异常等事件被触发的次数。</p><p>实现原理：<strong>select和poll采用的都是轮询的方式</strong>，即每次调用都要扫描整个注册文件描述符集合，并将其中就绪的文件描述符返回给用户程序，因此它们检测就绪事件的算法的时间复杂度是O（n）。<br><strong>epoll_wait则不同，它采用的是回调的方式。</strong>内核检测到就绪的文件描 述符时，将触发回调函数，回调函数就将该文件描述符上对应的事件插入内核就绪事件队列。内核最后在适当的时机将该就绪事件队列中的内容拷贝到用户空间。因此epoll_wait无须轮询整个文件描述符集合来检测哪些事件已经就绪，其算法时间复杂度是O（1）。</p><p>epoll_wait适用于连接数量多，但活动连接较少的情况。</p><p>select、poll和epoll的区别：</p><table><thead><tr><th align="center"><span style="display:inline-block;width:100px">系统调用</span></th><th align="center"><span style="display:inline-block;width:240px">select</span></th><th align="center"><span style="display:inline-block;width:240px">poll</span></th><th align="center"><span style="display:inline-block;width:240px">epoll</span></th></tr></thead><tbody><tr><td align="center">事件集合</td><td align="center">用户通过3个参数来分别传入感兴趣的可读、可写及异常等事件，内核通过对这些参数的在线修改来反馈其中的就绪事件。这使得用户每次调用select都要重置这3个参数。</td><td align="center">统一处理所有事件类型，因此只需要一个事件集参数。用户通过pollfd.events传入感兴趣的事件，内核通过修改pollfd.revents反馈其中就绪的事件。</td><td align="center">内核通过一个事件表直接管理用户感兴趣的所有事件。因此每次调用epoll_wait时，无须反复传入用户感兴趣的事件。epoll_wait系统调用的参数events仅用来反馈就绪的事件。</td></tr><tr><td align="center">应用程序索引就绪文件描述符的时间复杂度</td><td align="center">O(n)</td><td align="center">O(n)</td><td align="center">O(1)</td></tr><tr><td align="center">最大支持文件描述符数</td><td align="center">一般有最大值限制</td><td align="center">65535</td><td align="center">65535</td></tr><tr><td align="center">工作模式</td><td align="center">LT</td><td align="center">LT</td><td align="center">ET</td></tr><tr><td align="center">内核实现和工作效率</td><td align="center">采用轮询方式来检测就绪事件，算法时间复杂度为O(n)</td><td align="center">采用轮询方式来检测就绪事件，算法时间复杂度为O(n)</td><td align="center">采用回调方式来检测就绪事件，算法时间复杂度为O(1)</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器程序框架</title>
      <link href="/posts/81ce2909/"/>
      <url>/posts/81ce2909/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>按照服务器程序的一般原理，将服务器解构为如下三个主要模块：</p><ul><li>I/O处理单元。四种I/O模型和两种高效事件处理模式。</li><li>逻辑单元。两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</li><li>存储单元。服务器程序的可选模块。</li></ul><h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><h3 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h3><p>C/S（客户端/服务器）模型：所有客户端都通过访问服务器来获取所需的资源。</p><img src="/posts/81ce2909/image-20220726231329183.png" alt="image-20220726231329183" style="zoom:50%;"><p>采用C/S模型的TCP服务器和TCP客户端的工作流程：</p><img src="/posts/81ce2909/image-20220726231424223.png" alt="image-20220726231424223" style="zoom:75%;"><p>服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。<br>服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。这里服务器使用的是I/O复用技术之一的select系统调用。<br>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或者其他。服务器给客户端分配的逻辑单元是由fork系统调用创建的子进 程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。<br>客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。至此，双方的通信结束。</p><p>注意：服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了（必须先处理完前一个客户的请求，才能继续处理下一个客户请求）。这里服务器同时监听多个客户请求是通过select系统调用实现的。</p><p>优点：非常适合资源相对集中的场合，实现简单。</p><p>缺点：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。</p><h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>P2P（Peer to Peer，点对点）模型，摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。两种P2P模型：</p><img src="/posts/81ce2909/image-20220726232111418.png" alt="image-20220726232111418" style="zoom:80%;"><p>优点：每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。</p><p>缺点：当用户之间传输的请求过多时，网络的负载将加重。</p><p>图a的P2P模型的问题，主机之间很难互相发现。实际使用中，需要加入一个专门的发现服务器，如图b，发现服务器通常还提供查找服务（甚至还可以提供内容服务），使每个客户都能尽快地找到自己需要的资源。</p><p>从编程角度来讲，P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器。</p><h2 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h2><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。</p><p>服务器基本框架如下：</p><img src="/posts/81ce2909/image-20220726232518637.png" alt="image-20220726232518637" style="zoom:80%;"><p>服务器基本模块的功能概述：</p><table><thead><tr><th align="center">模块</th><th align="center">单个服务器程序</th><th align="center">服务器机群</th></tr></thead><tbody><tr><td align="center">I/O处理单元</td><td align="center">处理客户连接，读写网络数据</td><td align="center">作为接入服务器，实现负载均衡</td></tr><tr><td align="center">逻辑单元</td><td align="center">业务进程或线程</td><td align="center">逻辑服务器</td></tr><tr><td align="center">网络存储单元</td><td align="center">本地数据库、文件或缓存</td><td align="center">数据库服务器</td></tr><tr><td align="center">请求队列</td><td align="center">各单元之间的通信方式</td><td align="center">各服务器之间的永久TCP连接</td></tr></tbody></table><p><strong>I/O处理单元：</strong>服务器管理客户连接的模块。主要工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定只在I/O处理单元中执行，也可能在逻辑单元中执行。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。</p><p><strong>逻辑单元：</strong>通常是一个进程或线程。主要工作：分析并处理客户数据，然后将结果传递给I/O处理单元，或者直接发送给客户端（取决于事件处理模式）。对于服务器机群来说，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。</p><p><strong>网络存储单元：</strong>可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。</p><p><strong>请求队列：</strong>是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。</p><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>阻塞与非阻塞应用于文件描述符包括socket。阻塞的文件描述符为阻塞I/O，非阻塞的文件描述符为非阻塞I/O。</p><p><strong>阻塞I/O：</strong>执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。例如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。<br>socket基础API中，可能被阻塞的系统调用包括：accept、send、recv和connect。</p><p><strong>非阻塞I/O：</strong>执行的系统调用总是立即返回，而不管事件是否已经发送。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时必须根据errno来区分这两种情况。<br>对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）。</p><p>使用条件：只有在事件已经发送的情况下操作非阻塞I/O（读、写等），才能提高程序的效率。非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p><p><strong>I/O复用：</strong>最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux常用的I/O复用函数是select、poll和epoll_wait。<strong>I/O复用函数本身是阻塞的</strong>，它们能提高程序效率的原因在于它们<strong>具有同时监听多个I/O事件的能力</strong>。</p><p>SIGIO信号：可以用来报告I/O事件。可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。</p><p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是<strong>同步I/O模型</strong>。这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后，由应用程序来完成的。</p><p>POSIX规范所定义的<strong>异步I/O模型</strong>，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。</p><p>同步I/O模型：要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）</p><p>异步I/O机制：由内核来执行I/O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已由内核接管。</p><p>同步I/O向应用程序通知的是I/O就绪事件，而异步I/O向应用程序通知的是I/O完成事件</p><p>几种I/O模型的差异对比：</p><table><thead><tr><th align="left">I/O模型</th><th>读写操作和阻塞阶段</th></tr></thead><tbody><tr><td align="left">阻塞I/O</td><td>程序阻塞于读写函数</td></tr><tr><td align="left">I/O复用</td><td>程序阻塞于I/O复用系统调用，但可以同时监听多个I/O事件。对I/O本身的读写操作是非阻塞的</td></tr><tr><td align="left">SIGIO信号</td><td>信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段</td></tr><tr><td align="left">异步I/O</td><td>内核执行读写操作并触发读写完成事件。程序没有阻塞阶段</td></tr></tbody></table><h2 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h2><p>服务器程序需要处理的三类事件：I/O事件、信号、定时事件。</p><p>两种高效的事件处理模式：Reactor（同步I/O模型）和Proactor（异步I/O模型）。</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>Reactor模式：要求主线程（I/O处理单元，下同）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程：</p><img src="/posts/81ce2909/image-20220727120151684.png" alt="image-20220727120151684" style="zoom:80%;"><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li></ol><h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>Proactor模式：将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>Proactor模式的工作流程：</p><img src="/posts/81ce2909/image-20220727150928621.png" alt="image-20220727150928621" style="zoom:80%;"><ol><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 </li></ol><p>连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。主线程中的epoll_wait调用，仅能用来检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件。</p><h3 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h3><p>使用同步I/O方式模拟出Proactor模式的一种方法：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>用同步I/O模拟出的Proactor模式工作流程：</p><img src="/posts/81ce2909/image-20220727152705121.png" alt="image-20220727152705121" style="zoom: 67%;"><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li></ol><h2 id="两种高效的并发模式"><a href="#两种高效的并发模式" class="headerlink" title="两种高效的并发模式"></a>两种高效的并发模式</h2><p>对于I/O密集型的程序，如经常读写文件、访问数据库等，由于I/O操作的速度远没有CPU的计算速度快，让程序阻塞于I/O将浪费大量的CPU时间，并发编程让程序“同时”执行多个任务。</p><p>如果程序有多个执行线程，则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来调度），并将执行权转移到其他线程。这样一来，CPU就可以用来做更加有意义的事情（除非所有线程都同时被I/O操作所阻塞），而不是等待I/O操作完成，因此CPU的利用率显著提升。</p><p>并发编程主要有多进程和多线程两种方式。</p><p>并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法。</p><p>服务器主要有两种并发编程模式：</p><ul><li>半同步/半异步（half-sync/half-async）模式</li><li>领导者/追随者（Leader/Followers）模式。</li></ul><h3 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h3><p>I/O模型中的同步与异步的区分：</p><ul><li>内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件）。</li><li>该由谁来完成I/O读写（是应用程序还是内核）。</li></ul><p>并发模式中的同步与异步：</p><ul><li>同步：程序完全按照代码序列的顺序执行。</li><li>异步：程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</li></ul><img src="/posts/81ce2909/image-20220727155301767.png" alt="image-20220727155301767" style="zoom: 67%;"><p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。</p><p>异步线程：执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调 试和扩展，而且不适合于大量的并发。</p><p>同步线程：虽然效率相对较低，实时性较差，但逻辑简单。</p><p><strong>半同步/半异步模式：</strong>同步线程用于处理客户逻辑，相当于逻辑处理单元；异步线程用于处理I/O事件，相当于I/O处理单元。</p><p>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。</p><p>半同步/半异步模式的工作流程：</p><img src="/posts/81ce2909/image-20220727155822372.png" alt="image-20220727155822372" style="zoom:67%;"><p>服务器程序中，结合考虑两种事件处理模式和几种I/O模型，其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式：</p><img src="/posts/81ce2909/image-20220727160014636.png" alt="image-20220727160014636" style="zoom:67%;"><p>图8-10中，异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。<br>所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p><p>主线程插入请求队列中的任务是就绪的连接socket。这说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。</p><p>半同步/半反应堆模式存在如下缺点：</p><ul><li>主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间。</li><li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量CPU时间。</li></ul><p>一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接：</p><img src="/posts/81ce2909/image-20220727161338185.png" alt="image-20220727161338185" style="zoom:67%;"><p>主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。<br>主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。<br>图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。</p><h3 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者/追随者模式"></a>领导者/追随者模式</h3><p><strong>领导者/追随者模式：</strong>多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。</p><p>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。</p><p>领导者/追随者模式的组件：句柄集（HandleSet）、线程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）。</p><img src="/posts/81ce2909/image-20220727162049774.png" alt="image-20220727162049774" style="zoom:67%;"><h4 id="句柄集"><a href="#句柄集" class="headerlink" title="句柄集"></a>句柄集</h4><p>句柄（Handle）用于表示I/O资源，在Linux下通常就是一个文件描述符。<br>句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。<br>领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将Handle和事件处理器绑定是通过调用句柄集中的register_handle方法实现的。</p><h4 id="线程集"><a href="#线程集" class="headerlink" title="线程集"></a>线程集</h4><p>这个组件是所有工作线程（包括领导者线程和追随者线程）的管理者。它负责各线程之间的同步，以及新领导者线程的推选。线程集中的线程在任一时间必处于如下三种状态之一：</p><ul><li>Leader：线程当前处于领导者身份，负责等待句柄集上的I/O事件。</li><li>Processing：线程正在处理事件。领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者；也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。<br>当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接转变为追随者。</li><li>Follower：线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。</li></ul><p>三种状态之间的转换关系：</p><img src="/posts/81ce2909/image-20220727162626955.png" alt="image-20220727162626955" style="zoom: 50%;"><p>注意：领导者线程推选新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员Synchronizer来同步这两个操作，以避免竞态条件。</p><h4 id="事件处理器和具体的事件处理器"><a href="#事件处理器和具体的事件处理器" class="headerlink" title="事件处理器和具体的事件处理器"></a>事件处理器和具体的事件处理器</h4><p>事件处理器通常包含一个或多个回调函数handle_event。这些回调函数用于处理事件对应的业务逻辑。<br>事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的handle_event方法，以处理特定的任务。</p><p>领导者/追随者模式的工作流程总结：</p><img src="/posts/81ce2909/image-20220727163037306.png" alt="image-20220727163037306" style="zoom: 67%;"><p>优点：由于领导者线程自己监听I/O事件并处理客户请求，因而领导者/追随者模式不需要在线程之间传递任何额外的数据，也无须像半同步/半反应堆模式那样在线程之间同步对请求队列的访问。</p><p>缺点：仅支持一个事件源集合，因此也无法像图8-11所示的那样，让每个工作线程独立地管理多个客户连接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器程序规范</title>
      <link href="/posts/7295db68/"/>
      <url>/posts/7295db68/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>Linux服务器程序规范包括：</p><ul><li>Linux服务器程序一般以后台进程（守护进程）运行，没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是init进程（PID为1的进程）。</li><li>日志系统，至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台进程都在/var/log目录下拥有自己的日志目录。</li><li>Linux服务器程序一般以某个专门的非root身份运行，比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、apache和syslog。 </li><li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在/etc目录下。</li><li>Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件是/var/run/syslogd.pid。</li><li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h3><p>守护进程syslogd，处理系统日志。现在的Linux系统上使用的都是它的升级版——rsyslogd。 rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志。</p><p>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中，rsyslogd则监听该文件以获取用户进程的输出。</p><p>内核日志由printk等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。rsyslogd则通过读取该文件获得内核日志。 </p><p>rsyslogd的主配置文件是/etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径，是否接收UDP日志及其监听端口（默认是514，见/etc/services文件），是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文件（比如/etc/rsyslog.d/*.conf）。rsyslogd的子配置文件则指定各类日志的目标存储文件。</p><p>Linux的系统日志体系：</p><p><img src="/20220726/image-20220726200803717.png" alt="image-20220726200803717"></p><h3 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h3><p>应用程序使用syslog函数与rsyslogd守护进程通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>* message,...)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">priority：设施值与日志级别的按位或，设施值的默认值是LOG_USER</span></span><br><span class="line"><span class="comment">message, ...：可变参数，结构化输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_EMERG 0<span class="comment">/*系统不可用*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ALERT 1<span class="comment">/*报警，需要立即采取动作*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CRIT 2<span class="comment">/*非常严重的情况*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERR 3<span class="comment">/*错误*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARNING 4<span class="comment">/*警告*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NOTICE 5<span class="comment">/*通知*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO 6<span class="comment">/*信息*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG 7<span class="comment">/*调试*/</span></span></span><br></pre></td></tr></table></figure><p>改变syslog的默认输出方式，进一步结构化日志内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident, <span class="keyword">int</span> logopt, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">ident：指定的字符串将被添加到日志消息的日期和时间之后，通常为程序的名字</span></span><br><span class="line"><span class="comment">logopt：对后续syslog调用的行为进行配 置，它可取下列值的按位或</span></span><br><span class="line"><span class="comment">facility：用来修改syslog函数中的默认设施值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PID 0x01<span class="comment">/*在日志消息中包含程序PID*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CONS 0x02<span class="comment">/*如果消息不能记录到日志文件，则打印至终端*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ODELAY 0x04<span class="comment">/*延迟打开日志功能直到第一次调用syslog*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NDELAY 0x08<span class="comment">/*不延迟打开日志功能*/</span></span></span><br></pre></td></tr></table></figure><p>日志的过滤，设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">maskpri：指定日志掩码值</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">该函数始终会成功，它返回调用进程先前的日志掩码值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关闭日志功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h3><p>UID：真实用户ID<br>EUID：有效用户ID<br>GID：真实组<br>EGID：有效组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure><p>一个进程拥有两个用户ID：UID和EUID。<br>EUID存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</p><p>任何普通用户运行su程序时，其有效用户就是该程序的所有者root。任何运行su程序的普通用户都能够访问/etc/passwd文件。</p><p>有效用户为root的进程称为特权进程（privileged processes）。EGID的含义与EUID类似：给运行目标程序的组用户提供有效组的权限。</p><p>测试进程的UID和EUID的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid = <span class="built_in">getuid</span>();</span><br><span class="line">    <span class="keyword">uid_t</span> euid = <span class="built_in">geteuid</span>();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effective userid is: %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该文件，将生成的可执行文件（名为test_uid）的所有者设置为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID和EUID。具体操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chown root:root test_uid<span class="comment">#修改目标文件的所有者为root</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo chmod+s test_uid<span class="comment">#设置目标文件的set-user-id标志</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">./test_uid<span class="comment">#运行程序</span></span> </span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure><p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>将以root身份启动的进程切换为以一个普通用户身份运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">( <span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确保目标用户不是root</span></span><br><span class="line">    <span class="keyword">if</span> ( ( user_id == <span class="number">0</span> ) &amp;&amp; ( gp_id == <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保当前用户是合法用户：root或者目标用户</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid = <span class="built_in">getgid</span>();</span><br><span class="line">    <span class="keyword">uid_t</span> uid = <span class="built_in">getuid</span>();</span><br><span class="line">    <span class="keyword">if</span> ( ( ( gid != <span class="number">0</span> ) || ( uid != <span class="number">0</span> ) ) &amp;&amp; ( ( gid != gp_id ) || ( uid != user_id ) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是root</span></span><br><span class="line">    <span class="keyword">if</span> ( uid != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到目标用户</span></span><br><span class="line">    <span class="keyword">if</span> ( ( <span class="built_in">setgid</span>( gp_id ) &lt; <span class="number">0</span> ) || ( <span class="built_in">setuid</span>( user_id ) &lt; <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>Linux下每个进程都隶属于一个进程组，除了PID信息外，还有进程组ID（PGID）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取指定进程的PGID</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">pid：进程识别号</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回进程pid所属进程组的PGID，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>每个进程组都有一个首领进程，其PGID和PID相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置PGID，将PID为pid的进程的PGID设置为pgid</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">pid：进程号</span></span><br><span class="line"><span class="comment">pgid：进程组号</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领；如果pid为0，则表示设置当前进程的PGID为pgid；如果pgid为0，则使用pid作为目标PGID。</p><p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话（session）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：创建一个会话</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回新的进程组的PGID，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该函数不能由进程组的首领进程调用，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p><ul><li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li><li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li><li>调用进程将甩开终端（如果有的话）。</li></ul><p>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为它等于会话首领所在的进程组的PGID，并提供了如下函数来读取SID：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="用ps命令查看进程关系"><a href="#用ps命令查看进程关系" class="headerlink" title="用ps命令查看进程关系"></a>用ps命令查看进程关系</h3><p>执行ps命令可查看进程、进程组和会话之间的关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ps-o pid,ppid,pgid,sid,comm|less</span></span><br><span class="line">PID PPID PGID SID COMMAND </span><br><span class="line">1943 1942 1943 1943 bash </span><br><span class="line">2298 1943 2298 1943 ps</span><br><span class="line">2299 1943 2298 1943 less</span><br></pre></td></tr></table></figure><p>bash shell下执行ps和less命令，因此以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。这3条命令创建了1个会话（SID是1943）和2个进程组（PGID分别是1943和2298）。bash命令的PID、PGID和SID都相同，很明显它既是会话的首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298。</p><p>进程间关系：</p><img src="/posts/7295db68/image-20220726214000802.png" alt="image-20220726214000802" style="zoom:67%;"><h2 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h2><p>读取和设置Linux系统资源限制的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/resource.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit* rlim)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取系统资源限制</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">resource：指定资源限制类型，见表7-1</span></span><br><span class="line"><span class="comment">rlim：指向rlimit结构体</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置系统资源限制</span></span><br><span class="line"><span class="comment">参数，返回值：参考getrlimit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rlimit结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur; <span class="comment">// 描述资源级别，指定资源的软限制，软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max; <span class="comment">// 指定资源的硬限制，软限制的上限，只有以root身份运行的程序才能增加硬限制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/20220726/image-20220726214838702.png" alt="image-20220726214838702"></p><h2 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h2><p>一般来说，Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录（对于Linux的Web服务来说，该目录一般是/var/www/）。</p><p>获取进程当前工作目录的改变进程工作目录的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">buf：指向的内存存储当前工作路径的绝对路径名</span></span><br><span class="line"><span class="comment">size：buf路径的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">如果当前工作目录的绝对路径的长度（再加上一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置errno为 ERANGE；</span></span><br><span class="line"><span class="comment">如果buf为NULL并且size非0，则getcwd可能在内部使用 malloc动态分配内存，并将进程的当前工作目录存储在其中。（需自己释放getcwd在内部创建的这块内存）；</span></span><br><span class="line"><span class="comment">成功返回一个指向目标存储区的指针，失败返回NULL。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：修改当前工作路径</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">path：指定要切换到的目标目录</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：修改进程根目录</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">path：指定要切换到的目标根目录</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>chroot并不改变进程的当前工作目录，所以调用chroot之后，仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。</p><p>改变进程的根目录之后，程序可能无法访问类似/dev的文件（和目录），因为这些文件（和目录）并非处于新的根目录之下。不过好在调用chroot之后，进程原先打开的文件描述符依然生效，所以可以利用这些早先打开的文件描述符，来访问调用chroot之后不能直接访问的文件（和目录），尤其是一些日志文件。此外，只有特权进程才能改变根目录。</p><h2 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h2><p>在代码中让一个服务器进程以守护进程的方式运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子进程，父进程关闭，这样可使程序在后台运行</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置文件权掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777</span></span><br><span class="line">    <span class="built_in">umask</span>( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的会话，设置本进程为进程组的首领</span></span><br><span class="line">    <span class="keyword">pid_t</span> sid = <span class="built_in">setsid</span>();</span><br><span class="line">    <span class="keyword">if</span> ( sid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换工作目录</span></span><br><span class="line">    <span class="keyword">if</span> ( ( <span class="built_in">chdir</span>( <span class="string">&quot;/&quot;</span> ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Log the failure */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭标准输入设备、标准输出设备和标准错误输出设备</span></span><br><span class="line">    <span class="built_in">close</span>( STDIN_FILENO );</span><br><span class="line">    <span class="built_in">close</span>( STDOUT_FILENO );</span><br><span class="line">    <span class="built_in">close</span>( STDERR_FILENO );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭其他已经打开的文件描述符，代码省略</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将标准输入、标准输出和标准错误输出都定向到/dev/null文件</span></span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDONLY );</span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">nochdir：用于指定是否改变工作目录，传值为0，则工作目录被设置为“/”（根目录），否则继续使用当前工作目录。</span></span><br><span class="line"><span class="comment">noclose：参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败 则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux高级I/O函数</title>
      <link href="/posts/4131876a/"/>
      <url>/posts/4131876a/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>常用Linux网络编程相关的高级I/O函数：</p><ul><li>用于创建文件描述符的函数，包括pipe、dup/dup2函数</li><li>用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数</li><li>用于控制I/O行为和属性的函数，包括fctnl函数</li></ul><h2 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h2><p>pipe函数：创建一个管道，以实现进程间的通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：创建管道的两端fd[0]和fd[1]，向fd[1]写入的数据可以从fd[0]读出。fd[0]只能用于从管道读出数据，fd[1]只能用于向管道写入数据，不可以反过来用。</span></span><br><span class="line"><span class="comment">如果要实现双向传输，需要建立两个管道。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd[2]：包含两个int型的数组指针（传出参数）</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，并将一对打开的文件描述符值，填入参数指向的数组；</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>默认情况下，一对文件描述符都是阻塞的。如果用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果用write系统调用来往一个满的管道中写入数据，则write亦将被阻塞，直到管道有足够多的空闲空间可用。<br>如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。</p><p>如果写端fd[1]的引用计数减少到0，表面没有任何进程需要向管道内写入数据，则该管道的读端fd[0]和read操作将返回0，即读取到了文件结束标记EOF。</p><p>如果读端fd[0]的引用计数减少到0，表面没有任何进程需要从管道内读取数据，则该管道的写端fd[1]和write操作将失败，并引发SIGPIPE信号。</p><p>管道内部传输的数据是字节流。管道容量的大小默认是65536字节。可以使用fcntl函数来修改管道容量。</p><p>socket的基础API中有一个socketpair函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：创建双向管道，这对文件描述符都是既可读又可写的。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">domain：底层的协议族。只能使用UNIX本地域协议族AF_UNIX，仅能在本地使用双向管道。</span></span><br><span class="line"><span class="comment">type：指定服务类型。</span></span><br><span class="line"><span class="comment">SOCK_STREAM（TCP）、SOCK_UGRAM（UDP）、SOCK_NONBLOCK（非阻塞的）、SOCK_CLOEXEC</span></span><br><span class="line"><span class="comment">protocol：选择协议，通常由前两个参数决定。</span></span><br><span class="line"><span class="comment">设置为0，使用默认协议</span></span><br><span class="line"><span class="comment">fd[2]：指向两个int型整数。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，并将一对打开的文件描述符值，填入参数指向的数组；</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="dup和dup2函数"><a href="#dup和dup2函数" class="headerlink" title="dup和dup2函数"></a>dup和dup2函数</h2><p>把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接。通过用于复制文件描述符的dup或dup2函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：复制文件描述符</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">file_descriptor：旧的文件描述符</span></span><br><span class="line"><span class="comment">返回值：成功，返回新的文件描述符；失败，返回-1</span></span><br><span class="line"><span class="comment">fd = 3, int fd1 = dup(fd);</span></span><br><span class="line"><span class="comment">fd指向a.txt, fd1也指向a.txt，从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one, <span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：重定向文件描述符</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">file_descriptor_one：旧的文件描述符，必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment">file_descriptor_two：新的文件描述符，和file_descriptor_one相同，相当于什么都没做</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功，返回新的文件描述符；失败，返回-1</span></span><br><span class="line"><span class="comment">file_descriptor_one 指向a.txt，file_descriptor_two 指向b.txt，</span></span><br><span class="line"><span class="comment">调用函数成功后：file_descriptor_two 和b.txt 做close，file_descriptor_two 指向a.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意：通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等。</p><p>利用dup函数实现了一个基本的CGI服务器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-1testdup.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP类型的socket</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="comment">// 接受客户端的连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="built_in">close</span>( STDOUT_FILENO ); <span class="comment">// 关闭标准输出文件描述符（STDOUT_FILENO值为1）</span></span><br><span class="line">        <span class="built_in">dup</span>( connfd ); <span class="comment">// 复制connfd，这里dup返回值实际上是1，即之前关闭的标准输出文件描述符的值</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;abcd\n&quot;</span> ); <span class="comment">// 服务器输出到标准输出的内容，会直接发送到与客户连接对应的socket上</span></span><br><span class="line">        <span class="comment">// 此printf调用的输出将被客户端获得（而不是显示在服务器 程序的终端上）</span></span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readv和writev函数"><a href="#readv和writev函数" class="headerlink" title="readv和writev函数"></a>readv和writev函数</h2><p>readv函数：将数据从文件描述符读到分散的内存块中，分散读。<br>writev函数：将多块分散的内存数据一并写入文件描述符中，集中写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* vector, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd：目标文件描述符</span></span><br><span class="line"><span class="comment">vector：指向iovec结构数组，该结构体描述一块内存区</span></span><br><span class="line"><span class="comment">count：vector数组的长度，即有多少内存数据需要从fd读出。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回读出fd的字节数，失败则返回-1并设置errno，简化版的recvmsg函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* vector, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd：目标文件描述符</span></span><br><span class="line"><span class="comment">vector：指向iovec结构数组，该结构体描述一块内存区</span></span><br><span class="line"><span class="comment">count：vector数组的长度，即有多少内存数据需要写入到fd。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回写入fd的字节数，失败则返回-1并设置errno，简化版的sendmsg函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Web服务器上的集中写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-2testwritev.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两种HTTP状态码和状态信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* status_line[<span class="number">2</span>] = &#123; <span class="string">&quot;200 OK&quot;</span>, <span class="string">&quot;500 Internal server error&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* file_name = argv[<span class="number">3</span>]; <span class="comment">// 将目标文件作为程序的第三个参数传入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址信息</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="comment">// 接受socket连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="comment">// 设置缓冲区，用于保存HTTP应答的状态行、头部字段和一个空行</span></span><br><span class="line">        <span class="keyword">char</span> header_buf[ BUFFER_SIZE ]; </span><br><span class="line">        <span class="built_in">memset</span>( header_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* file_buf; <span class="comment">// 用于存放目标文件内容的应用程序缓存</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span> <span class="comment">// 用于获取目标文件的属性，比如是否为目录，文件大小等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> valid = <span class="literal">true</span>; <span class="comment">// 记录目标文件是否是有效文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 缓存区header_buf目前已经使用了多少字节的空间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">stat</span>( file_name, &amp;file_stat ) &lt; <span class="number">0</span> ) <span class="comment">// 目标文件不存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">S_ISDIR</span>( file_stat.st_mode ) ) <span class="comment">// 目标文件是一个目录</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( file_stat.st_mode &amp; S_IROTH ) <span class="comment">// 当前用户有读取目标文件的权限</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// *动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size加1，</span></span><br><span class="line">                <span class="comment">// 然后将目标文件读入缓存区file_buf中</span></span><br><span class="line">                <span class="keyword">int</span> fd = <span class="built_in">open</span>( file_name, O_RDONLY );</span><br><span class="line">                file_buf = <span class="keyword">new</span> <span class="keyword">char</span> [ file_stat.st_size + <span class="number">1</span> ];</span><br><span class="line">                <span class="built_in">memset</span>( file_buf, <span class="string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( <span class="built_in">read</span>( fd, file_buf, file_stat.st_size ) &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( valid ) <span class="comment">// 如果目标文件有效，则发送正常的HTTP应答</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次 加入header_buf中</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">0</span>] );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, </span><br><span class="line">                             <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, file_stat.st_size );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用writev将header_buf和file_buf的内容一并写出</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iv</span>[2];</span></span><br><span class="line">            iv[ <span class="number">0</span> ].iov_base = header_buf;</span><br><span class="line">            iv[ <span class="number">0</span> ].iov_len = <span class="built_in">strlen</span>( header_buf );</span><br><span class="line">            iv[ <span class="number">1</span> ].iov_base = file_buf;</span><br><span class="line">            iv[ <span class="number">1</span> ].iov_len = file_stat.st_size;</span><br><span class="line">            ret = <span class="built_in">writev</span>( connfd, iv, <span class="number">2</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">// 如果目标文件无效，则通知客户端服务器发生了“内部错误”</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">1</span>] );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            <span class="built_in">send</span>( connfd, header_buf, <span class="built_in">strlen</span>( header_buf ), <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">        <span class="keyword">delete</span> [] file_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h2><p>sendfile函数：在两个文件描述符之间直接传递数据（完全在内核中操作），避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sendfile.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">out_fd：待写入内容的文件描述符</span></span><br><span class="line"><span class="comment">in_fd：待读出内容的文件描述符</span></span><br><span class="line"><span class="comment">offset：指定从读入文件流的哪个位置开始读，若为空，则使用读入文件流默认的起始位置</span></span><br><span class="line"><span class="comment">count：指定在文件描述符in_fd和out_fd之间传输的字节数</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回传输的字节数，失 败则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注：in_fd必须是支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；out_fd必须是一个socket。</p><p>利用sendfile函数将服务器上的一个文件传送给客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-3testsendfile.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开本地文件</span></span><br><span class="line">    <span class="keyword">int</span> filefd = <span class="built_in">open</span>( file_name, O_RDONLY );</span><br><span class="line">    <span class="built_in">assert</span>( filefd &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标文件属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    <span class="built_in">fstat</span>( filefd, &amp;stat_buf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 接收连接成功，使用sendfile发送数据</span></span><br><span class="line">        <span class="built_in">sendfile</span>( connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size );</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将目标文件作为第3个参数传递给服务器程序，客户telnet到该服务器上即可获得该文件。<br>与6-2estwritev.cpp相比，6-3testsendfile.cpp没有为目标文件分布任何用户空间的缓存，也没有执行读取文件的操作，同样实现了文件的发送，显然效率更高。</p><h2 id="mmap和munmap函数"><a href="#mmap和munmap函数" class="headerlink" title="mmap和munmap函数"></a>mmap和munmap函数</h2><p>mmap函数：用于申请一段内存空间。可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。<br>munmap函数：释放由mmap创建的这段内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：申请内存空间，以实现进程间共享内存</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">start：允许用户使用某个特定的地址作为这段内存的起始地址，设置成NULL，则系统自动分配一个地址</span></span><br><span class="line"><span class="comment">length：指定内存的长度</span></span><br><span class="line"><span class="comment">prot：设置内存段的访问权限，取值有：</span></span><br><span class="line"><span class="comment">PROT_READ，内存段可读</span></span><br><span class="line"><span class="comment">PROT_WRITE，内存段可写</span></span><br><span class="line"><span class="comment">PROT_EXEC，内存段可执行</span></span><br><span class="line"><span class="comment">PROT_NONE，内存段不能被访问</span></span><br><span class="line"><span class="comment">flags：控制内存段内容被修改后程序的行为，见表6-1按位或</span></span><br><span class="line"><span class="comment">（MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）</span></span><br><span class="line"><span class="comment">fd：被映射文件对应的文件描述符</span></span><br><span class="line"><span class="comment">offset：设置从文件的何处开始映射</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回指向目标内存区域的指针，失败则返回 MAP_FAILED（(void*)-1）并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start,<span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：释放空间</span></span><br><span class="line"><span class="comment">参数：参考mmap</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/20220725/image-20220725234309852.png" alt="image-20220725234309852"></p><h2 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h2><p>splice函数：用于在两个文件描述符之间移动数据，也是零拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span>* off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span>* off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd_in：待输入数据的文件描述符</span></span><br><span class="line"><span class="comment">如果fd_in是一个管道文件 描述符，那么off_in参数必须被设置为NULL；</span></span><br><span class="line"><span class="comment">off_in：从输入数据流的何处开始读取数据，设置为NULL表示从输入数据流的当前偏移位置读入</span></span><br><span class="line"><span class="comment">fd_out：输出数据流的文件描述符</span></span><br><span class="line"><span class="comment">off_out：输出数据流的偏移量</span></span><br><span class="line"><span class="comment">len：指定移动数据的长度</span></span><br><span class="line"><span class="comment">flags：控制数据如何移动，它可以被设置为表6-2中的某些值的按位或</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回移动字节的数量。可能返回0，表示没有数据需要移动（从管道中读取数据（fd_in是管道文件描述 符）而该管道没有被写入任何数据）；</span></span><br><span class="line"><span class="comment">失败返回-1并设置 errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</p><p><img src="/20220725/image-20220725234325910.png" alt="image-20220725234325910"></p><p><img src="/20220725/image-20220725234520263.png" alt="image-20220725234520263"></p><p>使用splice函数来实现一个零拷贝的回射服务器，它将客户端发送的数据原样返回给客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-4testsplice.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="comment">// 接收连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功</span></span><br><span class="line">        <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">        ret = <span class="built_in">pipe</span>( pipefd ); <span class="comment">// 创建管道</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将connfd上流入的客户数据定向到管道中，splice函数将客户端的内容读入到pipefd[1]中</span></span><br><span class="line">        ret = <span class="built_in">splice</span>( connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE ); </span><br><span class="line">        <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将管道的输出定向到connfd客户连接文件描述符，splice函数从pipefd[0]中读出该内容到客户端</span></span><br><span class="line">        ret = <span class="built_in">splice</span>( pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过splice函数将客户端的内容读入到pipefd[1]中，然后再使用splice函数从pipefd[0]中读出该内容到客户端，从而实现了简单高效的回射服务。整个过程未执行recv/send操作，因此也未涉及用户空间和内核空间之间的数据拷贝。</p><h2 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h2><p>tee函数：在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">int</span> fd_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd_in：待输入数据的管道文件描述符</span></span><br><span class="line"><span class="comment">fd_out：管道文件描述符</span></span><br><span class="line"><span class="comment">len：指定移动数据的长度</span></span><br><span class="line"><span class="comment">flags：控制数据如何移动</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回在两个文件描述符之间复制的数据数量（字节数）。</span></span><br><span class="line"><span class="comment">返回0表示没有复制任何数据。</span></span><br><span class="line"><span class="comment">失败时返回-1并设置 errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>利用tee函数和splice函数，实现Linux下tee程序的基本功能（同时输出数据到终端和文件的程序，不要和tee函数混淆）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-5testtee.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开本地文件</span></span><br><span class="line"><span class="keyword">int</span> filefd = <span class="built_in">open</span>( argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span> );</span><br><span class="line"><span class="built_in">assert</span>( filefd &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="keyword">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">pipe</span>( pipefd_stdout );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd_file[<span class="number">2</span>];</span><br><span class="line">        ret = <span class="built_in">pipe</span>( pipefd_file );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//close( STDIN_FILENO );</span></span><br><span class="line"><span class="comment">// dup2( pipefd_stdout[1], STDIN_FILENO );</span></span><br><span class="line"><span class="comment">//write( pipefd_stdout[1], &quot;abc\n&quot;, 4 );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标准输入内容输入管道pipefd_stdout</span></span><br><span class="line">ret = <span class="built_in">splice</span>( STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道pipefd_stdout的输出复制到管道pipefd_file的输入端</span></span><br><span class="line">ret = <span class="built_in">tee</span>( pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK ); </span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件</span></span><br><span class="line">ret = <span class="built_in">splice</span>( pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致</span></span><br><span class="line">ret = <span class="built_in">splice</span>( pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>( filefd );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_stdout[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_stdout[<span class="number">1</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_file[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_file[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>fcntl函数：提供了对文件描述符的各种控制操作。对于控制文件描述符常用的属性和行为，fcntl函数是由POSIX规范指定的首选方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd,…)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取或修改文件的属性</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd：需要操作的文件描述符</span></span><br><span class="line"><span class="comment">cmd：对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">- F_DUPFD：复制第一个参数文件描述符fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">int ret = fnctl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment">- F_GETFL：获取指定的文件描述符的文件状态flag（与open函数传递的文件权限flag是相同的）</span></span><br><span class="line"><span class="comment">- F_SETFL：设置文件描述符的文件状态flag</span></span><br><span class="line"><span class="comment">            必选项：O_RONLY, O_WRONLY, O_RDWR 不可以被修改（文件访问、创建权限）</span></span><br><span class="line"><span class="comment">            可选项：O_APPEND, O_NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                O_NONBLOCK 设置成非阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。</p><p>将文件描述符设置成非阻塞的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL); <span class="comment">/*获取文件描述符旧的状态标志*/</span> </span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK; <span class="comment">/*设置非阻塞标志*/</span> </span><br><span class="line">    <span class="built_in">fcntl</span>(fd,F_SETFL,new_option); </span><br><span class="line">    <span class="keyword">return</span> old_option; <span class="comment">/*返回文件描述符旧的状态标志，以便日后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/20220725/image-20220726152218986.png" alt="image-20220726152218986"></p><p><img src="/20220725/image-20220726152238201.png" alt="image-20220726152238201"></p><p>SIGIO和SIGURG这两个信号与其他Linux信号不同，它们必须与某个文件描述符相关联方可使用：当被关联的文件描述符可读或可写时，系统将触发SIGIO信号；当被关联的文件描述符（而且必须是一个socket）上有带外数据可读时，系统将触发SIGURG信号。<br>使用SIGIO时，还需要利用fcntl设置其O_ASYNC标志（异步I/O标志，不过SIGIO信号模型并非真正意义上的异步I/O模型）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程基础API</title>
      <link href="/posts/47fa327/"/>
      <url>/posts/47fa327/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>Linux网络API：</p><ul><li>socket地址API。一个ip地址和端口对(ip, port)。唯一表示使用TCP通信的一端</li><li>socket基础API。头文件&lt;sys/socket.h&gt;，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</li><li>网络信息API。Linux提供的网络信息API，实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。头文件&lt;netdb.h&gt;中。</li></ul><h2 id="1-socket地址API"><a href="#1-socket地址API" class="headerlink" title="1.socket地址API"></a>1.socket地址API</h2><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><ul><li>大端字节序：一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7bit）存储在内存的高地址处</li><li>小端字节序：整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</li></ul><p><strong>现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。</strong><br>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞ </span></span><br><span class="line"><span class="comment">// host to network long 将长整型（32bit）的主机字节序数据转化为网络字节序数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p>长整型函数通常用来转换IP地址，短整型函数用来转换端口号。</p><h3 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h3><p>结构体sockaddr，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 地址族类型，与协议族类型相对应</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 存放socket地址值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见协议族与对应的地址族的关系：</p><table><thead><tr><th align="center">协议族</th><th align="center">地址族</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PF_UNIX</td><td align="center">AF_UNIX</td><td align="center">UNIX本地域协议族</td></tr><tr><td align="center">PF_INET</td><td align="center">AF_INET</td><td align="center">TCP/IPv4协议族</td></tr><tr><td align="center">PF_INET6</td><td align="center">AF_INET6</td><td align="center">TCP/IPv6协议族</td></tr></tbody></table><p>宏<code>PF_*</code>和<code>AF_*</code>都定义在<code>bits/socket.h</code>头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p><p>不同的协议族的地址值具有不同的含义和长度。14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line">char__ss_padding[<span class="number">128</span>-<span class="built_in"><span class="keyword">sizeof</span></span>(__ss_align)]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅提供了足够大的空间用于存放地址值，而且是内存对齐的（这是<code>__ss_align</code>成员的作用）</p><h3 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h3><p>Linux为各个协议族提供了专门的socket地址结构体。  </p><p>UNIX本地域协议族的专用socket地址<code>sockaddr_un</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/un.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_UNIX*/</span> </span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];<span class="comment">/*文件路径名*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCP/IP协议族:<code>sockaddr_in</code>(IPV4)和<code>sockaddr_in6</code>(IPV6)地址结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span> </span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;<span class="comment">/*IPv4地址，要用网络字节序表示*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span> </span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。 </p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p>IPV4地址：点分十进制字符串<br>IPV6地址：十六进制字符串<br>编程中需要将他们转化为整数（二进制数）使用，记录日志则相反，需要由整数转化为可读的字符串。</p><p>用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*strptr)</span></span>; </span><br><span class="line"><span class="comment">// 点分十进制字符串-&gt;网络字节序整数，失败返回INADDR_NONE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*cp,struct in_addr*inp)</span></span>; </span><br><span class="line"><span class="comment">// 功能与inet_addr相同，结果存在inp指向的地址结构（传出参数），成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">// 网络字节序整数-&gt;点分十进制字符串。函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存</span></span><br><span class="line"><span class="comment">// inet_ntoa是不 可重入的，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* szValue1 = <span class="built_in">inet_ntoa</span>(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”); </span><br><span class="line"><span class="keyword">char</span>* szValue2 = <span class="built_in">inet_ntoa</span>(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”); </span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”, szValue1); </span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”, szValue2);</span><br><span class="line"><span class="comment">// 返回结果为：</span></span><br><span class="line"><span class="comment">// address1:10.194.71.60 </span></span><br><span class="line"><span class="comment">// address2:10.194.71.60</span></span><br></pre></td></tr></table></figure><p>更新函数适用于IPV4和IPV6：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 字符串IP地址src-&gt;网络字节序整数，结果存储在dst指向的内存中</span></span><br><span class="line"><span class="comment">// 参数af：指定地址族，AF_INET或者AF_INET6</span></span><br><span class="line"><span class="comment">// 成功返回1，失败返回0并设置errno</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br><span class="line"><span class="comment">// 网络字节序整数-&gt;字符串IP地址src，前三个参数与之前的函数相同</span></span><br><span class="line"><span class="comment">// 参数cnt：指定目标存储单元的大小，定义两个宏帮助指定大小（分别用于IPV4和IPV6）</span></span><br><span class="line"><span class="comment">// 成功返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure><h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>UNIX/Linux系统中：所有东西都是文件。<br>socket，可读可写、可控制、可关闭的文件描述符。<br>socket系统调用创建一个socket：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">domain：底层的协议族。</span></span><br><span class="line"><span class="comment">PF_INET（IPv4）、 PF_INET6（IPv6）、PF_UNIX（本地域）</span></span><br><span class="line"><span class="comment">type：指定服务类型。</span></span><br><span class="line"><span class="comment">SOCK_STREAM（TCP）、SOCK_UGRAM（UDP）、SOCK_NONBLOCK（非阻塞的）、SOCK_CLOEXEC</span></span><br><span class="line"><span class="comment">protocol：选择协议，通常由前两个参数决定。</span></span><br><span class="line"><span class="comment">设置为0，使用默认协议</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回一个socket文件描述符，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>命名socket：将一个socket与socket地址绑定。<br>服务器程序中，命名后客户端才知道如何连接它。<br>命名socket的系统调用：bind函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：未命名的sockfd文件描述符</span></span><br><span class="line"><span class="comment">my_addr：指向socket地址</span></span><br><span class="line"><span class="comment">addrlen：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">错误：</span></span><br><span class="line"><span class="comment">EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。</span></span><br><span class="line"><span class="comment">EADDRINUSE，被绑定的地址正在使用中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>创建一个监听队列以存放待处理的客户连接，listen函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：指定被监听的socket</span></span><br><span class="line"><span class="comment">backlog：提示内核监听队列的最大长度。如果监听队列的长度超过backlog，服务器不受理新的客户连接，客户端收到ECONNREFUSED错误信息。backlog典型值为5</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>backlog函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-3testlisten.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// SIGTERM信号的处理函数，触发时结束主程序中的循环</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">( <span class="keyword">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testlisten函数接收三个参数：IP地址，端口号，backlog值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>( SIGTERM, handle_term );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>]; <span class="comment">// ip地址</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ); <span class="comment">// 端口号</span></span><br><span class="line">    <span class="keyword">int</span> backlog = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] ); <span class="comment">// backlog值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> ); <span class="comment">// 创建ipv4 socket文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">// 创建一个ipv4 socket地址</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr ); <span class="comment">// 字符串ip地址转化为网络字节序整数</span></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port ); <span class="comment">// 主机字节序转化为网络字节序，短整型函数转化端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, backlog );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待连接，直到有SIGTERM信号将它中断</span></span><br><span class="line">    <span class="keyword">while</span> ( ! stop )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器程序testlisten，接受3个参数：IP地址，端口号，backlog值。<br>服务器运行该程序，客户端多次执行telnet命令连接该服务器程序。使用telnet建立连接，执行netstat命令查看服务器上连接的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testlisten 192.168.1.109 12345 5<span class="comment">#监听12345端口，给backlog传递典型 值5</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">telnet 192.168.1.109 12345<span class="comment">#多次执行之</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 12345<span class="comment">#多次执行之</span></span></span><br></pre></td></tr></table></figure><p>在监听队列中，处于ESTABLISHED状态的连接只有6个（backlog值加1），其他的连接都处于SYN_RCVD状态。即完整连接最多有（backlog+1）个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p><h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>从listen监听队列中接受一个连接，accept函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr*addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：执行过listen系统调用的监听socket（处于LISTEN状态的socket，而所有处于ESTABLISHED状态的socket则称为连接socket）</span></span><br><span class="line"><span class="comment">addr：获取被接受的远端socket地址</span></span><br><span class="line"><span class="comment">addrlen：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信；</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>接受一个异常的连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-5testaccept.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>]; <span class="comment">// ipv4地址</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ); <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">// 创建socket地址结构体，传入ip地址和端口号</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> ); <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址结构体与socket文件描述符，命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> ); <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*暂停20秒以等待客户端连接和相关操作（掉线或者退出）完成*/</span> </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span> <span class="comment">// 客户端socket地址结构体</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept接收连接调用，返回值connfd</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接成功，打印客户端地址和端口号</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器运行testaccept程序，在客户端执行telnet命令连接该服务器的程序：<br>(服务器ip地址：192.168.1.109)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testaccept 192.168.1.109 54321<span class="comment">#监听54321端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">telnet 192.168.1.109 54321</span></span><br></pre></td></tr></table></figure><p>启动telnet客户端程序，立即断开该客户端的网络连接（建立和断开连接的过程要在服务器启动后20秒内完成）。结果发现accept调用能够正常返回，服务器输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected with ip:192.168.1.108 and port:38545</span><br></pre></td></tr></table></figure><p>服务器运行netstat命令查看accept返回socket连接的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 54321</span></span><br><span class="line">tcp 0 0 192.168.1.109:54321 192.168.1.108:38545 ESTABLISHED</span><br></pre></td></tr></table></figure><p>accept调用对于客户端网络断开毫不知情。重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回。服务器运行netstat命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 54321</span></span><br><span class="line">tcp 1 0 192.168.1.109:54321 192.168.1.108:52070 CLOSE_WAIT</span><br></pre></td></tr></table></figure><p>由此可见，accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。</p><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>服务器通过listen调用，被动接受连接；客户端通过connect调用，主动与服务器建立连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：socket系统调用返回的socket文件描述符</span></span><br><span class="line"><span class="comment">serv_addr：服务器监听的socket地址</span></span><br><span class="line"><span class="comment">addrlen：指定地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">常见错误：</span></span><br><span class="line"><span class="comment">ECONNREFUSED：目标端口不存在，连接被拒绝</span></span><br><span class="line"><span class="comment">ETIMEDOUT：连接超时</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭该连接所对应的socket，通过关闭普通文件描述符的系统调用完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数fd：待关闭的socket</span></span><br><span class="line"><span class="comment">close函数将fd的引用计数减1，只有当fd的引用计数为0时，才真正关闭连接。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>多进程程序中，一次fork系统调用默认使父进程中打开的socket的引用计数加1，因此，必须在父进程和子进程中都对该socket执行close调用，才能将连接关闭。</p><p>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：待关闭的socket</span></span><br><span class="line"><span class="comment">howto：决定shutdown的行为，可选择：</span></span><br><span class="line"><span class="comment">SHUT_RD：关闭sockfd的读，应用程序无法对socket文件描述符执行读操作</span></span><br><span class="line"><span class="comment">SHUT_WR：关闭sockfd的写，应用程序无法对socket文件描述符指向写操作，连接处于半关闭状态</span></span><br><span class="line"><span class="comment">SHUT_RDWD：同时关闭sockfd上的读和写</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><p>对文件的读写操作read和write同样适用于socket。用于TCP流数据读写的系统调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">recv作用：读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要读取的sockfd文件描述符</span></span><br><span class="line"><span class="comment">buf：指定读缓冲区的位置（传出参数）</span></span><br><span class="line"><span class="comment">len：缓冲区大小</span></span><br><span class="line"><span class="comment">flags：通常设置为0</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">可能要多次调用recv，才能读取到完整的数据。</span></span><br><span class="line"><span class="comment">返回0表示通信对方已经关闭连接，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">send作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">sockfd：要写入数据的sockfd文件描述符</span></span><br><span class="line"><span class="comment">buf：指定读缓冲区的位置（传出参数）</span></span><br><span class="line"><span class="comment">len：缓冲区大小</span></span><br><span class="line"><span class="comment">flags：数据收发的额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>发送带外数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-6oobsend.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ip地址与端口号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sockfd &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connection failed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 发起连接成功</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;send oob data out\n&quot;</span> );</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* oob_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="comment">// 写入数据发送</span></span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">send</span>( sockfd, oob_data, <span class="built_in">strlen</span>( oob_data ), MSG_OOB ); <span class="comment">// 发送或接受紧急数据</span></span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受带外数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-7oobrecv.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取ip地址与端口号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受地址socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket文件描述符与socket地址信息</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket地址监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听的socket接受连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="keyword">char</span> buffer[ BUF_SIZE ]; <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取socket中的数据，写入到buffer缓冲区中，打印缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OOB );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在服务器上启动5-7oobrecv.cpp服务器程序testoobrecv，客户端执行5-6oobsend.cpp客户端程序testoobsend，向服务器发送带外数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testoobrecv 192.168.1.109 54321 <span class="comment">#在Kongming20上执行服务器程序，监听 54321端口 $./testoobsend 192.168.1.109 54321 #在ernest-laptop上执行客户端程序</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">sudo tcpdump-ntx-i eth0 port 54321</span></span><br></pre></td></tr></table></figure><p>服务器的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got 5 bytes of normal data&#x27;123ab&#x27; </span><br><span class="line">got 1 bytes of oob data&#x27;c&#x27; </span><br><span class="line">got 3 bytes of normal data&#x27;123&#x27;</span><br></pre></td></tr></table></figure><p>客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收。并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p><h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><p>用于UDP数据报读写的系统调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; </span><br><span class="line"><span class="comment">/* recvfrom调用</span></span><br><span class="line"><span class="comment">作用：读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要读取的socket文件描述符</span></span><br><span class="line"><span class="comment">buf：指定缓冲区位置</span></span><br><span class="line"><span class="comment">len：缓冲区的大小</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">src_addr：获取发送端的socket的地址</span></span><br><span class="line"><span class="comment">addrlen：发送端socket地址的大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/* sendto调用：</span></span><br><span class="line"><span class="comment">作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要写入数据的socket文件描述符</span></span><br><span class="line"><span class="comment">buf：指定缓冲区位置</span></span><br><span class="line"><span class="comment">len：缓冲区的大小</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">dest_addr：指定接收端的socket的地址</span></span><br><span class="line"><span class="comment">addrlen：接收端socket地址的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。</p><h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><p>不仅适用于TCP流数据，也能用于UDP数据报：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="comment">/* recvmsg调用：</span></span><br><span class="line"><span class="comment">作用：接收读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要读取的socket文件描述符</span></span><br><span class="line"><span class="comment">msg：指向msghdr结构体</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要写入数据的socket文件描述符</span></span><br><span class="line"><span class="comment">msg：指向msghdr结构体</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// msghdr结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* msg_name; <span class="comment">/*socket地址*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen; <span class="comment">/*socket地址的长度*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span> <span class="comment">/*分散的内存块，见后文*/</span> </span><br><span class="line">    <span class="keyword">int</span> msg_iovlen; <span class="comment">/*分散内存块的数量*/</span></span><br><span class="line">    <span class="keyword">void</span>* msg_control; <span class="comment">/*指向辅助数据的起始位置*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_controllen; <span class="comment">/*辅助数据的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> msg_flags; <span class="comment">/*复制函数中的flags参数，并在调用过程中更新*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iovec结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* iov_base; <span class="comment">/*内存起始地址*/</span> </span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/*这块内存的长度*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>msghdr结构体中，msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。</p><p>iovec结构体封装了一块内存的起始位置和长度。</p><p>分散读（scatter read）：recvmsg调用，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定。</p><p>集中写（gather write）：sendmsg调用，msg_iovlen块分散内存中的数据将被一并发送。</p><p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</p><h2 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h2><p>内核通知应用进程带外数据抵达的两种方式：</p><ul><li>I/O复用产生的异常事件</li><li>SIGURG信号</li></ul><p>即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。使用sockatmark调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：判断sockfd是否处于带外标记，即下一个被读取的数据是否是带外数据</span></span><br><span class="line"><span class="comment">参数fd：需要判断的socket文件描述符</span></span><br><span class="line"><span class="comment">返回值：若是带外数据，返回1，此时可以利用带MSG_OOB标志的recv调用来接收带外数据；若不是，返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h2><p>获取一个连接socket的本端socket地址，以及远端的socket地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取sockfd对应的本端socket地址，存储在address指向的内存中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：需要获取的socket文件描述符</span></span><br><span class="line"><span class="comment">address：指向socket地址结构体的指针，传出参数</span></span><br><span class="line"><span class="comment">address_len：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取sockfd对应的远端socket地址</span></span><br><span class="line"><span class="comment">参数，返回值的含义与getsockname调用的相同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><p>读取和设置socket文件描述符属性的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：读取sockfd的属性</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：指定被操作的目标socket文件描述符</span></span><br><span class="line"><span class="comment">level：指定要操作的协议属性（IPV4、IPV6、TCP等）</span></span><br><span class="line"><span class="comment">option_name：指定选项的名字，socket选项</span></span><br><span class="line"><span class="comment">option_value：被操作选项的值</span></span><br><span class="line"><span class="comment">option_len：被操作选项的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置sockfd的属性</span></span><br><span class="line"><span class="comment">参数，返回值：参照getsockopt调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/20220723/image-20220724232946013.png" alt="image-20220724232946013"></p><p>对于服务器，有部分socket选项只能在调用listen系统调用前针对监听socket设置才有效。因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。</p><p>解决方法：对监听socket设置socket选项，那么accept返回的连接socket将自动继承这些选项。这些socket选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。</p><p>对于客户端，socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成。</p><h3 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h3><p>服务器程序可以通过设置socket选项SO_REUSEADDR，来强制使用被处于TIME_WAIT状态的连接占用的socket地址。重用本地地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-9reuse_address.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// 设置socket属性为SO_REUSEADDR，重用本地地址</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="built_in"><span class="keyword">sizeof</span></span>( reuse ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址并绑定socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端接收socket地址，accept调用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功并打印</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭服务器连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a>SO_RCVBUF和SO_SNDBUF选项</h3><p>SO_RCVBUF选项：TCP接收缓冲区的大小，最小值256字节<br>SO_SNDBUF选项：TCP发送缓冲区的大小，最小值2048字节<br>用setsockopt来设置TCP的接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞。</p><p>修改TCP发送缓冲区的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-10set_send_buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TCP发送缓冲区的大小</span></span><br><span class="line">    <span class="keyword">int</span> sendbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>( sendbuf );</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="built_in"><span class="keyword">sizeof</span></span>( sendbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="keyword">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动发起连接成功</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sock, ( struct sockaddr* )&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) ) != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;a&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="number">0</span> ); <span class="comment">// 发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改TCP接收缓存区的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-11set_recv_buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">int</span> recvbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>( recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket属性，设置接收缓冲区大小</span></span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="built_in"><span class="keyword">sizeof</span></span>( recvbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="keyword">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址与socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收连接accept调用</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功</span></span><br><span class="line">        <span class="keyword">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> ) &gt; <span class="number">0</span> )&#123;&#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端运行5-11set_recv_buffer.cpp（set_recv_buffer程序），在客户端上运行5-10set_send_buffer.cpp（set_send_buffer程序），客户端向服务器发送512字节的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./set_recv_buffer 192.168.1.108 12345 50<span class="comment">#将TCP接收缓冲区的大小设置为 50字节</span></span></span><br><span class="line">the tcp receive buffer size after settting is 256 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./set_send_buffer 192.168.1.108 12345 2000<span class="comment">#将TCP发送缓冲区的大小设置 为2000字节</span></span> </span><br><span class="line">the tcp send buffer size after setting is 4000</span><br></pre></td></tr></table></figure><p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将忽略我们的设置。从客户端的输出来看，我们设置的TCP发送缓冲区的大小被系统增加了一倍。</p><h3 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h3><p>SO_RCVLOWAT选项：TCP接收缓冲区的低水位标记，可读数据总数大于其低水位标记，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据。<br>SO_SNDLOWAT选项：TCP发送缓冲区的低水位标记，缓冲区的空闲空间（可写入数据的空间）大于其低水位标记，I/O复用系统调用将通知应用程序可以往对应的socke上写入数据。<br>一般被I/O复用系统调用，用来判断socket是否可读或可写</p><p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。 </p><h3 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h3><p>SO_LINGER选项：用于控制close系统调用在关闭TCP连接时的行为。</p><p>默认情况下，使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方。</p><p>设置（获取）SO_LINGER选项的值时，需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff;<span class="comment">/*开启（非0）还是关闭（0）该选项*/</span> </span><br><span class="line">    <span class="keyword">int</span> l_linger;<span class="comment">/*滞留时间*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>close系统调用可能产生的3种行为：</p><ul><li>l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为关闭socket。</li><li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。</li><li>l_onoff不为0，l_linger大于0。close的行为取决于两个条件： <ul><li>被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据。</li><li>该socket是阻塞的，还是非阻塞的。<br>对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。<br>如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li></ul></li></ul><h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。可以用主机名来访问一台机器，而避免直接使用其IP地址，用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80 </span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure><p>telnet客户端程序，通过调用某些网络信息API，来实现主机名到IP地址的转换，以及服务名称到端口号的转换。</p><h3 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h3><p>gethostbyname函数：根据主机名称获取主机的完整信息。通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。<br>gethostbyaddr函数：根据IP地址获取主机的完整信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数name：指定目标主机的主机名</span></span><br><span class="line"><span class="comment">返回值：指向hostent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">addr：指定目标主机的IP地址</span></span><br><span class="line"><span class="comment">len：IP地址的长度</span></span><br><span class="line"><span class="comment">type：IP地址的类型，合法取值有AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址）</span></span><br><span class="line"><span class="comment">返回值：指向hostent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hostnet结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* h_name; <span class="comment">/*主机名*/</span> </span><br><span class="line">    <span class="keyword">char</span>** h_aliases; <span class="comment">/*主机别名列表，可能有多个*/</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/*地址类型（地址族）*/</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/*地址长度*/</span> </span><br><span class="line">    <span class="keyword">char</span>** h_addr_list <span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h3><p>getservbyname函数：根据名称获取某个服务的完整信息。<br>getservbyport函数：根据端口号获取某个服务的完整信息。<br>它们实际上都是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">name：指定服务的名字</span></span><br><span class="line"><span class="comment">proto：指定服务类型</span></span><br><span class="line"><span class="comment">返回值：指向servent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">port：指定目标服务对应的端口号</span></span><br><span class="line"><span class="comment">proto：指定服务类型</span></span><br><span class="line"><span class="comment">返回值：指向servent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// servent结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* s_name; <span class="comment">/*服务名称*/</span></span><br><span class="line">    <span class="keyword">char</span>** s_aliases; <span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line">    <span class="keyword">int</span> s_port; <span class="comment">/*端口号*/</span> </span><br><span class="line">    <span class="keyword">char</span>* s_proto; <span class="comment">/*服务类型,通常是tcp或者udp*/</span> &#125;;</span><br></pre></td></tr></table></figure><p>通过主机名和服务名来访问目标服务器上的daytime服务，以获取该机器的系统时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-12access_daytime.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>( argc == <span class="number">2</span> );</span><br><span class="line"><span class="keyword">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取目标主机的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hostinfo</span> =</span> <span class="built_in">gethostbyname</span>( host );</span><br><span class="line"><span class="built_in">assert</span>( hostinfo );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取daytime服务信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>* <span class="title">servinfo</span> =</span> <span class="built_in">getservbyname</span>( <span class="string">&quot;daytime&quot;</span>, <span class="string">&quot;tcp&quot;</span> );</span><br><span class="line"><span class="built_in">assert</span>( servinfo );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;daytime port is %d\n&quot;</span>, <span class="built_in">ntohs</span>( servinfo-&gt;s_port ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建socket地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_port = servinfo-&gt;s_port;</span><br><span class="line"><span class="comment">// 因为h_addr_list本身是使用网络字节序的地址列表，所以使用其中的IP地址时，无须对目标IP地址转换字节序</span></span><br><span class="line">address.sin_addr = *( struct in_addr* )*hostinfo-&gt;h_addr_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建socket文件描述符，主动发起连接</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">connect</span>( sockfd, (struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line"><span class="built_in">assert</span>( result != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">result = <span class="built_in">read</span>( sockfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>( buffer ) );</span><br><span class="line"><span class="built_in">assert</span>( result &gt; <span class="number">0</span> );</span><br><span class="line">buffer[ result ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;the day item is: %s&quot;</span>, buffer );</span><br><span class="line"><span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上讨论的4个函数都是不可重入的，即非线程安全的。不过netdb.h头文件给出了它们的可重入版本。这些函数的函数名是在原函数名尾部加上_r（re-entrant）。</p><h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>getaddrinfo函数：既能通过主机名获得IP地址（内部使用的是gethostbyname函数），也能通过服务名获得端口号（内部使用的是getservbyname函数）。<br>是否可重入取决于其内部调用的gethostbyname和getservbyname函数是否是它们的可重入版本。该函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname, <span class="keyword">const</span> <span class="keyword">char</span>* service, <span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">hostname：可以接收主机名，也可接收字符串表示的IP地址。</span></span><br><span class="line"><span class="comment">service：可以接收服务名，也可以接收字符串表示的十进制端口号。</span></span><br><span class="line"><span class="comment">hints：应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。</span></span><br><span class="line"><span class="comment">可以设置为NULL，表示允许getaddrinfo反馈任何可用的结果。</span></span><br><span class="line"><span class="comment">result：指向一个链表，存储getaddrinfo反馈的结果（传出参数）。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addrinfo结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ai_flags; <span class="comment">/*标志位，可以按位与*/</span></span><br><span class="line">    <span class="keyword">int</span> ai_family; <span class="comment">/*地址族*/</span> </span><br><span class="line">    <span class="keyword">int</span> ai_socktype; <span class="comment">/*服务类型，SOCK_STREAM或SOCK_DGRAM*/</span></span><br><span class="line">    <span class="keyword">int</span> ai_protocol; <span class="comment">/*具体的网络协议，通常设置为0*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> ai_addrlen; <span class="comment">/*socket地址ai_addr的长度*/</span> </span><br><span class="line">    <span class="keyword">char</span>* ai_canonname; <span class="comment">/*主机的别名*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/*指向socket地址*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/*指向下一个sockinfo结构的对象*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/20220723/image-20220725111725849.png" alt="image-20220725111725849"></p><p>使用hints参数的时候，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。</p><p>利用hints参数获取主机ernest-laptop上的“daytime”流服务信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">res</span>;</span></span><br><span class="line"><span class="built_in">bzero</span>(＆hints, <span class="built_in"><span class="keyword">sizeof</span></span>(hints)); </span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="built_in">getaddrinfo</span>(<span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, ＆hints, ＆res);</span><br></pre></td></tr></table></figure><p> getaddrinfo将隐式地分配堆内存（可以通过valgrind等工具查看），因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>getnameinfo函数：通过socket地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数）。函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* sockaddr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">char</span>* host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span>* serv, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockaddr：socket地址结构体</span></span><br><span class="line"><span class="comment">addrlen：socket地址长度</span></span><br><span class="line"><span class="comment">host：存储主机名</span></span><br><span class="line"><span class="comment">hostlen：主机名长度</span></span><br><span class="line"><span class="comment">serv：存储服务名</span></span><br><span class="line"><span class="comment">servlen：服务名长度</span></span><br><span class="line"><span class="comment">flags：控制getnameinfo的行为</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/20220723/image-20220725112716763.png" alt="image-20220725112716763"></p><p><img src="/20220723/image-20220725112747241.png" alt="image-20220725112747241"></p><p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。同样，下面的函数可将表5-8中的错误码转换成其字符串形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试金典题解</title>
      <link href="/posts/e017732d/"/>
      <url>/posts/e017732d/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><h3 id="1-1-确定字符互异"><a href="#1-1-确定字符互异" class="headerlink" title="1.1 确定字符互异"></a>1.1 确定字符互异</h3><p>描述：</p><p>给定一个字符串string str，请返回一个bool值,<strong>True</strong>代表字符串的所有字符全都不同，<strong>False</strong>代表存在相同的字符。保证字符串中的字符为ASCII字符且不允许使用额外的存储结构，字符串的长度小于等于3000。大小写字母算不同的字符</p><p>测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;aeiou&quot;</span><br><span class="line">返回：True</span><br><span class="line">&quot;BarackObama&quot;</span><br><span class="line">返回：False</span><br></pre></td></tr></table></figure><p>假设不使用额外的数据结构。</p><p>解法：</p><p>假定字符集为ASCII，若字符串的长度大于字母表的字符个数，直接返回false；字母表一共只有256个字符。<br>构建一个布尔值的数组，索引值i对应的标记该字符串是否含有字母表的第i个字符。若这个字符第二次出现，返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkDifferent</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">char_set</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = str[i];</span><br><span class="line">        <span class="keyword">if</span> (char_set[val]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这个字符已在字符串中出现过</span></span><br><span class="line">        char_set[val] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-原串翻转"><a href="#1-2-原串翻转" class="headerlink" title="1.2 原串翻转"></a>1.2 原串翻转</h3><p>描述：</p><p>给定一个string <strong>iniString</strong>，请返回一个string，为该字符串翻转后的结果。要求不使用额外数据结构和储存空间，可以使用单个过程变量，保证字符串的长度小于等于5000。</p><p>测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is nowcoder&quot;</span><br><span class="line">返回：&quot;redocwon si sihT&quot;</span><br></pre></td></tr></table></figure><p>解法：</p><p>不分配额外空间，直接就地翻转字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (iniString.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> iniString;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = iniString.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123; <span class="comment">// 字符串首尾开始交换两个字符，直至两个指针在中间碰头</span></span><br><span class="line">        tmp = iniString[i];</span><br><span class="line">        iniString[i++] = iniString[j];</span><br><span class="line">        iniString[j--] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iniString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-确定两串乱序同构"><a href="#1-3-确定两串乱序同构" class="headerlink" title="1.3 确定两串乱序同构"></a>1.3 确定两串乱序同构</h3><p>描述：</p><p>给定string <strong>stringA</strong>和string <strong>stringB</strong>，编写程序确认两字符串包含的字符是否完全相同，注意大小写为不同字符，且考虑字符串中的空格，返回一个bool，代表两串是否由一样的字符组成。保证两串的长度都小于等于5000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：&quot;This is nowcoder&quot;,&quot;is This nowcoder&quot;</span><br><span class="line">返回值：true</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;Here you are&quot;,&quot;Are you here&quot;</span><br><span class="line">返回值：false</span><br></pre></td></tr></table></figure><p>注：变位词区分大小写，空白也考虑在内。比较两个如果长度不同，就不可能是变位词。</p><p>解法1：排序字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (stringA.<span class="built_in">size</span>() != stringB.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">sort</span>(stringA.<span class="built_in">begin</span>(), stringA.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(stringB.<span class="built_in">begin</span>(), stringB.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> stringA == stringB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：检查两个字符串的各字符数是否相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (stringA.<span class="built_in">size</span>() != stringB.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : stringA) &#123;</span><br><span class="line">        letters[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> d : stringB) &#123;</span><br><span class="line">        letters[d]--;</span><br><span class="line">        <span class="keyword">if</span> (letters[d] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-空格替换"><a href="#1-4-空格替换" class="headerlink" title="1.4 空格替换"></a>1.4 空格替换</h3><p>描述：</p><p>给定一个string <strong>iniString</strong> 及其长度 int <strong>len</strong>, 已知该字符串中有空格，现要求编写程序将字符串中空格替换为“%20”。返回更改后的string。假设该字符串有足够的空间存放新增的字符，并且知道原字符的长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：&quot;Mr John Smith&quot;,13</span><br><span class="line">返回值：&quot;Mr%20John%20Smith&quot;</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;Hello  World&quot;,12</span><br><span class="line">返回值：&quot;Hello%20%20World&quot;</span><br></pre></td></tr></table></figure><p>解法：</p><p>处理字符串操作问题，常用做法是从字符串尾部开始编辑，从后向前反向操作。因为字符串尾部有额外的缓存，可以直接修改，不必担心会覆写原来的数据。</p><p>两次扫描，一次先数出字符串中有多少空格，从而算出最终的字符串的长度；第二次扫描反向编辑字符串。检测到空格将%20复制到下一个位置，若不是空白，就复制原来的字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string iniString, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, newLength = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    newLength = length + <span class="number">2</span> * count;</span><br><span class="line">    <span class="function">string <span class="title">res</span><span class="params">(newLength, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            res[newLength - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res[newLength - <span class="number">2</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            res[newLength - <span class="number">3</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            newLength -= <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[newLength - <span class="number">1</span>] = iniString[i];</span><br><span class="line">            newLength--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-基本字符串压缩"><a href="#1-5-基本字符串压缩" class="headerlink" title="1.5 基本字符串压缩"></a>1.5 基本字符串压缩</h3><p>描述：</p><p>现给定一个string iniString字符串(长度小于等于10000)，请按连续重复字母压缩的方式将该字符串压缩，返回结果为string，比如，字符串“aabbcccccaaa”经压缩会变成“a2b2c5a3”，若压缩后的字符串没有变短，则返回原先的字符串。注意保证串内字符均由大小写英文字母组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">返回值：&quot;a2b1c5a3&quot;</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;welcometonowcoderrrrr&quot;</span><br><span class="line">返回值：&quot;welcometonowcoderrrrr&quot;</span><br><span class="line"></span><br><span class="line">说明：welcometonowcoderrrrr转换成重复字母压缩的结果是w1e1l1c1o1m1e1t1o1n1o1w1c1o1d1e1r5，比原字符串的长度还要长，所以返回原先的字符串。 </span><br></pre></td></tr></table></figure><p>解法：</p><p>加入压缩长度检查，算出压缩后的长度，构建相应大小的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">zipString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">countCompression</span>(iniString);</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= iniString.<span class="built_in">size</span>()) <span class="keyword">return</span> iniString;</span><br><span class="line">    <span class="function">string <span class="title">res</span><span class="params">(size, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> last = iniString[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">0</span>] = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; iniString.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == last) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = iniString[i];</span><br><span class="line">            string tmp = <span class="built_in">to_string</span>(count);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> d : tmp) &#123;</span><br><span class="line">                res[index++] = d;</span><br><span class="line">            &#125;</span><br><span class="line">            res[index++] = last;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string tmp = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> d : tmp) &#123;</span><br><span class="line">        res[index++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCompression</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> last = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == last) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = str[i];</span><br><span class="line">            size += <span class="number">1</span> + <span class="built_in">to_string</span>(count).<span class="built_in">size</span>();</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span> + <span class="built_in">to_string</span>(count).<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-像素翻转"><a href="#1-6-像素翻转" class="headerlink" title="1.6 像素翻转"></a>1.6 像素翻转</h3><p>描述：</p><p>现有一个NxN的矩阵，阶数为N，请编写一个算法将矩阵顺时针旋转90度并将其作为返回值。要求不使用缓存矩阵，保证N不大于500，元素不大于256，每个元素用int表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[[1,2,3],[4,5,6],[7,8,9]],3</span><br><span class="line">返回：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p>解法：</p><p>按索引一个一个进行交换，从最外层开始逐渐向里，在每一层进行交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">transformImage</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = layer, last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> offset = i - first;</span><br><span class="line">            <span class="comment">// 存储上边</span></span><br><span class="line">            <span class="keyword">int</span> top = mat[first][i];</span><br><span class="line">            mat[first][i] = mat[last - offset][first]; <span class="comment">// 左到上</span></span><br><span class="line">            mat[last - offset][first] = mat[last][last - offset]; <span class="comment">// 下到左</span></span><br><span class="line">            mat[last][last - offset] = mat[i][last]; <span class="comment">// 右到下</span></span><br><span class="line">            mat[i][last] = top; <span class="comment">// 上到右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-清除行列"><a href="#1-7-清除行列" class="headerlink" title="1.7 清除行列"></a>1.7 清除行列</h3><p>描述：给定一个N阶方阵<code>int[][]</code>(C++中为<code>vector&lt;vector&gt;&lt;int&gt;&gt;</code>)<strong>mat</strong>及其阶数<strong>n</strong>，若方阵中某个元素为0，则将其所在的行与列清零。返回改变后的<code>int[][]</code>方阵(C++中为<code>vector&lt;vector&gt;&lt;int&gt;&gt;</code>)，保证n小于等于300，矩阵中的元素在nt范围内。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[[1,2,3],[0,1,2],[0,0,1]]</span><br><span class="line">返回：[[0,0,3],[0,0,0],[0,0,0]]</span><br></pre></td></tr></table></figure><p>解法：</p><p>避免陷阱将矩阵所有元素清零。用两个数组记录包含零的所有行与列，第二次遍历矩阵时，若所在行或列标记为零，则将元素清零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">clearZero</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = <span class="literal">true</span>;</span><br><span class="line">                col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-翻转子串"><a href="#1-8-翻转子串" class="headerlink" title="1.8 翻转子串"></a>1.8 翻转子串</h3><p>描述：</p><p>给定2个字符串s1和s2，请判断s2是否为s1旋转而成，返回bool值。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&quot;Hello world&quot;,&quot;worldhello &quot;</span><br><span class="line">返回：false</span><br><span class="line">&quot;waterbottle&quot;,&quot;erbottlewat&quot;</span><br><span class="line">返回：true</span><br></pre></td></tr></table></figure><p>解法：</p><p>假定s2由s1旋转而成，将s1划分为两部分：x和y，满足xy = s1和yx = s2.无论分割点在哪里，yx肯定是xyxy的子串，即s2为s1s1的子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkReverseEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == s2.<span class="built_in">size</span>() &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        string s1s1 = s1 + s1;</span><br><span class="line">        <span class="keyword">if</span> (s1s1.<span class="built_in">find</span>(s2) != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="2-1-访问单个节点的删除"><a href="#2-1-访问单个节点的删除" class="headerlink" title="2.1 访问单个节点的删除"></a>2.1 访问单个节点的删除</h3><p>描述：</p><p>编写代码，移除未排序链表中的重复节点。<br>进阶：不使用临时缓冲区</p><p>解法：</p><p>使用散列表，直接迭代访问整个链表，将每个节点加入散列表，若发现重复元素，将该节点从链表中删除，然后继续迭代。一次扫描完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(ListNode* n)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(n-&gt;val) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            pre-&gt;next = n-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[n-&gt;val] = <span class="number">1</span>;</span><br><span class="line">            pre = n;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶：不使用缓冲区。<br>用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点是否重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除后续值相同的节点</span></span><br><span class="line">        ListNode* runner = current;</span><br><span class="line">        <span class="keyword">while</span> (runner-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runner-&gt;next-&gt;val == current-&gt;val) &#123;</span><br><span class="line">                runner-&gt;next = runner-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runner = runner-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空间复杂度O(1), 时间复杂度O(N^2)</span></span><br></pre></td></tr></table></figure><h3 id="2-2-倒数第k个节点"><a href="#2-2-倒数第k个节点" class="headerlink" title="2.2 倒数第k个节点"></a>2.2 倒数第k个节点</h3><p>描述：</p><p>实现一个算法，找出单向链表中倒数第K个节点。</p><p>解法1：链表长度已知</p><p>若链表长度已知，那么倒数第k个节点就是第(length - k)个节点，直接迭代访问即可，比较简单。</p><p>解法2：递归</p><p>递归访问整个链表，当抵达链表末端时，该方法回传一个置为零的计数器，之后每次调用都会计数器加一。当计数器等于k时，表示访问的是倒数第k个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">nthToLast</span><span class="params">(ListNode* head, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* node = <span class="built_in">nthToLast</span>(head-&gt;next, k, i);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* l1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">10</span>);</span><br><span class="line">    l1 = <span class="built_in">fun</span>(l1);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ListNode* node = <span class="built_in">nthToLast</span>(l1, <span class="number">3</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-删除某个节点"><a href="#2-3-删除某个节点" class="headerlink" title="2.3 删除某个节点"></a>2.3 删除某个节点</h3><p>描述：</p><p>实现一个算法，删除单向链表中间的某个节点，假定只能访问该节点。</p><p>解法：</p><p>访问不到链表的首节点，只能访问待删除节点。解法很简单，直接将后继节点的数据复制到当前节点，然后删除该节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNode</span><span class="params">(ListNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">nullptr</span> || n-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* next = n-&gt;next;</span><br><span class="line">    n-&gt;val = next-&gt;val;</span><br><span class="line">    n-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，若待删除节点为链表的尾节点，则这个问题无解。</p><h3 id="2-4-链表分割"><a href="#2-4-链表分割" class="headerlink" title="2.4 链表分割"></a>2.4 链表分割</h3><p>描述：</p><p>现有一链表的头指针 ListNode* <strong>pHead</strong>，给一定值x，以x为基准将链表分割成两部分，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。</p><p>解法：</p><p>不必移动和交换元素，直接创建两个链表，一个链表存储小于x的元素，一个链表存储大于等于x的元素。迭代访问整个链表，将元素插入before或after链表中。一旦抵达链表末端，表面拆分完成，最后合并两个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* pHead, in</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// write code here</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* beforeStart = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* beforeEnd = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* afterStart = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* afterEnd = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* cur = pHead;</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 分割链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ListNode* next = cur-&gt;next; <span class="comment">// 临时变量记录后继结点</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cur-&gt;next = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (cur-&gt;val &lt; x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 将节点插入before链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (beforeStart == <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeStart = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd-&gt;next = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd = beforeEnd-&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 将节点插入after链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (afterStart == <span class="literal">nullptr</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">                afterStart = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd-&gt;next = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd = afterEnd-&gt;ne</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        cur = next;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (beforeStart == <span class="literal">nullptr</span>) <span class="keyword">return</span> afterStart;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 合并链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    beforeEnd-&gt;next = afterStart;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> beforeStart;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-5-链式A-B"><a href="#2-5-链式A-B" class="headerlink" title="2.5 链式A+B"></a>2.5 链式A+B</h3><p>描述：</p><p>将两个反向存储在链表中的整数求和（即整数的个位存放在了链表首部，一位数对应一个节点），返回的结果仍用链表形式。给定两个链表ListNode* <strong>A</strong>，ListNode* <strong>B</strong>，请返回A+B的结果(ListNode*)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&#123;1,2,3&#125;,&#123;3,2,1&#125;</span><br><span class="line">返回：&#123;4,4,4&#125;</span><br><span class="line">&#123;7,1,6&#125;,&#123;5,9,2&#125;</span><br><span class="line">返回：&#123;2,1,9&#125;</span><br></pre></td></tr></table></figure><p>解法：</p><p>递归模拟，两个节点的值相加，如有进位则转入下一节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addList</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">addList</span><span class="params">(ListNode* a, ListNode* b, <span class="keyword">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> val = carry;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val += a-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val += b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    res-&gt;val = val % <span class="number">10</span>;</span><br><span class="line">    ListNode* more = <span class="built_in">addList</span>(a == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : a-&gt;next, b == <span class="literal">nullptr</span> ?</span><br><span class="line">                             <span class="literal">nullptr</span> : b-&gt;next, val &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    res-&gt;next = more;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode* haha = b;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        b-&gt;val += a-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            b-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">                b-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b-&gt;next-&gt;val++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            b-&gt;next = a-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-有环链表的环路开头节点"><a href="#2-6-有环链表的环路开头节点" class="headerlink" title="2.6 有环链表的环路开头节点"></a>2.6 有环链表的环路开头节点</h3><p>描述：</p><p>给定一个有环链表，实现一个算法返回环路的开头节点。</p><p>解法：</p><ul><li>创建两个指针：fast和slow；</li><li>slow每走1步，fast走2步；</li><li>两者碰在一起时，将slow指向链表的头节点head，fast保持不变</li><li>以相同的速度移动slow和fast，一次走1步，返回新的碰撞处。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findBeginning</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出第一次相遇的位置</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;<span class="comment">// 碰撞</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误检查：没有碰撞即没有环路</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow指向链表首部，fast不变，直到第二次相遇</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回环路起始点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-回文链表"><a href="#2-7-回文链表" class="headerlink" title="2.7 回文链表"></a>2.7 回文链表</h3><p>描述：编写一个函数，检查链表是否为回文。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&#123;1,2,3,2,1&#125;</span><br><span class="line">返回：true</span><br><span class="line">&#123;1,2,3,2,3&#125;</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure><p>解法1：反转并比较</p><p>反转整个链表，然后比较反转链表和原始链表。若两者相同，则该链表为回文。<br>注意，在比较原始链表和反转链表时，其实只需比较链表的前半部分。若原始链表和反转链表的前半部分相同，那么，两者的后半部分肯定相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode* revered = <span class="built_in">reverseList</span>(pHead);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isEqual</span>(pHead, revered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">        n-&gt;next = res;</span><br><span class="line">        res = n;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">nullptr</span> &amp;&amp; b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;val != b-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：迭代法</p><p>将链表前半部分反转，利用栈来实现。<br>入栈有两种方式，若链表长度已知：可以用for循环迭代访问前半部分节点，将每个节点入栈；<br>若链表长度未知，使用快慢指针，迭代访问链表，在快指针到达链表尾部时，慢指针刚好在链表中间位置。<br>至此，栈里就存放了链表前半部分的所有节点，不过顺序是相反的。接下来，只需迭代访问链表余下节点。每次迭代时，比较当前节点和栈顶元素，若完成迭代时比较结果完全相同，则该链表是回文序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">// 链表前半部分元素入栈，偶数个节点fast最后指向nullptr，奇数个节点fast最后指向最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(slow-&gt;val);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数个节点，跳过中间节点</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">nullptr</span> &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 判断回文</span></span><br><span class="line">        <span class="keyword">if</span> (top != slow-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法3：递归法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* myLeft = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    myLeft = pHead;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tranverse</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tranverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">tranverse</span>(right-&gt;next);       </span><br><span class="line">    res = (res &amp;&amp; right-&gt;val == myLeft-&gt;val);</span><br><span class="line">    myLeft = myLeft-&gt;next;                  </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="3-1-三合一"><a href="#3-1-三合一" class="headerlink" title="3.1 三合一"></a>3.1 三合一</h3><p>描述：</p><p>如何只用一个数组来实现三个栈。</p><p>解法：</p><p>固定分割：将整个数组三等分，并将每个栈的增长限制在各自的空间里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedMultiStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> numberOfStacks = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> stackCapacity;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sizes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FixedMultiStack</span>(<span class="keyword">int</span> stackSize) : <span class="built_in">stackCapacity</span>(stackSize) &#123;</span><br><span class="line">        values.<span class="built_in">resize</span>(stackSize * numberOfStacks);</span><br><span class="line">        sizes.<span class="built_in">resize</span>(numberOfStacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将值压入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> throws FullStackException </span>&#123; </span><br><span class="line"><span class="comment">/* 检查有空间容纳下一个元素 */</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isFull</span>(stackNum)) &#123; </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">FullStackException</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 对栈顶指针加 1 并更新顶部的值 */</span> </span><br><span class="line">        sizes[stackNum]++; </span><br><span class="line">        values[<span class="built_in">indexOfTop</span>(stackNum)] = value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(stackNum)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> topIndex = <span class="built_in">indexOfTop</span>(stackNum);</span><br><span class="line">        <span class="keyword">int</span> value = values[topIndex]; <span class="comment">// 获取顶部元素</span></span><br><span class="line">        values[topIndex] = <span class="number">0</span>; <span class="comment">// 清零</span></span><br><span class="line">        sizes[stackNum]--; <span class="comment">// 缩减大小</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizes[stackNum] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizes[stackNum] == stackCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回栈顶元素索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IndexOfTop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = stackNum * stackCapacity;</span><br><span class="line">        <span class="keyword">int</span> size = sizes[stackNum];</span><br><span class="line">        <span class="keyword">return</span> offset + size - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-栈的最小值"><a href="#3-2-栈的最小值" class="headerlink" title="3.2 栈的最小值"></a>3.2 栈的最小值</h3><p>描述：</p><p>请设计一个栈，除了 pop 与 push 函数，还支持 min 函数，其可返回栈元素中的最小值。执行 push、pop 和 min 操作的时间复杂度必须为O(1)。</p><p>解法：</p><p>每个节点记录当前最小值。这么一来，要找到 min，直接查看栈顶元素就能得到最小值。缺点是栈很大时，每个元素都要记录min，会浪费大量空间。改进：用其他的栈来记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1; <span class="comment">// 数据栈</span></span><br><span class="line">    satck&lt;<span class="keyword">int</span>&gt; s2; <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= <span class="built_in">min</span>()) &#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = s1.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="built_in">min</span>()) &#123;</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-集合栈"><a href="#3-3-集合栈" class="headerlink" title="3.3 集合栈"></a>3.3 集合栈</h3><p>描述：</p><p>请实现一种数据结构SetOfStacks，由多个大小为size的栈组成，当前一个栈填满时，则新建一个栈，且也可以与普通栈一样拥有相同的push和pop操作。<br>现给定一个操作序列<code>int[][2] </code>ope(C++为<code>vector&lt;vector&lt;int&gt;&gt;</code>)，若执行push操作则第一个数为1，第二个数为应push的数字；若执行pop操作，则第一个数为2，第二个数为空。返回值为int[]<a href="C++%E4%B8%BA%60vector%3Cvector%3Cint%3E%3E%60"></a>，即为变动后的SetOfStacks，顺序从下到上，初始SetOfStacks为空，并保证数据合法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">setOfStacks</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ope, <span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = ope.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ope[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>().<span class="built_in">size</span>() == size) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">back</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-双栈排序"><a href="#3-4-双栈排序" class="headerlink" title="3.4 双栈排序"></a>3.4 双栈排序</h3><p>描述：</p><p>给定一个<code>int[] numbers</code>(C++中为<code>vector&lt;int&gt;</code>)，其中第一个元素为栈顶，请编写程序将栈进行升序排列（即<strong>最大元素位于栈顶</strong>），返回排序后的栈。要求最多使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。并注意这是一个栈，意味着排序过程中只能访问到最后一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">返回：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>解法：</p><p>s1为原先的栈，s2为最终排好序的栈，若要对s1排序，可以从s1逐一弹出元素，然后按顺序插入s2中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoStacksSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 把s1中的每个元素有序地插入到tmp中</span></span><br><span class="line">        <span class="keyword">int</span> top = s1.<span class="built_in">top</span>();</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>() &amp;&amp; tmp.<span class="built_in">top</span>() &gt; top) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">            tmp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 将tmp中元素复制回s</span></span><br><span class="line">    <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = tmp.<span class="built_in">top</span>();</span><br><span class="line">        s1.<span class="built_in">push</span>(top);</span><br><span class="line">        res.<span class="built_in">push_back</span>(top);</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h2><h3 id="4-1-二叉树平衡检查"><a href="#4-1-二叉树平衡检查" class="headerlink" title="4.1 二叉树平衡检查"></a>4.1 二叉树平衡检查</h3><p>描述：</p><p>平衡的定义如下，已知对于树中的任意一个结点，若其两颗子树的高度差不超过1，则我们称该树平衡。现给定指向树根结点的指针<code>TreeNode* root</code>，请编写函数返回一个bool，表示该二叉树是否平衡。</p><p>解法：</p><p>递归访问整棵树，计算每个节点的两个子树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">int</span> diff = <span class="built_in">getHeight</span>(root-&gt;left) - <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(diff) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBalance</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalance</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root -&gt; left), <span class="built_in">getHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：<code>getHeight</code>函数不仅可以检查高度，还能检查这棵树是否平衡。从根节点递归向下检查每棵子树的高度，设计<code>checkHeight</code>函数，若子树平衡返回子树的实际高度，若子树不平衡返回-1并中断执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkHeight</span>(root) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 高度为0</span></span><br><span class="line">    <span class="comment">// 检查左子树是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> leftHeight = <span class="built_in">checkHeight</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 检查右子树是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> rightHeight = <span class="built_in">checkHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 检查当前节点是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> diff = leftHeight - rightHeight;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(diff) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不平衡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>; <span class="comment">// 返回高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-高度最小的BST"><a href="#4-2-高度最小的BST" class="headerlink" title="4.2 高度最小的BST"></a>4.2 高度最小的BST</h3><p>描述：</p><p>给定一个元素各不相同的有序序列int[] vals（升序排列）,请编写算法创建一棵高度最小的二叉查找树，并返回二叉查找树的高度。</p><p>解法：</p><p>递归方法创建高度最小的BST。将数组中间位置的元素插入树中，数组左半部分插入左子树，数组右半部分插入右子树，递归处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildMinimalBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    TreeNode* root = <span class="built_in">createMinBST</span>(vals, <span class="number">0</span>, vals.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">createMinBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; start) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode* n = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[mid]);</span><br><span class="line">    n-&gt;left = <span class="built_in">createMinBST</span>(vals, start, mid - <span class="number">1</span>);</span><br><span class="line">    n-&gt;right = <span class="built_in">createMinBST</span>(vals, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root -&gt; left), <span class="built_in">getHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-输出单层节点"><a href="#4-3-输出单层节点" class="headerlink" title="4.3 输出单层节点"></a>4.3 输出单层节点</h3><p>描述：</p><p>已知二叉树的根结点指针TreeNode* root以及链表上结点的深度，请设计算法返回一个链表ListNode，该链表代表该深度上所有结点的值，并按树上从左往右的顺序链接，深度不能超过树的高度，且树上结点的值为不大于100000的非负整数。</p><p>解法：</p><p>广度优先遍历，从根节点开始迭代，处于第i层时，表明访问过第i-1层的所有节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getTreeLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* res = node;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (deep == dep - <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                node-&gt;next = tmp;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-检查是否为BST"><a href="#4-4-检查是否为BST" class="headerlink" title="4.4 检查是否为BST"></a>4.4 检查是否为BST</h3><p>描述：</p><p>现给定树的根结点指针TreeNode* <strong>root</strong>，编辑函数返回一个bool值，判断该树是否为二叉查找树。</p><p>解法：</p><p>假定没有重复的值，可以采用中序遍历。BST中序遍历结果为递增序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">process</span>(arr, root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i<span class="number">-1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历BST</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">process</span>(arr, root-&gt;left);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">process</span>(arr, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：最小与最大法</p><p>二叉搜索树的条件：所有左边的节点必须小于或等于当前节点，而当前节点必须小于所有右边的节点。<br>迭代遍历整个树，自上而下传递最小与最大值，逐渐变窄的范围检查各个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* root, <span class="keyword">int</span> minval, <span class="keyword">int</span> maxval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; minval || root-&gt;val &gt; maxval) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, minval, root-&gt;val) &amp;&amp; </span><br><span class="line">        <span class="built_in">check</span>(root-&gt;right, root-&gt;val, maxval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-寻找下一个节点"><a href="#4-5-寻找下一个节点" class="headerlink" title="4.5 寻找下一个节点"></a>4.5 寻找下一个节点</h3><p>描述：</p><p>给定树的根结点指针TreeNode* root和结点的值int p，编写一个函数，寻找该二叉树中指定结点的下一个结点（即中序遍历的后继），并返回p结点的后继结点的值。保证结点的值是小于等于100000的正数且没有重复值，若不存在后继返回-1。</p><p>解法：</p><p>递归中序遍历。当节点值等于p，标记为true，返回遍历的下一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSucc</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findSuccCore</span>(root, p, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSuccCore</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p, <span class="keyword">bool</span>&amp; sign)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 左子树中寻找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">findSuccCore</span>(root-&gt;left, p, sign);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="literal">true</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="comment">// 当前值等于p，将标记置为true</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == p) sign = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findSuccCore</span>(root-&gt;right, p, sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-最近公共祖先"><a href="#4-6-最近公共祖先" class="headerlink" title="4.6 最近公共祖先"></a>4.6 最近公共祖先</h3><p>描述：</p><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p><p>解法：</p><p>顺着一条 p 和 q 都在同一边的链子查找，也就是说，若 p 和 q 都在某节点的左边，就到左子树中查找共同祖先，若都在右边，则在右子树中查找共同祖先。要是 p 和 q不在同一边，那就表示已经找到第一个共同祖先。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">commonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 错误检查，一个节点不在树中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cover</span>(root, p) || !<span class="built_in">cover</span>(root, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> pIsOnLeft = <span class="built_in">cover</span>(root-&gt;left, p);</span><br><span class="line">    <span class="keyword">bool</span> pIsOnRight = <span class="built_in">cover</span>(root-&gt;right, q);</span><br><span class="line">    <span class="keyword">if</span> (pIsOnLeft != pIsOnRight) &#123; <span class="comment">// 两个节点位于不同的两边</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* childSize = pIsOnLeft ? root-&gt;left : root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(childSize, p, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cover</span>(root-&gt;left, p) || <span class="built_in">cover</span>(root-&gt;right, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-求和路径"><a href="#4-7-求和路径" class="headerlink" title="4.7 求和路径"></a>4.7 求和路径</h3><p>描述：</p><p>给定一棵二叉树，其中每个节点都含有一个整数数值（该值或正或负）。设计一个算法，打印节点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下（只能从父节点指向子节点方向）。</p><p>解法1：暴力解法</p><p>遍历每个节点。对于每个节点，用递归法尝试所有向下的路径，并随着递归的进行跟踪路径的和。每当得到目标和，将发现的路径数目加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从root开始，符合目标和的路径进行计数</span></span><br><span class="line">    <span class="keyword">int</span> pathFromRoot = <span class="built_in">countPathWithSumFromRoot</span>(root, target, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左节点与右节点</span></span><br><span class="line">    <span class="keyword">int</span> pathFromLeft = <span class="built_in">countPathWithSum</span>(root-&gt;left, target);</span><br><span class="line">    <span class="keyword">int</span> pathFromRight = <span class="built_in">countPathWithSum</span>(root-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pathFromRoot + pathFromLeft + pathFromRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从根节点开始，符合目标和的路径总数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSumFromRoot</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum += node-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalPath = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123; <span class="comment">// 找到一条从root开始的路径</span></span><br><span class="line">        totalPath++;</span><br><span class="line">    &#125;</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSumFromRoot</span>(node-&gt;left, target, sum);</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSumFromRoot</span>(node-&gt;right, target, sum);</span><br><span class="line">    <span class="keyword">return</span> totalPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：优化算法</p><p>使用哈希表减少重复计算。使用深度优先查找对树进行遍历。当我们访问每个节点时，执行以下操作。(1) 跟踪 runningSum 的值。我们将使该变量成为函数的一个参数，并对其增加 node.value。<br>(2) 在散列表中查找 runningSum - targetSum。我们从散列表获得的值为路径的总数。将变量 totalPaths 的值设置为该值。<br>(3) 如果 runningSum == targetSum，则发现了另外一条从根节点开始的路径。将变量 totalPaths加 1。<br>(4) 将 runningSum 加入到散列表中（如果 runningSum 已经存在，则将增加其值）。<br>(5) 对左子树和右子树进行递归，计算和为 targetSum 的路径的条数。<br>(6) 对左子树和右子树的递归调用结束后，减少散列表中 runningSum 对应的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(root, target, <span class="number">0</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 基础情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对终止于该节点，符合目标和的路径进行计数</span></span><br><span class="line">    sum += node-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> diff = sum - target;</span><br><span class="line">    <span class="comment">//map[diff] = 0;</span></span><br><span class="line">    <span class="keyword">int</span> totalPath = map[diff];</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        totalPath++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map[sum]++;</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSum</span>(node-&gt;left, target, sum, map);</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSum</span>(node-&gt;right, target, sum, map);</span><br><span class="line">    map[sum]--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归与动态规划"><a href="#递归与动态规划" class="headerlink" title="递归与动态规划"></a>递归与动态规划</h2><h3 id="5-1-加到n"><a href="#5-1-加到n" class="headerlink" title="5.1 加到n"></a>5.1 加到n</h3><p>描述：</p><p>给定一个正整数int <strong>n</strong>，从0开始加到n，每次可增加1、2或3，直到其大于等于n，请返回一个数，代表加到n的方案的个数。保证n小于等于100000，并为了防止溢出，请将结果Mod 1000000007。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试样例1：</span><br><span class="line">1</span><br><span class="line">返回：1</span><br><span class="line">测试样例2：</span><br><span class="line">3</span><br><span class="line">返回：4</span><br><span class="line">测试样例3：</span><br><span class="line">4</span><br><span class="line">返回：7</span><br></pre></td></tr></table></figure><p>解法：</p><p>暴力解求解：递归，指数级增长，会超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countWays</span>(n - <span class="number">1</span>) + <span class="built_in">countWays</span>(n - <span class="number">2</span>) + <span class="built_in">countWays</span>(n - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：制表法，利用memo数组记录中间过程的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//memo[1] = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countWaysCore</span>(n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWaysCore</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memo[n] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memo[n] = ((<span class="built_in">countWaysCore</span>(n - <span class="number">1</span>, memo)  </span><br><span class="line">                    + <span class="built_in">countWaysCore</span>(n - <span class="number">2</span>, memo))% <span class="number">1000000007</span></span><br><span class="line">                   + <span class="built_in">countWaysCore</span>(n - <span class="number">3</span>, memo))% <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-机器人走方格I"><a href="#5-2-机器人走方格I" class="headerlink" title="5.2 机器人走方格I"></a>5.2 机器人走方格I</h3><p>描述：</p><p>给定两个正整数int <strong>x</strong>,int <strong>y</strong>，代表一个x乘y的网格，现有一个机器人要从网格左上角顶点走到右下角，每次只能走一步且只能向右或向下走，返回机器人有多少种走法。保证x＋y小于等于12。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">2,2</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure><p>解法：</p><p>假设网格r行c列，移动到(r, c), 需要先移动到相邻点(r-1, c)或(r, c-1)。<br>动态规划，用一个二维表dp记录每个点的走法，<code>dp[r][c] = dp[r - 1][c] + dp[r][c - 1]</code>.<br>需要注意边界的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> dp[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp[1][1] = 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= y; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-机器人走方格II"><a href="#5-3-机器人走方格II" class="headerlink" title="5.3 机器人走方格II"></a>5.3 机器人走方格II</h3><p>描述：</p><p>给定一个int[][] <strong>map</strong>(C++ 中为vector &gt;)网格图，若map[i][j]为1则该点不是障碍点，否则为障碍点。另外给定int <strong>x</strong>,int <strong>y</strong>，表示网格的大小。现有一个机器人要从网格左上角走到右下角，只能走格点且只能向右或向下走。请返回机器人从(0,0)走到(x - 1,y - 1)有多少种走法。请将结果Mod 1000000007以防止溢出，并保证x和y均小于等于50。</p><p>解法：</p><p>动态规划，建立dp表存储中间结果，如果<code>map[r][c]</code>值不为1，则<code>dp[r][c] = 0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; map, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(x, vector&lt;<span class="keyword">int</span>&gt;(y, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[i][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; y; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x - <span class="number">1</span>][y - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-魔术索引"><a href="#5-4-魔术索引" class="headerlink" title="5.4 魔术索引"></a>5.4 魔术索引</h3><p>描述：</p><p>已知数组<strong>A</strong>[0..n-1]和数组大小<strong>n</strong>（升序数组，元素值各不相同），若存在A[i]=i则称该数组有魔术索引，请判断该数组是否存在魔术索引，返回值为bool，要求复杂度优于o(n)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure><p>解法：</p><p>有序数组，二分查找，要找出元素k，会先拿它跟数组中间的元素 x比较，确定k位于x的左边还是右边。递归二分查找：（数组中没有重复的值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findMagicIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; mid)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, start, mid - <span class="number">1</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, end); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶：数组中有重复的值，判断是否存在魔术索引。</p><p>解法：如果数组元素有重复值，前面的算法就会失效。如果 A[mid] &lt; mid，我们无法断定魔术索引位于数组哪一边。它可能在数组右侧，也可能在左侧。<br>二分递归：（也适用于不存在重复的值，暴力解法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findMagicIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, start, mid - <span class="number">1</span>) || <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, end); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-子集"><a href="#5-5-子集" class="headerlink" title="5.5 子集"></a>5.5 子集</h3><p>描述：</p><p>已知数组<strong>A</strong>和其大小<strong>n</strong>，请返回A的所有非空子集。要求A中元素个数不大于20且互异。各子集内部从大到小排序,子集间字典逆序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[123,456,789]</span><br><span class="line">返回：&#123;[789,456,123],[789,456],[789,123],[789],[456 123],[456],[123]&#125;</span><br></pre></td></tr></table></figure><p>解法：</p><p>递归，path记录中间过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">getSubsets</span>(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">    <span class="comment">// res.clear();</span></span><br><span class="line">    <span class="comment">// path.clear();</span></span><br><span class="line">    <span class="built_in">recur</span>(A, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= arr.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">recur</span>(arr, i + <span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++并发编程笔记</title>
      <link href="/posts/20a59019/"/>
      <url>/posts/20a59019/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h1><p>并发，指两个或两个以上的独立活动同时发生。</p><p>计算机的并发，指在单个系统里同时执行多个独立的任务。</p><p>并发的两种方式：真正并行 vs 任务切换</p><p><img src="/20220627/1-1.png" alt="1-1"></p><p>四个任务在双核处理器上的任务切换，仍是将任务整齐地划分为同等大小子任务块的理想情况。实际上，许多因素会使得任务分割不均或调度不规则。</p><p><img src="/20220627/1-2.png" alt="1-2"></p><p>四个任务在两个核心之间的切换</p><h2 id="并发的方式"><a href="#并发的方式" class="headerlink" title="并发的方式"></a>并发的方式</h2><ul><li>多进程并发</li><li>多线程并发</li></ul><p><strong>多进程并发：</strong>将应用程序分为多个独立的进程同时运行，就像同时进行网页浏览和文字处理一样。</p><p>独立的进程可以通过进程间的通信渠道传递讯息(信号、套接字、文件、管道等等)。</p><p><img src="/20220627/1-3.png" alt="1-3"></p><p>缺点：</p><ul><li>进程间的通信非常复杂，速度很慢，因为操作系统会对进程进行保护，以避免一个进程去修改另一个进程的数据。</li><li>运行多个进程的固定开销大：需要时间启动进程，操作系统需要资源来管理进程等等。</li></ul><p><strong>多线程并发：</strong>在单进程中运行多个线程。</p><p>线程很像轻量级的进程：每个线程相互独立运行，并且可以在不同的指令序列中运行。不过，进程中的所有线程都共享地址空间，并且能访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</p><p><img src="/20220627/1-4.png" alt="1-4"></p><p>一个进程中的两个线程，正在通过共享内存进行通信。</p><p>地址空间共享，以及缺少线程间的数据保护，使得操作系统记录的工作量减小，所以使用多线程的开销远远小于多进程。不过，共享内存的灵活性是有代价的：如果多个线程访问数据，那么必须确保每个线程所访问到的数据一致，这就需要对线程通信做大量的工作。</p><h2 id="使用并发的原因"><a href="#使用并发的原因" class="headerlink" title="使用并发的原因"></a>使用并发的原因</h2><p>原因有二：分离关注点（SOC）、性能</p><ul><li><p>分离关注点。通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能。即使一些操作需要同时进行，依旧可以使用并发，分离不同的功能区域。</p></li><li><p>性能。两种利用并发提高性能的方式：</p><ul><li>任务并行：将一个单个任务分成几部分并行运行，从而降低总运行时间</li><li>数据并行：一个线程执行算法的一部分，而另一个线程执行算法的另一个部分，每个线程在不同的数据块上执行相同的操作</li></ul></li></ul><p><strong>什么时候不使用并发：</strong></p><p>收益比不上成本。使用并发的代码在很多情况下难以理解，因此编写和维护多线程代码会产生脑力成本，而增加的复杂性也可能会引起更多的错误。</p><p>线程的资源有限。如果太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。不仅如此，因为每个线程都需要一个独立的堆栈，所以运行太多的线程也会耗尽进程的可用内存或地址空间。</p><p>运行越多的线程，操作系统就需要越多的上下文切换，每一次切换都需要耗费时间。所以在某些时候，增加线程实际上会降低应用的整体性能。</p><h2 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h2><p>C++多线程程序和其他C++程序差不多。唯一的区别在于某些函数可以并发运行，所以需要确保共享数据在并发访问时是安全的。</p><p>例子：打印“Hello World”的程序</p><p>单线程运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动独立的线程显示信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>  <span class="comment">// 1 标准库中对多线程支持的声明</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  <span class="comment">// 2 独立的函数打印信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">// 3 构造名为t的std::thread对象拥有新函数hello()作为其执行函数</span></span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">// 4 当前线程等待t线程终止之后才从t.join()返回。创建线程等待std::thread对象创建的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-线程管理"><a href="#2-线程管理" class="headerlink" title="2.线程管理"></a>2.线程管理</h1><h2 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>使用C++线程库启动线程，就是构造<code>std::thread</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure><p>需要包含<code>&lt;thread&gt;</code>头文件，<code>std::thread</code>可以通过有函数操作符类型的实例进行构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure><p>代码中，提供的函数对象会复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行。</p><p>Lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something();</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something_else();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>线程启动后是要等待线程结束，还是让其自主运行。</p><p>当<code>std::thread</code>对象销毁之前还没有做出决定，程序就会终止。</p><p>即便是有异常存在，也需要确保线程能够正确<em>汇入</em>(joined)或<em>分离</em>(detached)。</p><p>如果不等待线程汇入 ，就必须保证线程结束之前，访问数据的有效性。</p><p>代码2.1：函数已经返回，线程依旧访问局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>&amp; i;</span><br><span class="line">  <span class="built_in">func</span>(<span class="keyword">int</span>&amp; i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span> ; j&lt;<span class="number">1000000</span> ; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">do_something</span>(i);           <span class="comment">// 1 潜在访问隐患：空引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  my_thread.<span class="built_in">detach</span>();          <span class="comment">// 2 不等待线程结束</span></span><br><span class="line">&#125;                              <span class="comment">// 3 新线程可能还在运行</span></span><br></pre></td></tr></table></figure><p>可能会出现新线程访问已经销毁的变量。过程如下：</p><table><thead><tr><th align="center">主线程</th><th align="center">新线程</th></tr></thead><tbody><tr><td align="center">使用some_local_state构造my_func</td><td align="center"></td></tr><tr><td align="center">开启新线程my_thread</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">启动</td></tr><tr><td align="center"></td><td align="center">调用func::operator()</td></tr><tr><td align="center">将my_thread分离</td><td align="center">执行func::operator();可能会在do_something中调用some_local_state的引用</td></tr><tr><td align="center">销毁some_local_state</td><td align="center">持续运行</td></tr><tr><td align="center">退出oops函数</td><td align="center">持续执行func::operator()；可能会在do_something中调用some_local_state的引用 –&gt; 导致未定义行为</td></tr></tbody></table><p>常规处理方法：</p><ul><li><p>将数据复制到线程中。对于对象中包含的指针和引用需谨慎。使用访问局部变量的函数去创建线程是一个糟糕的主意。</p></li><li><p>可以通过join()函数来确保线程在主函数完成前结束。</p></li></ul><h3 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h3><p>如需等待线程，需要使用**join()**。</p><p>将例2-1中的<code>my_thread.detach()</code>替换为<code>my_thread.join()</code>，就可以确保局部变量在线程完成后才销毁。</p><p>只能对一个线程使用一次join()，一旦使用过join()，<code>std::thread</code>对象就不能再次汇入了。当对其使用joinable()时，将返回false。</p><h3 id="特殊情况下的等待"><a href="#特殊情况下的等待" class="headerlink" title="特殊情况下的等待"></a>特殊情况下的等待</h3><p>避免应用被抛出的异常所终止。通常，在无异常的情况下使用join()时，需要在异常处理过程中调用join()，从而避免生命周期的问题。</p><p>代码2.2 等待线程完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在代码2.1中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 1 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">// 2 正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用“资源获取即初始化方式”(RAII，Resource Acquisition Is Initialization)，提供一个类，在析构函数中使用join()。</p><p>代码2.3 使用RAII等待线程完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">    t(t_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">thread_guard</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.<span class="built_in">joinable</span>()) <span class="comment">// 1 判断线程是否可以汇入</span></span><br><span class="line">    &#123;</span><br><span class="line">      t.<span class="built_in">join</span>();      <span class="comment">// 2 汇入</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">thread_guard</span>(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;   <span class="comment">// 3 不让编译器自动生成拷贝或赋值</span></span><br><span class="line">  thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在代码2.1中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;    <span class="comment">// 4 thread_guard对象g是第一个被销毁的，</span></span><br><span class="line"><span class="comment">// 即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。</span></span><br></pre></td></tr></table></figure><h3 id="后台运行线程"><a href="#后台运行线程" class="headerlink" title="后台运行线程"></a>后台运行线程</h3><p>detach()会让线程在后台运行，这就意味着与主线程不能直接交互。</p><p>守护线程（daemon threads）：分离线程，UNIX中是指没有任何显示的接口，在后台运行的线程。特点是长时间运行。</p><p>分离线程只能确定线程什么时候结束，发后即忘的任务使用分离线程。</p><p>代码2-4 使用分离线程处理文档</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_document</span><span class="params">(std::string <span class="keyword">const</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">open_document_and_display_gui</span>(filename);</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done_editing</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    user_command cmd=<span class="built_in">get_user_input</span>();</span><br><span class="line">    <span class="keyword">if</span>(cmd.type==open_new_document)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string <span class="keyword">const</span> new_name=<span class="built_in">get_filename_from_user</span>();</span><br><span class="line">      <span class="function">std::thread <span class="title">t</span><span class="params">(edit_document,new_name)</span></span>;  <span class="comment">// 1 打开新文档，可以传入函数名和函数所需参数</span></span><br><span class="line">      t.<span class="built_in">detach</span>();  <span class="comment">// 2 分离线程，新线程打开另一个文件，edit_document函数可以复用，并通过传参的形式打开新的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">process_user_input</span>(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>向可调用对象或函数传递参数很简单，只需要将这些参数作为 <code>std::thread</code>构造函数的附加参数即可。</p><p>即使函数中的参数是引用的形式，拷贝操作也会执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>代码创建了一个调用f(3, “hello”)的线程。函数f需要一个<code>std::string</code>对象作为第二个参数，但这里使用的是字符串的字面值，也就是<code>char const *</code>类型，线程的上下文完成字面值向<code>std::string</code>的转化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_oops</span><span class="params">(<span class="keyword">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// buffer是一个指针变量，指向局部变量</span></span><br><span class="line">  <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,std::string(buffer))</span></span>;  <span class="comment">// 使用std::string，将字面值转化为std::string避免悬空指针</span></span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部代码会将拷贝的参数以右值的方式进行传递，这是为了那些只支持移动的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">display_status</span>();</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">process_widget_data</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数期望的是一个非常量引用作为参数(而非右值)，所以会在编译时出错。可以使用<code>std::ref</code>将参数转换成引用的形式。因此可将线程的调用改为以下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,std::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><p>update_data_for_widget就会收到data的引用，而非data的拷贝副本，这样代码就能顺利的通过编译了。</p><p>如果提供的参数支持移动（move），不能拷贝。</p><p><code>std::unique_ptr</code>(C++11中的智能指针)，为动态分配的对象提供内存自动管理机制(类似垃圾回收机制)。同一时间内，只允许一个<code>std::unique_ptr</code>实例指向一个对象，并且当这个实例销毁时，指向的对象也将被删除。</p><p><em>移动构造函数</em>(move constructor)和<em>移动赋值操作符</em>(move assignment operator)允许一个对象的所有权在多个<code>std::unique_ptr</code>实例中传递。使用“移动”转移对象所有权后，就会留下一个空指针。</p><p><code>std::move</code>转移动态对象的所有权到线程中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(std::unique_ptr&lt;big_object&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>;</span><br><span class="line">p-&gt;<span class="built_in">prepare_data</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(process_big_object,std::move(p))</span></span>;</span><br><span class="line"><span class="comment">// big_object 对象的所有权首先被转移到新创建线程的的内部存储中，之后再传递给process_big_object函数。</span></span><br></pre></td></tr></table></figure><p>线程的所有权可以在多个<code>std::thread</code>实例中转移，这依赖于<code>std::thread</code>实例的<strong>可移动</strong>且<strong>不可复制</strong>性。</p><p>可移动性：使得开发者可以自己决定，哪个实例拥有线程实际执行的所有权。</p><p>不可复制性：在某一时间点，一个<code>std::thread</code>实例只能关联一个执行线程。</p><h2 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h2><p>例子，创建两个执行进程，并在<code>std::thread</code>实例之间(t1，t2和t3)转移所有权：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1 新线程与t1相关联</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1);            <span class="comment">// 2 t1所有权转移给t2，执行some_function的函数线程与t2关联。</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function);    <span class="comment">// 3 临时std::thread对象相关的线程启动</span></span><br><span class="line">std::thread t3;                            <span class="comment">// 4 默认构造方式创建，没有与任何线程进行关联</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2); <span class="comment">// 5 移动操作后，t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure><p>最后的移动操作，将some_function线程的所有权转移给t1，但是t1已经有了一个关联的线程（执行some_other_function的线程），所以这里系统直接调用<code>std::terminate()</code>终止程序继续运行。</p><p><code>std::terminate()</code>不抛出异常，是noexpect函数，保证与<code>std::thread</code>的析构函数的行为一致。</p><p>线程对象析构前，显式的等待线程完成或分离它，即不能通过赋新值给<code>std::thread</code>对象的方式”丢弃“一个线程。</p><p><code>std::thread</code>支持移动，线程的所有权可以在函数外进行转移。</p><p>代码2.5 函数返回<code>std::thread</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">thread</span>(some_function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有权可以在函数内部传递，允许<code>std::thread</code>实例作为参数进行传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::thread t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">f</span>(std::<span class="built_in">thread</span>(some_function));</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">  <span class="built_in">f</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确保线程在程序退出前完成，定义了scoped_thread类。</p><p>代码2.6 scoped_thread的用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span>: // <span class="number">1</span></span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())  <span class="comment">// 2 检测线程是否可汇入放在构造函数中，不可汇入则抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“No thread”);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scoped_thread</span>(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在代码2.1中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(std::thread(func(some_local_state)))</span></span>;    <span class="comment">// 4 新线程会直接传递到scoped_thread中</span></span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125; <span class="comment">// 5 scoped_thread对象就会销毁，然后在析构函数中完成汇入3</span></span><br></pre></td></tr></table></figure><p>代码2.7 joining_thread类的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">joining_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span>=<span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable,<span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(Callable&amp;&amp; func,Args&amp;&amp; ... args)</span>:</span></span><br><span class="line"><span class="function">    t(std::forward&lt;Callable&gt;(func),std::forward&lt;Args&gt;(args)...)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(std::thread t_)</span> <span class="keyword">noexcept</span>:</span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">joining_thread</span>(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span>:</span><br><span class="line">    <span class="built_in">t</span>(std::<span class="built_in">move</span>(other.t))</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  joining_thread&amp; <span class="keyword">operator</span>=(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>（<span class="built_in">joinable</span>()）&#123;</span><br><span class="line">      <span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    t = std::<span class="built_in">move</span>(other.t);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  joining_thread&amp; <span class="keyword">operator</span>=(std::thread other) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">      <span class="built_in">join</span>();</span><br><span class="line">    t=std::<span class="built_in">move</span>(other);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">    <span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(joining_thread&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t.<span class="built_in">swap</span>(other.t);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">get_id</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">joinable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::thread</code>中对移动语义的支持，也适用于使用<code>std::thread</code>的<strong>移动敏感</strong>(move-aware)容器(比如，<code>std::vector&lt;&gt;</code>)。了解这些后，就可以量产了一些线程，并且等待它们结束，代码如下所示。</p><p>代码2.8 量产线程，等待它们结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(do_work,i); <span class="comment">// 产生线程</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads) <span class="comment">// 对每个线程调用 join()</span></span><br><span class="line">    entry.<span class="built_in">join</span>();       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码2.8中每个线程所做的工作都是独立的，并且结果会受到共享数据的影响。</p><p>如果f()有返回值，这个返回值就依赖于线程得到的结果。写入返回值之前，程序会检查使用共享数据的线程是否终止。</p><h2 id="确定线程数量"><a href="#确定线程数量" class="headerlink" title="确定线程数量"></a>确定线程数量</h2><p><code>std::thread::hardware_concurrency()</code>在新版C++中非常有用，返回并发线程的数量。</p><p>代码2.9将整体工作拆分成小任务，交给每个线程去做，并设置最小任务数，避免产生太多的线程，程序会在操作数量为0时抛出异常。比如，<code>std::thread</code>无法启动线程，就会抛出异常。</p><p>代码2.9 并行版的<code>std::accumulate</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    result=std::<span class="built_in">accumulate</span>(first,last,result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!length) <span class="comment">// 1 输入范围为空，返回init的值</span></span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread=<span class="number">25</span>; <span class="comment">// 线程中最小任务数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads=</span><br><span class="line">      (length+min_per_thread<span class="number">-1</span>)/min_per_thread; <span class="comment">// 2 启动线程最大数量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads=</span><br><span class="line">      std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads= <span class="comment">// 3 std::thread::hardware_concurrency()返回0时，选择一个合适数字</span></span><br><span class="line">      std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size=length/num_threads; <span class="comment">// 4 每个线程中处理的元素数量</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>; <span class="comment">//  存放中间结果</span></span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;  <span class="comment">// 5 在启动之前已经有了一个线程(主线程)，所以启动的线程数必须比num_threads少1</span></span><br><span class="line"></span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>; i &lt; (num_threads<span class="number">-1</span>); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;</span><br><span class="line">    std::<span class="built_in">advance</span>(block_end,block_size);  <span class="comment">// 6 block_end迭代器指向当前块的末尾，把一个迭代器移动 n 个位置</span></span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(     <span class="comment">// 7 启动一个新线程为当前块累加结果</span></span><br><span class="line">        accumulate_block&lt;Iterator,T&gt;(),</span><br><span class="line">        block_start,block_end,std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">    block_start=block_end;  <span class="comment">// 8 当迭代器指向当前块的末尾时，启动下一个块</span></span><br><span class="line">  &#125;</span><br><span class="line">  accumulate_block&lt;Iterator,T&gt;()(</span><br><span class="line">      block_start,last,results[num_threads<span class="number">-1</span>]); <span class="comment">// 9 处理最终块的结果</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads)</span><br><span class="line">    entry.<span class="built_in">join</span>();  <span class="comment">// 10 创建线程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>(),init); <span class="comment">// 11 累加所有结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>T类型的加法不满足结合律(比如，对于float型或double型，在进行加法操作时，系统很可能会做截断操作)，因为对范围中元素的分组，会导致parallel_accumulate得到的结果可能与<code>std::accumulate</code>的结果不同。</p></li><li><p>迭代器必须是前向迭代器。</p></li><li><p>对于results容器，需要保证T有默认构造函数。</p></li></ul><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p><code>std::thread::id</code>类型，获取方式：</p><ul><li>调用<code>std::thread</code>对象的成员函数<code>get_id()</code>来直接获取。如果<code>std::thread</code>对象没有与任何执行线程相关联，<code>get_id()</code>将返回<code>std::thread::type</code>默认构造值，这个值表示“无线程”。</li><li>当前线程中调用<code>std::this_thread::get_id()</code>(这个函数定义在<code>&lt;thread&gt;</code>头文件中)也可以获得线程标识。</li></ul><p><code>std::thread::id</code>对象可以<strong>自由的拷贝和对比</strong>，因为<strong>标识符可以复用</strong>。</p><p>如果两个对象的<code>std::thread::id</code>相等，那就是同一个线程，或者都“无线程”。</p><p>如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有线程。</p><p>标准库提供<code>std::hash&lt;std::thread::id&gt;</code>容器，<code>std::thread::id</code>也可以作为无序容器的键值。</p><p>启动其他线程前，可以通过<code>std::this_thread::get_id()</code>得到自己的线程ID。每个线程都要检查一下，其拥有的线程ID是否与初始线程的ID相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id master_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(std::this_thread::<span class="built_in">get_id</span>()==master_thread)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程ID在容器中可作为键值.</p><p>可以使用输出流(<code>std::cout</code>)来记录一个<code>std::thread::id</code>对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure><h1 id="3-共享数据"><a href="#3-共享数据" class="headerlink" title="3.共享数据"></a>3.共享数据</h1><p>线程间的问题在于修改共享数据，会使不变量遭到破坏。</p><p>并行中常见错误：条件竞争(race condition)。</p><h2 id="共享数据的问题"><a href="#共享数据的问题" class="headerlink" title="共享数据的问题"></a>共享数据的问题</h2><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>并发中的竞争条件，取决于一个以上线程的执行顺序，每个线程都抢着完成自己的任务。</p><p>当不变量遭到破坏时，才会产生条件竞争。</p><p>操作要访问两个独立的数据块，独立的指令会对数据块将进行修改，并且其中一个线程可能正在进行修改，另一个线程就对数据块进行了访问。因为出现的概率低，很难查找，也很难复现。</p><h3 id="避免恶性条件竞争"><a href="#避免恶性条件竞争" class="headerlink" title="避免恶性条件竞争"></a>避免恶性条件竞争</h3><ul><li><p>最简单的办法：对数据结构采用某种保护机制，确保只有修改线程才能看到不变量的中间状态。</p><p>从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。</p></li><li><p>对数据结构和不变量进行修改，修改完的结构必须能完成一系列不可分割的变化，也就保证了每个不变量的状态，这就是所谓的<strong>无锁编程</strong>。</p></li><li><p>使用事务的方式去处理数据结构的更新。一些数据和读取都存储在事务日志中，然后将之前的操作进行合并，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”(software transactional memory (STM))</p></li></ul><h2 id="使用互斥量"><a href="#使用互斥量" class="headerlink" title="使用互斥量"></a>使用互斥量</h2><p>访问共享数据前，将数据锁住，在访问结束后，再将数据解锁。线程库需要保证，当线程使用互斥量锁住共享数据时，其他的线程都必须等到之前那个线程对数据进行解锁后，才能进行访问数据。</p><p>互斥量会造成死锁，或对数据保护的太多(或太少)</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>实例化<code>std::mutex</code>创建互斥量实例，成员函数lock()可对互斥量上锁，unlock()为解锁。</p><p>不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用unlock()(包括异常的情况)。</p><p><code>std::lock_guard</code>：在构造时就能提供已锁的互斥量，并在析构时进行解锁，从而保证了互斥量能被正确解锁。</p><p>代码3.1 使用互斥量保护列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="keyword">int</span>&gt; some_list;    <span class="comment">// 1 全局变量</span></span><br><span class="line">std::mutex some_mutex;    <span class="comment">// 2 全局的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 3 加锁，对数据访问互斥的</span></span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 4 加锁后，看不到add_to_list()修改的列表</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find) != some_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中添加了一个新特性，称为模板类参数推导，类似<code>std::lock_guard</code>这样简单的模板类型，其模板参数列表可以省略。③和④的代码可以简化成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>C++17中的一种加强版数据保护机制——<code>std::scoped_lock</code>，所以在C++17的环境下，上面的这行代码也可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>大多数情况下，互斥量通常会与需要保护的数据放在同一类中，而不是定义成全局变量。</p><p>当其中一个成员函数返回的是保护数据的指针或引用时，也会破坏数据。具有访问能力的指针或引用可以访问(并可能修改)保护数据，而不会被互斥锁限制。这就需要对接口谨慎设计，要确保互斥量能锁住数据访问，并且不留后门。</p><h3 id="保护共享数据"><a href="#保护共享数据" class="headerlink" title="保护共享数据"></a>保护共享数据</h3><p>代码3.2 无意中传递了保护数据的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  std::string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_wrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">func</span>(data);    <span class="comment">// 1 传递“保护”数据给用户函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unprotected=&amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">process_data</span>(malicious_function);    <span class="comment">// 2 传递一个恶意函数</span></span><br><span class="line">  unprotected-&gt;<span class="built_in">do_something</span>();    <span class="comment">// 3 在无保护的情况下访问保护数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中process_data看起来没有问题，<code>std::lock_guard</code>对数据做了很好的保护，但调用用户提供的函数func①，就意味着foo能够绕过保护机制将函数<code>malicious_function</code>传递进去②，可以在没有锁定互斥量的情况下调用<code>do_something()</code>。</p><p>函数<code>foo()</code>中调用<code>unprotected-&gt;do_something()</code>的代码未能被标记为互斥。</p><p>切勿将受保护数据的指针或引用传递到互斥锁作用域之外。</p><h3 id="接口间的条件竞争"><a href="#接口间的条件竞争" class="headerlink" title="接口间的条件竞争"></a>接口间的条件竞争</h3><p>代码3.3 <code>std::stack</code>容器的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=std::deque&lt;T&gt; &gt;</span><br><span class="line">class stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">stack</span>(<span class="keyword">const</span> Container&amp;);</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(<span class="keyword">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="built_in">stack</span>(<span class="keyword">const</span> Container&amp;, <span class="keyword">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="built_in">stack</span>(Container&amp;&amp;, <span class="keyword">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="built_in">stack</span>(stack&amp;&amp;, <span class="keyword">const</span> Alloc&amp;);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(stack&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span></span>; <span class="comment">// C++14的新特性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然empty()和size()可能在返回时是正确的，但结果不可靠。当返回后，其他线程就可以自由地访问栈，并且可能push()多个新元素到栈中，也可能pop()一些已在栈中的元素。这样的话，之前从empty()和size()得到的数值就有问题了。</p><p>非共享的栈对象，如果栈非空，使用empty()检查再调用top()访问栈顶部的元素是安全的。如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span> (! s.<span class="built_in">empty</span>())&#123;    <span class="comment">// 1 判断栈是否为空</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> value = s.<span class="built_in">top</span>();    <span class="comment">// 2 非空调用栈顶</span></span><br><span class="line">  s.<span class="built_in">pop</span>();    <span class="comment">// 3 弹出栈顶元素</span></span><br><span class="line">  <span class="built_in">do_something</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于共享的栈对象，这样的调用顺序就不再安全，因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除了最后一个元素。这是一个经典的条件竞争，使用互斥量对栈内部数据进行保护，但依旧不能阻止条件竞争的发生，这就是接口固有的问题。</p><p>解决：改变接口的设计</p><p>先获取顶部元素(top())，然后从栈中移除(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足，应用可能会释放一些内存，然后再进行尝试。</p><p>不幸的是，这样的分割却制造了本想避免的条件竞争。</p><p><strong>选项1：传入一个引用</strong></p><p>将变量的引用作为参数，传入pop()函数中获取“弹出值”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">some_stack.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure><p>缺点：需要构造出一个栈中类型的实例，用于接收目标值。对于一些类型，这样做是不现实的，因为临时构造一个实例，从时间和资源的角度上来看都不划算。</p><p><strong>选项2：无异常抛出的拷贝构造函数或移动构造函数</strong></p><p>一个有用的选项可以限制对线程安全栈的使用，并且能让栈安全的返回所需的值，而不抛出异常。虽然安全，但非可靠。</p><p>那些有抛出异常的拷贝构造函数，但没有移动构造函数的类型往往更多。</p><p><strong>选项3：返回指向弹出值的指针</strong></p><p>指针的优势是自由拷贝，并且不会产生异常，这样就能避免Cargill提到的异常问题了。</p><p>缺点就是返回指针需要对对象的内存分配进行管理，对于简单数据类型(比如:int)，内存管理的开销要远大于直接返回值。</p><p>使用<code>std::shared_ptr</code>，不仅能避免内存泄露(因为当对象中指针销毁时，对象也会被销毁)，而且标准库能够完全控制内存分配方案，就不需要new和delete操作。</p><p><strong>例：定义线程安全的堆栈</strong></p><p>代码3.4中是一个接口没有条件竞争的堆栈类定义，它实现了选项1和选项3：重载了pop()，使用局部引用去存储弹出值，并返回<code>std::shared_ptr&lt;&gt;</code>对象。它有一个简单的接口，只有两个函数：push()和pop();</p><p>代码3.4 线程安全的堆栈类定义(概述)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span>  <span class="comment">// For std::shared_ptr&lt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>();</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="keyword">const</span> threadsafe_stack&amp;);</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>; <span class="comment">// 1 赋值操作被删除</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当栈为空时，pop()函数会抛出一个empty_stack异常，所以在empty()函数被调用后，其他部件还能正常工作。</p><p>使用<code>std::shared_ptr</code>可以避免内存分配管理的问题，并避免多次使用new和delete操作。堆栈中的五个操作，现在就剩下三个：push(), pop()和empty()(这里empty()都有些多余)。</p><p>简化接口更有利于数据控制，可以保证互斥量将操作完全锁住。</p><p>代码3.5 扩充(线程安全)堆栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;empty stack!&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::stack&lt;T&gt; data;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>()</span><br><span class="line">: <span class="built_in">data</span>(std::stack&lt;T&gt;())&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="keyword">const</span> threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">    data = other.data; <span class="comment">// 1 在构造函数体中的执行拷贝</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.<span class="built_in">push</span>(new_value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>(); <span class="comment">// 在调用pop前，检查栈是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>; <span class="comment">// 在修改堆栈前，分配出返回值</span></span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line"></span><br><span class="line">    value=data.<span class="built_in">top</span>();</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆栈可以拷贝——拷贝构造函数对互斥量上锁，再拷贝堆栈。构造函数体中①的拷贝使用互斥量来确保复制结果的正确性，这样的方式比成员初始化列表好。</p><p>一个给定操作需要两个或两个以上的互斥量时，另一个潜在的问题将出现：死锁。与条件竞争完全相反——不同的两个线程会互相等待，从而什么都没做。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>线程有对锁的竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。因为他们都在等待对方释放互斥量，没有线程能工作。</p><p>避免死锁：让两个互斥量以相同顺序上锁。某些情况下是可以这样用，因为不同的互斥量用于不同的地方。</p><p>选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！</p><p><code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。</p><p>代码3.6 交换操作中使用<code>std::lock()</code>和<code>std::lock_guard</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的std::lock()需要包含&lt;mutex&gt;头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lhs.m,rhs.m); <span class="comment">// 1 锁住两个互斥量</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>; <span class="comment">// 2 创建实例</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::adopt_lock</code>参数除了表示<code>std::lock_guard</code>可获取锁之外，还将锁交由<code>std::lock_guard</code>管理，就不需要<code>std::lock_guard</code>再去构建新的锁了。</p><p><code>std::lock</code>要么将两个锁都锁住，要不一个都不锁。</p><p>C++17中，<code>std::scoped_lock&lt;&gt;</code>是一种新的RAII模板类型，与<code> std::lock_guard&lt;&gt;</code>的功能相同，这个新类型能接受不定数量的互斥量类型作为模板参数，以及相应的互斥量(数量和类型)作为构造参数。</p><p>互斥量支持构造时上锁，与<code>std::lock</code>的用法相同，解锁在析构中进行。代码3.6中swap()操作可以重写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(lhs.m,rhs.m)</span></span>; <span class="comment">// 1 通过传递的对象类型来构造实例，等价于</span></span><br><span class="line">  <span class="comment">//std::scoped_lock&lt;std::mutex,std::mutex&gt; guard(lhs.m,rhs.m);</span></span><br><span class="line"><span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17新特性：自动推导模板参数。隐式参数模板类型推导机制。</p><p><code> std::scoped_lock</code>的好处在于，可以将所有<code>std::lock</code>替换掉，从而减少错误的发生。</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>无锁的情况下，仅需要两个线程<code>std::thread</code>对象互相调用join()就能产生死锁。这种情况下，没有线程可以继续运行，因为他们正在互相等待。</p><p><strong>避免嵌套锁</strong></p><p>线程获得一个锁时，就别再去获取第二个。每个线程只持有一个锁，就不会产生死锁。</p><p>当需要获取多个锁，使用<code>std::lock</code>来做这件事(对获取锁的操作上锁)，避免产生死锁。</p><p><strong>避免在持有锁时调用外部代码</strong></p><p>外部程序可能做任何事情，包括获取锁。在持有锁的情况下，如果用外部代码要获取一个锁，就会违反第一个指导意见，并造成死锁。</p><p><strong>使用固定顺序获取锁</strong></p><p>当硬性要求获取两个或两个以上的锁，并且不能使用<code>std::lock</code>单独操作来获取它们时，最好在每个线程上，用固定的顺序获取它们(锁)。</p><p>例如，不同线程以相反顺序访问列表所造成的死锁。当节点A和B在列表中相邻，当前线程可能会同时尝试获取A和B上的锁。另一个线程可能已经获取了节点B上的锁，并试图获取节点A上的锁——经典的死锁场景。</p><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">锁住主入口的互斥量</td><td align="center"></td></tr><tr><td align="center">读取头结点指针</td><td align="center"></td></tr><tr><td align="center">锁住头结点互斥量</td><td align="center"></td></tr><tr><td align="center">解锁主入口互斥量</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">锁住主入口互斥量</td></tr><tr><td align="center">读取head-&gt;next指针</td><td align="center">锁住尾结点互斥量</td></tr><tr><td align="center">锁住next结点的互斥量</td><td align="center">读取tail-&gt;prev指针</td></tr><tr><td align="center">读取next-&gt;next指针</td><td align="center">解锁尾结点的互斥量</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">锁住A结点的互斥量</td><td align="center">锁住C结点的互斥量</td></tr><tr><td align="center">读取A-&gt;next指针(也就是B结点)</td><td align="center">读取C-&gt;next指针(也就是B结点)</td></tr><tr><td align="center"></td><td align="center">锁住B结点互斥量</td></tr><tr><td align="center">阻塞，尝试锁住B结点的互斥量</td><td align="center">解锁C结点互斥量</td></tr><tr><td align="center"></td><td align="center">读取B-&gt;prev指针(也就是A结点)</td></tr><tr><td align="center"></td><td align="center">阻塞，尝试锁住A结点的互斥量</td></tr><tr><td align="center">死锁！</td><td align="center"></td></tr></tbody></table><p>当A、C节点中间的B节点删除时，有线程在已获取A和C上的锁后，还要获取B节点上的锁时，就可能发生死锁。</p><p>解决：定义遍历的顺序，一个线程必须先锁住A才能获取B的锁，在锁住B之后才能获取C的锁。这将消除死锁，不允许反向遍历链表。</p><p><strong>使用层次锁结构</strong></p><p>当代码试图对互斥量上锁，而低层已持有该层锁时，不允许锁定。可以通过每个互斥量对应的层数，以及每个线程使用的互斥量，在运行时检查锁定操作是否可以进行。</p><p>层级互斥量不可能死锁，因为互斥量本身会严格遵循约定进行上锁。当多个互斥量在是在同一级上时，不能同时持有多个锁。</p><p>代码3.7 使用层次锁来避免死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>; <span class="comment">// 1 3个hierarchical_mutex实例，逐渐递减的层级构造</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">6000</span>)</span></span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>; <span class="comment">// 假设do_low_level_stuff不会对任何互斥量进行上锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>; <span class="comment">// 4 low_level_func为层级最低的函数，并且会对low_level_mutex进行上锁</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>; <span class="comment">// 6 锁的层级更高</span></span><br><span class="line">  <span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>()); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_a</span><span class="params">()</span>  <span class="comment">// 7 遵守规则，运行成功</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_stuff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();  <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_b</span><span class="params">()</span> <span class="comment">// 8 other_stuff()调用high_level_func()时，就违反了层级结构,运行失败</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>; <span class="comment">// 9 中层级的数据已被保护</span></span><br><span class="line">  <span class="built_in">other_stuff</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码3.8 简单的层级互斥量实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::mutex internal_mutex;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;  <span class="comment">// 1 当前线程的层级值</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)  <span class="comment">// 2 判断层级抛出异常</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;  <span class="comment">// 3</span></span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span>:</span></span><br><span class="line"><span class="function">      hierarchy_value(value),</span></span><br><span class="line"><span class="function">      previous_hierarchy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex.<span class="built_in">lock</span>();  <span class="comment">// 4 lock()代表内部互斥锁已锁住</span></span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();  <span class="comment">// 5 一旦成功锁住，更新层级值</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value!=hierarchy_value)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);  <span class="comment">// 9</span></span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;  <span class="comment">// 6 对层级值进行保存</span></span><br><span class="line">    internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())  <span class="comment">// 7 try_lock()与lock()的功能相似，除了在调用internal_mutex的try_lock()失败时，不能持有对应锁，所以不必更新层级值，并直接返回false。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function">     <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;  <span class="comment">// 8 初始化为最大值</span></span><br></pre></td></tr></table></figure><p><strong>超越锁的延伸扩展</strong></p><p>死锁不仅仅会发生在锁之间，也会发生在同步构造中(可能会产生一个等待循环)</p><p>如果去等待一个线程结束，应该确定这个线程的层级，这样一个线程只需要等待比其层级低的线程结束即可。</p><p><code>std::lock()</code>和<code>std::lock_guard</code>可组成简单的锁，并覆盖大多数情况，但有时需要更多的灵活性，可以使用标准库提供的<code>std::unique_lock</code>模板。</p><h3 id="std-unique-lock——灵活的锁"><a href="#std-unique-lock——灵活的锁" class="headerlink" title="std::unique_lock——灵活的锁"></a><code>std::unique_lock</code>——灵活的锁</h3><p><code>std::unique_lock</code>实例不带互斥量：信息已存储，且已更新。在创建时自动加锁，在销毁时自动解锁****</p><p><strong>unique_lock是对lock_guard的扩展，允许在生命周期内再调用lock和unlock来加解锁以切换锁的状态。</strong></p><p>但是内存会占用比较多的空间，并且比<code>std::lock_guard</code>稍慢一些。</p><p>使用时<code>std::lock_guard&lt;std::mutex&gt; lk(mtx);</code>直接替换成<code>std::unique_lock&lt;std::mutex&gt; lk(mtx);</code></p><p><strong>lock_guard和unique_lock第二参数的作用:</strong></p><ul><li><p><code>std::adopt_lock</code>: 假设调用一方已经拥有了互斥量的所有权（已经lock成功了）；通知lock_guard不需要再构造函数中lock这个互斥量了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mtx, std::adopt_lock)</span></span>;</span><br><span class="line">    g_mtx.<span class="built_in">lock</span>();</span><br><span class="line">    临界区或临界资源</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于lock_guard第二参数类型只有一种，锁管理器构造的时候不会自动对可锁对象上锁；由可锁对象自己加锁；等锁管理器析构的时候自动解锁。</p><p>如果指定了第二参数，但是没有lock，锁管理器析构的时候解锁了无拥有权的可锁对象，导致异常。</p><p>多锁场景下，会调用<code>std::lock</code>避免死锁的出现，但是这个方法要求锁管理器不能拥有可锁对象，由<code>std::lock</code>方法执行锁操作。如果没有提供第二参数构造函数，那么就无法使用该方法。</p><p>注意：使用该参数类型构造的锁管理器必须只能通过可锁对象进行lock，不可通过锁管理器进行lock，误用会导致程序异常。</p></li><li><p><code>std::defer_lock</code>: 初始化了一个没有加锁的mutex。前提是自己不能先lock否则报异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mtx, std::defer_lock)</span></span>;</span><br><span class="line">    lock.<span class="built_in">lock</span>();           <span class="comment">// 不能用g_mtx.lock()，第二次锁的时候会崩溃</span></span><br><span class="line">    临界区或临界资源</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>锁管理器在构造的时候不主动lock且不拥有可锁对象；如果后续执行lock，锁管理器析构的时候自动解锁。</p><p>注意：该类型构造的锁管理器只能通过锁管理器执行lock且拥有可锁对象。如果直接调用可锁对象进行锁操作后，会导致程序异常。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 </span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 std::defer_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a,lock_b); <span class="comment">// 2 互斥量在这里上锁</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_lock</code>支持lock(), try_lock()和unlock()成员函数</p><h3 id="不同域中互斥量的传递"><a href="#不同域中互斥量的传递" class="headerlink" title="不同域中互斥量的传递"></a>不同域中互斥量的传递</h3><p><code>std::unique_lock</code>是可移动，但不可赋值的类型。</p><p>函数get_lock()锁住了互斥量，然后准备数据，返回锁的调用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">prepare_data</span>();</span><br><span class="line">  <span class="keyword">return</span> lk;  <span class="comment">// 1 lk在函数中被声明为自动变量，它不需要调用std::move()，可以直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;  <span class="comment">// 2 process_data()函数直接转移std::unique_lock实例的所有权</span></span><br><span class="line">  <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::unique_lock</code>的灵活性同样也允许实例在销毁之前放弃拥有的锁。可以使用unlock()来做这件事，如同一个互斥量：<code>std::unique_lock</code>的成员函数提供类似于锁定和解锁的功能。</p><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>锁的粒度：用来描述通过一个锁保护着的数据量大小。<em>一个细粒度锁</em>(a fine-grained lock)能够保护较小的数据量，<em>一个粗粒度锁</em>(a coarse-grained lock)能够保护较多的数据量。</p><p>如果很多线程正在等待同一个资源(等待收银员对自己拿到的商品进行清点)，当有线程持有锁的时间过长，这就会增加等待的时间(别等到结账的时候，才想起来蔓越莓酱没拿)。</p><p><code>std::unique_lock</code>在这种情况下工作正常，调用unlock()时，代码不需要再访问共享数据。当再次需要对共享数据进行访问时，再调用lock()就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">  some_class data_to_process=<span class="built_in">get_next_data_chunk</span>();</span><br><span class="line">  my_lock.<span class="built_in">unlock</span>();  <span class="comment">// 1 不要让锁住的互斥量越过process()函数的调用</span></span><br><span class="line">  result_type result=<span class="built_in">process</span>(data_to_process);</span><br><span class="line">  my_lock.<span class="built_in">lock</span>(); <span class="comment">// 2 为了写入数据，对互斥量再次上锁</span></span><br><span class="line">  <span class="built_in">write_result</span>(data_to_process,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要让锁住的互斥量越过对process()函数的调用，所以可以在函数调用①前对互斥量进行手动解锁，之后对其再次上锁②。</p><p>代码3.10 比较操作符中一次锁住一个互斥量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> some_detail;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> some_detail;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Y</span>(<span class="keyword">int</span> sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Y <span class="keyword">const</span>&amp; lhs, Y <span class="keyword">const</span>&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> lhs_value=lhs.<span class="built_in">get_detail</span>();  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> rhs_value=rhs.<span class="built_in">get_detail</span>();  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> lhs_value==rhs_value;  <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比较操作符首先通过调用get_detail()成员函数检索要比较的值②③，函数在索引时被锁保护着①。比较操作符会在之后比较索引出来的值④。</p><p>虽然锁只持有一次的操作能减少锁持有的时间(这样能消除死锁的可能性)，但这里有一个微妙的语义操作同时对两个锁住的值进行比较。</p><p>当操作符返回true时，就意味着在这个时间点上的lhs.some_detail与另一个时间点的rhs.some_detail相同。</p><p>这两个值在读取之后，可能会以任意方式修改。两个值会在②和③处进行交换，这样就会失去了比较的意义。比较可能会返回true，表明这两个值是相等的，实际上这两个值相等的情况可能就发生在一瞬间。</p><p>当持有锁的时间没有达到整个操作时间，就会让自己处于条件竞争的状态。</p><h2 id="保护共享数据的方式"><a href="#保护共享数据的方式" class="headerlink" title="保护共享数据的方式"></a>保护共享数据的方式</h2><h3 id="保护共享数据的初始化过程"><a href="#保护共享数据的初始化过程" class="headerlink" title="保护共享数据的初始化过程"></a>保护共享数据的初始化过程</h3><p>假设有一个共享源，构建代价很昂贵，它可能会打开一个数据库连接或分配出很多的内存。</p><p>延迟初始化(Lazy initialization)在单线程代码很常见————每一个操作都需要先对源进行检查，为了了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转为多线程代码时，只有①处需要保护，这样共享数据对于并发访问就是安全的。</p><p>代码3.11 使用延迟初始化(线程安全)的过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;  <span class="comment">// 所有线程在此序列化 </span></span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 只有初始化过程需要保护 </span></span><br><span class="line">  &#125;</span><br><span class="line">  lk.<span class="built_in">unlock</span>();</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码3.12 使用<code>std::call_once</code>作为类成员的延迟初始化(线程安全)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details;</span><br><span class="line">  connection_handle connection;</span><br><span class="line">  std::once_flag connection_init_flag;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    connection=connection_manager.<span class="built_in">open</span>(connection_details);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(connection_info <span class="keyword">const</span>&amp; connection_details_):</span><br><span class="line">      <span class="built_in">connection_details</span>(connection_details_)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="keyword">const</span>&amp; data)</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  <span class="comment">// 2</span></span><br><span class="line">    connection.<span class="built_in">send_data</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> connection.<span class="built_in">receive_data</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例子中第一次调用send_data()①或receive_data()③的线程完成初始化过程。使用成员函数open_connection()去初始化数据，也需要将this指针传进去。</p><p><code>std::mutex</code>和<code>std::once_flag</code>的实例不能拷贝和移动，需要通过显式定义相应的成员函数，对这些类成员进行操作。</p><h3 id="保护不常更新的数据机构"><a href="#保护不常更新的数据机构" class="headerlink" title="保护不常更新的数据机构"></a>保护不常更新的数据机构</h3><p>互斥量“读者-作者锁”，其允许两种不同的使用方式：一个“作者”线程独占访问和共享访问，让多个“读者”线程并发访问。</p><p>c++17标准库提供了两种非常好的互斥量——<code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>。</p><p>对于更新操作，可以使用<code>std::lock_guard&lt;std::shared_mutex&gt;</code>和<code>std::unique_lock&lt;std::shared_mutex&gt;</code>上锁。</p><p>代码3.13 使用<code>std::shared_mutex</code>对数据结构进行保护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::map&lt;std::string,dns_entry&gt; entries;</span><br><span class="line">  <span class="keyword">mutable</span> std::shared_mutex entry_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(std::string <span class="keyword">const</span>&amp; domain)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  <span class="comment">// 1 使用std::shared_lock&lt;&gt;来保护共享和只读权限</span></span><br><span class="line">    std::map&lt;std::string,dns_entry&gt;::const_iterator <span class="keyword">const</span> it=</span><br><span class="line">       entries.<span class="built_in">find</span>(domain);</span><br><span class="line">    <span class="keyword">return</span> (it==entries.<span class="built_in">end</span>())?<span class="built_in">dns_entry</span>():it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(std::string <span class="keyword">const</span>&amp; domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                           dns_entry <span class="keyword">const</span>&amp; dns_details)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  <span class="comment">// 2 使用std::lock_guard&lt;&gt;实例，当表格需要更新时②，为其提供独占访问权限</span></span><br><span class="line">    entries[domain]=dns_details;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多线程可以同时调用find_entry()，且不会出错。</p><p>update_or_add_entry()函数调用时，独占锁会阻止其他线程对数据结构进行修改，并且阻止线程调用find_entry()。</p><h3 id="嵌套锁"><a href="#嵌套锁" class="headerlink" title="嵌套锁"></a>嵌套锁</h3><p>线程对已经获取的<code>std::mutex</code>(已经上锁)再次上锁是错误的，尝试这样做会导致未定义行为。</p><p>C++标准库提供了<code>std::recursive_mutex</code>类。除了可以在同一线程的单个实例上多次上锁，其他功能与<code>std::mutex</code>相同。</p><p>其他线程对互斥量上锁前，当前线程必须释放拥有的所有锁，所以如果你调用lock()三次，也必须调用unlock()三次。</p><p>使用<code>std::lock_guard&lt;std::recursive_mutex&gt;</code>和<code>std::unique_lock&lt;std::recursive_mutex&gt;</code></p><p>嵌套锁一般用在可并发访问的类上。每个公共成员函数都会对互斥量上锁，然后完成对应的操作后再解锁互斥量。不过，有时成员函数会调用另一个成员函数，这种情况下，第二个成员函数也会试图锁住互斥量，这就会导致未定义行为的发生。</p><p>解决方案为将互斥量转为嵌套锁，第二个成员函数就能成功的进行上锁，并且函数能继续执行。</p><p>缺点：对应类的不变量通常会被破坏。当不变量被破坏时，第二个成员函数还需要继续执行。</p><p>一个比较好的方式是，从中提取出一个函数作为类的私有成员，这个私有成员函数不会对互斥量进行上锁(调用前必须获得锁)。然后，需要仔细考虑一下，这种情况调用新函数时数据的状态。</p><h1 id="4-同步操作"><a href="#4-同步操作" class="headerlink" title="4.同步操作"></a>4.同步操作</h1><h2 id="等待事件或条件"><a href="#等待事件或条件" class="headerlink" title="等待事件或条件"></a>等待事件或条件</h2><p>当一个线程等待另一个线程完成时，可以持续的检查共享数据标志(用于做保护工作的互斥量)，直到另一线程完成工作时对这个标识进行重置。但是，这种方式会消耗线程的执行时间检查标识，并且当互斥量上锁后，其他线程就没有办法获取锁，就会持续等待。</p><p>在等待线程在检查间隙，使用<code>std::this_thread::sleep_for()</code>进行周期性的间歇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!flag)</span><br><span class="line">  &#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 1 解锁互斥量</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 2 休眠100ms</span></span><br><span class="line">    lk.<span class="built_in">lock</span>();   <span class="comment">// 3 再锁互斥量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程休眠时没有浪费执行时间，但很难确定正确的休眠时间。</p><p>条件变量：通过另一线程触发等待事件的机制是最基本的唤醒方式(例如：流水线上存在额外的任务时)</p><p>条件变量会与多个事件或其他条件相关，并且一个或多个线程会等待条件的达成。当某些线程被终止时，为了唤醒等待线程(允许等待线程继续执行)，终止线程将会向等待着的线程广播“条件达成”的信息。</p><h3 id="等待条件达成"><a href="#等待条件达成" class="headerlink" title="等待条件达成"></a>等待条件达成</h3><p>c++标准库条件变量的实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。</p><p>两者都需要与互斥量一起才能工作(互斥量是为了同步)，前者仅能与<code>std::mutex</code>一起工作，而后者可以和合适的互斥量一起工作，从而加上了<code>_any</code>的后缀。</p><p><code> std::condition_variable_any</code>更加通用，不过在性能和系统资源的使用方面会有更多的开销，所以通常会将<code>std::condition_variable</code>作为首选类型。</p><p>代码4.1 使用<code>std::condition_variable</code>处理数据等待</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1 队列中中有两个线程，两个线程之间会对数据进行传递</span></span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2 数据压入队列</span></span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();  <span class="comment">// 3 对等待的线程(如果有等待线程)进行通知</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;  <span class="comment">// 4 对互斥量上锁</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(</span><br><span class="line">         lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);  <span class="comment">// 5 传递一个锁和一个Lambda表达式(作为等待的条件)</span></span><br><span class="line">    data_chunk data=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait()会去检查这些条件(通过Lambda函数)，当条件满足(Lambda函数返回true)时返回。如果条件不满足(Lambda函数返回false)，wait()将解锁互斥量，并且将线程(处理数据的线程)置于阻塞或等待状态。当准备数据的线程调用notify_one()通知条件变量时，处理数据的线程从睡眠中苏醒，重新获取互斥锁，并且再次进行条件检查。在条件满足的情况下，从wait()返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并重新等待。</p><p>用<code>std::unique_lock</code>而不使用<code>std::lock_guard</code>的原因：等待中的线程必须在等待期间解锁互斥量，并对互斥量再次上锁，而<code>std::lock_guard</code>没有这么灵活。</p><p>可以不使用lambda表达式，写一个检查函数传入到wait()。调用wait()的过程中，在互斥量锁定时，可能会去检查条件变量若干次，当提供测试条件的函数返回true就会立即返回。</p><p><strong>伪唤醒：</strong>当等待线程重新获取互斥量并检查条件变量时，并非直接响应另一个线程的通知。</p><p>当多个线程同时在等待同一条件，此时条件满足发起唤醒则可能会唤醒多个线程，但是如果对应的资源不够所有唤醒线程使用，则剩余线程的唤醒就是无意义的，也就被称作虚假唤醒。</p><p>避免方法：在睡眠返回之后重新检查条件判断（while代替if）</p><p><code> std::condition_variable::wait</code>是“忙碌-等待”的优化。下面用简单的循环实现了一个“忙碌-等待”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minimal_wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lk, Predicate pred)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">pred</span>())&#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    lk.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建线程安全队列"><a href="#构建线程安全队列" class="headerlink" title="构建线程安全队列"></a>构建线程安全队列</h3><p>代码4.3 线程安全队列的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span> <span class="comment">// 为了使用std::shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>();</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>(<span class="keyword">const</span> threadsafe_queue&amp;);</span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(</span><br><span class="line">      <span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 不允许简单的赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>;  <span class="comment">// 1 返回队列中值的状态</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;  <span class="comment">// 2 直接返回检索值，当没有值可检索时，这个函数返回NULL。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>裁剪了很多构造函数，并禁止简单赋值。需要提供两个版本的try_pop()和wait_for_pop()。</p><p>代码4.4 从代码4.1中提取push()和wait_and_pop()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::mutex mut;</span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadsafe_queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk data;</span><br><span class="line">    data_queue.<span class="built_in">wait_and_pop</span>(data);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程队列中有互斥量和条件变量，所以独立的变量就不需要了①，并且push()不需要外部同步②。当然，wait_and_pop()还要兼顾条件变量的等待③。</p><p>代码4.5 使用条件变量的线程安全队列(完整版)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex mut;  <span class="comment">// 1 互斥量必须是可变的 </span></span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>(threadsafe_queue <span class="keyword">const</span>&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">    data_queue=other.data_queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> std::shared_ptr&lt;T&gt;();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>empty()是一个const成员函数，并且传入拷贝构造函数的other形参是一个const引用。因为其他线程可能有非const引用对象，并调用变种成员函数，所以这里有必要对互斥量上锁。又因为锁住互斥量是个可变操作，所以互斥量成员必须为mutable①才能在empty()和拷贝构造函数中进行上锁。</p><p>当数据准备完成时，调用notify_one()将会唤醒一个正在wait()的线程，检查条件和wait()函数的返回状态(因为仅是向data_queue添加了一个数据项)。</p><h2 id="使用future"><a href="#使用future" class="headerlink" title="使用future"></a>使用future</h2><p>future：当线程需要等待特定事件时，某种程度上来说就需要知道期望的结果。之后，线程会周期性(较短的周期)的等待或检查事件是否触发(检查信息板)，检查期间也会执行其他任务(品尝昂贵的咖啡)。另外，等待任务期间也可以先执行另外的任务，直到对应的任务触发，而后等待future的状态会变为就绪状态。</p><p>当事件发生时(状态为就绪)，这个future就不能重置了。</p><p>c++标准库中，声明在<code>&lt;future&gt;</code>头文件中: unique future(<code>std::future&lt;&gt;</code>)和shared futures(<code>std::shared_future&lt;&gt;</code>)，与了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>非常类似。</p><p><code>std::future</code>只能与指定事件相关联，而<code>std::shared_future</code>就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且可以访问与事件相关的数据。</p><p>当多个线程需要访问一个独立future对象时，必须使用互斥量或类似同步机制进行保护。</p><h3 id="后台任务的返回值"><a href="#后台任务的返回值" class="headerlink" title="后台任务的返回值"></a>后台任务的返回值</h3><p>当不着急让任务结果时，可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用这个对象的get()成员函数，就会阻塞线程直到future为就绪为止，并返回计算结果。</p><p>代码4.6 <code>std::future</code>从异步任务中获取返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::future&lt;<span class="keyword">int</span>&gt; the_answer=std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer is &quot;</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::async</code>允许通过添加额外的调用参数，向函数传递额外的参数。第一个参数是指向成员函数的指针，第二个参数提供这个函数成员类的具体对象(是通过指针，也可以包装在<code>std::ref</code>中)，剩余的参数可作为函数的参数传入。</p><p>代码4.7 使用<code>std::async</code>向函数传递参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,std::string <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">bar</span><span class="params">(std::string <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=std::<span class="built_in">async</span>(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 调用p-&gt;foo(42, &quot;hello&quot;)，p是指向x的指针</span></span><br><span class="line"><span class="keyword">auto</span> f2=std::<span class="built_in">async</span>(&amp;X::bar,x,<span class="string">&quot;goodbye&quot;</span>);  <span class="comment">// 调用tmpx.bar(&quot;goodbye&quot;)， tmpx是x的拷贝副本</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=std::<span class="built_in">async</span>(<span class="built_in">Y</span>(),<span class="number">3.141</span>);  <span class="comment">// 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到</span></span><br><span class="line"><span class="keyword">auto</span> f4=std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y),<span class="number">2.718</span>);  <span class="comment">// 调用y(2.718)</span></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line">std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 调用baz(x)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">move_only</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">move_only</span>();</span><br><span class="line">  <span class="built_in">move_only</span>(move_only&amp;&amp;)</span><br><span class="line">  <span class="built_in">move_only</span>(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f5=std::<span class="built_in">async</span>(<span class="built_in">move_only</span>());  <span class="comment">// 调用tmp()，tmp是通过std::move(move_only())构造得到</span></span><br></pre></td></tr></table></figure><p>future的等待取决于<code>std::async</code>是否启动一个线程，或是否有任务在进行同步。</p><p>可以在函数调用之前向<code>std::async</code>传递一个额外参数:</p><p><code>std::launch::async</code>，表明函数必须在其所在的独立线程上执行；</p><p><code>std::launch::defered</code>，表明函数调用延迟到wait()或get()函数调用时才执行。</p><p><code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种（默认选项）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6=std::<span class="built_in">async</span>(std::launch::async,<span class="built_in">Y</span>(),<span class="number">1.2</span>);  <span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f7=std::<span class="built_in">async</span>(std::launch::deferred,baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 在wait()或get()调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f8=std::<span class="built_in">async</span>(</span><br><span class="line">              std::launch::deferred | std::launch::async,</span><br><span class="line">              baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="keyword">auto</span> f9=std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));</span><br><span class="line">f7.<span class="built_in">wait</span>();  <span class="comment">//  调用延迟函数</span></span><br></pre></td></tr></table></figure><h3 id="future与任务关联"><a href="#future与任务关联" class="headerlink" title="future与任务关联"></a>future与任务关联</h3><p><code>std::packaged_task&lt;&gt;</code>会将future与函数或可调用对象进行绑定。当调用<code>std::packaged_task&lt;&gt;</code>对象时，就会调用相关函数或可调用对象，当future状态为就绪时，会存储返回值。</p><p>构造<code>std::packaged_task&lt;&gt;</code>实例时，就必须传入函数或可调用对象。这个函数或可调用的对象，需要能接收指定的参数和返回(可转换为指定返回类型的)值。类型可以不完全匹配，因为这里类型可以隐式转换，可以用int类型参数和返回float类型的函数，来构建<code>std::packaged_task&lt;double(double)&gt;</code>实例。</p><p>函数签名的返回类型可以用来标识从get_future()返回的<code>std::future&lt;&gt;</code>的类型，而函数签名的参数列表，可用来指定packaged_task的函数调用操作符。例如，模板偏特化</p><p>代码4.8 <code>std::packaged_task&lt;&gt;</code>的偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">packaged_task</span>&lt;</span>std::<span class="built_in">string</span>(std::vector&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>;</span><br><span class="line">  <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当<code>std::packaged_task</code>作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在<code>std::future</code>中，并且可通过get_future()获取。</p><p><code>std::packaged_task</code>对任务进行打包，并适时的取回future。当异步任务需要返回值时，可以等待future状态变为“就绪”。</p><p><strong>线程间传递任务</strong></p><p>代码4.9 使用<code>std::packaged_task</code>执行一个图形界面线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2 关闭图形界面的信息</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3 关闭界面前，进行轮询界面消息处理</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4 当队列中没有任务时，循环将继续</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5 能在队列中提取出一个任务</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6 释放队列上的锁，并且执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7 提供一个打包好的任务</span></span><br><span class="line">  std::future&lt;<span class="keyword">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8 用get_future()成员函数获取future对象</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 9 任务推入列表</span></span><br><span class="line">  <span class="keyword">return</span> res; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::packaged_task</code>是一个类模板，顾名思义是用来打包的，将一个可调用对象封装起来，然后可以将其的返回值传给future。<code>std::packaged_task&lt;函数返回类型(参数类型)&gt; 变量名(函数名)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">x++;</span><br><span class="line">x *= <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">pt</span><span class="params">(fun)</span></span>;         <span class="comment">// 将函数打包起来</span></span><br><span class="line">std::future&lt;<span class="keyword">int</span>&gt; fu = pt.<span class="built_in">get_future</span>();        <span class="comment">// 并将结果返回给future</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::ref(pt), <span class="number">1</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用std-promises"><a href="#使用std-promises" class="headerlink" title="使用std::promises"></a>使用std::promises</h3><p>当线程处理多个连接事件，来自不同的端口连接的数据包基本上以乱序方式进行处理。同样的，数据包也将以乱序的方式进入队列。很多情况下，一些应用不是等待数据成功的发送，就是等待(新的)指定网络接口数据的接收成功。</p><p><code>std::promise</code>是一个类模板，它的作用是在不同的线程中实现数据的同步，与future结合使用，也间接实现了future在不同线程间的同步。</p><p><code>std::promise/std::future</code>对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。</p><p>当promise设置完毕(使用set_value()成员函数)时，对应的future状态就变为“就绪”，并且可用于检索已存储的值。当设置值之前销毁<code>std::promise</code>，将会存储一个异常。</p><p>代码4.10 使用promise解决单线程多连接问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done</span>(connections))  <span class="comment">// 1 循环直到done()返回true为止</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(connection_iterator  <span class="comment">// 2</span></span><br><span class="line">            connection=connections.<span class="built_in">begin</span>(),end=connections.<span class="built_in">end</span>();</span><br><span class="line">          connection!=end;</span><br><span class="line">          ++connection)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_incoming_data</span>())  <span class="comment">// 3 检索是否有数据</span></span><br><span class="line">      &#123;</span><br><span class="line">        data_packet data=connection-&gt;<span class="built_in">incoming</span>();</span><br><span class="line">        std::promise&lt;payload_type&gt;&amp; p=</span><br><span class="line">            connection-&gt;<span class="built_in">get_promise</span>(data.id);  <span class="comment">// 4</span></span><br><span class="line">        p.<span class="built_in">set_value</span>(data.payload);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_outgoing_data</span>())  <span class="comment">// 5 检索是否正在发送已入队的传出数据</span></span><br><span class="line">      &#123;</span><br><span class="line">        outgoing_packet data=</span><br><span class="line">            connection-&gt;<span class="built_in">top_of_outgoing_queue</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">send</span>(data.payload);</span><br><span class="line">        data.promise.<span class="built_in">set_value</span>(<span class="literal">true</span>);  <span class="comment">// 6 当发送完成，传出数据相关的promise将置为true，来表明传输成功</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_value()</code>则直接将future的状态设置为ready。需要注意的是在使用的过程中不能多次<code>set_value()</code>，也不能多次<code>get_future()</code>和多次<code>get()</code>，因为一个promise对象只能和一个对象相关联，否则就会抛出异常。</p><h2 id="将异常存于future中"><a href="#将异常存于future中" class="headerlink" title="将异常存于future中"></a>将异常存于future中</h2><p>函数作为<code>std::async</code>的一部分时，当调用抛出一个异常时，这个异常就会存储到future中，之后future的状态置为“就绪”，之后调用get()会抛出已存储的异常(注意：标准级别没有指定重新抛出的这个异常是原始的异常对象，还是一个拷贝。不同的编译器和库将会在这方面做出不同的选择)。</p><p>将函数打包入<code>std::packaged_task</code>任务包后，当任务调用时，同样的事情也会发生。打包函数抛出一个异常，这个异常将存储在future中，在get()调用时会再次抛出。</p><p><code>std::promise</code>也能提供同样的功能。当存入的是异常而非数值时，就需要调用set_exception()成员函数，而非set_value()。这通常是用在一个catch块中，并作为算法的一部分。为了捕获异常，这里使用异常填充promise：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> std::promise&lt;<span class="keyword">double</span>&gt; some_promise;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_value</span>(<span class="built_in">calculate_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>std::current_exception()</code>来检索抛出的异常，可用<code>std::copy_exception()</code>作为替代方案，<code>std::copy_exception()</code>会直接存储新的异常而不抛出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">copy_exception</span>(std::<span class="built_in">logic_error</span>(<span class="string">&quot;foo &quot;</span>)));</span><br></pre></td></tr></table></figure><p>这比使用try/catch块更加清晰，当异常类型已知，就应该优先使用。</p><h3 id="多个线程的等待"><a href="#多个线程的等待" class="headerlink" title="多个线程的等待"></a>多个线程的等待</h3><p>多线程在没有额外同步的情况下，访问独立<code>std::future</code>对象时，就会有数据竞争和未定义行为。因为<code>std::future</code>独享同步结果，并且通过调用get()函数，一次性的获取数据，这就让并发访问变的毫无意义。</p><p><code>std::shared_future</code>：其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。</p><p>每一个<code>std::shared_future</code>的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p><p><code>std::shared_future</code>的实例同步<code>std::future</code>实例的状态。当<code>std::future</code>对象没有与其他对象共享同步状态所有权，那么所有权必须使用<code>std::move</code>将所有权传递到<code>std::shared_future</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(f.<span class="built_in">valid</span>());  <span class="comment">// 1 期望值 f 是合法的</span></span><br><span class="line"><span class="function">std::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(!f.<span class="built_in">valid</span>());  <span class="comment">// 2 期望值 f 现在是不合法的</span></span><br><span class="line"><span class="built_in">assert</span>(sf.<span class="built_in">valid</span>());  <span class="comment">// 3 sf 现在是合法的</span></span><br></pre></td></tr></table></figure><p>期望值f开始是合法的①，因为引用的是promise p的同步状态，但是在转移sf的状态后，f就不合法了②，而sf就是合法的了③。</p><p>如其他可移动对象一样，转移所有权是对右值的隐式操作，所以可以通过<code>std::promise</code>对象的成员函数get_future()的返回值，直接构造一个<code>std::shared_future</code>对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;std::string&gt; p;</span><br><span class="line"><span class="function">std::shared_future&lt;std::string&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;  <span class="comment">// 1 隐式转移所有权</span></span><br></pre></td></tr></table></figure><p><code>std::future</code>有一个share()成员函数，可用来创建新的<code>std::shared_future</code> ，并且可以直接转移future的所有权。这样也就能保存很多类型，并且使得代码易于修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator,</span><br><span class="line">     SomeAllocator&gt;::iterator&gt; p;</span><br><span class="line"><span class="keyword">auto</span> sf=p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure><p>当比较器或分配器有所改动，只需要对promise的类型进行修改即可。future的类型会自动与promise的修改进行匹配。</p><h2 id="限时等待"><a href="#限时等待" class="headerlink" title="限时等待"></a>限时等待</h2><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>时钟和与时间相关的工具，都在<code>&lt;chrono&gt;</code>库头文件中定义。</p><p>c++标准库中，时钟是一个类，提供了四种不同的信息：</p><p>当前时间可以通过静态成员函数now()从获取。例如，<code>std::chrono::system_clock::now()</code>会返回系统的当前时间。返回类型为some_clock::time_point</p><p>通常情况下，因为<code>std::chrono::system_clock</code>可调，所以是不稳定的。这可调可能造成首次调用now()返回的时间要早于上次调用now()所返回的时间，这就违反了节拍频率的均匀分布。</p><p>稳定时钟<code>std::chrono::steady_clock</code>。</p><h3 id="时间段"><a href="#时间段" class="headerlink" title="时间段"></a>时间段</h3><p><code>std::chrono::duration&lt;&gt;</code>函数模板能够对时间段进行处理(线程库使用到的所有C++时间处理工具，都在<code>std::chrono</code>命名空间内)。第一个模板参数是一个类型表示(比如，int，long或double)，第二个模板参数是定制部分，表示每一个单元所用秒数。</p><p>例如，<code>std::chrono::duration&lt;short, std::ratio&lt;60, 1&gt;&gt;</code>，几分钟的时间要存在short类型中，因为60秒是才是1分钟，所以第二个参数写成<code>std::ratio&lt;60, 1&gt;</code>。当需要将毫秒级计数存在double类型中时，可以写成<code>std::chrono::duration&lt;double, std::ratio&lt;1, 1000&gt;&gt;</code>，因为1秒等于1000毫秒</p><p>标准库在<code>std::chrono</code>命名空间内为时间段变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。</p><p>当不要求截断值的情况下(时转换成秒是没问题，但是秒转换成时就不行)时间段的转换是隐式的，显示转换可以由<code>std::chrono::duration_cast&lt;&gt;</code>来完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line">std::chrono::seconds s=</span><br><span class="line">       std::chrono::duration_cast&lt;std::chrono::seconds&gt;(ms);</span><br></pre></td></tr></table></figure><p>这里的结果就是截断的，而不是进行了舍入，所以s最后的值为54。</p><p>时间值支持四则运算，所以能够对两个时间段进行加减，或者是对一个时间段乘除一个常数(模板的第一个参数)来获得一个新时间段变量。例如，5*seconds(1)与seconds(5)或minutes(1)-seconds(55)是一样。</p><p>在时间段中可以通过count()成员函数获得单位时间的数量。例如，<code>std::chrono::milliseconds(1234).count()</code>就是1234。</p><p>例如：等待future状态变为就绪需要35毫秒：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="keyword">int</span>&gt; f=std::<span class="built_in">async</span>(some_task);</span><br><span class="line"><span class="keyword">if</span>(f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>))==std::future_status::ready)</span><br><span class="line">  <span class="built_in">do_something_with</span>(f.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><p>等待函数会返回状态值，表示是等待是超时，还是继续等待。等待future时，超时时会返回<code>std::future_status::timeout</code>。当future状态改变，则会返回<code>std::future_status::ready</code>。当与future相关的任务延迟了，则会返回<code>std::future_status::deferred</code>。</p><p>系统调度的不确定性和不同操作系统的时钟精度意味着：线程调用和返回的实际时间间隔可能要比35毫秒长。</p><h3 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h3><p>时间点可用<code>std::chrono::time_point&lt;&gt;</code>来表示，第一个参数用来指定使用的时钟，第二个函数参数用来表示时间单位(特化的<code>std::chrono::duration&lt;&gt;</code>)。</p><p>可以通过对<code>std::chrono::time_point&lt;&gt;</code>实例进行加/减，来获得一个新的时间点，所以<code>std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)</code>将得到500纳秒后的时间，这对于计算绝对时间来说非常方便。</p><p>可以减去一个时间点(二者需要共享同一个时钟)，结果是两个时间点的时间差：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">do_something</span>();</span><br><span class="line"><span class="keyword">auto</span> stop=std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">std::cout&lt;&lt;”<span class="built_in">do_something</span>() took “</span><br><span class="line">  &lt;&lt;std::chrono::duration&lt;<span class="keyword">double</span>,std::chrono::seconds&gt;(stop-start).<span class="built_in">count</span>()</span><br><span class="line">  &lt;&lt;” seconds”&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>代码4.11 等待条件变量满足条件——有超时功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> timeout= std::chrono::steady_clock::<span class="built_in">now</span>()+</span><br><span class="line">      std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!done) <span class="comment">// while循环处理假唤醒</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lk,timeout)==std::cv_status::timeout) <span class="comment">// 等待函数wait_until()传入一个时间点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有什么可以等待时，可在一定时限中等待条件变量。这种方式中，循环的整体长度有限。当循环中使用wait_for()时，可能在等待了足够长的时间后结束等待(在假唤醒之前)，且下一次等待又开始了。这可能重复很多次，出现无限等待的情况。</p><h3 id="使用超时"><a href="#使用超时" class="headerlink" title="使用超时"></a>使用超时</h3><p>最简单方式，对特定线程添加延迟处理。</p><p>例如循环检查“done”标志，两个处理函数分别是<code>std::this_thread::sleep_for()</code>和<code>std::this_thread::sleep_until()</code>。当线程因为指定时长而进入睡眠时，可使用sleep_for()唤醒，可指定休眠的时间点，之后可使用sleep_until唤醒。</p><p><code>std::mutex</code>和<code>std::recursive_mutex</code>都不支持超时，而<code>std::timed_mutex</code>和<code>std::recursive_timed_mutex</code>支持超时。这两种类型也有try_lock_for()和try_lock_until()成员函数，可以在一段时期内尝试获取锁，或在指定时间点前获取互斥锁。</p><p>表4.1 可接受超时的函数</p><table border="1">  <td>类型/命名空间</td>  <td>函数</td>  <td>返回值</td><tr>  <td rowspan="2"> std::this_thread 命名空间 </td>  <td> sleep_for(duration) </td>  <td rowspan="2">N/A</td></tr><tr>  <td>sleep_until(time_point)</td></tr><tr>  <td rowspan="2">std::condition_variable 或 std::condition_variable_any</td>  <td>wait_for(lock, duration)</td>  <td rowspan="2">std::cv_status::time_out 或 std::cv_status::no_timeout</td></tr><tr>  <td>wait_until(lock, time_point)</td></tr><tr>  <td rowspan="2"> </td>  <td> wait_for(lock, duration, predicate)</td>  <td rowspan="2">bool —— 当唤醒时，返回谓词的结果</td></tr><tr>  <td>wait_until(lock, duration, predicate)</td></tr><tr>  <td rowspan="2">std::timed_mutex 或 std::recursive_timed_mutex</td>  <td>try_lock_for(duration)</td>  <td rowspan="2"> bool —— 获取锁时返回true，否则返回fasle</td></tr><tr>  <td>try_lock_until(time_point)</td></tr><tr>  <td rowspan="2">std::unique_lock&lt;TimedLockable&gt;</td>  <td>unique_lock(lockable, duration)</td>  <td>N/A —— 对新构建的对象调用owns_lock();</td></tr><tr>  <td>unique_lock(lockable, time_point)</td>  <td>当获取锁时返回true，否则返回false</td></tr><tr>  <td rowspan="2"></td>  <td>try_lock_for(duration)</td>  <td rowspan="2">bool —— 当获取锁时返回true，否则返回false</td></tr><tr>  <td>try_lock_until(time_point)</td></tr><tr>  <td rowspan="3">std::future&lt;ValueType&gt;或std::shared_future&lt;ValueType&gt;</td>  <td>wait_for(duration)</td>  <td>当等待超时，返回std::future_status::timeout</td></tr><tr>  <td rowspan="2">wait_until(time_point)</td>  <td>当期望值准备就绪时，返回std::future_status::ready</td></tr><tr>  <td>当期望值持有一个为启动的延迟函数，返回std::future_status::deferred</td></tr></table><h1 id="5-内存模型和原子操作"><a href="#5-内存模型和原子操作" class="headerlink" title="5.内存模型和原子操作"></a>5.内存模型和原子操作</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="对象和内存位置"><a href="#对象和内存位置" class="headerlink" title="对象和内存位置"></a>对象和内存位置</h3><p>图5.1 将一个struct分解为多个对象，展示每个对象的内存位置。</p><img src="/posts/20a59019/5-1.png" alt="5-1" style="zoom: 50%;"><p>完整的struct是一个有多个子对象(每一个成员变量)组成的对象。</p><p>四个原则：</p><ol><li>每个变量都是对象，包括其成员变量的对象。</li><li>每个对象至少占有一个内存位置。</li><li>基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部分)。</li><li>相邻位域是相同内存中的一部分。</li></ol><h3 id="对象、内存位置和并发"><a href="#对象、内存位置和并发" class="headerlink" title="对象、内存位置和并发"></a>对象、内存位置和并发</h3><p>当两个线程访问同一个内存位置，如果线程不更新数据，只读数据不需要保护或同步。当线程对内存位置上的数据进行修改，就可能会产生<strong>条件竞争</strong>。</p><p>为了避免条件竞争，线程就要以一定的顺序执行：</p><ul><li>使用<strong>互斥量</strong>来确定访问的顺序。当同一互斥量在两个线程同时访问前锁住，那么在同一时间内就只有一个线程能够访问对应的内存位置。</li><li>使用<strong>原子操作</strong>决定两个线程的访问顺序，当多个线程访问同一个内存地址时，对每个访问者都需要设定顺序。</li></ul><p>如果不规定对同一内存地址访问的顺序，那么访问就不是原子的。当两个线程都是“写入者”时，就会产生数据竞争和未定义行为。</p><p>使用原子操作避免未定义行为。</p><h3 id="修改顺序"><a href="#修改顺序" class="headerlink" title="修改顺序"></a>修改顺序</h3><p>C++程序中的对象都有(由程序中的所有线程对象)在初始化开始阶段确定好修改顺序的。大多数情况下，这个顺序不同于执行中的顺序，但在给定的程序中，所有线程都需要遵守这个顺序。</p><p>如果使用原子操作，编译器就有责任去做同步。</p><h2 id="原子操作和原子类型"><a href="#原子操作和原子类型" class="headerlink" title="原子操作和原子类型"></a>原子操作和原子类型</h2><h3 id="标准原子类型"><a href="#标准原子类型" class="headerlink" title="标准原子类型"></a>标准原子类型</h3><p>标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中。</p><p>原子操作可以替代互斥量，来完成同步操作。</p><p>表5.1 标准原子类型的备选名和与其相关的<code>std::atomic&lt;&gt;</code>特化类</p><table><thead><tr><th>原子类型</th><th>相关特化类</th></tr></thead><tbody><tr><td>atomic_bool</td><td>std::atomic&lt;bool&gt;</td></tr><tr><td>atomic_char</td><td>std::atomic&lt;char&gt;</td></tr><tr><td>atomic_schar</td><td>std::atomic&lt;signed char&gt;</td></tr><tr><td>atomic_uchar</td><td>std::atomic&lt;unsigned char&gt;</td></tr><tr><td>atomic_int</td><td>std::atomic&lt;int&gt;</td></tr><tr><td>atomic_uint</td><td>std::atomic&lt;unsigned&gt;</td></tr><tr><td>atomic_short</td><td>std::atomic&lt;short&gt;</td></tr><tr><td>atomic_ushort</td><td>std::atomic&lt;unsigned short&gt;</td></tr><tr><td>atomic_long</td><td>std::atomic&lt;long&gt;</td></tr><tr><td>atomic_ulong</td><td>std::atomic&lt;unsigned long&gt;</td></tr><tr><td>atomic_llong</td><td>std::atomic&lt;long long&gt;</td></tr><tr><td>atomic_ullong</td><td>std::atomic&lt;unsigned long long&gt;</td></tr><tr><td>atomic_char16_t</td><td>std::atomic&lt;char16_t&gt;</td></tr><tr><td>atomic_char32_t</td><td>std::atomic&lt;char32_t&gt;</td></tr><tr><td>atomic_wchar_t</td><td>std::atomic&lt;wchar_t&gt;</td></tr></tbody></table><p>C++标准库不仅提供基本原子类型，还定义了与原子类型对应的非原子类型，就如同标准库中的<code>std::size_t</code>。如表5.2所示这些类型:</p><p>表5.2 标准原子类型定义(typedefs)和对应的内置类型定义(typedefs)</p><table><thead><tr><th>原子类型定义</th><th>标准库中相关类型定义</th></tr></thead><tbody><tr><td>atomic_int_least8_t</td><td>int_least8_t</td></tr><tr><td>atomic_uint_least8_t</td><td>uint_least8_t</td></tr><tr><td>atomic_int_least16_t</td><td>int_least16_t</td></tr><tr><td>atomic_uint_least16_t</td><td>uint_least16_t</td></tr><tr><td>atomic_int_least32_t</td><td>int_least32_t</td></tr><tr><td>atomic_uint_least32_t</td><td>uint_least32_t</td></tr><tr><td>atomic_int_least64_t</td><td>int_least64_t</td></tr><tr><td>atomic_uint_least64_t</td><td>uint_least64_t</td></tr><tr><td>atomic_int_fast8_t</td><td>int_fast8_t</td></tr><tr><td>atomic_uint_fast8_t</td><td>uint_fast8_t</td></tr><tr><td>atomic_int_fast16_t</td><td>int_fast16_t</td></tr><tr><td>atomic_uint_fast16_t</td><td>uint_fast16_t</td></tr><tr><td>atomic_int_fast32_t</td><td>int_fast32_t</td></tr><tr><td>atomic_uint_fast32_t</td><td>uint_fast32_t</td></tr><tr><td>atomic_int_fast64_t</td><td>int_fast64_t</td></tr><tr><td>atomic_uint_fast64_t</td><td>uint_fast64_t</td></tr><tr><td>atomic_intptr_t</td><td>intptr_t</td></tr><tr><td>atomic_uintptr_t</td><td>uintptr_t</td></tr><tr><td>atomic_size_t</td><td>size_t</td></tr><tr><td>atomic_ptrdiff_t</td><td>ptrdiff_t</td></tr><tr><td>atomic_intmax_t</td><td>intmax_t</td></tr><tr><td>atomic_uintmax_t</td><td>uintmax_t</td></tr></tbody></table><p>对于标准类型进行typedef T，相关的原子类型就在原来的类型名前加上atomic_的前缀：atomic_T。</p><p>通常，标准原子类型不能进行拷贝和赋值，它们没有拷贝构造函数和拷贝赋值操作符。但是，可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用<code>load()</code>和<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p><p>它们都支持复合赋值符：+=, -=, *=, |= 等等。并且使用整型和指针的特化类型还支持++和–操作。</p><p>每种函数类型的操作都有一个内存序参数，这个参数可以用来指定存储的顺序。操作分为三类：</p><ol><li><em>Store</em>操作，可选如下内存序：<code>memory_order_relaxed</code>, <code>memory_order_release</code>, <code>memory_order_seq_cst</code>。</li><li><em>Load</em>操作，可选如下内存序：<code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_seq_cst</code>。</li><li><em>Read-modify-write</em>(读-改-写)操作，可选如下内存序：<code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_release</code>, <code>memory_order_acq_rel</code>, <code>memory_order_seq_cst</code>。</li></ol><h3 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a><code>std::atomic_flag</code></h3><p><code>std::atomic_flag</code>是最简单的原子类型，这个类型的对象可以在两个状态间切换：设置和清除。</p><p><code>std::atomic_flag</code>类型的对象必须被ATOMIC_FLAG_INIT初始化。初始化标志位是“清除”状态。这里没得选择，这个标志总是初始化为“清除”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure><p>这适用于任何对象的声明，是唯一需要以如此特殊的方式初始化的原子类型，但也是唯一保证无锁的类型。首次使用时，需要初始化。如果<code>std::atomic_flag</code>是静态存储的，那么就的保证其是静态初始化的，也就意味着没有初始化顺序问题。</p><p>当标志对象已初始化，只能做三件事情：</p><ul><li>销毁，clear()成员函数，是一个存储操作，所以不能有memory_order_acquire或memory_order_acq_rel语义</li><li>清除或设置(查询之前的值)，test_and_set()成员函数，“读-改-写”操作，可以应用于任何内存顺序。</li></ul><p>每一个原子操作，默认的内存序都是memory_order_seq_cst。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="built_in">clear</span>(std::memory_order_release);  <span class="comment">// 1 使用释放语义清除标志</span></span><br><span class="line"><span class="keyword">bool</span> x=f.<span class="built_in">test_and_set</span>();  <span class="comment">// 2 使用默认内存序设置表示，并且检索旧值</span></span><br></pre></td></tr></table></figure><p>不能拷贝构造<code>std::atomic_flag</code>对象，不能将一个对象赋予另一个<code>std::atomic_flag</code>对象。这不是<code>std::atomic_flag</code>特有的属性，而是所有原子类型共有的属性。</p><p><strong>原子类型的所有操作都是原子的，而赋值和拷贝调用了两个对象，这就就破坏了操作的原子性。</strong></p><blockquote><p>互斥锁与自旋锁</p><p>同一时刻只能有一个线程获取到锁，没有获取到锁的线程通常有两种处理方式：</p><ul><li>没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)</li><li>把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</li></ul><p>自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。</p><p>因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，<strong>操作系统的内核经常使用自旋锁</strong>。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 <code>OS(Operating System)</code> 调度程序中断的风险越大。</p></blockquote><p>代码5.1 使用<code>std::atomic_flag</code>实现自旋锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():</span><br><span class="line">    <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于<code>std::atomic_flag</code>的局限性太强，没有非修改查询操作，甚至不能像普通的布尔标志那样使用。所以，实际操作中最好使用<code>std::atomic&lt;bool&gt;</code></p><h3 id="std-atomic-lt-bool-gt"><a href="#std-atomic-lt-bool-gt" class="headerlink" title="std::atomic&lt;bool&gt;"></a><code>std::atomic&lt;bool&gt;</code></h3><p>最基本的原子整型类型就是<code>std::atomic&lt;bool&gt;</code>，它有着比<code>std::atomic_flag</code>更加齐全的布尔标志特性。</p><p>不能拷贝和拷贝赋值，但可以使用非原子的bool类型进行构造，所以可以初始化为true或false，并且可以从非原子bool变量赋值给<code>std::atomic&lt;bool&gt;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>store()是一个存储操作，而load()是一个加载操作，exchange()是一个“读-改-写”操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">b.<span class="built_in">store</span>(<span class="literal">true</span>); <span class="comment">// 使用store()写入(true或false) </span></span><br><span class="line">x=b.<span class="built_in">exchange</span>(<span class="literal">false</span>, std::memory_order_acq_rel); <span class="comment">// exchange()允许使用新选的值替换已存储的值，并且会自动检索原始值</span></span><br></pre></td></tr></table></figure><p>另一种存储方式：当前值与预期值一致时，存储新值的操作。<strong>存储一个新值(或旧值)取决于当前值</strong></p><p>比较/交换：表现为compare_exchange_weak()和compare_exchange_strong()</p><p>比较原子变量的当前值和期望值，当两值相等时，存储所提供值。当两值不等，期望值就会被更新为原子变量中的值。</p><p>“比较/交换”函数值是一个bool变量，当返回true时执行存储操作，false则更新期望值。当存储完成(因为只相等)，则操作是成功的，否则即为失败。操作成功是返回true，失败时返回false。</p><p>因为<code>compare_exchange_weak()</code>可以伪失败，所以通常会配合一个循环使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// 设置些什么</span></span><br><span class="line"><span class="keyword">while</span>(!b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br></pre></td></tr></table></figure><p>循环中expected的值始终是false，表示compare_exchange_weak()会莫名的失败。</p><p>另一方面，当实际值与<code>expected</code>不符，compare_exchange_strong()就能保证值返回false。这就能消除对循环的需要，就可以知道是否成功的改变了一个变量，或已让另一个线程完成。</p><p>“compare/exchange”另一点不同的是，它拥有对两个内存序的参数进行操作的能力，这就允许内存序语义在成功和失败的例子中有所不同。可能成功时使用memory_order_acq_rel，而失败时使用memory_order_relaxed。失败的“compare/exchange”将不会进行存储，所以“compare/exchange”操作不能拥有meory_order_release或memory_order_acq_rel。</p><p>下面对compare_exchange_weak()的两次调用是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> expected;</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>,</span><br><span class="line">  memory_order_acq_rel,memory_order_acquire);</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>,memory_order_acq_rel);</span><br></pre></td></tr></table></figure><p><code>std::atomic&lt;bool&gt;</code>和<code>std::atomic_flag</code>的不同之处在于，<code>std::atomic&lt;bool&gt;</code>可能不是无锁的。为了保证操作的原子性，其实现中可能需要内置的互斥量。特殊情况时，可以使用is_lock_free()成员函数，检查<code>std::atomic&lt;bool&gt;</code>上的操作是否无锁。这是除了<code>std::atomic_flag</code>之外，另一个所有原子类型都拥有的特征(is_lock_free)。</p><h3 id="std-atomic-lt-T-gt"><a href="#std-atomic-lt-T-gt" class="headerlink" title="std::atomic&lt;T*&gt;"></a><code>std::atomic&lt;T*&gt;</code></h3><p>原子指针类型，可以使用内置类型或自定义类型T，通过特化<code>std::atomic&lt;T*&gt;</code>进行定义，操作是针对于相关类型的指针。</p><p>不能拷贝构造，也不能拷贝赋值，但是可以通过合适的类型指针进行构造和赋值。<code>std::atomic&lt;T*&gt;</code>也有load(), store(), exchange(), compare_exchange_weak()和compare_exchage_strong()成员函数，获取与返回的类型都是T*。</p><p><code>std::atomic&lt;T*&gt;</code>为指针运算提供新的操作。基本操作有fetch_add()和fetch_sub()，它们在存储地址上做原子加法和减法，为+=, -=, ++和–提供简易的封装。对于内置类型的操作，例如：如果x是<code>std::atomic&lt;Foo*&gt;</code>类型的数组的首地址，然后x+=3让其偏移到第四个元素的地址，并返回一个普通的<code>Foo*</code>类型值，这个指针值是指向数组中第四个元素。</p><p>fetch_add()和fetch_sub()的返回值略有不同(所以x.ftech_add(3)让x指向第四个元素，并且函数返回指向第一个元素的地址)。这种操作也被称为“交换-相加”，并且这是一个原子的“读-改-写”操作，如同exchange()和compare_exchange_weak()/compare_exchange_strong()一样。正像其他操作那样，返回值是一个普通的<code>T*</code>值，而非是<code>std::atomic&lt;T*&gt;</code>对象的引用，所以调用代码可以基于之前的值进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span>&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="function">std::atomic&lt;Foo*&gt; <span class="title">p</span><span class="params">(some_array)</span></span>;</span><br><span class="line">Foo* x=p.<span class="built_in">fetch_add</span>(<span class="number">2</span>);  <span class="comment">// p加2，并返回原始值</span></span><br><span class="line"><span class="built_in">assert</span>(x==some_array);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>);  <span class="comment">// p减1，并返回原始值</span></span><br><span class="line"><span class="built_in">assert</span>(x==&amp;some_array[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>函数也允许内存序作为给定函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="built_in">fetch_add</span>(<span class="number">3</span>,std::memory_order_release);</span><br></pre></td></tr></table></figure><p>因为fetch_add()和fetch_sub()都是“读-改-写”操作，可以使用任意的内存序，以及加入到一个释放序列中。因为没办法提供必要的信息(这些形式都具有memory_order_seq_cst语义)，所以指定的语序不支持操作符形式。</p><h3 id="标准原子整型的相关操作"><a href="#标准原子整型的相关操作" class="headerlink" title="标准原子整型的相关操作"></a>标准原子整型的相关操作</h3><p>如同普通的操作集合一样(load(), store(), exchange(), compare_exchange_weak(), 和compare_exchange_strong())，<code>std::atomic&lt;int&gt;</code>和<code>std::atomic&lt;unsigned long long&gt;</code>也是有一套完整的操作可以供使用：fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor()，还有复合赋值方式((+=, -=, &amp;=, |=和^=)，以及++和–(++x, x++, –x和x–)。</p><p>虽然对于普通的整型来说，这些复合赋值方式还不完全：除法、乘法和移位操作不在其中。因为，整型原子值通常用来作计数器，或者是掩码，所以以上操作的缺失显得不是那么重要。如果需要，可以使用compare_exchange_weak()完成。</p><p>对于<code>std::atomic&lt;T*&gt;</code>类型，紧密相关的两个函数就是fetch_add()和fetch_sub()。函数原子化操作，并且返回旧值，而符合赋值运算会返回新值。前缀加减和后缀加减与普通用法一样：++x对变量进行自加，并且返回新值；而x++对变量自加，返回旧值。</p><h3 id="std-atomic-lt-gt-类模板"><a href="#std-atomic-lt-gt-类模板" class="headerlink" title="std::atomic&lt;&gt;类模板"></a><code>std::atomic&lt;&gt;</code>类模板</h3><p>模板允许用户使用自定义类型创建一个原子变量(除了标准原子类型之外)，需要满足一定的标准才可以使用<code>std::atomic&lt;&gt;</code>。</p><p>为了使用<code>std::atomic&lt;UDT&gt;</code>(UDT是用户定义类型)，这个类型必须有拷贝赋值运算符。这就意味着这个类型不能有任何虚函数或虚基类，以及必须使用编译器创建的拷贝赋值操作。自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。这(基本上)就允许编译器使用memcpy()或赋值操作的等价操作，因为实现中没有用户代码。</p><p><strong>不要将锁定区域内的数据以引用或指针的形式，作为参数传递给用户提供的函数。</strong></p><p>创建一个<code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>类型。不能使用包含有计数器，标志指针和简单数组的类型，作为特化类型。虽然这不会导致任何问题，但是越是复杂的数据结构，就有越多的操作，而非只有赋值和比较。如果这种情况发生了，最好使用<code>std::mutex</code>保护数据。</p><p>当使用用户定义类型T进行实例化时，<code>std::atomic&lt;T&gt;</code>的可用接口就只有: load(), store(), exchange(), compare_exchange_weak(), compare_exchange_strong()和赋值操作，以及向类型T转换的操作。</p><p>表5.3 每一个原子类型所能使用的操作</p><img src="/posts/20a59019/5-3-table.png" alt="5-3-table" style="zoom: 50%;"><h3 id="原子操作的非成员函数"><a href="#原子操作的非成员函数" class="headerlink" title="原子操作的非成员函数"></a>原子操作的非成员函数</h3><p>大多数非成员函数的命名与对应成员函数有关，需要<code>atomic_</code>作为前缀(比如，<code>std::atomic_load()</code>)。这些函数都会重载不同的原子类型，指定内存序时会分成两种：一种没有标签，另一种以<code>_explicit</code>为后缀，并且需要额外的参数，或将内存序作为标签，亦或只有标签(例如，<code>std::atomic_store(&amp;atomic_var,new_value)</code>与<code>std::atomic_store_explicit(&amp;atomic_var,new_value,std::memory_order_release</code>)。</p><p>成员函数隐式引用原子对象，所有非成员函数都持有一个指向原子对象的指针(作为第一个参数)。</p><p>例如，<code>std::atomic_is_lock_free()</code>只有一种类型(虽然会被其他类型所重载)，并且对于同一个对象a，<code>std::atomic_is_lock_free(&amp;a)</code>返回值与a.is_lock_free()相同。</p><p>同样的，<code>std::atomic_load(&amp;a)</code>和a.load()的作用一样。需要注意的是，<code>a.load(std::memory_order_acquire)</code>与<code>std::atomic_load_explicit(&amp;a, std::memory_order_acquire)</code>的操作相同。</p><p>非成员函数的设计是为了与C语言兼容，C语言中没有引用。</p><p>C++标准库也对原子类型中的<code>std::shared_ptr&lt;&gt;</code>智能指针类型提供非成员函数，这打破了“只有原子类型，才能提供原子操作”的原则。<code>std::shared_ptr&lt;&gt;</code>不是原子类型，但是C++标准委员会认为这很重要。可使用的原子操作有：load, store, exchange和compare/exchange，这些操作重载了标准原子类型的操作，并且可获取<code>std::shared_ptr&lt;&gt;*</code>作为第一个参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;my_data&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_global_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::shared_ptr&lt;my_data&gt; local=std::<span class="built_in">atomic_load</span>(&amp;p);</span><br><span class="line">  <span class="built_in">process_data</span>(local);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_global_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;my_data&gt; <span class="title">local</span><span class="params">(<span class="keyword">new</span> my_data)</span></span>;</span><br><span class="line">  std::<span class="built_in">atomic_store</span>(&amp;p,local);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准原子类型不仅仅是为了避免数据竞争所造成的未定义行为，还允许用户对不同线程上的操作进行强制排序。这种强制排序是数据保护和同步操作的基础，例如：<code>std::mutex</code>和<code>std::future</code>。</p><h2 id="同步操作和强制排序"><a href="#同步操作和强制排序" class="headerlink" title="同步操作和强制排序"></a>同步操作和强制排序</h2><p>假设两个线程，一个向数据结构中填充数据，另一个读取数据结构中的数据。为了避免恶性条件竞争，第一个线程设置一个标志，用来表明数据已经准备就绪，从而第二个线程在这个标志设置前不能读取数据。</p><p>代码5.2 不同线程对数据的读写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!data_ready.<span class="built_in">load</span>())  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer=&quot;</span>&lt;&lt;data[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\m&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">42</span>);  <span class="comment">// 3</span></span><br><span class="line">  data_ready=<span class="literal">true</span>;  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问顺序通过对<code>std::atomic&lt;bool&gt;</code>类型的data_ready变量进行操作完成，这些操作通过*<a href="http://en.wikipedia.org/wiki/Happened-before">先行</a><em>(happens-before)和</em>同发*(synchronizes-with)确定顺序。写入数据③在写入data_ready④前发生，读取①发生在读取数据②之前。</p><p>强制了顺序：写入数据先行于读取数据。</p><p>当data_ready①为true，写操作就会与读操作同步，建立一个“先行”的关系。因为“先行”关系是可传递的，所以写入③先行于写入④，这两个行为又先行于读取操作①，之前的操作都先行于读取数据②。</p><img src="/posts/20a59019/5-2.png" alt="5-2" style="zoom: 67%;"><p>图5.2 对非原子操作，使用原子操作对操作进行强制排序</p><h3 id="同步发生"><a href="#同步发生" class="headerlink" title="同步发生"></a>同步发生</h3><p>“同发”只在原子类型之间进行。例如：操作一个数据结构(对互斥量上锁)，如果数据结构包含有原子类型，并且操作内部执行了一定的原子操作，那这些操作就是“同发”关系。</p><p>“同发”的基本想法：原子写操作W对变量x进行标记，同步与对x进行原子读操作，读取的是W操作写入的内容，或是W之后，同一线程上的原子写操作对x写入的值，亦或是任意线程对x的一系列原子读-改-写操作(例如，fetch_add()或compare_exchange_weak())。</p><p>因为对原子类型的操作默认都有“适当的标记”，如果线程A存储了一个值，并且线程B读取了这个值，线程A的存储操作与线程B的载入操作就是同步发生关系。</p><p>所有细微的差别都在“适当的标记”中，C++内存模型允许为原子类型提供各种约束顺序。</p><h3 id="先行发生"><a href="#先行发生" class="headerlink" title="先行发生"></a>先行发生</h3><p>“先行”关系是一个程序中基本构建块的操作顺序：指定了某个操作去影响另一个操作。</p><p>对于单线程来说：一个操作排在另一个之后，那这个操作就先执行。</p><p>如果源码中操作A发生在操作B之前，那A就先行于B。可以回看代码5.2：对data的写入③先于对data_ready④的写入。如果操作在同时发生，因为操作间无序执行，通常情况下就没有先行关系了。</p><p>代码5.3 对于参数中的函数调用顺序未指定顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;”,”&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="built_in">get_num</span>(),<span class="built_in">get_num</span>());  <span class="comment">// 无序调用get_num()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会输出“1，2”或“2，1”，因为两个get_num()的执行顺序未指定。</p><p>这种情况下，操作在单一声明中可测序，例如：逗号操作符的使用或是表达式的结果作为参数传给另一个表达式。通常情况下，操作在单一声明中不可排序，所以无法先行安排顺序(也就没有先行发生了)。</p><p>线程间先行可以与排序先行相结合：如果操作A排序先行于操作B，并且操作B线程间先行于操作C，那么A线程间先行于C。同样的，如果A同步于B，并且B排序先于C，那么A线程间先行于C。当对数据进行一系列修改(单线程)时，只需要对数据进行一次同步即可。</p><p>如果操作A与操作B同步，或操作A的顺序在操作B之前，那么A就是强先行于B。也适用于顺序传递：如果A强先行于B，并且B强先行于C，那么A就肯定强先行于C。</p><h3 id="原子操作的内存序"><a href="#原子操作的内存序" class="headerlink" title="原子操作的内存序"></a>原子操作的内存序</h3><p>有六个内存序列选项可应用于对原子类型的操作：</p><ol><li>memory_order_relaxed</li><li>memory_order_consume</li><li>memory_order_acquire</li><li>memory_order_release</li><li>memory_order_acq_rel</li><li>memory_order_seq_cst</li></ol><p>除非为特定的操作指定一个序列选项，要不内存序列默认都是memory_order_seq_cst。</p><p>三种内存模型：</p><ul><li>顺序一致性(sequentially consistent)</li><li>获取-释放序(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)</li><li>自由序(memory_order_relaxed)。</li></ul><p>不同的内存序在不同的CPU架构下功耗不同。不同种类的内存序，允许使用其提升相关操作的性能。使用顺序一致序(相较于其他序列，它是最简单的)时，对于在通常情况来说就够用了。</p><p><strong>顺序一致性</strong></p><p>默认序命名为顺序一致性，因为程序中的行为从任意角度去看，序列都保持一定顺序。</p><p>如果原子实例的所有操作都是序列一致的，那么多线程就会如单线程那样以某种特殊的排序执行</p><p>不同的操作也要遵守相同的顺序。因为行为简单，可以使用原子变量进行编写。通过不同的线程，可以写出所有可能的操作消除那些不一致，以及确认代码的行为是否与预期相符。所以，操作都不能重排；如果代码在一个线程中，将一个操作放在另一个操作前面，那其他线程也需要了解这个顺序。</p><p>缺点：因为整个序列中的操作都必须在多个处理器上保持一致，可能需要对处理器间的同步操作进行扩展(代价很昂贵！)</p><p>代码5.4 全序——序列一致性</p><p>#include <atomic><br>#include <thread><br>#include &lt;assert.h&gt;</thread></atomic></p><p>std::atomic<bool> x,y;<br>std::atomic<int> z;</int></bool></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_seq_cst))  <span class="comment">// 3</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_seq_cst))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assert⑤语句是永远不会触发的，因为不是存储x的操作①发生，就是存储y的操作②发生。</p><img src="/posts/20a59019/5-3.png" alt="5-3" style="zoom: 50%;"><p>图5.3 序列一致与先行关系</p><p>序列一致性是最简单、直观的序列，因为需要对所有线程进行全局同步，所以也是开销最大的内存序。多处理器设备上需要在处理期间，在信息交换上耗费大量的时间。</p><p>为了避免这种消耗，就需考虑使用其他内存序。</p><p><strong>非顺序一致性内存</strong></p><p>不同线程看到相同操作，不一定有着相同的顺序。</p><p>不仅是考虑事情同时发生的问题，还有<strong>线程没办法保证一致性</strong>。</p><p><strong>自由序</strong></p><p>原子类型上的操作以自由序执行。同一线程中对于同一变量的操作还是遵从先行关系，但不同线程不需要规定顺序。唯一的要求是在访问同一线程中的单个原子变量不能重排序，当给定线程看到原子变量的值时，随后线程的读操作就不会去检索较早的那个值。当使用memory_order_relaxed时，不需要任何额外的同步，对于每个变量的修改顺序只存在于线程间共享。</p><p>代码5.5 非限制操作只有非常少的顺序要求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次assert⑤可能会触发，因为加载x的操作④可能读取到false，即使加载y的操作③读取到true，并且存储x的操作①先发与存储y的操作②。x和y是两个不同的变量，所以没有顺序去保证每个操作产生相关值的可见性。</p><p>非限制操作对于不同变量可以重排序，只要服从任意的先行关系即可(比如，在同一线程中)。</p><img src="/posts/20a59019/5-4.png" alt="5-4" style="zoom: 50%;"><p>图5.4 非限制原子操作与先发执行</p><p>代码5.6 非限制操作——多线程版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">y</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">go</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">const</span> loop_count=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_values</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">read_values values1[loop_count];</span><br><span class="line">read_values values2[loop_count];</span><br><span class="line">read_values values3[loop_count];</span><br><span class="line">read_values values4[loop_count];</span><br><span class="line">read_values values5[loop_count];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(std::atomic&lt;<span class="keyword">int</span>&gt;* var_to_inc,read_values* values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 3 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    values[i].x=x.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].z=z.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    var_to_inc-&gt;<span class="built_in">store</span>(i+<span class="number">1</span>,std::memory_order_relaxed);  <span class="comment">// 4</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_vals</span><span class="params">(read_values* values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 5 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    values[i].x=x.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].z=z.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(read_values* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i)</span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].z&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(increment,&amp;x,values1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(increment,&amp;y,values2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t3</span><span class="params">(increment,&amp;z,values3)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t4</span><span class="params">(read_vals,values4)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t5</span><span class="params">(read_vals,values5)</span></span>;</span><br><span class="line"></span><br><span class="line">  go=<span class="literal">true</span>;  <span class="comment">// 6 开始执行主循环的信号</span></span><br><span class="line"></span><br><span class="line">  t5.<span class="built_in">join</span>();</span><br><span class="line">  t4.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(values1);  <span class="comment">// 7 打印最终结果</span></span><br><span class="line">  <span class="built_in">print</span>(values2);</span><br><span class="line">  <span class="built_in">print</span>(values3);</span><br><span class="line">  <span class="built_in">print</span>(values4);</span><br><span class="line">  <span class="built_in">print</span>(values5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个全局原子变量①和五个线程。每一个线程循环10次，使用时memory_order_relaxed读取三个原子变量的值，并且将它们存储在一个数组上。其中三个线程每次通过循环④来更新其中一个原子变量，这时剩下的两个线程就负责读取。当线程都汇入主线程，就能打印出来每个线程存到数组上的值了。</p><p>原子变量go②用来确保线程同时退出。启动线程是昂贵的操作，并且没有明确的延迟，第一个线程可能在最后一个线程开始前结束。每个线程都在go变为true前，都在循环③⑤。并且当go设置为true时，所有线程都会开始运行⑥。</p><p>程序一种可能的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,7,0),(6,7,8),(7,9,8),(8,9,8),(9,9,10)</span><br><span class="line">(0,0,0),(0,1,0),(0,2,0),(1,3,5),(8,4,5),(8,5,5),(8,6,6),(8,7,9),(10,8,9),(10,9,10)</span><br><span class="line">(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8),(0,0,9)</span><br><span class="line">(1,3,0),(2,3,0),(2,4,1),(3,6,4),(3,9,5),(5,10,6),(5,10,8),(5,10,10),(9,10,10),(10,10,10)</span><br><span class="line">(0,0,0),(0,0,0),(0,0,0),(6,3,7),(6,5,7),(7,7,7),(7,8,7),(8,8,7),(8,8,9),(8,8,9)</span><br></pre></td></tr></table></figure><p>前三行中线程都做了更新，后两行线程只是做读取。每三个值都是一组x，y和z，并按照这样的顺序依次循环。对于输出，需要注意的是：</p><ol><li>第一组值中x增1，第二组值中y增1，第三组中z增1。</li><li>x元素只在给定集中增加，y和z也一样，但是是不均匀增加，并且每个线程中的相对顺序都不同。</li><li>线程3看不到x或y的任何更新，它能看到的只有z的更新。这并不妨碍别的线程观察z的更新，并同时观察x和y的更新。</li></ol><p>对于非限制操作，这个结果没毛病(但是不是唯一合法的输出)。任意组都用三个变量保持一致，从0到10依次递增，并且线程对相应变量进行递增操作，所以打印出的值在0到10的范围内都合理。</p><p>要想获取额外的同步，且不使用全局排序一致，可以使用<em>获取-释放序</em>(acquire-release ordering)。</p><p><strong>获取-释放序</strong></p><p><em>自由序</em>(relaxed ordering)的加强版，虽然操作依旧没有统一顺序，但引入了同步。</p><p>原子加载就是<em>获取</em>(acquire)操作(memory_order_acquire)，原子存储就是<em>释放</em>(memory_order_release)操作，原子读-改-写操作(例如fetch_add()或exchange())在这里，不是“获取”就是“释放”，或者两者兼有的操作(memory_order_acq_rel)，同步在线程释放和获取间是<em>成对的</em>(pairwise)，释放操作与获取操作同步就能读取已写入的值。</p><p>代码5.7 获取-释放不意味着统一操作顺序 使用获取-释放序(而非序列一致方式)，对代码5.4的一次重写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_acquire))  <span class="comment">// 1</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_acquire))  <span class="comment">// 2</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言③可能会触发(就如同自由排序那样)，因为在加载x②和y①时，可能读取到false。因为x和y是由不同线程写入，所以序列中的每一次释放和获取都不会影响到其他线程的操作。</p><img src="/posts/20a59019/5-6.png" alt="5-6" style="zoom:50%;"><p>图5.6 获取-释放，以及先行过程</p><p>对于读取的结果，两个(读取)线程看到的是两个完全不同的世界。</p><p>代码5.8 获取-释放序操作会影响释放操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1 </span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3 自旋，等待y被设置为true</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取y③时会得到true，和存储时写入的一样②。存储使用的是memory_order_release，读取使用的是memory_order_acquire，存储与读取就同步了。因为这两个操作是由同一个线程串行完成的，所以存储x①的操作先行于存储y②的操作。</p><p>对y的存储同步与对y的加载，存储x也就先行于对y的加载，并且扩展先行于x的读取。因此，加载x的值必为true，并且断言⑤不会触发。如果对于y的加载不是在while循环中，情况可能就会有所不同。加载y的时候可能会读取到false，这种情况下对于读取到的x是什么值没有要求了。为了保证同步，加载和释放操作必须成对。</p><p>释放操作存储的值必须要让获取操作看到。当存储②或加载③都是一个释放操作时，对x的访问就无序了，也就无法保证④处读到的是true，并且还会触发断言。</p><p><strong>获取-释放序传递同步</strong></p><p>为了考虑传递顺序，至少需要三个线程。第一个线程用来修改共享变量，第二个线程使用“加载-获取”读取由“存储-释放”操作过的变量，并且再对第二个变量进行“存储-释放”操作。最后，由第三个线程通过“加载-获取”读取第二个共享变量，并提供“加载-获取”操作来读取被“存储-释放”操作写入的值。为了保证同步关系，即便是中间线程没有对共享变量做任何操作，第三个线程也可以读取第一个线程操作过的变量。</p><p>代码5.9 使用获取和释放序传递同步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; data[<span class="number">5</span>];</span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">sync1</span><span class="params">(<span class="literal">false</span>)</span>, <span class="title">sync2</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data[<span class="number">0</span>].<span class="built_in">store</span>(<span class="number">42</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">1</span>].<span class="built_in">store</span>(<span class="number">97</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">2</span>].<span class="built_in">store</span>(<span class="number">17</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">3</span>].<span class="built_in">store</span>(<span class="number">-141</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">4</span>].<span class="built_in">store</span>(<span class="number">2003</span>,std::memory_order_relaxed);</span><br><span class="line">  sync1.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);  <span class="comment">// 1.设置sync1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync1.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 2.直到sync1设置后，循环结束</span></span><br><span class="line">  sync2.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);  <span class="comment">// 3.设置sync2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync2.<span class="built_in">load</span>(std::memory_order_acquire));   <span class="comment">// 4.直到sync1设置后，循环结束</span></span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">0</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">1</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">97</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">2</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">17</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">3</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">-141</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">4</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">2003</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread_1将数据存储到data中先行于存储sync1①(它们在同一个线程内)。因为加载sync1①的是一个while循环，它最终会看到thread_1存储的值。因此，对于sync1的存储先行于最终对于sync1的加载(在while循环中)。thread_3的加载操作④，位于存储sync2③操作的前面。存储sync2③因此先行于thread_3的加载④，加载又先行于存储sync2③，存储sync2又先行于加载sync2④，加载syn2又先行于加载data。因此，thread_1存储数据到data的操作先行于thread_3中对data的加载，并且保证断言都不会触发。</p><p>将sync1和sync2通过在thread_2中使用“读-改-写”操作(memory_order_acq_rel)合并成一个独立的变量。其中会使用compare_exchange_strong()来保证thread_1对变量只进行一次更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">sync</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sync.<span class="built_in">store</span>(<span class="number">1</span>,std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> expected=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!sync.<span class="built_in">compare_exchange_strong</span>(expected,<span class="number">2</span>,</span><br><span class="line">              std::memory_order_acq_rel))</span><br><span class="line">    expected=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(sync.<span class="built_in">load</span>(std::memory_order_acquire)&lt;<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用memory_order_acq_rel语义的“读-改-写”操作，每一个动作都包含获取和释放操作，所以可以和之前的存储操作进行同步，并且可以对随后的加载操作进行同步，就像上面例子一样。</p><h3 id="释放队列与同步"><a href="#释放队列与同步" class="headerlink" title="释放队列与同步"></a>释放队列与同步</h3><p>通过线程在存储和加载操作之间有(有序的)多个“读-改-写”操作(所有操作都已经做了适当的标记)，所以可以获取原子变量存储与加载的同步关系。存储操作标记为memory_order_release，memory_order_acq_rel或memory_order_seq_cst，加载标记为memory_order_consum，memory_order_acquire或memory_order_sqy_cst，并且操作链上的每一加载操作都会读取之前操作写入的值，因此链上的操作构成了一个释放序列(<em>release sequence</em>)，并且初始化存储同步(对应memory_order_acquire或memory_order_seq_cst)或是前序依赖(对应memory_order_consume)的最终加载，操作链上的任何原子“读-改-写”操作可以拥有任意个内存序(甚至是memory_order_relaxed)。</p><p>假设使用<code>atomic&lt;int&gt;</code>对共享队列的元素进行计数：</p><p>代码5.11 使用原子操作从队列中读取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; queue_data;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">const</span> number_of_items=<span class="number">20</span>;</span><br><span class="line">  queue_data.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;number_of_items;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    queue_data.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count.<span class="built_in">store</span>(number_of_items,std::memory_order_release);  <span class="comment">// 1 初始化存储</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_queue_items</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> item_index;</span><br><span class="line">    <span class="keyword">if</span>((item_index=count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>,std::memory_order_acquire))&lt;=<span class="number">0</span>)  <span class="comment">// 2 一个“读-改-写”操作</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">wait_for_more_items</span>();  <span class="comment">// 3 等待更多元素</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process</span>(queue_data[item_index<span class="number">-1</span>]);  <span class="comment">// 4 安全读取queue_data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个消费者线程时还好，fetch_sub()带有memory_order_acquire的读取操作，并且存储操作是带有memory_order_release语义，所以存储与加载同步，线程可以从缓存中读取元素。当有两个读取线程时，第二个fetch_sub()操作将看到第一个线程修改的值，且没有值通过store写入其中。先不管释放序列的规则，第二个线程与第一个线程不存在先行关系，并且对共享内存中值的读取也不安全。除非第一个fetch_sub()是带有memory_order_release语义，为两个消费者线程建立了不必要的同步。无论是释放序列的规则，还是具有memory_order_release语义的fetch_sub操作，第二个消费者看到的是一个空的queue_data，无法从其获取任何数据，并且还会产生条件竞争。</p><p>不过，第一个fetch_sub()对释放顺序做了一些事情，所以store()能同步与第二个fetch_sub()操作。两个消费者线程间不需要同步关系。过程在图5.7中展示，其中虚线表示的就是释放顺序，实线表示的是先行关系。</p><img src="/posts/20a59019/5-7.png" alt="5-7" style="zoom: 67%;"><p>图5.7 代码5.11中对队列操作的释放顺序</p><p>操作链中可以有任意数量的链接，提供的都是“读-改-写”操作，比如fetch_sub()，store()，每一个都会与使用memory_order_acquire语义的操作进行同步。</p><h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p>栅栏操作会对内存序列进行约束，使其无法对任何数据进行修改，典型的做法是与使用memory_order_relaxed约束序的原子操作一起使用。</p><p>栅栏属于全局操作，执行栅栏操作可以影响到在线程中的其他原子操作。因为这类操作就像画了一条任何代码都无法跨越的线一样，所以栅栏操作通常也被称为<em>内存栅栏</em>(memory barriers)。</p><p>代码5.12 栅栏可以让自由操作变的有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 4</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 5</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 6</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为加载y的操作④读取③处存储的值，所以释放栅栏②与获取栅栏⑤同步。①处存储x先行于⑥处加载x，最后x读取出来必为true，并且不会触发断言⑦。</p><p>这两个栅栏都是必要的：需要在一个线程中进行释放，然后在另一个线程中进行获取，这样才能构建同步关系。</p><p>当获取操作能看到释放栅栏操作后的存储结果，那么这个栅栏就与获取操作同步。并且，当加载操作在获取栅栏操作前，看到一个释放操作的结果，那么这个释放操作同步于获取栅栏。</p><p>虽然，栅栏同步依赖于读取/写入的操作发生于栅栏之前/后，但是这里有一点很重要：同步点，就是栅栏本身。当执行代码5.12中的write_x_then_y，并且在栅栏操作之后对x进行写入，就像下面的代码一样。触发断言的条件就不保证一定为true了，尽管写入x的操作在写入y的操作之前发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栅栏不会分开这里的两个操作，并且也不再有序。只有当栅栏出现在存储x和存储y操作之间时，顺序才是硬性的。当然，栅栏是否存在不会影响任何拥有先行关系的执行序列。</p><h3 id="原子操作对非原子的操作排序"><a href="#原子操作对非原子的操作排序" class="headerlink" title="原子操作对非原子的操作排序"></a>原子操作对非原子的操作排序</h3><p>使用普通的非原子bool类型来替换代码5.12中的x，行为和替换前完全一样。</p><p>代码5.13 使用非原子操作执行序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> x=<span class="literal">false</span>;  <span class="comment">// x现在是一个非原子变量</span></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">true</span>;  <span class="comment">// 1 在栅栏前存储x</span></span><br><span class="line">  <span class="function">std::atomic_thread_fe <span class="title">nce</span><span class="params">(std::memory_order_release)</span></span>;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 2 在栅栏后存储y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3 在#2写入前，持续等待</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span>(x)  <span class="comment">// 4 这里读取到的值，是#1中写入</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5 断言将不会触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栅栏仍然为存储x①和存储y②，还为加载y③和加载x④提供一个执行序，并且这里存储x和加载x之间仍然有一个先行关系，所以不会触发断言⑤。②中的存储和③中对y的加载必须是原子操作，否则会在y上产生条件竞争。当读取线程看到存储到y的操作，栅栏将会对x执行有序的操作，这个执行序意味着x上不存在条件竞争。</p><p>不仅是栅栏可对非原子操作排序，memory_order_release/memory_order_consume也为非原子访问排序，可以动态分配对象，并且本章中的许多例子都可以使用普通的非原子操作，去替代memory_order_relaxed的操作。</p><h3 id="非原子操作排序"><a href="#非原子操作排序" class="headerlink" title="非原子操作排序"></a>非原子操作排序</h3><p>某一内存位置上，lock()作为一个获取操作，在同样的位置上unlock()作为一个释放操作。</p><p>以下的工具都可以提供同步：</p><p><strong>std::thread</strong></p><ul><li>std::thread构造新线程时，构造函数与调用函数或新线程的可调用对象间的同步。</li><li>对std::thread对象调用join，可以和对应的线程进行同步。</li></ul><p><strong>std::mutex, std::timed_mutex, std::recursive_mutex, std::recursibe_timed_mutex</strong></p><ul><li>对给定互斥量对象调用lock和unlock，以及对try_lock，try_lock_for或try_lock_until，会形成该互斥量的锁序。</li><li>对给定的互斥量调用unlock，需要在调用lock或成功调用try_lock，try_lock_for或try_lock_until之后，这样才符合互斥量的锁序。</li><li>对try_lock，try_lock_for或try_lock_until失败的调用，不具有任何同步关系。</li></ul><p><strong>std::shared_mutex ,  std::shared_timed_mutex</strong></p><ul><li>对给定互斥量对象调用lock、unlock、lock_shared和unlock_shared，以及对 try_lock ,  try_lock_for ,  try_lock_until ,  try_lock_shared ,  try_lock_shared_for或 try_lock_shared_until的成功调用，会形成该互斥量的锁序。</li><li>对给定的互斥量调用unlock，需要在调用lock或shared_lock，亦或是成功调用try_lock ,  try_lock_for,  try_lock_until,  try_lock_shared,  try_lock_shared_for或try_lock_shared_until之后，才符合互斥量的锁序。</li><li>对try_lock，try_lock_for，try_lock_until，try_lock_shared，try_lock_shared_for或try_lock_shared_until 失败的调用，不具有任何同步关系。</li></ul><p><strong>std::shared_mutex和std::shared_timed_mutex</strong></p><ul><li>成功的调用std::promise对象的set_value或set_exception与成功的调用wait或get之间同步，或是调用wait_for或wait_until的返回例如future状态std::future_status::ready与promise共享同步状态。</li><li>给定std::promise对象的析构函数，该对象存储了一个std::future_error异常，成功的调用wait或get后，共享同步状态与promise之间的同步，或是调用wait_for或wait_until返回的future状态std::future_status::ready时，与promise共享同步状态。</li></ul><p><strong>std::packaged_task ,  std::future和std::shared_future</strong></p><ul><li>成功的调用std::packaged_task对象的函数操作符与成功的调用wait或get之间同步，或是调用wait_for或wait_until的返回future状态std::future_status::ready与打包任务共享同步状态。</li><li>std::packaged_task对象的析构函数，该对象存储了一个std::future_error异常，其共享同步状态与打包任务之间的同步在于成功的调用wait或get，或是调用wait_for或wait_until返回的future状态std::future_status::ready与打包任务共享同步状态。</li></ul><p><strong>std::async ,  std::future和std::shared_future</strong></p><ul><li>使用std::launch::async策略性的通过std::async启动线程执行任务与成功的调用wait和get之间是同步的，或调用wait_for或wait_until返回的future状态std::future_status::ready与产生的任务共享同步状态。</li><li>使用std::launch::deferred策略性的通过std::async启动任务与成功的调用wait和get之间是同步的，或调用wait_for或wait_until返回的future状态std::future_status::ready与promise共享同步状态。</li></ul><p><strong>std::experimental::future ,  std::experimental::shared_future和持续性</strong></p><ul><li>异步共享状态变为就绪的事件与该共享状态上调度延续函数的调用同步。</li><li>持续性函数的完成与成功调用wait或get的返回同步，或调用wait_for或wait_until返回的期望值状态std::future_status::ready与调用then构建的持续性返回的future同步，或是与在调度用使用这个future的操作同步。</li></ul><p><strong>std::experimental::latch</strong></p><ul><li>对std::experimental::latch实例调用count_down或count_down_and_wait与在该对象上成功的调用wait或count_down_and_wait之间是同步的。</li></ul><p><strong>std::experimental::barrier</strong></p><ul><li>对std::experimental::barrier实例调用arrive_and_wait或arrive_and_drop与在该对象上随后成功完成的arrive_and_wait之间是同步的。</li></ul><p><strong>std::experimental::flex_barrier</strong></p><ul><li>对std::experimental::flex_barrier实例调用arrive_and_wait或arrive_and_drop与在该对象上随后成功完成的arrive_and_wait之间是同步的。</li><li>对std::experimental::flex_barrier实例调用arrive_and_wait或arrive_and_drop与在该对象上随后完成的给定函数之间是同步的。</li><li>对std::experimental::flex_barrier实例的给定函数的返回与每次对arrive_and_wait的调用同步，当调用给定函数线程会在栅栏处阻塞等待。</li></ul><p><strong>std::condition_variable和std::condition_variable_any</strong></p><ul><li>条件变量不提供任何同步关系，它们是对忙等待的优化，所有同步都由互斥量提供。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> c++多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频算法考察</title>
      <link href="/posts/605267a3/"/>
      <url>/posts/605267a3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">力扣链接</a></p><p>将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            node-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) node-&gt;next = l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) node-&gt;next = l1;</span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode* node0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    node0-&gt;next = node1;</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> node = <span class="built_in">merge</span>(node0, node4);</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; endl;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span>  <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">ListNode* pre =dummy;</span><br><span class="line">pre-&gt;next = pHead;</span><br><span class="line">ListNode* cur = pHead-&gt;next;</span><br><span class="line">pHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//pre = cur;</span></span><br><span class="line">ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">temp = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">temp-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="comment">//for_each(data.begin(), data.end(), [](const auto a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> key = data[low], begin = low, end = high;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp; data[end] &gt; key) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin &lt; end) data[begin++] = data[end];</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp; data[begin] &lt;= key) &#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin &lt; end) data[end--] = data[begin];</span><br><span class="line">&#125;</span><br><span class="line">data[begin] = key;</span><br><span class="line"><span class="built_in">quickSort</span>(data, low, begin - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quickSort</span>(data, begin + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//data和copy数组大小相同，copy数组变为有序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, vector&lt;<span class="keyword">int</span>&gt;&amp; copy, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line"><span class="keyword">int</span> index = begin;</span><br><span class="line"><span class="built_in">mergeSort</span>(copy, data, low1, high1);</span><br><span class="line"><span class="built_in">mergeSort</span>(copy, data, low2, high2);</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) &#123;</span><br><span class="line">copy[index++] = data[low1] &lt; data[low2] ? data[low1++] : data[low2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1) copy[index++] = data[low1++];</span><br><span class="line"><span class="keyword">while</span> (low2 &lt;= high2) copy[index++] = data[low2++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对原数组进行归并排序。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">mergeSort2</span>(data, low1, high1);</span><br><span class="line"><span class="built_in">mergeSort2</span>(data, low2, high2);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(end - begin + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) &#123;</span><br><span class="line">help[index++] = data[low1] &lt; data[low2] ? data[low1++] : data[low2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1) help[index++] = data[low1++];</span><br><span class="line"><span class="keyword">while</span> (low2 &lt;= high2) help[index++] = data[low2++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">data[begin + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个堆排序"><a href="#实现一个堆排序" class="headerlink" title="实现一个堆排序"></a>实现一个堆排序</h2><p>堆排序过程：</p><ul><li>将n个元素的序列构建一个大顶堆或小顶堆</li><li>将堆顶的元素放到序列末尾</li><li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li></ul><p>整体时间复杂度为O(nlogn)，空间复杂度O(1)</p><p>注：堆排序是<strong>不稳定</strong>的排序算法，是一种树形选择排序。恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。不适合记录较少的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxid = index;</span><br><span class="line"><span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[maxid]) maxid = left;</span><br><span class="line"><span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[maxid]) maxid = right;</span><br><span class="line">    <span class="comment">// maxid是3个数中最大数的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line"><span class="keyword">if</span> (maxid != index) &#123; <span class="comment">// 如果maxid的值有更新</span></span><br><span class="line"><span class="built_in">swap</span>(arr[maxid], arr[index]);</span><br><span class="line"><span class="built_in">adjust</span>(arr, len, maxid); <span class="comment">//递归调整其他不满足堆性质的部分</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)</span></span><br><span class="line"><span class="built_in">adjust</span>(arr, len, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">// 将当前最大的放置到数组末尾，将未完成排序的部分继续进行堆排序</span></span><br><span class="line"><span class="built_in">adjust</span>(arr, i, <span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 3 4 2 1 5 8 7 6</span></span><br><span class="line"><span class="built_in">heapsort</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr)cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计LRU缓存"><a href="#设计LRU缓存" class="headerlink" title="设计LRU缓存"></a>设计LRU缓存</h2><p><a href="https://leetcode-cn.com/problems/lru-cache-lcci">力扣链接(opens new window)</a></p><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> <span class="built_in">LRUCache</span>( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleList</span> &#123;</span><span class="comment">// 定义双向链表</span></span><br><span class="line"><span class="keyword">int</span> key, val;</span><br><span class="line">DoubleList* pre, *next;</span><br><span class="line"><span class="built_in">DoubleList</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _val) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> capcity;<span class="comment">// LRU容量</span></span><br><span class="line">DoubleList* head, *tail;<span class="comment">// 头尾哨兵节点</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, DoubleList*&gt; memory;<span class="comment">// 哈希表存储key对应的双向链表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRU</span>(<span class="keyword">int</span> _capcity) &#123;<span class="comment">// 初始化LRU，设置双向链表的头尾哨兵节点</span></span><br><span class="line"><span class="keyword">this</span>-&gt;capcity = _capcity;</span><br><span class="line">head = <span class="keyword">new</span> <span class="built_in">DoubleList</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">tail = <span class="keyword">new</span> <span class="built_in">DoubleList</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">head-&gt;next = tail;</span><br><span class="line">tail-&gt;pre = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">LRU</span>() &#123;<span class="comment">// 析构删除不为空的指针</span></span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> tail;</span><br><span class="line">tail = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : memory) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.second != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> a.second;</span><br><span class="line">a.second = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入数据（key,val)形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果存储哈希表中有key值存在，更新val值，当前节点先删后加</span></span><br><span class="line"><span class="keyword">if</span> (memory.<span class="built_in">find</span>(_key) != memory.<span class="built_in">end</span>()) &#123;</span><br><span class="line">DoubleList* node = memory[_key];</span><br><span class="line"><span class="built_in">removeNode</span>(node);</span><br><span class="line">node-&gt;val = _val;</span><br><span class="line"><span class="built_in">pushNode</span>(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 哈希表中未存储key，检查当前哈希表的大小与存储容量比较</span></span><br><span class="line"><span class="keyword">if</span> (memory.<span class="built_in">size</span>() == <span class="keyword">this</span>-&gt;capcity) &#123; <span class="comment">// 这里很重要，也很爱错，千万记得更新memory</span></span><br><span class="line"><span class="keyword">int</span> topKey = head-&gt;next-&gt;key;<span class="comment">// 取得key值，方便在后面删除</span></span><br><span class="line"><span class="built_in">removeNode</span>(head-&gt;next);<span class="comment">// 移除头部的下一个</span></span><br><span class="line">memory.<span class="built_in">erase</span>(topKey);<span class="comment">// 在memory中删除当前头部的值</span></span><br><span class="line">&#125;</span><br><span class="line">DoubleList* node = <span class="keyword">new</span> <span class="built_in">DoubleList</span>(_key, _val);<span class="comment">// 新增node</span></span><br><span class="line"><span class="built_in">pushNode</span>(node);<span class="comment">// 放在尾部</span></span><br><span class="line">memory[_key] = node;<span class="comment">// 记得在memory中添加进去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> _key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希表中存在key，返回存储的key对应的val</span></span><br><span class="line"><span class="keyword">if</span> (memory.<span class="built_in">find</span>(_key) != memory.<span class="built_in">end</span>()) &#123;</span><br><span class="line">DoubleList* node = memory[_key];</span><br><span class="line"><span class="built_in">removeNode</span>(node);<span class="comment">// 注意读取的节点先删后加，进行更新</span></span><br><span class="line"><span class="built_in">pushNode</span>(node);</span><br><span class="line"><span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">tail-&gt;pre-&gt;next = node;</span><br><span class="line">node-&gt;pre = tail-&gt;pre;</span><br><span class="line">node-&gt;next = tail;</span><br><span class="line">tail-&gt;pre = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">LRU <span class="title">cache</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cout&lt;&lt; cache.<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl;       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">3</span>) &lt;&lt; endl;       <span class="comment">// 返回  3</span></span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">4</span>) &lt;&lt; endl;       <span class="comment">// 返回  4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><p><a href="https://leetcode-cn.com/problems/reorder-list/">力扣链接</a></p><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line"><span class="built_in">ListNode</span>(<span class="keyword">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 翻转链表，定义哨兵节点，头插法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">myReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line">pre-&gt;next = head;</span><br><span class="line">ListNode* cur = head-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* node = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">node = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">node-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// merge归并过程，链表长度p1 &gt;= p2</span></span><br><span class="line"><span class="function">ListNode* <span class="title">myMerge</span><span class="params">(ListNode* p1, ListNode* p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> p2;</span><br><span class="line"><span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">// 定义哨兵节点</span></span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line"><span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">pre-&gt;next = p1;</span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">pre-&gt;next = p2;</span><br><span class="line">p2 = p2-&gt;next;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>) pre-&gt;next = p1;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重排链表主函数</span></span><br><span class="line"><span class="function">ListNode* <span class="title">myReverOrderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* slow = head, * fast = head-&gt;next;</span><br><span class="line">    <span class="comment">// 快慢指针确定链表中点位置slow</span></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 切分后半部分链表，前半部的链表末尾指向nullptr</span></span><br><span class="line">ListNode* second = slow-&gt;next;</span><br><span class="line">slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">second = <span class="built_in">myReverseList</span>(second);<span class="comment">//翻转后半部分链表</span></span><br><span class="line">head = <span class="built_in">myMerge</span>(head, second);<span class="comment">//归并merge链表返回头节点head</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">head-&gt;next = node1;</span><br><span class="line">node1-&gt;next = node2;</span><br><span class="line">node2-&gt;next = node3;</span><br><span class="line">node3-&gt;next = node4;</span><br><span class="line">node4-&gt;next = node5;</span><br><span class="line">node5-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = <span class="built_in">myReverOrderList</span>(head);</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">力扣链接</a></p><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br><span class="line">示例 2:</span><br><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p>注意：应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p><p>法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* first = head;<span class="comment">// 奇链表头结点</span></span><br><span class="line">ListNode* second = head-&gt;next;<span class="comment">// 偶链表头结点</span></span><br><span class="line">ListNode* cur = second;<span class="comment">// 保存偶链表头结点</span></span><br><span class="line"><span class="keyword">while</span> (second != <span class="literal">nullptr</span> &amp;&amp; second-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">first-&gt;next = second-&gt;next;</span><br><span class="line">second-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line">first = first-&gt;next;</span><br><span class="line">second = second-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">first-&gt;next = cur;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* p = head;</span><br><span class="line">ListNode* q = head-&gt;next;</span><br><span class="line">ListNode* evenhead = q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q-&gt;next = q-&gt;next-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;next = evenhead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><p>Top K问题的常见形式：</p><ul><li>给定10000个整数，找到第K大（第K小）的数</li><li>给定10000个整数，找出最大（最小）的前K个数</li><li>给定100000个单词，求前K词频的单词</li></ul><p>解决Top K问题若干种方法：</p><ul><li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li><li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li><li>使用排序方法，排序后再寻找top K元素。</li><li>使用选择排序的思想，对前K个元素部分排序。</li><li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数</li></ul><ol><li><p>使用最大最小堆的思路（以top K 最大元素为例）</p><p>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</p></li></ol><p>注意：最小堆的插入时间复杂度为log(n), n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p><p>C++中的最大最小堆要用标准库的priority_queue来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="keyword">int</span> v, <span class="keyword">int</span> i) : <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用Quick Select的思路（以寻找第K大的元素为例）</p><p>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的： 首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。 此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作； 如果左边的数组元素个数等于K-1，则第K大的数就是pivot； 如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</p></li></ol><p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, k, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// quick select to find the kth-largest element</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[right];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, left, right);<span class="comment">// 确定第k大（第k小）关键找对边界p</span></span><br><span class="line">    <span class="keyword">if</span> (index - left + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, k, left, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index - left + <span class="number">1</span> == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, k - (index - left + <span class="number">1</span>), index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数确定边界p，左边比p大，右边比p小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left, end = right;</span><br><span class="line">    <span class="keyword">int</span> key = nums[begin];</span><br><span class="line">    <span class="keyword">while</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &gt; end &amp;&amp; nums[end] &lt; key) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) nums[begin++] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (begin &gt; end &amp;&amp; nums[begin] &gt;= key) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) nums[end--] = nums[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[begin] = key;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数确定边界p，左边比p小，右边比p大，使用交换法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high, pivot = arr[low];<span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) j--;<span class="comment">//向左扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;<span class="comment">//向右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j--]);<span class="comment">//交换arr[i]和arr[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[low], arr[i - <span class="number">1</span>]);<span class="comment">//交换arr[i - 1]和arr[low]，并返回基准元素位置i - 1</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[low]);<span class="comment">//交换arr[i]和arr[low]，并返回基准元素位置i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li></ol><h2 id="写三个线程交替打印ABC"><a href="#写三个线程交替打印ABC" class="headerlink" title="写三个线程交替打印ABC"></a>写三个线程交替打印ABC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 1 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 2 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    th3.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; main thread &quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记01</title>
      <link href="/posts/80d55e53/"/>
      <url>/posts/80d55e53/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="OS概述"><a href="#OS概述" class="headerlink" title="OS概述"></a>OS概述</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p><strong>操作系统的两个职责：</strong></p><ul><li><p><strong>对硬件进行管理与抽象</strong></p><ul><li><p>管理硬件：内存分配、设备驱动</p></li><li><p>对硬件进行抽象：将有限的、离散的资源高效地抽象为无限的、连续的资源。将硬件通过易用的接口提供给上层的</p><p>应用，从而使应用无须关心硬件的具体细节。</p></li></ul></li><li><p><strong>为应用提供服务并管理</strong></p><ul><li>服务于应用：提供接口（如系统调用），不同类型的访问控制、应用间交互等服务</li><li>管理应用：应用生命周期管理，包括应用的加载、启动、切换、调度、销毁等。</li></ul></li></ul><p>狭义的OS：操作系统内核 + Shell(命令行界面)</p><p>广义的OS：</p><ul><li><strong>操作系统内核</strong>（对硬件资源的管理与抽象，为操作系统框架提供基础的系统服务）</li><li><strong>操作系统框架</strong>（基于操作系统内核提供的服务，为不同的应用领域提供编程接口与运行环境）</li></ul><p>OS发展历史：</p><p>批处理操作系统 -&gt; 分时处理操作系统（UNIX), shell命令行交互 -&gt; 个人PC（macOS/Windows），人机交互更好</p><h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><ul><li><strong>系统调用接口</strong> 向内核申请服务</li><li><strong>POSIX接口</strong> 可移植操作系统接口，通常通过C library（libc）来实现。</li><li><strong>领域应用接口</strong> 封装面向不同领域的领域应用接口</li></ul><h2 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h2><p>计算机硬件结构主要为<strong>冯·诺伊曼结构</strong></p><ul><li>中央处理器 CPU</li><li>存储器（内存）</li><li>输入输出 I/O</li></ul><p>CPU缓存，比物理内存访问速度快。</p><p><img src="/OS-1/image-20220527155653122.png" alt="image-20220527155653122"></p><p>设备与中断</p><p>内存映射输入输出 MIMO：</p><p>把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配相应的地址。</p><p>轮询与中断</p><p>让CPU不断通过MIMO查看是否有输入，但会使CPU长时间处于等待状态造成浪费。</p><p>获得输入后，向CPU发送一个中断。</p><p>MMIO使得CPU可以主动地访问设备,中断使得设备能够主动地通知CPU，这两种机制是CPU与设备之间交互的重要方式。</p><p>内存</p><p><img src="/OS-1/image-20220527231741888.png" alt="image-20220527231741888"></p><h3 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程 Process"></a>进程 Process</h3><p>与每个进程相关的是<strong>地址空间</strong></p><p>地址空间中存放可执行程序、程序所需要的数据和栈</p><p>进程可以看作是容纳运行一个程序所有信息的容器</p><p><strong>进程表：</strong> 数组或链表结构，存放进程信息</p><p>进程树：一个进程可以创建多个进程（子进程），树形结构</p><p>系统管理器授权每个进程一个给定的UID，子进程与父进程拥有一样的UID</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>管理进程，每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值。一个进程可以拥有的最大地址空间小于主存。</p><p>虚拟内存：操作系统把部分地址空间装入主存，部分留在磁盘上，并在需要的时候交换回来</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>抽象文件模型</p><p>创建文件、删除文件、读和写文件 都需要系统调用。</p><p><strong>文件描述符：</strong> 读写文件前，检查权限可以打开，系统返回一个小整数，供后续操作使用；若禁止使用返回一个错误码</p><p><strong>管道：</strong> 一种虚文件，可以连接两个进程</p><p><img src="/OS-1/image-20220528171527111.png" alt="image-20220528171527111"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统的两大功能：</p><ul><li>为用户提供应用程序抽象</li><li>管理计算机资源</li></ul><p>只有<strong>系统调用能够进入内核态而过程调用则不能进行内核态</strong></p><h4 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h4><p>UNIX中唯一可以在POSIX中创建进程的途径：fork</p><p>fork调用返回一个值，在子进程中为0，在父进程中等于子进程的进程标识符PID。使用返回的PID可以看出哪个是父进程和子进程。</p><p>POSIX：可移植操作系统接口</p><p>waitpid系统调用：为等待子进程完成，父进程执行waitpid</p><p>execve系统调用：实现系统执行，三个参数：将要执行的文件名称、一个指向变量数组的指针、一个指向环境数组的指针。</p><p>一个shell指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure><p>此命令将file1复制到file2文件中，在shell执行fork之后，子进程定位并执行文件拷贝，将将源文件和目标文件的名称传递给它。</p><p>cp的主程序包含声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>(agrc, argv, envp)</span><br></pre></td></tr></table></figure><p>argc：命令行中参数数目的计数，包括程序名称。对于上面的例子，argc是3。</p><p>argv：数组的指针，该数组的元素i为第i个字符串的指针，例如，argc[0]指向字符串cp，argc[1]指向字符串file1，argc[2]指向字符串file2。</p><p>envp：指向环境的指针，该环境是一个数组，含有name = value的赋值形式，例子中，没有环境参数传递给execve，所以execve的第三个参数为0。</p><p>UNIX中的进程将内存划分为三部分：</p><ul><li>text segment，文本区，例如程序代码</li><li>data segment，数据区，例如变量</li><li>stack segment，栈区域，数据向上增长而堆栈向下增长。</li></ul><img src="/posts/80d55e53/image-20220529153518116.png" alt="image-20220529153518116" style="zoom:35%;"><h4 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h4><p>与某个文件有关的系统调用</p><p>常用的调用read和write</p><p>UNIX为每个文件保存了该文件的类型、大小、最后修改时间以及其他信息，程序可以通过stat系统调用查看这些信息。</p><h4 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h4><p>与整个文件系统有关的系统调用</p><p>mkdir和rmdir分别用于创建和删除空目录。</p><p>mount系统调用将两个文件系统合并为一个。</p><h4 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h4><p>chdir调用更改当前工作目录</p><p>chmod系统调用提供改变文件模式的操作</p><p>UNIX与Win32系统调用API</p><table><thead><tr><th>UNIX</th><th>Win32</th><th>说明</th></tr></thead><tbody><tr><td>fork</td><td>CreateProcess</td><td>创建一个进程</td></tr><tr><td>waitpid</td><td>WaitForSingleObject</td><td>等待一个进程退出</td></tr><tr><td>execve</td><td>none</td><td>CraeteProcess = fork + service</td></tr><tr><td>exit</td><td>ExitProcess</td><td>终止执行</td></tr><tr><td>open</td><td>CreateFile</td><td>创建一个文件或打开一个已有的文件</td></tr><tr><td>close</td><td>CloseHandle</td><td>关闭文件</td></tr><tr><td>read</td><td>ReadFile</td><td>从单个文件中读取数据</td></tr><tr><td>write</td><td>WriteFile</td><td>向单个文件中写数据</td></tr><tr><td>lseek</td><td>SetFilePointer</td><td>移动文件指针</td></tr><tr><td>stat</td><td>GetFileAttributesEx</td><td>获得不同的文件属性</td></tr><tr><td>mkdir</td><td>CreateDirectory</td><td>创建一个新的目录</td></tr><tr><td>rmdir</td><td>RemoveDirectory</td><td>移除一个空的目录</td></tr><tr><td>link</td><td>none</td><td>Win32不支持link</td></tr><tr><td>unlink</td><td>DeleteFile</td><td>销毁一个已有的文件</td></tr><tr><td>mount</td><td>none</td><td>Win32不支持mount</td></tr><tr><td>umount</td><td>none</td><td>Win32不支持mount</td></tr><tr><td>chdir</td><td>SetCurrentDirectory</td><td>切换当前工作目录</td></tr><tr><td>chmod</td><td>none</td><td>Win32不支持安全</td></tr><tr><td>kill</td><td>none</td><td>Win32不支持信号</td></tr><tr><td>time</td><td>GetLocalTime</td><td>获取当前时间</td></tr></tbody></table><h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul><li>单体系统</li><li>分层系统</li><li>微内核</li><li>客户-服务端系统</li><li>虚拟机</li><li>外核</li></ul><h4 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h4><p>整个系统在内核态以单一程序的方式运行</p><p>整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行文件</p><p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中。</p><p>三层模型：</p><ul><li>主程序：调用请求服务程序</li><li>服务程序：执行系统调用</li><li>实用程序：辅助服务过程调用</li></ul><h4 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h4><p>使用层来分隔不同的功能单元，每一层只与该层的上层和下层通信。</p><p>每一层都使用下面的层来执行其功能，层之间的通信通过预定义的固定接口通信。</p><table><thead><tr><th>层号</th><th>功能</th></tr></thead><tbody><tr><td>5</td><td>操作员</td></tr><tr><td>4</td><td>用户程序</td></tr><tr><td>3</td><td>输入/输出管理</td></tr><tr><td>2</td><td>操作员-进程通信</td></tr><tr><td>1</td><td>存储器和磁鼓管理</td></tr><tr><td>0</td><td>处理器分配和多道程序编程</td></tr></tbody></table><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核运行在内核态，其余模块可以作为普通用户进程运行。</p><img src="/posts/80d55e53/image-20220529222250168.png" alt="image-20220529222250168" style="zoom:60%;"><p>机制与策略分离，比如系统调度，一个简单的调度算法是对每个进程赋予优先级，让内核执行优先级最高的进程。内核的机制是寻找最高的优先级进程并运行，而策略（赋予进程优先级）可以在用户态中的进程完成。策略与机制分离，使得内核变得更小。</p><h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h4><p>把进程划分为两类：</p><ul><li>服务器，每个服务器用来提供服务</li><li>客户端，使用这些服务</li></ul><img src="/posts/80d55e53/image-20220529222837516.png" alt="image-20220529222837516" style="zoom:67%;"><p>两种载体：</p><ul><li>计算机既是客户端又是服务器</li><li>客户端与服务器在不同机器上（普遍情况），通过局域网或广域网连接</li></ul><p>客户端发送请求并得到回应。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程：对正在运行中的程序的抽象，操作系统最核心的概念。</p><p><strong>伪并发</strong>：单核或多核处理器同时执行多个进程，从而使程序更快。以非常有限的时间间隔在程序之间快速切换CPU。</p><p>缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>计算机上运行的软件包括操作系统，被组织为若干<strong>顺序进程</strong> </p><p>进程包括：程序计数器、寄存器、变量的当前值</p><p>在进程不断切换的过程中，程序计数器也在不同的变化</p><img src="/posts/80d55e53/image-20220530113613610.png" alt="image-20220530113613610" style="zoom:67%;"><p>任何一个给定的瞬间仅有一个进程真正运行</p><p>一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU），每一个核也只能一次运行一个线程。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ul><li>系统初始化（init)</li><li>正在运行的程序执行了创建进程的系统调用（比如fork）</li><li>用户请求创建一个新进程</li><li>初始化一个批处理工作</li></ul><h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>前台进程：同用户进行交互并替他们完成工作的进程</p><p>守护进程：进程运行在后台用来处理一些活动如Email、web网页、打印等</p><p>UNIX中，ps程序可以列出正在运行的进程，Windows中使用任务管理器</p><h4 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h4><p>一个正在运行的进程会发出系统调用，用来创建一个或多个新进程来帮助其完成工作。</p><p>多处理器中，每个进程运行在不同的CPU上可以使工作更快。</p><p>UNIX中，仅有一个系统调用可以创建一个新进程：<strong>fork</strong> ，该调用会创建一个与调用进程相关的副本。</p><h4 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h4><p>交互式系统中，输入一个命令或双击图标可以启动程序，这些操作可以选择开启一个新的进程。</p><p>新进程将接管启动它的窗口，每个窗口都可以运行进程。</p><h3 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h3><p>大型机的批处理系统</p><p>用户提交批处理作业，当操作系统决定它有资源来运行另一个任务时，将创建一个新进程并从其中的输入队列中运行下一个作业。</p><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ul><li>正常退出（自愿的）</li><li>错误退出（自愿的）</li><li>严重错误（非自愿的）</li><li>被其他进程杀死（非自愿的）</li></ul><h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止</p><p>UNIX调用是exit。</p><h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>例如编译foo.c 但是该文件不存在，编译器会发出声明并退出。</p><p>通常会弹出对话框告知用户发生系统错误</p><h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>通常由于程序中的错误导致。例如，执行了一条非法指令，引用不存在的内存，除数为0等。</p><p>UNIX中，这类错误，进程会收到信号（中断），而不是在这类错误出现时直接终止进程</p><h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>UNIX中调用kill，某个进程执行系统调用告诉操作系统杀死某个进程。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>每个进程是一个独立的实体，有其自己的程序计数器和内部状态。</p><p>进程之间需要相互帮助，例如，一个进程的结果可以作为另一个进程的输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程cat，将三个文件级联并输出。</p><p>第二个进程grep，从输入中选取包含有关键字tree的内容。</p><p>可能出现grep准备就绪开始执行，但是输入还未完成，于是必须阻塞grep进程，直到输入完毕。</p><p>进程状态的切换：</p><img src="/posts/80d55e53/image-20220530160754572.png" alt="image-20220530160754572" style="zoom:50%;"><p>进程状态有三种：</p><ul><li><strong>运行态</strong>：进程实际占用CPU时间片运行时</li><li><strong>就绪态</strong>：可运行，但因为其他进程正在运行而处于就绪状态</li><li><strong>阻塞态</strong>：除非某种外部事件发生，否则进程不能运行</li></ul><p>运行态与就绪态很相似，都表示进程可运行，区别在于就绪状态没有获得CPU时间分片。</p><p>阻塞态与前两个不同，进程不能运行，CPU空闲时也不能运行。</p><p>在操作系统发现进程不能继续执行时发生转换1，某些系统执行系统调用如pause，获取一个阻塞的状态。UNIX中，当进程从管道或特殊文件（如终端）中读取没有可用的输入时，该进程自动终止。</p><p>转换2和3由进程调度程序引起。</p><p>进程等待一个外部事件发生（如从外部输入一些数据后），发生转换4；若此时没有其他进程在运行，则立即触发转换3，该进程开始运行，否则该进程处于就绪阶段，等待CPU空闲后再轮到它运行。</p><p><strong>操作系统最底层的就是调度程序。</strong>所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。</p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p><strong>进程表</strong> 进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状态、所打开文件的状态、调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后可以再次启动，就像从未中断过一样。</p><p>关键字段：</p><ul><li>进程管理</li><li>存储管理</li><li>文件管理</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程thread，线程也会有程序计数器、寄存器、堆栈。</p><p>进程用于把资源集中到一起，<strong>线程是CPU上调度执行的实体</strong>。</p><p>线程比进程创建快。</p><p>线程不像进程那样有较强的独立性。由于每个线程都可以访问进程地址空间的每个内存地址，因此<strong>一个线程可以读取、写入甚至擦除另一个线程的堆栈。</strong></p><img src="/posts/80d55e53/image-20220530234435504.png" alt="image-20220530234435504" style="zoom:50%;"><p>线程的状态：运行中、阻塞、就绪和终止。线程之间的状态转换与进程之间的状态转换是一样的。</p><p>线程无法利用时钟中断强制让线程让出CPU。</p><p>线程创建：调用库函数，线程创建函数会要求指定新创建线程的名称，创建的线程通常会返回一个线程标识符，该标识符就是新线程的名字。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要三种实现方式</p><ul><li>在用户空间中实现线程</li><li>在内核空间中实现线程</li><li>在用户和内核空间中混合实现线程</li></ul><h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。</p><img src="/posts/80d55e53/image-20220531103211795.png" alt="image-20220531103211795" style="zoom:50%;"><p>运行时系统：也叫运行时环境，提供了程序在其中运行的环境。</p><p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p><p>每个进程需要有其专用的线程表，用来跟踪该进程中的线程。</p><p>优势：</p><ul><li>启动线程比内核调用效率更高，不需要切换到内核，也不需要上下文切换，不需要对内存高速缓存进行刷新，线程调用非常便捷，因此效率高</li><li>允许每个进程有自己定制的调度算法，用户线程具有较好的可扩展性。</li></ul><p>劣势：</p><ul><li>阻塞系统调用问题，使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程</li><li>缺页中断问题，如果某个程序发生函数调用或跳转指令到了一条不在内存的指令上，会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，称为缺页故障。</li><li>如果一个线程开始运行，该线程所在进程中的其他线程都不能运行，单进程内部没有时钟中断，不能使用轮转调度的方式调度线程。</li></ul><h4 id="在内核空间中实现线程"><a href="#在内核空间中实现线程" class="headerlink" title="在内核空间中实现线程"></a>在内核空间中实现线程</h4><p>不需要运行时环境，每个进程中也没有线程表，在内核中会有记录系统中所有线程的线程表。某个线程希望创建新线程或撤销一个已有线程，会执行一个系统调用，完成对线程表的更新。</p><img src="/posts/80d55e53/image-20220531104923664.png" alt="image-20220531104923664" style="zoom:50%;"><p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，例如运行同一个进程中的另一个线程或者运行另一个进程中的一个线程。</p><p>内核中创建或销毁线程的开销比较大，某些系统会采用可循环利用的方式来回收线程。当某个线程被销毁时，就把他标志为不可运行的状态，但其内部结构没有收到影响，稍后在创建一个新线程时，就会重新启用旧线程，标志为可用状态。</p><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>内核级线程，将用户级线程与某些或全部内核线程多路复用起来。</p><img src="/posts/80d55e53/image-20220531115650409.png" alt="image-20220531115650409" style="zoom:50%;"><p>编程人员可以自由控制用户线程和内核线程的数量，灵活度高。内核只识别内核级线程，对其进行调度，其中一些内核级线程会被多个用户级线程多路复用。</p><h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p>三个问题：</p><ul><li>进程如何传递消息给其他进程</li><li>确保两个或多个线程之间不会相互干扰</li><li>数据的先后顺序问题</li></ul><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>存在共享资源、共享文件、共享内存</p><p>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性。</p><p>如何避免：</p><p><strong>禁止一个或多个进程在同一时刻对共享资源（包括共享文件、共享内存等）进行读写。</strong></p><p>需要<strong>互斥条件</strong>。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区（临界区域）：对共享内存进行访问的程序片。</p><p>使两个不同进程不可能同时处于临界区，就能避免竞争条件。</p><p>使用临界区的互斥</p><img src="/posts/80d55e53/image-20220531121115455.png" alt="image-20220531121115455" style="zoom:50%;"><h3 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h3><h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>单核处理器，每个进程在进入临界区后立即<strong>屏蔽所有中断</strong>，并在离开临界区之前重新启用他们。屏蔽中断后CPU不会切换到其他进程。一旦某个进程屏蔽中断后，就可以检查和修改共享内存，而不担心其他进程介入访问共享数据。</p><p>屏蔽中断对于操作系统本身是一种有用的技术，但是对于用户线程来说，屏蔽中断不是一项通用的互斥机制。</p><h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>考虑有单个共享的锁变量，初始值为0。当一个线程想要进入关键区域时，会首先查看锁的值是否为0，如果锁的值为0，进程会把它设置为1并让进程进入关键区域；如果锁的状态为1，进程会等待直到锁变量的值为0。</p><p>锁变量值为0，表示没有线程进入关键区域，如果为1，表示有进程在关键区域内。</p><img src="/posts/80d55e53/image-20220606180447319.png" alt="image-20220606180447319" style="zoom:50%;"><p>会发生竞争条件，临界区可能会有两个进程同时运行，set-before-check 不是一种原子性操作。</p><h4 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h4><p>先抛出一段代码，用c语言编写。</p><p>进程0的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">/* 进入关键区域*/</span> </span><br><span class="line"> critical_region();</span><br><span class="line"> turn = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 离开关键区域*/</span> </span><br><span class="line"> noncritical_region();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程1的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">/* 进入关键区域*/</span> </span><br><span class="line"> critical_region();</span><br><span class="line"> turn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 离开关键区域*/</span> </span><br><span class="line"> noncritical_region();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量turn初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新内存。</p><p>忙等待：连续检查一个变量直到某个值出现为止，但是这种方式浪费CPU时间，通常应该避免。</p><p>只有在有理由认为等待时间是非常短的情况下，才能使用忙等待。用于忙等待的锁，，称为自旋锁。</p><p>可能会出现违反 <strong>位于临界区外的进程不得阻塞其他进程</strong> 的情况，不算一个好的方案。</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量mutex，一些共享资源和一段代码保持互斥。</p><p>两种状态：解锁和加锁。</p><p>当一个线程（或进程）需要访问关键区域时，会调用mutex_lock进行加锁。如果互斥锁处于解锁状态（表示关键区域可用），则调用成功，并且调用线程可以自由进入关键区域。</p><p>如果mutex互斥量已经锁定，调用线程会阻塞直到关键区域内的线程执行完毕并且调用了mutex_unlock。如果多个线程在mutex互斥量上阻塞，将随机选择一个线程并选择一个线程并允许它获得锁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论基础与拓补排序</title>
      <link href="/posts/75bf15f1/"/>
      <url>/posts/75bf15f1/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h2><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><p>二元组G = &lt;V, E&gt;, V节点集，E边集；</p><p>节点的度：与该节点相关联的边数</p><p>分为：有向图、无向图</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>一个一维数组存储图中节点的信息，一个二维数组存储图中节点之间的邻接关系。</p><p><strong>无向图：</strong></p><img src="/posts/75bf15f1/image-20220520174528197.png" alt="image-20220520174528197" style="zoom:80%;"><p>特点：</p><ul><li><p>无向图的邻接矩阵是<strong>对称矩阵，并且是唯一的</strong>。</p></li><li><p>第i行或第i列非零元素的个数正好是第i个节点的度。上图中的邻接矩阵，第3列非零元素的个数为2，说明第3个节点c的度为2。</p></li></ul><p><strong>有向图：</strong></p><p>以尖括号&lt;vi, vj&gt;表示的是有序对，以圆括号(vi ,vj)表示的是无序对。</p><p>有向图的邻接矩阵不一定是对称的</p><img src="/posts/75bf15f1/image-20220520174937549.png" alt="image-20220520174937549" style="zoom:80%;"><p>特点：</p><ul><li>有向图的邻接矩阵<strong>不一定是对称</strong>的。</li><li><strong>第i行非零元素的个数正好是第i个节点的出度，第i列非零元素的个数正好是第i个节点的入度。</strong>上图中的邻接矩阵，第3行非零元素的个数为2，第3列非零元素的个数也为2，说明第3个节点c的出度和入度均为2。</li></ul><p><strong>网（带权图）：</strong></p><img src="/posts/75bf15f1/image-20220520175300124.png" alt="image-20220520175300124" style="zoom:80%;"><p><strong>邻接矩阵的优点：</strong></p><ul><li><p>快速判断在两节点之间是否有边。在图中，<code>Edge[i][j]=1</code>，表示有边；<code>Edge[i][j]=0</code>，表示无边。在网中，<code>Edge[i][j]=∞</code>，表示无边，否则表示有边。时间复杂度为O (1)。</p></li><li><p>方便计算各节点的度。在无向图中，邻接矩阵第i行元素之和就是节点i的度；在有向图中，第i行元素之和就是节点i的出度，第i列元素之和就是节点i的入度。时间复杂度为O(n)。</p></li></ul><p><strong>邻接矩阵的缺点：</strong></p><ul><li><p>不便于增删节点。增删节点时，需要改变邻接矩阵的大小，效率较低。</p></li><li><p>不便于访问所有邻接点。访问第i个节点的所有邻接点时，需要访问第i行的所有元素，时间复杂度为O(n)。访问所有节点的邻接点，时间复杂度为O(n^2)。</p></li><li><p>空间复杂度高，为O(n^2)。</p></li></ul><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表是图的一种链式存储方法，其数据结构包括两部分：节点和邻接点。</p><ol><li>无向图</li></ol><p>一个节点的所有邻接点构成一个单链表。</p><p><img src="/20220520/image-20220520175923798.png" alt="image-20220520175923798"></p><p>无向图特点：</p><ul><li><p>如果无向图有n个节点、e条边，则节点表有n个节点，邻接点表有2e个节点。</p></li><li><p>节点的度为该节点后面单链表中的节点数。</p></li></ul><ol start="2"><li>有向图</li></ol><p><img src="/20220520/image-20220520180303332.png" alt="image-20220520180303332"></p><p>对有向图中节点的邻接点，只看该节点的出边（出弧）。</p><p>有向图特点：</p><ul><li><p>如果有向图有n个节点、e条边，则节点表有n个节点，邻接点表有e个节点。</p></li><li><p>节点的出度为该节点后面单链表中的节点数。</p></li></ul><p>在有向图邻接表中很<strong>容易找到节点的出度</strong>，但是<strong>找入度很难，需要遍历所有邻接点表中的节点</strong>，查找到<strong>该节点出现了多少次，入度就是多少</strong>。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>参考多叉树，多叉树的遍历框架如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 多叉树遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (TreeNode* child : root -&gt; children) &#123;</span><br><span class="line"><span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图和多叉树最⼤的区别是，图是可能包含环的，你从图的某⼀个节点开始遍历，有可能⾛了⼀圈⼜回到这个 </p><p>节点。 </p><p>因此，遍历需要一个<code>visited</code>辅助数组，不走重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于图的遍历，应该把<code>onPath</code>的操作放到for循环外⾯，否则会漏掉记录起始点的遍历。</p><p>如果图中不含有环，可以把<code>visited</code>数组省略。</p><p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797.所有可能路径</a></p><p>题目描述： </p><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） <code>graph[i]</code>是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>解析：</p><p>有向无环图，以0为起点开始遍历，同时记录走过的路径，当遍历到终点时将路径记录下来。</p><p>可以不使用visited数组辅助。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res; <span class="comment">//记录所有的路径</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//维护递归过程中经过的路径</span></span><br><span class="line">    <span class="built_in">tranverse</span>(graph, path, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加节点index到路径</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == n - <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, path, v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//从路径移除节点index</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断图是否有环（图的遍历）"><a href="#判断图是否有环（图的遍历）" class="headerlink" title="判断图是否有环（图的遍历）"></a>判断图是否有环（图的遍历）</h2><p><a href="https://leetcode.cn/problems/course-schedule/">207.课程表</a></p><p>存在依赖问题，⾸先把问题转化成「有向图」这种数据结构，<strong>只要图中存在环，那就说明存在循环依赖</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>graph[index]</strong> 是⼀个列表，存储着节点 index 所指向的节点。 </p><p>先建图 + 遍历图判断是否存在环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle = <span class="number">0</span>; <span class="comment">// 记录图中是否有环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//防止重复遍历同一节点</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//记录当前走过的路径</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历图中的所有节点</span></span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, i, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 只要没有循环依赖可以完成所有课程</span></span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立图的邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    <span class="comment">//图中共有numCourses个节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to  = v[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 修完课程 from 才能修课程 to</span></span><br><span class="line"><span class="comment">// 在图中添加⼀条从 from 指向 to 的有向边</span></span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited,vector&lt;<span class="keyword">bool</span>&gt;&amp; path, <span class="keyword">int</span> index, <span class="keyword">bool</span>&amp; hasCycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[index]) &#123; <span class="comment">//如果发现Path[index] 已经被标记说明出现了环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>; <span class="comment">//发现环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[index] || hasCycle) &#123; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将节点index标记为已遍历</span></span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//开始遍历节点index</span></span><br><span class="line">    path[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, v, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点index遍历完成</span></span><br><span class="line">    path[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓补排序"><a href="#拓补排序" class="headerlink" title="拓补排序"></a>拓补排序</h2><p><a href="https://leetcode.cn/problems/course-schedule-ii/submissions/">210.课程表II</a></p><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>拓扑排序（Topological Sorting）</p><p>直观地说就是，让你把⼀幅图「拉平」，⽽且这个「拉平」的图⾥⾯，所有箭头⽅向都是⼀致的。</p><p>如果⼀幅有向图中存在环，是⽆法进⾏拓扑排序的，因为肯定做不到所有箭头⽅向⼀致；反过来，如果⼀幅图是<strong>「有向⽆环图」</strong>，那么<strong>⼀定可以进⾏拓扑排序</strong>。 </p><p><strong>将后序遍历的结果进⾏反转，就是拓扑排序的结果。</strong></p><p>先对图进行DFS遍历，记录后序遍历结果，最后将后序遍历结果反转。</p><p>进⾏<strong>拓扑排序之前要进⾏环检测</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; postorder; <span class="comment">// 记录后序遍历结果</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle = <span class="literal">false</span>; <span class="comment">// 记录是否存在环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 建立图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, i, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有环图⽆法进⾏拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 逆后序遍历结果即为拓扑排序结果</span></span><br><span class="line">    <span class="built_in">reverse</span>(postorder.<span class="built_in">begin</span>(), postorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postorder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立图的邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to  = v[<span class="number">0</span>];</span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited,vector&lt;<span class="keyword">bool</span>&gt;&amp; path, <span class="keyword">int</span> index, <span class="keyword">bool</span>&amp; hasCycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[index]) &#123;</span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[index] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 前序遍历位置</span></span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    path[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited, path, v, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    postorder.<span class="built_in">push_back</span>(index);</span><br><span class="line">    path[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且 </p><p>两个⼦集内的顶点不相邻。</p><p>给出一副图，用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p><img src="/posts/75bf15f1/image-20220520214203061.png" alt="image-20220520214203061" style="zoom:50%;"><p>二分图的判定：</p><p>遍历⼀遍图，⼀边遍历⼀边染⾊，看看能不能⽤两种颜⾊给所有节点染⾊，且相邻节点的颜⾊都不相同。 </p><p><strong>图的遍历框架1：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图的遍历框架2：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 只遍历没标记过的相邻节点</span></span><br><span class="line">            <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法把对 visited 的判断放到递归调⽤之前，和之前的写法唯⼀的不同就是，你需要保证调⽤</p><p>traverse(v) 的时候，visited[v] == false。 </p><p><a href="https://leetcode.cn/problems/is-graph-bipartite/">785.判断⼆分图</a></p><p>输⼊⼀个 邻接表 表示⼀幅⽆向图，请你判断这幅图是否是⼆分图。 </p><img src="/posts/75bf15f1/image-20220520215456736.png" alt="image-20220520215456736" style="zoom:80%;"><p>解析：</p><p>遍历图，相邻节点涂不同颜色，额外使用一个color数组记录每个节点的颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 记录图是否符合⼆分图性质</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; color; <span class="comment">// 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited; <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，输⼊邻接表，判断是否是⼆分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    color.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 因为图不⼀定是联通的，可能存在多个⼦图</span></span><br><span class="line"> <span class="comment">// 所以要把每个节点都作为起点进⾏⼀次遍历</span></span><br><span class="line"> <span class="comment">// 如果发现任何⼀个⼦图不是⼆分图，整幅图都不算⼆分图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">tranverse</span>(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经确定不是⼆分图了，就不⽤浪费时间再递归遍历了</span></span><br><span class="line"> <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 没有被访问过</span></span><br><span class="line"> <span class="comment">// 那么应该给节点 s 涂上和节点 v 不同的颜⾊</span></span><br><span class="line"> color[s] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 s</span></span><br><span class="line">            <span class="built_in">tranverse</span>(graph, s);</span><br><span class="line">            <span class="comment">//bfs(graph, s);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 已经被访问过</span></span><br><span class="line"> <span class="comment">// 根据 v 和 s 的颜⾊判断是否是⼆分图</span></span><br><span class="line">            <span class="keyword">if</span> (color[s] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS遍历</span></span><br><span class="line"><span class="comment">// 从 start 节点开始进⾏ BFS 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; ok) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                color[w] = !color[v];</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(w);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[w] == color[v]) &#123;</span><br><span class="line">                    <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p><p>给定一组 n 人（编号为 1, 2, …, n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p><p>给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和  bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：group1 [1,4], group2 [2,3]</span><br><span class="line"></span><br><span class="line">输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>二分图的判定，每个人看作节点，相互关系看作边，双色图，按照颜色分成两组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 记录图是否符合⼆分图性质</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; color; <span class="comment">// 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited; <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 图节点编号从 1 开始</span></span><br><span class="line">    color.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 转化成邻接表表示图结构</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(n, dislikes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">tranverse</span>(graph, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes) &#123;</span><br><span class="line">    <span class="comment">// 图节点编号为 1...n</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : dislikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 「⽆向图」相当于「双向图」</span></span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        graph[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经确定不是⼆分图了，就不⽤浪费时间再递归遍历了</span></span><br><span class="line"> <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 没有被访问过</span></span><br><span class="line"> <span class="comment">// 那么应该给节点 s 涂上和节点 v 不同的颜⾊</span></span><br><span class="line"> color[s] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 s</span></span><br><span class="line">            <span class="built_in">tranverse</span>(graph, s);</span><br><span class="line">            <span class="comment">//bfs(graph, s);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 已经被访问过</span></span><br><span class="line"> <span class="comment">// 根据 v 和 s 的颜⾊判断是否是⼆分图</span></span><br><span class="line">            <span class="keyword">if</span> (color[s] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题随笔02</title>
      <link href="/posts/6832ed80/"/>
      <url>/posts/6832ed80/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="01-绳子覆盖最多的节点"><a href="#01-绳子覆盖最多的节点" class="headerlink" title="01 绳子覆盖最多的节点"></a>01 绳子覆盖最多的节点</h2><p>题目：</p><p>给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？<br>即使绳子边缘处盖住点也算盖住</p><p>例如，<code>arr = [1, 3, 4, 7, 13, 16, 17]</code>, <code>target = 4</code>, 子数组<code>[3, 4, 7]</code>满足所有节点被覆盖</p><p>解析：</p><ol><li>普通解</li></ol><p>利用贪心，每一个点向前推，记录每个节点前target距离内覆盖个数最大值，一次遍历</p><p>小优化：数组有序，每个点向前找符合条件的节点个数，二分搜索优化，复杂度O(Nlog(N))</p><ol start="2"><li>最优解</li></ol><p>双指针，L和起始位置指向0，<code>arr[R] - arr[L] &lt;= target</code>, R++向右移动；<code>arr[R] - arr[L] &gt; target</code>, L++向左移动。绳子起始边缘为L的最大覆盖节点个数，依次遍历。复杂度O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：贪心+二分搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nearest = <span class="built_in">nearestIndex</span>(arr, i, arr[i] - target);</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - nearest + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> R, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = R;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + (R- L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：贪心+双指针，滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; arr[right] - arr[left] &lt;= target) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="built_in">max</span>(count, right - left);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-两种字符最少交换次数"><a href="#02-两种字符最少交换次数" class="headerlink" title="02 两种字符最少交换次数"></a>02 两种字符最少交换次数</h2><p>题目：</p><p>一个数组中只有两种字符’G’和’B’，可以让所有的G都放在左侧，所有的B都放在右侧<br>或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在<strong>相邻字符之间进行交换操作</strong>，返回至少需要交换几次</p><p>解析：</p><p>贪心，遍历遇到第一个G，移到0位置，遇到第二个G，移到位置1……，双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStep</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//G在左边，B在右边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">            step1 += i - gi;</span><br><span class="line">            gi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//G在右边，B在左边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            step2 += i - bi;</span><br><span class="line">            bi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(step1,step2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03-数组目标和为target的所有排列个数"><a href="#03-数组目标和为target的所有排列个数" class="headerlink" title="03 数组目标和为target的所有排列个数"></a>03 数组目标和为target的所有排列个数</h2><p>题目：</p><p>给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target<br>请问最后算出target的方法数</p><p>leetcode：494</p><p>解析：</p><ol><li>递归暴力求解</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays1</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归函数，可以自由使用arr[index...]所有的数字</span></span><br><span class="line"><span class="comment">//能够得出target这个数，方法数是多少，返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123; <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> target ==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, target - arr[index]) + <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, target + arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态规划，记忆化搜索</li></ol><ul><li>假设将arr变为非负数组，前面进行加减不影响</li><li>非负arr累加和为sum，target &gt; sum 则不存在</li><li>target与sum的奇偶性不一致，不存在</li><li>取正集合和为P，取负集合和为N，P - N = target, p + N = sum, ==&gt; p = (sum + target) / 2,转化为取正集合和为P的组合有多少个</li><li>二维动态规划的空间压缩</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays2</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  n : arr) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || ((sum &amp; <span class="number">1</span>) ^ (target &amp; <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subset</span>(arr, (sum + target) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subset</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= n; i--) &#123;</span><br><span class="line">            dp[i] += dp[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04-总体最多收入分配"><a href="#04-总体最多收入分配" class="headerlink" title="04 总体最多收入分配"></a>04 总体最多收入分配</h2><p>题目：</p><p>现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为<code>income[i][0]</code>，去B可得收入为<code>income[i][1]</code>, 返回能使所有司机总收入最高的方案是多少钱?</p><p>解析：</p><ol><li>递归暴力 O(N^2)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  income -&gt; N * 2 的矩阵 N是偶数！</span></span><br><span class="line"><span class="comment">// 0 [9, 13]</span></span><br><span class="line"><span class="comment">// 1 [45,60]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMoney1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = income.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || (N &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//N为奇数返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>; <span class="comment">//M = N / 2, 去A地区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(income, <span class="number">0</span>, M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.....所有的司机，往A和B区域分配！</span></span><br><span class="line"><span class="comment">// A区域还有rest个名额!</span></span><br><span class="line"><span class="comment">// 返回把index...司机，分配完，并且最终A和B区域同样多的情况下，index...这些司机，整体收入最大是多少！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == income.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 还剩下司机！</span></span><br><span class="line">    <span class="keyword">if</span> (income.<span class="built_in">size</span>() - index == rest) &#123; <span class="comment">//B区域满了</span></span><br><span class="line">        <span class="keyword">return</span> income[index][<span class="number">0</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;<span class="comment">//A区域满了</span></span><br><span class="line">        <span class="keyword">return</span> income[index][<span class="number">1</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前司机，可以去A，或者去B</span></span><br><span class="line">    <span class="keyword">int</span> p1 = income[index][<span class="number">0</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> p2 = income[index][<span class="number">1</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态规划</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMoney2</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = income.length;</span><br><span class="line">    <span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(M + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N - i == j) &#123;</span><br><span class="line">                dp[i][j] = income[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = income[i][<span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = income[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> p2 = income[i][<span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(p1, p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="05-含有SetAll功能的哈希表"><a href="#05-含有SetAll功能的哈希表" class="headerlink" title="05 含有SetAll功能的哈希表"></a>05 含有SetAll功能的哈希表</h2><p>题目：</p><p>设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)</p><p>setAll(num), 将所有的key对应的value值改为num</p><p>解析：</p><p>加入时间戳，记录加入的时间，key -&gt; int, value -&gt; (int, long)</p><p>setAlltime默认无穷大，调用setAll(num)后，时间戳早于当前值的进行更新，setAlltime更新为当前时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> V value;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyValue</span><span class="params">(V v, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">value = v;</span><br><span class="line">time = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="keyword">private</span> MyValue&lt;V&gt; setAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(<span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAll</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.get(key).time &gt; setAll.time) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key).value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> setAll.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="06-最长无重复字串的子串长度"><a href="#06-最长无重复字串的子串长度" class="headerlink" title="06 最长无重复字串的子串长度"></a>06 最长无重复字串的子串长度</h2><p>题目：</p><p>求一个字符串中，最长无重复字符子串长度</p><p>解析：</p><p>子串子数组问题，想每个<code>i</code>结尾时，满足条件的情况，无重复的子串长度<code>dp[i]</code></p><p>从第<code>i</code>个位置向前推影响因素：某个位置与<code>i</code>位置的字符相同，或者i-1位置向左推的距离</p><p>可以滑动窗口</p><p>也可动态规划：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//acsii取值范围0~255</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">map</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="comment">//map存放上次出现的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        map[i] = <span class="number">-1</span>; <span class="comment">//初始默认出现在-1位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    map[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;<span class="comment">//上一个位置，向左推了多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre = <span class="built_in">min</span>(i - map[s[i]], pre + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pre);</span><br><span class="line">        map[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="07-差值为k的数对的最大组数"><a href="#07-差值为k的数对的最大组数" class="headerlink" title="07 差值为k的数对的最大组数"></a>07 差值为k的数对的最大组数</h2><p>题目描述：</p><p>给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛<br>一局比赛只有两个人，返回最多可以同时有多少场比赛</p><p>解析：</p><p>数组arr排序后，滑动窗口求解+贪心</p><p>暴力解：全排列寻找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPairNUm1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(arr, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123;<span class="comment">//全排列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = index; r &lt; arr.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[index], arr[r]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, k));</span><br><span class="line">            <span class="built_in">swap</span>(arr[index], arr[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(N*logN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPairNum2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());<span class="comment">//排序，满足单调性，先满足小值的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;<span class="comment">//双指针窗口</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">usedR</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (usedR[L]) &#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">            R++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不止一个数，而且都没用过！</span></span><br><span class="line">            <span class="keyword">int</span> dis = arr[R] - arr[L];</span><br><span class="line">            <span class="keyword">if</span> (dis == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                usedR[R++] = <span class="literal">true</span>;</span><br><span class="line">                L++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis &lt; k) &#123;</span><br><span class="line">                R++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="08-最多载两个人的船同时过河问题"><a href="#08-最多载两个人的船同时过河问题" class="headerlink" title="08 最多载两个人的船同时过河问题"></a>08 最多载两个人的船同时过河问题</h2><p>题目描述：</p><p>给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重<br>想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数<br>Leetcode链接 : <a href="https://leetcode.com/problems/boats-to-save-people/">https://leetcode.com/problems/boats-to-save-people/</a></p><p>解析：</p><p>先排序，如果arr中某个值大于limit，返回无穷大不合题意。</p><p>寻找&gt;=limit/2的右边界，边界右侧的值大于limit/2，两个指针指向边界左侧和右侧</p><p>相加和大于limit，左指针左移</p><p>一侧先耗尽，左侧未满足条件的数量除以2（向上取整），加上满足条件的数量，加上右侧剩余未满足条件的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (arr[N<span class="number">-1</span>] &gt; limit) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lessR = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= limit / <span class="number">2</span>) &#123;</span><br><span class="line">            lessR = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lessR == <span class="number">-1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> L = lessR, R = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> noUsed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> solved = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) &#123;</span><br><span class="line">            R++;</span><br><span class="line">            solved++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (solved == <span class="number">0</span>) &#123;</span><br><span class="line">            noUsed++;</span><br><span class="line">            L--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = <span class="built_in">max</span>(<span class="number">-1</span>, L - solved);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> used = all - noUsed;</span><br><span class="line">    <span class="keyword">int</span> moreUnsolved = (N - all) - used;</span><br><span class="line">    <span class="keyword">return</span> used + ((noUsed + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + moreUnsolved;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：首尾双指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        sum = L == R ? arr[L] : arr[L] + arr[R];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; limit) &#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L++;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="09-子数组的最大累加和"><a href="#09-子数组的最大累加和" class="headerlink" title="09 子数组的最大累加和"></a>09 子数组的最大累加和</h2><p>题目描述：</p><p>返回一个数组arr中，子数组最大累加和</p><p>解析：</p><p>子数组以arr[i]结尾的最大累加和，求其最大值</p><p><code>dp[i] = max(dp[i - 1] + arr[i], arr[i])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上一步，dp的值</span></span><br><span class="line">    <span class="comment">// dp[0]</span></span><br><span class="line">    <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre + arr[i], arr[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(pre, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-分糖果问题"><a href="#10-分糖果问题" class="headerlink" title="10 分糖果问题"></a>10 分糖果问题</h2><p>题目描述：</p><p>老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，返回老师至少需要准备多少颗糖果<br>进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果</p><p>解析：<br>从左遍历，坡度值加一，从右遍历，坡度值加一，二者取最大值，以坡度大的为准</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">max</span>(left[i], right[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充规则：相邻孩子分数一样则分的糖果数一样</p><p>解析：比左边大++，和左边相等不变，比左边小置1，右侧遍历同理</p><h2 id="11-字符串交错组成问题"><a href="#11-字符串交错组成问题" class="headerlink" title="11 字符串交错组成问题"></a>11 字符串交错组成问题</h2><p>题目描述：</p><p>给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的</p><p>Leetcode题目：<a href="https://leetcode.com/problems/interleaving-string/">https://leetcode.com/problems/interleaving-string/</a></p><p>解析：</p><p>长度s1.size() + s2.size() != s3.size()，不成立</p><p>动态规划，<code>dp[i][j]</code>长度为i的s1与长度为j的s2，能否组成长度i + j的s3</p><p>s1长度i，下标0 ~ i-1;</p><p>s2长度j，下标0 ~ j-1;</p><p>s3长度i + j, 下标0 ~ i + j - 1</p><p>每个位置最后一个字符可能来着s1或s2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterLeave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (s3.<span class="built_in">size</span>() != m + n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i - <span class="number">1</span>] != s3[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2[j - <span class="number">1</span>] != s3[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-求相等子树的数量"><a href="#12-求相等子树的数量" class="headerlink" title="12 求相等子树的数量"></a>12 求相等子树的数量</h2><p>题目描述：</p><p>如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树</p><p>解析：<br>递归，head左子树的相等子树+head右子树的相等子树+head是否为相等子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 时间复杂度O(N * logN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sameNumber1</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sameNumber1</span>(head -&gt; left) + <span class="built_in">sameNumber1</span>(head -&gt; right) + (<span class="built_in">same</span>(head-&gt;left, head -&gt; right) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(TreeNode* h1, TreeNode* h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span> ^ h2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span> &amp;&amp; h2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//两个都不为空</span></span><br><span class="line">    <span class="keyword">return</span> h1 -&gt; val == h2 -&gt; val &amp;&amp; <span class="built_in">same</span>(h1 -&gt; left, h2 -&gt; left) &amp;&amp; <span class="built_in">same</span>(h1 -&gt; right, h2 -&gt; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题随笔01</title>
      <link href="/posts/bba1d2c5/"/>
      <url>/posts/bba1d2c5/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="01-复杂度、排序与二分法"><a href="#01-复杂度、排序与二分法" class="headerlink" title="01 复杂度、排序与二分法"></a>01 复杂度、排序与二分法</h1><h2 id="十大排序"><a href="#十大排序" class="headerlink" title="十大排序"></a>十大排序</h2><p>1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p><p>2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</p><p>3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p><p>4、非原地排序：需要利用额外的数组来辅助排序。</p><p>5、时间复杂度：一个算法执行所消耗的时间。</p><p>6、空间复杂度：运行完一个算法所需的内存大小</p><h3 id="十大排序一图总览"><a href="#十大排序一图总览" class="headerlink" title="十大排序一图总览"></a>十大排序一图总览</h3><img src="/posts/bba1d2c5/202205072325169.png" alt="img" style="zoom:80%;"><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><ul><li>冒泡排序（bubble sort） — O(n2) </li><li>插入排序 （insertion sort）— O(n2) </li><li>归并排序 （merge sort）— O(n log n)</li></ul><h3 id="非稳定性排序"><a href="#非稳定性排序" class="headerlink" title="非稳定性排序"></a>非稳定性排序</h3><ul><li>选择排序 （selection sort）— O(n2) </li><li>希尔排序 （shell sort）— O(n log n) </li><li>堆排序 （heapsort）— O(n log n) </li><li>快速排序 （quicksort）— O(n log n)</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数组索引0 ~ N-1，找到最小值，放到0位置上；</p><p>依次向后遍历，在i ~ N-1中，找到最小值，放到i位置上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//在i ~ n-1上找到最小值的下标</span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIdex] ? j : minIdex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>0-1，1-2，2-3…依次两两交换，大的交换到后边，每一轮的最大值到最后。</p><p>[3 2 5 1 6 4] ==&gt; [2 3 1 5 4 6] ==&gt; [2 1 3 4 5 6] ==&gt; [1 2 3 4 5 6]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 0 ~ N-1</span></span><br><span class="line">    <span class="comment">// 0 ~ N-2</span></span><br><span class="line">    <span class="comment">// 0 ~ N-3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.<span class="built_in">size</span>() - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>0 ~ 0，0 ~ 1 , 0 ~ 2, … 0 ~ n -1，依次变得有序。第i轮，若第i个数小于前一个数，二者交换，直到i大于等于前一个数。</p><p>类似与摸牌后，每次进行插入排序。</p><p>初始数据状况会影响时间复杂度。最差O(n ^ 2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//0~0 有序的</span></span><br><span class="line">    <span class="comment">//0~i 变为有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>经常在有序数组上，使用二分搜索，但是有序不是必要条件。</p><p><strong>只要能正确构建左右两侧的逻辑，就可以使用二分。</strong></p><ul><li>一个有序数组，找某个数是否存在</li><li>一个有序数组，找 &gt;= 某个数的最左侧位置</li><li>一个有序数组，找 &lt;= 某个数的最右侧位置</li><li>局部最小值问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sortArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortArr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = sortArr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//L...R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123; <span class="comment">//L..R 至少两个数</span></span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">//mid = (L + R) / 2</span></span><br><span class="line">        <span class="keyword">if</span> (sortArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索&gt;= 某个数的最左侧位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;<span class="comment">//记录最左的对号</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">//至少一个数的时候</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无序数组，任意两个相邻的数不相等，返回任意一个局部最小值（比左右相邻的数小）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[n - <span class="number">1</span>] &lt; arr[n - <span class="number">2</span>]) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="02-异或运算"><a href="#02-异或运算" class="headerlink" title="02 异或运算"></a>02 异或运算</h1><p>异或运算：相同为0，不同为1，二进制<strong>无进位相加</strong>（不进位）</p><p>同或运算：相同为1，不同为0</p><p>异或运算 (^) 性质：</p><ul><li>0 ^ N = N</li><li>N ^ N = 0</li><li>a ^ b = b ^ a （交换律）</li><li>(a ^ b) ^ c = a ^ (b ^ c) （结合律）</li><li>a ^ b = c ==&gt; a = c ^ b ==&gt; b = c ^ a</li></ul><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>不使用额外空间变量交换两个数</p><p>利用异或运算的性质，注意：<strong>交换的两个数不能是同一块内存空间</strong>，否则二者变为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>一个数组中有<strong>一个数出现了奇数次</strong>，其他数出现了偶数次，找到并打印这个数（O(1) 额外空间复杂度完成）</p><p>解析：设置变量eor，顺序遍历异或所有的值，返回最后的eor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; eor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p>把一个int类型的数，提取出最右侧的1</p><p>a = 0xb 00110110 ==&gt; ans = 0xb 00000010</p><p>解析：<strong>a &amp; (-a)</strong> 等价于 <strong>a &amp; (~a + 1)</strong></p><h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><p>一个数组中有<strong>两种数出现了奇数次</strong>，其他数出现了偶数次，找到并打印这两种数（O(1) 额外空间复杂度完成）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">//提取出最右的1, eor != 0</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">//eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// arr[1] = 11100010</span></span><br><span class="line">        <span class="comment">//rightOne= 00000010</span></span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            onlyOne ^= arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; onlyOne &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (eor ^ onlyOne) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h2><p>一个数组中<strong>只有一种数出现K次</strong>，其他数都出现了M次，已知M &gt; 1，K &lt; M，找到出现了K次的数<br>要求额外空间复杂度O(1)，时间复杂度O(N)</p><p>解析：设置一个int数组长度为32，累加每个数的二进制位置的1的数量。每一位是否为M的整数倍判断出现K次的数的二进制最后一个1出现的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onlyKtimes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//help[i]位置的1出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((num &gt;&gt; i) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            help[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*返回只出现k次的数，如果不是k次，返回-1；</span></span><br><span class="line"><span class="comment">        if (help[i] % m == 0) continue;</span></span><br><span class="line"><span class="comment">        if (help[i] % m == k) &#123;</span></span><br><span class="line"><span class="comment">        ans |= 1 &lt;&lt; i;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (help[i] % m != <span class="number">0</span>) &#123; <span class="comment">//在第i位上有1</span></span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="03-归并排序"><a href="#03-归并排序" class="headerlink" title="03 归并排序"></a>03 归并排序</h1><p>左半部分有序 + 右半部分有序 + merge </p><p>merge过程双指针，顺序copy结果到新有序数组</p><p>总体时间复杂度为 O(n * log(N))</p><p><strong>递归写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr[L...R]排有序</span></span><br><span class="line"><span class="comment">// T(N) = 2 * T(N / 2) + O(N)</span></span><br><span class="line"><span class="comment">// O(N * logN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">process</span>(arr, L, mid);</span><br><span class="line">    <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">merge</span>(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(R - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 步长</span></span><br><span class="line">    <span class="keyword">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">// log N</span></span><br><span class="line">        <span class="comment">// 当前左组的，第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mergeSize &gt;= N - L) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = <span class="built_in">min</span>(mergeSize + M, N - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">            L = R + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目1：小和问题"><a href="#题目1：小和问题" class="headerlink" title="题目1：小和问题"></a>题目1：小和问题</h2><p>在一个数组中，一个数左边比它小的数的总和，叫该数的小和<br>所有数的小和累加起来，叫数组小和</p><p>给定一个数组，求最小和，到第i个数，若第j （j &lt; i）个数的值小于第i个数，累加上第j个数。</p><p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>[6 3 2 1 6 7] ==&gt; i = 0, sum = 0; i = 1, sum = 0; i = 2, sum = 0; i = 3, sum = 0; i = 4, sum = 4, sum = 0;</p><p>i = 5, sum = 3 +2 + 1 = 6; i = 6, sum = 18; 返回 res = 6 + 18 = 24;</p><p>每个位置，之前比自己小的数累加起来，各个位置累加和再求和。</p><p>暴力法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comparator</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res += arr[j] &lt; arr[i] ? arr[j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求小和返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的小和，累加</span></span><br><span class="line"><span class="comment">// 左 排序   merge</span></span><br><span class="line"><span class="comment">// 右 排序  merge</span></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="built_in">process</span>(arr, l, mid) </span><br><span class="line">        + </span><br><span class="line">        <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) </span><br><span class="line">        + </span><br><span class="line">        <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2：逆序对总数"><a href="#题目2：逆序对总数" class="headerlink" title="题目2：逆序对总数"></a>题目2：逆序对总数</h2><p>在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为逆序对<br>给定一个数组arr，求数组的逆序对总数量</p><p>[3 1 0 4 3 1] ==&gt; 6</p><p>每一个数右边有多少个数比他小，从右向左merge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverPairNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求逆序对数量返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的逆序对数量，累加，返回</span></span><br><span class="line"><span class="comment">// 左 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="comment">// 右 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//l &lt; r</span></span><br><span class="line"><span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">process</span>(arr, l, mid) + <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = help.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = m, p2 = r;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L &amp;&amp; p2 &gt; m) &#123;</span><br><span class="line">        res += arr[p1] &gt; arr[p2] ? (p2 - m) : <span class="number">0</span>;</span><br><span class="line">        help[i--] = arr[p1] &gt; arr[p2] ? arr[p1--] : arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L) &#123;</span><br><span class="line">        help[i--] = arr[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &gt; m) &#123;</span><br><span class="line">        help[i--] = arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3：Bigger-than-right-twice"><a href="#题目3：Bigger-than-right-twice" class="headerlink" title="题目3：Bigger than right twice"></a>题目3：Bigger than right twice</h2><p>在一个数组中，对于任何一个数num，求有多少个(后面的数*2)依然&lt;num，返回总个数<br>比如：[3,1,7,0,2]<br>3的后面有：1，0<br>1的后面有：0<br>7的后面有：0，2<br>0的后面没有<br>2的后面没有<br>所以总共有5个</p><p>解析：左组有序+有组有序+merge，双指针从左向右遍历不回退，记录个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//l &lt; r</span></span><br><span class="line"><span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">process</span>(arr, l, mid) + <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [L....M] [M+1....R]</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目前囊括进来的数，是从[M+1, windowR)</span></span><br><span class="line">    <span class="keyword">int</span> windowR = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (windowR &lt;= r &amp;&amp; (<span class="keyword">long</span>) arr[i] &gt; (<span class="keyword">long</span>) arr[windowR] * <span class="number">2</span>) &#123;</span><br><span class="line">            windowR++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += windowR - m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= L) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="04-快速排序"><a href="#04-快速排序" class="headerlink" title="04 快速排序"></a>04 快速排序</h1><p>快速排序是基于分治策略的，其算法思想如下。<br>（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。<br>（2）治理：对两个子序列进行快速排序。</p><p>（3）合并：将排好序的两个子序列合并在一起，得到原问题的解。</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//划分函数，对原序列进行分解，将其分解为两个子序列，以基准元素pivot为界，</span></span><br><span class="line"><span class="comment">//左侧子序列都比pivot小，右侧子序列都比pivot大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high, pivot = arr[low];<span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) j--;<span class="comment">//向左扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;<span class="comment">//向右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j--]);<span class="comment">//交换arr[i]和arr[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[low], arr[i - <span class="number">1</span>]);<span class="comment">//交换arr[i - 1]和arr[low]，并返回基准元素位置i - 1</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[low]);<span class="comment">//交换arr[i]和arr[low]，并返回基准元素位置i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序函数。首先对原序列划分，得到划分的中间位置mid；然后以中间位置为界，</span></span><br><span class="line"><span class="comment">//分别对左半部分(low,mid-1)执行快速排序，对右半部分(mid+1,high)执行快速排序。</span></span><br><span class="line"><span class="comment">//递归结束的条件是low≥high</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(arr, low, high);<span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">qsort</span>(arr, low, p - <span class="number">1</span>);<span class="comment">//左区间递归快排</span></span><br><span class="line">        <span class="built_in">qsort</span>(arr, p + <span class="number">1</span>, high);<span class="comment">//右区间递归快排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">qsort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况时间复杂度为O(nlogn)</p><p>最坏情况下的时间复杂度为O(n^2)</p><p>平均情况下的空间复杂度为O(nlogn)</p><h1 id="05-希尔排序"><a href="#05-希尔排序" class="headerlink" title="05 希尔排序"></a>05 希尔排序</h1><p>希尔排序：插入排序的改进版，实现简单，对于中等规模数据的性能表现还不错。对较大规模并且无序的数据也非常有效率</p><p>无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要n - 1次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。</p><p>希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为h的元素有序，刚开始h的大小可以是h = n / 2，接着让 h = n / 4，让h一直缩小，当h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p><p>把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高。</p><p>希尔排序的复杂度和增量序列是相关的</p><p>希尔排序不稳定，在插入的时候是跳跃性插入的，有可能破坏稳定性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将nums[i]插入到所在分组的正确位置上， nums[i]所在分组为：</span></span><br><span class="line"><span class="comment">// …nums[i-2*gap], nums[i-gap], nums[i], nums[i+gap], nums[i+2*gap]…</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSortCore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> gap, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inserted = nums[i];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 插入的时候按组进行插入（组内元素两两相隔gap）</span></span><br><span class="line">    <span class="keyword">for</span> (j = i - gap; j&gt;= <span class="number">0</span> &amp;&amp; inserted &lt; nums[j]; j -= gap) &#123;</span><br><span class="line">        nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = inserted;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 进行分组，最开始的时候，gap为数组长度一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对各个分组进行插入分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 将nums[i]插入到所在分组正确的位置上</span></span><br><span class="line">            <span class="built_in">shellSortCore</span>(nums, gap, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印希尔排序后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : nums) &#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="06-堆排序"><a href="#06-堆排序" class="headerlink" title="06 堆排序"></a>06 堆排序</h1><p>大顶堆：父节点的值大于子节点，堆排序中为升序排列</p><p>小顶堆：父节点的值小于子节点，堆排序中为降序排列</p><p>先把数组构造成一个大顶堆，然后把堆顶（数组最大值，数组的第一个元素）和数组的最后一个元素交换，把最大值放到了最后边。数组长度n-1，再进行构造堆，把剩余的第二大值放到堆顶，输出堆顶（放到数组最后）。依此类推，直到数组排序完成。</p><p>堆符合两个特点：</p><ul><li>是一个完全二叉树</li><li>所有父节点的值都大于（或小于）子节点的值</li></ul><p>平均时间复杂度：O(nlogn)</p><p>注：堆排序是<strong>不稳定</strong>的排序算法，是一种树形选择排序。恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。不适合记录较少的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对有一定顺序的堆，当前第i个结点取根左右的最大值（这个操作称heapfiy）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>;<span class="comment">// 左右节点索引, left=2*i+1  right=2*i+2  </span></span><br><span class="line">    <span class="keyword">int</span> maxid = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[maxid]) &#123;</span><br><span class="line">        maxid = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[maxid]) &#123;</span><br><span class="line">        maxid = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxid != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[maxid]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立大根堆，从树的倒数第二层第一个结点开始，对每个结点进行heapify操作，然后向上走</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify_build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = temp; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印当前数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立大根堆之后，每次交换最后一个结点和根节点（最大值），</span></span><br><span class="line"><span class="comment">// 对交换后的根节点继续进行heapify（此时堆的最后一位是最大值，因此不用管他，n变为n-1）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">heapify_build</span>(nums, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums.<span class="built_in">front</span>(), nums[n - i - <span class="number">1</span>]);</span><br><span class="line"><span class="built_in">heapify</span>(nums, n - i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换一种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，构造大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxid = index;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 计算第i个节点的左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[maxid]) maxid = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[maxid]) maxid = right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (maxid != index) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[maxid], arr[index]);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, maxid); <span class="comment">// 递归调整其他不满足堆性质的部分</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSortCore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i从第一个非叶子节点开始进行堆调整，i节点的父节点为parent=(i-1)/2，即(len-1-1)/2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);<span class="comment">// 将当前最大的放置到数组末尾，将未完成排序的部分继续进行堆排序</span></span><br><span class="line">        <span class="built_in">adjust</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">heapSortCore</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="07-计数排序"><a href="#07-计数排序" class="headerlink" title="07 计数排序"></a>07 计数排序</h1><p>统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p><ul><li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li><li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li><li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li></ul><p>算法思想：</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去 1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序, 输入原始数组与目标数组（初始化与原数组相同）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vecRaw, vector&lt;<span class="keyword">int</span>&gt;&amp; vecObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保待排序容器非空</span></span><br><span class="line">    <span class="keyword">if</span>(vecRaw.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span></span><br><span class="line">    <span class="keyword">int</span> vecCountLen = (*<span class="built_in">max_element</span>(vecRaw.<span class="built_in">begin</span>(), vecRaw.<span class="built_in">end</span>())) + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecCount</span><span class="params">(vecCountLen, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个键值出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecRaw.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vecCount[vecRaw[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vecCountLen; i++) &#123;</span><br><span class="line">        vecCount[i] += vecCount[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将键值放到目标位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vecRaw.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 此处逆序是为了保持相同键值的稳定性</span></span><br><span class="line">        vecObj[--vecCount[vecRaw[i]]] = vecRaw[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecRaw = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecObj</span><span class="params">(vecRaw.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">countSort</span>(vecRaw, vecObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecObj.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; vecObj[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="08-桶排序"><a href="#08-桶排序" class="headerlink" title="08 桶排序"></a>08 桶排序</h1><p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。是计数排序的变种，利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p><p>算法思想：</p><ul><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ul><p>平均时间复杂度：O(n + k)</p><p>空间复杂度：O(n * k)</p><p>稳定性：稳定</p><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序，输入原始数组和桶的数量（默认可为5）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 确定数组的最大值与最小值</span></span><br><span class="line">    <span class="keyword">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minVal) &#123;</span><br><span class="line">            minVal = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxVal) &#123;</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置每个桶的容量大小</span></span><br><span class="line">    <span class="keyword">int</span> bucketCount = (maxVal - minVal) / bucketSize + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (arr[i] - minVal) / bucketSize; <span class="comment">// 第index个桶</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="built_in">insertSort</span>(bucket);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">            arr[arrIndex++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//0~0 有序的</span></span><br><span class="line">    <span class="comment">//0~i 变为有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="09-基数排序"><a href="#09-基数排序" class="headerlink" title="09 基数排序"></a>09 基数排序</h1><p>一种多关键字的排序算法，可用桶排序实现。</p><p>算法思想：</p><ul><li><p>取得数组中的最大数，并取得位数；</p></li><li><p>arr为原始数组，从最低位开始取每个位组成radix数组；</p></li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数，求数据的最大位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; arr[i]) &#123;</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;<span class="comment">// 位数</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;<span class="comment">//尾数0-9，10进制</span></span><br><span class="line">    <span class="keyword">while</span> (maxVal &gt;= p) &#123;</span><br><span class="line">        maxVal /= <span class="number">10</span>;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基数排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">maxbit</span>(arr, n);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;<span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;<span class="comment">// 进行d次排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            count[j] = <span class="number">0</span>;<span class="comment">// 每次分配前清空计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (arr[j] / radix) % <span class="number">10</span>;<span class="comment">// 统计每个桶中的记录数     </span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j];<span class="comment">// 将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (arr[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = arr[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">// 将临时数组的内容复制到arr中</span></span><br><span class="line">            arr[j] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记：数模运算</title>
      <link href="/posts/bbb48ce1/"/>
      <url>/posts/bbb48ce1/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h1><p>素数：只能被1或其本身整除。</p><p>实现一个函数，输入一个整数<code>n</code>，返回<code>[2, n]</code>中的素数个数</p><p>暴力解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i)) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断整数n是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力解法时间复杂度为O(n^2)，不够高效。</p><p>改进：</p><ul><li><code>i</code> 只需遍历到<code>sqrt(n)</code>；</li><li>筛数法，2，3…的所有倍数都不是素数，但存在计算冗余；</li><li>内层<code>for</code>循环的<code>j</code>从<code>i</code>的平方开始遍历，不是从<code>2 * i </code>开始.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j++) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h1><h2 id="位运算n-amp-n-1-的妙用"><a href="#位运算n-amp-n-1-的妙用" class="headerlink" title="位运算n &amp; (n-1)的妙用"></a>位运算<code>n &amp; (n-1)</code>的妙用</h2><p><code>n&amp;(n-1)</code>作用：将<code>n</code>的二进制表示中的<strong>最低位为<code>1</code>的改为<code>0</code></strong></p><p><code>n = 10100</code>(二进制），则<code>(n-1) = 10011</code>  –&gt; <code>n&amp;(n-1) = 10000</code></p><ul><li><p>判断一个数是否是2的n次幂<br><code>n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0 )</code></p><p>解释<code>((n &amp; (n-1)) == 0)：</code></p><p>如果<code>A &amp; B == 0</code>，表示A与B的二进制形式<strong>没有在同一个位置都为1</strong>的时候。</p></li><li><p>求某一个数的二进制表示中1的个数</p><p><code>while (n &gt; 0 ) &#123;    count ++;    n &amp;= (n-1); &#125;</code></p></li></ul><h2 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h2><p>整数<code>a</code>，数组<code>b</code>，返回幂运算<code>a ^ b</code>的结果，与<code>1337</code>取模（mod，余数）运算后的结果。</p><p>例如输入<code>a = 2, b = [1, 2]</code>，返回<code>2 ^ 12</code> 和<code>1337</code>取模的结果，<code>4096 % 1337 = 85</code></p><ul><li><p>处理指数数组</p><p>注：b为指数数组，可以采用递归求幂，<code>superPow(a, [1, 2, 5, 6])  ==&gt;  superPow(a, [1, 2, 5])</code></p></li><li><p>处理模运算</p><p><code>(a * b) % base = (a % k) * (b % k) % k</code></p><p><strong>对乘法的结果求模，等价于先对每个因子求模，然后对因子相乘的结果再求模。</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line">    <span class="comment">//先对a求模，然后每次多对乘法结果res求模</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res *= a;</span><br><span class="line">        res %= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vecter&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = b.<span class="built_in">back</span>();</span><br><span class="line">    b.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> part1 = <span class="built_in">mypow</span>(a, last);</span><br><span class="line">    <span class="keyword">int</span> part2 = <span class="built_in">mypow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (part1 * part2) % base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>高效求幂</p><p>幂运算的递归关系式：</p><p><code>a ^ b = a * a ^ (b - 1) </code>, b为奇数</p><p><code>a ^ b = (a ^ (b / 2)) ^ 2 </code>, b为偶数</p><p>加上对<code>base</code>求模运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (a * <span class="built_in">mypow</span>(a, k - <span class="number">1</span>)) % base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sub = <span class="built_in">mypow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (sub * sub) % base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="连续N个数的和"><a href="#连续N个数的和" class="headerlink" title="连续N个数的和"></a>连续N个数的和</h2><p>求 1 2 … n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>示例：</p><ul><li>输入：n = 3 输出：6</li><li>输入：n = 9 输出：45</li></ul><p>限制：1 &lt;= n &lt;= 1000</p><p><strong>解析：</strong></p><p>因为不能使用公式直接计算（公式中包含乘除法），所以考虑使用递归进行求解，又不能使用if等判断返回条件，采用<code>A &amp;&amp; B </code>的特性进行判断。</p><ul><li><p>如果A为true，返回B的布尔值（继续往下执行）</p></li><li><p>如果A为false，直接返回false（相当于短路）</p></li></ul><p><strong>将递归的返回条件取非然后作为</strong> <strong>&amp;&amp;</strong> <strong>的第一个条件，递归主体转换为第二个条件语句</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> b = n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分搜索剪枝"><a href="#二分搜索剪枝" class="headerlink" title="二分搜索剪枝"></a>二分搜索剪枝</h1><ol start="875"><li><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">Koko食香蕉</a></li></ol><p>有 <code>N</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉，Koko要在<code>H</code>小时内吃完，吃香蕉的速度为每小时<code>K</code>根，每小时最多吃一堆香蕉，若吃不下到下一小时再吃，如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 <strong>计算Koko每小时至少吃几根香蕉，才能在<code>H</code>小时内全部吃完？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br></pre></td></tr></table></figure><p>解析：求<code>H</code>小时内吃完的最小速率，假设为<code>speed</code>，<code>speed</code>至少为1，最大为<code>max(piles)</code>，一小时最多吃一堆。</p><p>暴力解法：从1开始穷举到<code>max(piles)</code>，一旦发现某个值符合，就为最小速度。</p><p>改进：可以<strong>利用二分搜索剪枝，搜索左侧边界。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSpeed</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="built_in">getMax</span>(piles) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canFinish</span>(piles, mid, h)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> speed, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        time += (n + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time &lt;= h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="1011"><li><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></li></ol><p>传送带上的第<code> i</code> 个包裹的重量为<code> weights[i]</code>。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>days </code>天内将传送带上的所有包裹送达的船的最低运载能力。</p><p><strong>货物不可分割且必须按顺序运输</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br></pre></td></tr></table></figure><p>解法：本质上和koko食香蕉的问题是一样的，首先确定最小载重<code>cap</code>，最小值为<code>max(weights)</code>和<code>sum(weights)</code>，<strong>求最小载重。</strong></p><p>暴力法顺序遍历，改进<strong>二分搜索左侧边界剪枝</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="built_in">getMax</span>(weights);</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">accumulate</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canFinish</span>(weights, days, mid)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; days; day++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxCap = cap;</span><br><span class="line">        <span class="keyword">while</span> ((maxCap -= weights[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == weights.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : weights) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模运算 </tag>
            
            <tag> 幂运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++笔试题常用技巧</title>
      <link href="/posts/413d4c3c/"/>
      <url>/posts/413d4c3c/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="C-笔试输入输出"><a href="#C-笔试输入输出" class="headerlink" title="C++笔试输入输出"></a>C++笔试输入输出</h2><p>牛客网常用头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">函数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>cin&gt;&gt;</code></td><td align="center">遇到空格和换行符自动停止读入，下次读入自动跳过，读取后面的字符</td></tr><tr><td align="center"><code>cin.get()</code></td><td align="center">读入字符，包括换行符<code>&#39;\n&#39;</code>和空格<code>&#39; &#39;</code></td></tr><tr><td align="center"><code>getline(cin, str)</code></td><td align="center">读取整行数据到<code>str</code>中</td></tr><tr><td align="center"><code>cin.getline(char*, int)</code></td><td align="center">接收字符串储存到char*中，长度为n可以接受空格</td></tr><tr><td align="center"><code>char a; cin.get(a)</code></td><td align="center"><code>a</code>中可以储存被<code>cin</code>丢弃的换行符</td></tr></tbody></table><ul><li><strong>cin&gt;&gt;输入的数据不包含空格和回车，空格和回车会存入到cin的缓冲区中</strong></li><li><strong>如果想拿到输入的空格和回车，通过cin.get()获得</strong></li></ul><ol><li><p>输入T组数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入2个数字</p></li></ol><blockquote><p>输入：两个正整数a, b</p><p>1 5</p><p>10 20</p></blockquote><blockquote><p>输出：a + b 结果</p><p>6 </p><p>30</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>单组数据，已知有多少个数据，<strong>数据长度已知</strong>，一般用空格分隔。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多组数据，已知有多少个数据，数据长度已知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">nums</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单组数据，未告知多少个数据，<strong>数据长度未知</strong>，用逗号或空格隔开的数据</p></li></ol><ul><li><p>法1：</p><blockquote><p>输入：用空格隔开每一个数据（逗号，分号同理）</p><p>123 456 789</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; tmp) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//只处理一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：用空格隔开每一个数据，数据有多行</p><p>123 456 789</p><p>321 654 987</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; tmp) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vec.push_back(path);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : c) &#123;</span><br><span class="line">            cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>法2：构造split函数，指定分隔符，对字符串进行切片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">split</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    str += pattern;</span><br><span class="line">    <span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern, i);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size) &#123;</span><br><span class="line">            string s = str.<span class="built_in">substr</span>(i, pos - i);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s));</span><br><span class="line">            i = pos + pattern.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">    <span class="comment">//input = &quot;7 17 27 35 8 49 50&quot;;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">split</span>(input, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="comment">//input为&quot;123, 456, 756&quot;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">split</span>(input, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用数据结构与函数"><a href="#常用数据结构与函数" class="headerlink" title="常用数据结构与函数"></a>常用数据结构与函数</h2><h3 id="map与set的使用"><a href="#map与set的使用" class="headerlink" title="map与set的使用"></a>map与set的使用</h3><ul><li><p>初始化：</p><ul><li>对于set：直接初始化<code>set&lt;int&gt; myset=&#123;0,1,2&#125;;</code> 或者把<code>vector</code>复制过来<code>set&lt;int&gt; myset(v.begin(),v.end());</code></li><li>对于map：<code>map&lt;int,int&gt; mymap=&#123;&#123;0,1&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;</code></li></ul></li><li><p>插入：</p><ul><li>对于set：<code>myset.insert(888);</code></li><li>对于map：<code>mymap.insert(make_pair(6,7));</code>or, <code>mymap.insert(pair&lt;int ,int&gt;(6,7));</code>or, <code>mymap.insert&#123;6,7&#125;</code></li></ul></li></ul><table><thead><tr><th align="center">成员函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">begin()</td><td align="center">返回指向头部的迭代器</td></tr><tr><td align="center">end()</td><td align="center">返回指向末尾的迭代器</td></tr><tr><td align="center">empty()</td><td align="center">如果为空则返回 true</td></tr><tr><td align="center">find(val)</td><td align="center">查找一个值为val的元素，如果成功找到，则返回<br>指向该元素的双向迭代器；反之，返回 指向end() 的迭代器。</td></tr><tr><td align="center">count(val)</td><td align="center">返回指定元素val出现的次数</td></tr><tr><td align="center">insert()</td><td align="center">向容器中插入元素</td></tr><tr><td align="center">erase()</td><td align="center">删除容器中存储的一个元素</td></tr><tr><td align="center">size()</td><td align="center">返回容器中元素的个数</td></tr><tr><td align="center">clear()</td><td align="center">清空容器中所有的元素，即令容器的 size() 为 0</td></tr><tr><td align="center">lower_bound(val)</td><td align="center">返回一个指向当前容器中（key）第一个大于或等于 val 的元素的双向迭代器。</td></tr><tr><td align="center">upper_bound(val)</td><td align="center">返回一个指向当前容器中（key）第一个大于 val 的元素的迭代器。</td></tr></tbody></table><h3 id="queue与stack的使用"><a href="#queue与stack的使用" class="headerlink" title="queue与stack的使用"></a>queue与stack的使用</h3><ul><li>queue成员函数</li></ul><table><thead><tr><th align="center">成员函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">empty()</td><td align="center">如果 queue 中没有元素的话，返回 true</td></tr><tr><td align="center">size()</td><td align="center">返回 queue 中元素的个数</td></tr><tr><td align="center">front()</td><td align="center">返回 queue 中第一个元素的引用</td></tr><tr><td align="center">back()</td><td align="center">返回 queue 中最后一个元素的引用</td></tr><tr><td align="center">push(const T&amp; obj)</td><td align="center">在 queue 的尾部添加一个元素的副本。<br>调用底层容器的成员函数 push_back() 。</td></tr><tr><td align="center">emplace()</td><td align="center">在 queue 的尾部直接添加一个元素。</td></tr><tr><td align="center">push(T&amp;&amp; obj)</td><td align="center">以移动的方式在 queue 的尾部添加元素。<br>调用底层容器的具有右值引用参数的成员函数 push_back()</td></tr><tr><td align="center">pop()</td><td align="center">删除 queue 中的第一个元素。</td></tr></tbody></table><ul><li>stack成员函数</li></ul><table><thead><tr><th align="center">成员函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">empty()</td><td align="center">当 stack 栈中没有元素时，该成员函数返回 true</td></tr><tr><td align="center">size()</td><td align="center">返回 stack 栈中存储元素的个数</td></tr><tr><td align="center">top()</td><td align="center">返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td></tr><tr><td align="center">push(const T&amp; val)</td><td align="center">先复制 val，再将 val 副本压入栈顶。调用底层容器的 push_back() 函数。</td></tr><tr><td align="center">push(T&amp;&amp; obj)</td><td align="center">以移动元素的方式将其压入栈顶。调用底层容器的有右值引用参数的 push_back() 函数。</td></tr><tr><td align="center">pop()</td><td align="center">弹出栈顶元素。</td></tr></tbody></table><ul><li><strong>stack 和queue 没有迭代器</strong>，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。</li></ul><h3 id="priority-queue的使用"><a href="#priority-queue的使用" class="headerlink" title="priority_queue的使用"></a>priority_queue的使用</h3><p>优先队列具有与队列相似的操作：<code>top()</code>返回队首元素、<code>pop()</code>弹出队首元素、<code>push()</code>插入至队尾并排序。优先队列在内部添加了一个排序。其模板有3个参数：<code>priority_queue&lt; type, container, function &gt;</code>，<code>type</code>是存放的数据类型，<code>container</code>是实现优先队列的底层容器（一般都是<code>vector&lt;int&gt;</code>），<code>function</code>是元素之间的排序方式。</p><ul><li><p>大顶堆（降序队列）</p><p><code>priority_queue&lt;int&gt; a; //缺省情况下同下面定义</code></p><p><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; a;</code></p></li><li><p>小顶堆（升序队列）</p><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c;</code></p></li><li><p>常常把<code>pair&lt;int,int&gt;</code>作为数据类型存放进<code>priority_queue</code>里面，这时排序的规则就是先比较第一个元素，如果第一个元素相等再比较第二个元素。</p></li><li><p>对于自定义类型存放进<code>priority_queue</code>，那么仿函数<code>function</code>需要自己写。</p><p>具体写法定义一个类，里面定义<code>bool operator()(xxx,xxx)&#123;return a.x&lt;b.x;&#125;</code></p></li></ul><h3 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法"></a>STL常用算法</h3><ul><li><p>交换<code>swap()</code></p><p><code>vector</code>常用（交换容器中各元素的内存地址，并不是交换各个元素变量所存储的值）。</p><p>注意string是个例外，对string调用swap会导致迭代器、引用和指针失效</p><p>用法为：<code>swap(vec1,vec2);</code></p></li><li><p>逆序<code>reverse()</code></p><p><code>vector, string</code> 常用，反转在<code>[first,last)</code>范围内的顺序（包括first指向的元素，不包括last指向的元素），无返回值。</p><p>用法为<code>reverse(str.begin(),str.end());</code></p></li><li><p>统计<code>count()</code></p><p>统计某一值在一定范围内<code>[first,last)</code>出现的次数。</p><p>比如<code>int num = count(s.begin(),s.end(),&#39;a&#39;);</code></p></li><li><p>排序<code>sort()</code></p><p><code>sort (first, last) </code>对容器或普通数组中<code>[first, last)</code>范围内的元素进行排序，默认进行升序排序。</p><p><code>is_sorted (first, last)</code> 检测 <code>[first, last) </code>范围内是否已经排好序，默认检测是否按升序排序。</p><p><code>sort(vec.begin(), vec.end(), cmp)</code> 自定义比较函数<code>cmp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;</span><br><span class="line">    <span class="comment">//降序排列，通过自定义比较规则进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), mycomp);</span><br><span class="line">    <span class="comment">//降序排列，利用lambda函数</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span>&amp; i, <span class="keyword">int</span>&amp; j)&#123;<span class="keyword">return</span> i &gt; j;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义结构体排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myData</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">myData</span>(<span class="keyword">int</span> a_, b_) : <span class="built_in">a</span>(a_), <span class="built_in">b</span>(b_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义排序，按照a的大小，降序排列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> myData&amp; data1, <span class="keyword">const</span> myData&amp; data2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data1.a &gt; data2.a;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;myData, cmp&gt; myset;</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">2</span>, <span class="number">200</span>));</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">3</span>, <span class="number">300</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : myset) &#123;</span><br><span class="line">        cout &lt;&lt; c.a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找函数：</p><p><code>lower_bound(vec.begin(), vec.end(), target)</code>寻找<code>vec</code>数组中大于等于<code>target</code>的第一个数，返回其迭代器。</p><p><code>Upper_bound()</code>则是寻找第一个大于target的数。</p></li><li><p>全排列函数</p><p><code>next_permutation()</code>寻找下一个排列组合，<code>prev_permutation()</code>为上一个。</p><p>当<code> next_permutation()</code> 返回<code> false</code> 时，循环结束，表明到达最小排列。这样恰好可以生成 序列的全部排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li><li><p>原地删除<code>erase()</code></p><p>对于string：</p><ul><li><code>erase(pos,n);</code> 删除从下标<code>pos</code>开始的n个字符，比如<code>erase(0,1)</code>就是删除第一个字符。</li><li><code>erase(position);</code> 删除<code>postion</code>处的一个字符（<strong>position是一个string类型的迭代器</strong>）。</li><li><code>erase(first,last);</code> 删除从<code>first</code>到<code>last</code>之间的字符（<code>first</code>和<code>last</code>都是迭代器），注意是左闭右开。</li></ul><p>对于map：</p><ul><li><code>mymap.erase(key)</code>，会按key来删除map中对应的键值对。</li><li><code>mymap.erase(position)</code>，position为迭代器。</li><li><code>mymap.erase(first,last)</code>，删除迭代器表示的范围。</li></ul></li><li><p>子字符串<code>substr()</code></p><p><code>string sub=s.substr(pos);</code>复制从下标<code>pos</code>开始的一直到结尾的字符串为新的sub子串。</p><p><code>string sub=s.substr(pos,n)；</code>复制从下标<code>pos</code>开始的<code>n</code>个字符。</p></li><li><p>技巧：字符与数字的转换</p><ul><li><p>字符char 转为 数字int，利用<code>str[0]-‘0’</code></p></li><li><p>数字int 转为 字符char，利用<code>(7+&#39;0&#39;)</code></p></li><li><p>特殊字符char 转为 int，比如要把<code>&#39;a&#39;</code>转为0，<code>&#39;d&#39;</code>转为3。利用ASICII码，<code>’a’</code>的ASICII码为97，所以<code>(int)str[2]-97</code></p></li><li><p>字符串string 转为 int，<code>atoi()/stoi()</code>函数</p></li><li><p>整数int 转为字符串string，<code>to_string(value)</code>函数</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++输入处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法思想</title>
      <link href="/posts/6957245a/"/>
      <url>/posts/6957245a/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="回溯算法思想"><a href="#回溯算法思想" class="headerlink" title="回溯算法思想"></a>回溯算法思想</h1><p>回溯算法相当于一个决策树，解决一个决策树的遍历问题，需要考虑：</p><ul><li>路径：已经做出的选择</li><li>选择列表：可以做的选择</li><li>结束条件：到达决策树底层，无法做出选择的条件</li></ul><p>回溯框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径，选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h2 id="子集穷举"><a href="#子集穷举" class="headerlink" title="子集穷举"></a>子集穷举</h2><ol start="78"><li>给定一组不含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</li></ol><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><p><a href="https://leetcode-cn.com/problems/subsets/">力扣题目链接</a></p><img src="/posts/6957245a/image-20220404212935154.png" alt="image-20220404212935154" style="zoom:50%;"><p><code>[1, 2, 3]</code>的全部子集为递归树上的所有节点，for循环横向遍历，递归纵向遍历</p><ul><li><p>递归参数：二维数组<code>result</code>存放子集组合，一维数组<code>path</code>收集路径元素，需要<code>start</code>参数控制递归</p></li><li><p>递归终止条件：<code>start</code>大于等于数组的长度。没有元素可取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层逻辑：遍历整棵树，不需要剪枝</p></li></ul><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储所有子集</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">//记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*回溯算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(path); <span class="comment">//收集子集，始终在上面，防止漏掉自己，前序遍历的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>; <span class="comment">//可以不加，每次递归的下一层就是从i+1开始的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从start开始，防止产生重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">//递归回溯</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, path);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="90"><li>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li></ol><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><p><a href="https://leetcode-cn.com/problems/subsets-ii/">力扣题目链接</a></p><p>解法：回溯+去重，同一层横向遍历需要去重（需要首先对集合排序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 对同一树层使用过的元素进行跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] ) &#123; <span class="comment">// 注意这里使用i &gt; start</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 去重需要排序</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录走过的路径</span></span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: <code> n = 4, k = 2</code><br>输出: <code> [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</code></p><p>解法：<code>combine(4, 2)</code>的结果，决策树的高度为k，宽度为n的所有叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录所有组合</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录走过的路径</span></span><br><span class="line">    <span class="built_in">backtrack</span>(n, k, <span class="number">1</span>, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//到达叶子节点更新result</span></span><br><span class="line">    <span class="keyword">if</span> (k == path.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i从start开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>, path); <span class="comment">// 递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合可以看作特定长度的子集，<code>combine(3, 2) </code>等价于 <code>subset([1, 2, 3])</code>长度为2 的子集</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><ol start="46"><li>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</li></ol><p>示例:</p><ul><li>输入:<code> [1,2,3]</code></li><li>输出: <code>[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</code></li></ul><p><a href="https://leetcode-cn.com/problems/permutations/">力扣题目链接</a></p><p>解法：排列是有序的， <code>[1,2] </code>和 <code>[2,1]</code> 是两个集合，处理全排列问题不需要start防止重复。需要排除已经选择过的数字，将所有叶子节点作为结果。可以使用一个<code>used</code>数组，标记此时<code>path</code>中已经选择的元素，<strong>一个排列里一个元素只能使用一次</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时说明到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">//标记bool数组</span></span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="47"><li>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</li></ol><p>示例 1：</p><ul><li>输入：<code>nums = [1,1,2]</code></li><li>输出：<code> [[1,1,2], [1,2,1], [2,1,1]]</code></li></ul><p>示例 2：</p><ul><li>输入：<code>nums = [1,2,3]</code></li><li>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li></ul><p><a href="https://leetcode-cn.com/problems/permutations-ii/">力扣题目链接</a></p><p>解法：回溯+去重，去重需要对元素序列排序，方便通过相近节点判断是否重复使用。</p><p>去重逻辑的关键代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line"><span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> 子集 </tag>
            
            <tag> 排列 </tag>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树基础</title>
      <link href="/posts/84ac9751/"/>
      <url>/posts/84ac9751/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul><li><strong>满二叉树</strong>：一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。</li></ul><img src="/posts/84ac9751/image-20220326214418676.png" alt="image-20220326214418676" style="zoom: 30%;"><p>满二叉树的深度为k，有2^k-1个节点的二叉树。</p><ul><li><strong>完全二叉树</strong>：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</li></ul><img src="/posts/84ac9751/image-20220326214559918.png" alt="image-20220326214559918" style="zoom:75%;"><ul><li><strong>二叉搜索树</strong>：有序树，满足：<ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul></li></ul><img src="/posts/84ac9751/image-20220326214858888.png" alt="image-20220326214858888" style="zoom:75%;"><ul><li><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，满足：<ul><li>是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>左右两个子树都是一棵平衡二叉树。</li></ul></li></ul><img src="/posts/84ac9751/image-20220326215122495.png" alt="image-20220326215122495" style="zoom:75%;"><table><thead><tr><th align="center">C++中常用容器</th><th align="center">底层实现</th></tr></thead><tbody><tr><td align="center">map、set、multimap，multiset</td><td align="center">平衡二叉搜索树</td></tr><tr><td align="center">unordered_map、unordered_set，<br>unordered_map、unordered_map</td><td align="center">哈希表</td></tr></tbody></table><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。前中后序遍历。</li><li>广度优先遍历：一层一层的去遍历。层次遍历。</li></ol><p>遍历顺序：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><img src="/posts/84ac9751/image-20220326221443483.png" alt="image-20220326221443483" style="zoom:75%;"><h3 id="二叉树定义："><a href="#二叉树定义：" class="headerlink" title="二叉树定义："></a>二叉树定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><p>递归三要素：</p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p><strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。</p><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*辅助遍历函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">traversal</span>(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><p>迭代法：用栈来实现递归</p><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*和中序遍历相比仅仅改变了两行代码的顺序*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>解法：广度优先遍历，使用辅助队列，先进先出</p><p>层序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h2><h3 id="中序与后序遍历序列构造二叉树"><a href="#中序与后序遍历序列构造二叉树" class="headerlink" title="中序与后序遍历序列构造二叉树"></a>中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接</a></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>解法：对中序和后序遍历序列进行切割，找好切割区间，建议左闭右开。</p><p>中序数组 ==&gt; 左中序数组 + 根 + 右中序数组</p><p>后序数组 ==&gt; 左后序数组 + 右后序数组 + 根</p><p>递归求解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">    <span class="keyword">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">    <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">    <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割中序数组</span></span><br><span class="line">    <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line">    <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">    postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割后序数组</span></span><br><span class="line">    <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">    <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line">    <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h3><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">力扣题目地址</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>解析：首先找到序列的最大值，以最大值构造根节点，左子树区间 + 根节点（最大值）+ 右子树区间，递归构造子区间至少一个值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到数组中最大的值和对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">            maxValueIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;val = maxValue;</span><br><span class="line">    <span class="comment">// 最大值所在的下标左区间 构造左子树</span></span><br><span class="line">    <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">        node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大值所在的下标右区间 构造右子树</span></span><br><span class="line">    <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题必会：快速排序/选择</title>
      <link href="/posts/202ade3b/"/>
      <url>/posts/202ade3b/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的逻辑是，若要对<code> nums[lo..hi]</code> 进⾏排序，我们先找⼀个分界点<code> p</code>，通过交换元素使得<code>nums[lo..p-1] </code>都⼩于等于<code> nums[p]</code>，且 <code>nums[p+1..hi] </code>都⼤于<code> nums[p]</code>，然后递归地去<code>nums[lo..p-1] </code>和<code>nums[p+1..hi] </code>中寻找新的分界点，最后整个数组就被排序了。</p><p>关键就在于这个分界点索引 <code>p</code> 的确定</p><img src="/posts/202ade3b/image-20220322165722861.png" alt="image-20220322165722861" style="zoom:50%;"><p>索引<code>p</code>左侧的元素都⽐ <code>nums[p] </code>⼩，右侧的元素都⽐ <code>nums[p]</code>⼤，意味着这个元素已经放到了正确的位置 。</p><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 将 nums 数组随机打乱</span></span><br><span class="line"> <span class="built_in">shuffle</span>(nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">quicksort</span>(nums, lo, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序核⼼逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line"> <span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line"> <span class="built_in">quicksort</span>(nums, lo, p - <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">quicksort</span>(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分界点索引 p 的确定 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>, j = hi;</span><br><span class="line">    <span class="comment">// 将 nums[lo] 作为默认分界点 p</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= nums[lo]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; j &amp;&amp; nums[j] &gt;= nums[lo]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//此时， nums[i] &gt; p &amp;&amp; nums[j] &lt; p，需交换 nums[i] 和 nums[j]</span></span><br><span class="line">            <span class="comment">//保证 nums[lo..i] &lt; p &lt; nums[j..hi]</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将 p值（nums[lo]）交换到正确的位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[lo], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组元素进⾏随机打乱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><blockquote><p>相关题目：</p><ol start="215"><li>数组中的第 K 个最⼤元素（中等）</li></ol></blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p> 解法：快排简化，可以在O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择需要找到第<code>k </code>大的枢（pivot），不需要对其左右再进行排序。快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为O($n^2$).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// ⾸先随机打乱数组</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数 - 快速选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小知识：二叉树</title>
      <link href="/posts/471b5238/"/>
      <url>/posts/471b5238/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><blockquote><p>相关题目：</p><ol start="226"><li><p>翻转⼆叉树（简单） </p></li><li><p>⼆叉树展开为链表（中等） </p></li><li><p>填充每个节点的下⼀个右侧节点指针（中等）</p></li></ol></blockquote><p>二叉树递归：明确函数的定义，根据定义递归推导最终结果。先搞清楚当前根节点”该做什么”与”什么时候做”，然后根据函数定义递归调⽤⼦节点，让孩⼦节点做相同的事情。</p><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>输⼊⼀个⼆叉树根节点<code> root</code>，把整棵树镜像翻转，⼆叉树上的每⼀个节点的左右⼦节点进⾏交换。</p><img src="/posts/471b5238/invert1-tree.jpg" alt="img" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将整棵树的节点翻转</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">//root节点需要交换它的左右节点</span></span><br><span class="line">    TreeNode* tmp = root -&gt; left;</span><br><span class="line">    root -&gt; left = root -&gt; right;</span><br><span class="line">    root -&gt; right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让左右⼦节点继续翻转它们的⼦节点</span></span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="填充⼆叉树节点的右侧指针"><a href="#填充⼆叉树节点的右侧指针" class="headerlink" title="填充⼆叉树节点的右侧指针"></a>填充⼆叉树节点的右侧指针</h3><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个<code> next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/471b5238/116_sample.png" alt="img" style="zoom:50%;"><p>⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情，如果只依赖一个节点进行递归，无法连接跨父节点的两个相邻节点。需细化为两个节点进行递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">nullptr</span> || node2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传⼊的两个节点连接</span></span><br><span class="line">    node1 -&gt; next = node2;</span><br><span class="line">    <span class="comment">// 连接相同⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; left, node1 -&gt; right);</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node2 -&gt; left, node2 -&gt; right);</span><br><span class="line">    <span class="comment">// 连接跨越⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; right, node2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小知识：队列/栈</title>
      <link href="/posts/16a357/"/>
      <url>/posts/16a357/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>队列主要⽤在 BFS 算法，栈主要⽤在括号相关的问题</p><h2 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h2><blockquote><p>相关题目：</p><ol start="232"><li><p>⽤栈实现队列（简单） </p></li><li><p>⽤队列实现栈（简单） </p></li></ol></blockquote><p>队列：先进先出；栈：先进后出</p><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>双栈实现队列</p><img src="/posts/16a357/image-20220315182119191.png" alt="image-20220315182119191" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到队尾 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除队头的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">peek</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回队头元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>双队列实现栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到栈顶 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断栈是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号字符串问题"><a href="#括号字符串问题" class="headerlink" title="括号字符串问题"></a>括号字符串问题</h2><blockquote><p>相关题目：</p><ol start="20"><li><p>有效的括号（简单） </p></li><li><p>使括号有效的最⼩添加（中等） </p></li><li><p>平衡括号串的最少插⼊（中等） </p></li></ol></blockquote><h3 id="判断合法括号字符串"><a href="#判断合法括号字符串" class="headerlink" title="判断合法括号字符串"></a>判断合法括号字符串</h3><p>输⼊⼀个字符串，其中包含<code>[]()&#123;&#125;</code>六种括号，判断这个字符串组成的括号是否合法。 </p><p>每个右括号 <code>)</code> 的左边必须有⼀个左括号 <code>(</code> 和它匹配。</p><p>解法：使用栈，遇到左括号就⼊栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            left.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字符 c 是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (!left.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">leftOf</span>(c) == left.<span class="built_in">top</span>())</span><br><span class="line">                left.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">// 和最近的左括号不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡括号串"><a href="#平衡括号串" class="headerlink" title="平衡括号串"></a>平衡括号串</h3><p>输⼊⼀个字符串 <code>s</code>，你可以在其中的任意位置插⼊左括号<code>(</code>或者右括号<code> )</code>，返回需要⼏次插⼊才能使得 <code>s </code>变成⼀个合法的括号串</p><p>输⼊ <code>s = &quot;())(&quot;</code>，算法应该返回 2，因为⾄少需要插⼊两次把 s 变成<code> &quot;(())()&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 记录插⼊次数</span></span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>; <span class="comment">// need 变量记录右括号的需求量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 + 1</span></span><br><span class="line">            need++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 - 1\</span></span><br><span class="line"><span class="comment">            need--;</span></span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">                need = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 需插⼊⼀个左括号</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><blockquote><p>相关题目：</p><ol start="496"><li><p>下⼀个更⼤元素I（简单） </p></li><li><p>下⼀个更⼤元素II（中等） </p></li><li><p>每⽇温度（中等） </p></li></ol></blockquote><p>单调栈：每次新元素⼊栈后，栈内的元素都保持有序（单调递增或单调递减）。 </p><p>一般只用来处理Next Greater Element 问题。</p><h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><p>⽐如：输⼊⼀个数组<code> nums = [2,1,2,4,3]</code>，返回数组<code> [4,2,4,-1,-1]</code>。 </p><p>解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4 ⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt;  s;</span><br><span class="line">    <span class="comment">// 倒着往栈⾥放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ;i++) &#123;</span><br><span class="line">        <span class="comment">// 判定个⼦⾼矮</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的 next great number</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定⼀个数组 T，这个数组存放的是近⼏天的天⽓⽓温，你返回⼀个等⻓的数组，计算：对于每⼀天，还要⾄少等多少天才能等到⼀个更暖和的⽓温；如果等不到那⼀天，填 0。</p><p>⽐如：输⼊ <code>T = [73,74,75,71,69,76]</code>，返回 <code>[1,1,3,2,1,0]</code>。 </p><p>解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天，只要等⼀天就能等到⼀个更暖和的⽓温，后⾯的同理。 </p><p>解法：单调栈，区别在于需要返回与Next Greater Number 的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这⾥放元素索引，⽽不是元素</span></span><br><span class="line">    <span class="comment">/* 单调栈模板 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; T[s.<span class="built_in">top</span>()] &lt;= T[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : (s.<span class="built_in">top</span>() - i);</span><br><span class="line">        s.<span class="built_in">push</span>(i); <span class="comment">// 将索引⼊栈，⽽不是元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小知识：数组/链表</title>
      <link href="/posts/a0fdfee0/"/>
      <url>/posts/a0fdfee0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储。</p><p>主要算法：双指针，可分为</p><ul><li>中间向两端扩散</li><li>两端向中间收缩</li><li>快慢指针</li></ul><h2 id="1-前缀和数组"><a href="#1-前缀和数组" class="headerlink" title="1. 前缀和数组"></a>1. 前缀和数组</h2><p>前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。</p><p><strong>注：原始数组/矩阵不可变，频繁查询某个区间的累加和。</strong></p><blockquote><p>相关题目：</p><ol start="303"><li><p>区域和检索 - 数组不可变（中等） </p></li><li><p>⼆维区域和检索 - 矩阵不可变（中等） </p></li><li><p>和为K的⼦数组（中等） </p></li></ol></blockquote><p>一维数组的前缀和</p><img src="/posts/a0fdfee0/image-20220310181632054.png" alt="image-image-20220310181632054" style="zoom:50%;"><p>新建一个<code>preSum</code>数组，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p><p>如果我想求索引区间<code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1] </code>得出。 </p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixSum</span> &#123;</span></span><br><span class="line"> <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; prefix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">     <span class="built_in">PrefixSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">     prefix.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">         prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">/* 查询闭区间 [i, j] 的累加和 */</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组前缀和</p><img src="/posts/a0fdfee0/image-20220310183903115.png" alt="image-20220310183903115" style="zoom:33%;"><p>如果我想计算红⾊的这个⼦矩阵的元素之和，可以⽤绿⾊矩阵减去蓝⾊矩阵减去橙⾊矩阵最后加上粉⾊矩 阵，⽽绿蓝橙粉这四个矩阵有⼀个共同的特点，就是左上⻆就是 (0, 0) 原点。 </p><p>那么我们可以维护⼀个⼆维 <code>preSum </code>数组，专⻔记录以原点为顶点的矩阵的元素之和，就可以⽤⼏次加减运算算出任何⼀个⼦矩阵的元素和：</p><h2 id="2-差分数组"><a href="#2-差分数组" class="headerlink" title="2. 差分数组"></a>2. 差分数组</h2><blockquote><p>相关题目：</p><ol start="370"><li><p>区间加法（中等） </p></li><li><p>航班预订统计（中等） </p></li><li><p>拼⻋（中等）</p></li></ol></blockquote><p>差分数组的主要适⽤场景是<strong>频繁对原始数组的某个区间的元素进⾏增减</strong>。 </p><p>对 <code>nums</code> 数组构造⼀个 <code>diff</code> 差分数组，**<code>diff[i]</code>** 就是 <strong><code>nums[i]</code></strong> 和 <strong><code>nums[i-1]</code></strong> 之差：</p><img src="/posts/a0fdfee0/image-20220311120935829.jpg" alt="image-20220311120935829" style="zoom:50%;"><p>这样构造差分数组 **<code>diff</code>**，就可以快速进⾏区间增减的操作，如果你想对区间 <code>nums[i..j] </code>的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让<code> diff[j+1] -= 3</code> 即可：</p><p>把差分数组抽象成⼀个类，包含 increment ⽅法和 result ⽅法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组⼯具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span>   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; diff;<span class="comment">//差分数组</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        assert nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">        diff,<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123; <span class="comment">//当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff数组减 val 了。</span></span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h2><blockquote><p>相关题目：</p><ol start="76"><li><p>最⼩覆盖⼦串（困难） </p></li><li><p>字符串的排列（中等） </p></li><li><p>找到字符串中所有字⺟异位词（中等） </p></li><li><p>⽆重复字符的最⻓⼦串（中等） </p></li></ol></blockquote><p>滑动窗⼝算法的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗⼝算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"> <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="comment">// c 是将移⼊窗⼝的字符</span></span><br><span class="line"><span class="keyword">char</span> c = s[right];</span><br><span class="line"><span class="comment">// 右移窗⼝</span></span><br><span class="line">right++;</span><br><span class="line"><span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> ...</span><br><span class="line"><span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断左侧窗⼝是否要收缩</span></span><br><span class="line"><span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line"> <span class="comment">// d 是将移出窗⼝的字符</span></span><br><span class="line"> <span class="keyword">char</span> d = s[left];</span><br><span class="line"> <span class="comment">// 左移窗⼝</span></span><br><span class="line"> left++;</span><br><span class="line"> <span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二分搜索"><a href="#4-二分搜索" class="headerlink" title="4. 二分搜索"></a>4. 二分搜索</h2><blockquote><p>相关题目：</p><ol start="704"><li><p>⼆分查找（简单） </p></li><li><p>在排序数组中查找元素的第⼀个和最后⼀个位置（中等） </p></li></ol></blockquote><p>搜索一个元素，搜索区间两端闭，while带等号</p><p>搜索左右边界，左闭右开常用，while用小于号</p><p>零、二分查找框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。</p><h3 id="寻找一个数：存在返回其索引，不存在返回-1"><a href="#寻找一个数：存在返回其索引，不存在返回-1" class="headerlink" title="寻找一个数：存在返回其索引，不存在返回-1."></a>寻找一个数：存在返回其索引，不存在返回-1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找左侧边界的二分搜索："><a href="#寻找左侧边界的二分搜索：" class="headerlink" title="寻找左侧边界的二分搜索："></a>寻找左侧边界的二分搜索：</h3><p>左闭右开区间写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target ⽐所有数都⼤</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 类似之前算法的处理⽅式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全闭区间写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找右侧边界的⼆分查找"><a href="#寻找右侧边界的⼆分查找" class="headerlink" title="寻找右侧边界的⼆分查找:"></a>寻找右侧边界的⼆分查找:</h3><p>左闭右开写法（常见）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全闭区间写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议搜索区间全都统⼀成了<strong>两端都闭</strong>，便于记忆，只要修改两处即可变化出三种写法</p><h2 id="5-原地修改数组"><a href="#5-原地修改数组" class="headerlink" title="5. 原地修改数组"></a>5. 原地修改数组</h2><blockquote><p>相关题目：</p><ol start="26"><li><p>删除有序数组中的重复项（简单） </p></li><li><p>删除排序链表中的重复元素（简单） </p></li><li><p>移除元素（简单） </p></li><li><p>移动零（简单） </p></li></ol></blockquote><h3 id="有序数组-链表去重"><a href="#有序数组-链表去重" class="headerlink" title="有序数组/链表去重"></a>有序数组/链表去重</h3><p>通⽤解法：快慢指针技巧</p><h3 id="有序数组去重："><a href="#有序数组去重：" class="headerlink" title="有序数组去重："></a>有序数组去重：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != num[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] ⽆重复</span></span><br><span class="line">            num[slow] = num[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组⻓度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表去重："><a href="#有序链表去重：" class="headerlink" title="有序链表去重："></a>有序链表去重：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast -&gt; val != slow -&gt; val) &#123;</span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            slow -&gt; next = fast;</span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开与后⾯重复元素的连接</span></span><br><span class="line">    slow -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组原地删除元素："><a href="#数组原地删除元素：" class="headerlink" title="数组原地删除元素："></a>数组原地删除元素：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原地修改，将数组中的所有值为-0-的元素移到数组末尾："><a href="#原地修改，将数组中的所有值为-0-的元素移到数组末尾：" class="headerlink" title="原地修改，将数组中的所有值为 0 的元素移到数组末尾："></a>原地修改，将数组中的所有值为 0 的元素移到数组末尾：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 去除 nums 中的所有 0</span></span><br><span class="line"><span class="comment">// 返回去除 0 之后的数组⻓度</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="built_in">removeElement</span>(nums, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将 p 之后的所有元素赋值为 0</span></span><br><span class="line"><span class="keyword">for</span> (; p &lt; nums.length; p++) &#123;</span><br><span class="line">nums[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⻅上⽂代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="6-单链表"><a href="#6-单链表" class="headerlink" title="6. 单链表"></a>6. 单链表</h2><blockquote><p>相关题目：</p><ol start="21"><li><p>合并两个有序链表（简单） </p></li><li><p>合并K个升序链表（困难） </p></li><li><p>环形链表（简单） </p></li><li><p>环形链表 II（中等） </p></li><li><p>链表的中间结点（简单） </p></li><li><p>相交链表（简单） </p></li><li><p>删除链表的倒数第 N 个结点（中等）</p></li></ol></blockquote><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>给定输⼊两个有序链表，把他俩合并成⼀个新的有序链表。</p><p>输入：<code>l1 = [1, 2, 4], l2 = [1, 3, 4]</code></p><p>输出：<code>[1, 1, 2, 3, 4, 4]</code></p><p>解法：设立虚拟头节点<code>dummy</code>，避免处理空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// ⽐较 p1 和 p2 两个指针</span></span><br><span class="line"> <span class="comment">// 将值较⼩的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span>(p1 -&gt; val &gt; p2 -&gt; val) &#123;</span><br><span class="line">            p -&gt; next = p2;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p -&gt; next = p1;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h3><p>给定输⼊k个有序链表，把他们合并成⼀个新的有序链表。</p><p>输入：<code>lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</code></p><p>输出：<code>[1, 1, 2, 3, 4, 4, 5, 6]</code></p><p>解法：优先级队列（二叉堆），把链表节点放⼊⼀个最⼩堆，就可以每次获得 k 个节点中的最⼩节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; n) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.val &lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 优先级队列，最⼩堆</span></span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 k 个链表的头结点加⼊最⼩堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;head -&gt; val, head&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取最⼩节点，接到结果链表中</span></span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>().p;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            p -&gt; next = node;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;node -&gt; next -&gt; val, node -&gt; next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h3><p>要点：只遍历⼀次链表，就算出倒数第 k 个节点</p><img src="/posts/a0fdfee0/image-20220314210806020.png" alt="image-20220314210806020" style="zoom:50%;"><p>指针<code>p1</code>指向<code>head</code>节点，开始走<code>k</code>步；</p><img src="/posts/a0fdfee0/image-20220314211006249.png" alt="image-20220314211006249" style="zoom:50%;"><p>指针<code>p2</code>指向<code>head</code>节点，<code>p1</code>和<code>p2</code>同时走，<code>n-k</code>步后<code>p1</code>走到链表末尾空指针结束，返回<code>p2</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    <span class="comment">// p1 先⾛ k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时⾛ n - k 步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p2 = p2 -&gt; next;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表中点"><a href="#单链表中点" class="headerlink" title="单链表中点"></a>单链表中点</h3><p>解法：让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点<code> head</code>。 每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> ⾛到链表末尾时，<code>slow</code> 就指向了链 表中点。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> ListNode* slow = head, *fast = head;</span><br><span class="line"> <span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> slow = slow -&gt; next;</span><br><span class="line"> fast = fast -&gt; next -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果链表⻓度为偶数，也就是说中点有两个的时候，这个解法返回的节点是靠后的那个节点。 </p><h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><p>解法：快慢指针，每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast </code>最终和<code>slow</code>相遇，那肯定是<code> fast</code> 超过了<code>slow</code> ⼀圈，说明链表中含有环。</p><p>只需要把寻找链表中点的代码稍加修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> ListNode* slow = head, *fast = head;</span><br><span class="line"> <span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> slow = slow -&gt; next;</span><br><span class="line"> fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算环的起点*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line"> fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line"> slow = head;</span><br><span class="line"> <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"> <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"> fast = fast -&gt; next;</span><br><span class="line">     slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>输⼊两个链表的头结点<code>headA</code>和<code> headB</code>，这两个链表可能存在相交。如果相交，应该返回相交的那个节点；如果没相交，则返回 <code>nullptr</code>。</p><p>解法：可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让<code> p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表<code> A</code>，这样相 当于「逻辑上」两条链表接在了⼀起。让<code> p1</code> 和<code> p2</code> 同时进⼊公共部分，也就是同时到达相交节点<code> c1</code></p><img src="/posts/a0fdfee0/image-20220315104422008.png" alt="image-20220315104422008" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode* p1 = headA, *p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-链表操作的递归实现"><a href="#7-链表操作的递归实现" class="headerlink" title="7. 链表操作的递归实现"></a>7. 链表操作的递归实现</h2><blockquote><p>相关题目：</p><ol start="206"><li><p>反转链表（简单） </p></li><li><p>反转链表II（中等） </p></li></ol></blockquote><h3 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h3><p>输⼊⼀个节点 <code>head</code>，将以<code>head</code>为起点的链表反转，并返回反转之后的头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归函数base case，如果链表只有⼀个节点的时候，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的头结点是last, 将head之后部分反转</span></span><br><span class="line">    ListNode* last = <span class="built_in">reverse</span>(head -&gt; next);</span><br><span class="line">    head -&gt; next -&gt; next = head;</span><br><span class="line">    <span class="comment">//head 变成了最后⼀个节点，别忘了链表的末尾要指向 null</span></span><br><span class="line">    head -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h3><p>解决思路和反转整个链表差不多，稍加修改即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode* successor = <span class="literal">nullptr</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line"> successor = head -&gt; next;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line"> ListNode* last = <span class="built_in">reverseN</span>(head -&gt; next, n - <span class="number">1</span>);</span><br><span class="line"> head -&gt; next -&gt; next = head;</span><br><span class="line"><span class="comment">// 让反转之后的 head 节点和后⾯的节点连起来</span></span><br><span class="line"> head -&gt; next = successor;</span><br><span class="line"> <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h3><p>给⼀个索引区间<code> [left, right]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接上部分反转链表代码</span></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zhang-Tong-CV</title>
      <link href="/posts/676dd596/"/>
      <url>/posts/676dd596/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><table>    <tr>        <td width="80%">            <table>                <tr>                                        <td align="left"><b>Master</b></td>                </tr>                <tr>                                        <td align="left"><b>School of Mechanical & Automotive Engineering, South China University of Technology</b></td>                </tr>                <tr>                                        <td align="left"><b>Mail: zt_scut@163.com</b></td>                </tr>                <tr>                                        <td align="left"><b>Phone: +1 ‪(971) 373-7549‬</b></td>                </tr>                <tr>                                        <td align="left"><b>Address: 381 Wushan Road, Tianhe District, Guangzhou,Guangdong, China</b></td>                </tr>                            </table>        </td>        <td width="30%" height="100%">            <img src="/images/image-20220306.jpg">        </td>    </tr></table><h2 id="Educational-Qualification"><a href="#Educational-Qualification" class="headerlink" title="Educational Qualification"></a>Educational Qualification</h2><ul><li><strong>Master</strong> in Vehicle Engineering(2023)<br>South China University of Technology,Guangzhou, China</li><li><strong>B.Eng</strong> in Vehicle Engineering(2020)<br>Hefei University of Technology, China</li></ul><h2 id="Project-amp-Internship-Experience"><a href="#Project-amp-Internship-Experience" class="headerlink" title="Project &amp; Internship Experience"></a>Project &amp; Internship Experience</h2><p><em>Software Testing Engineer Intern in Kaizeli Technology Co. ,Ltd. (2020.07-2020.09)</em></p><ul><li>Write test scripts according to requirements documents, using Linux command and shell language</li><li>Responsible for the on-board OTA and IVI module testing projects, complete the test unit and upload test reports</li><li>Participated in the project of automated test platform, and improve the design of the testing interface, carry out a detailed needs analysis and use case design. </li></ul><p><em>Software Testing Engineer Intern in GAC R&amp;D Center. (2020.10—2020.12)</em></p><ul><li>Understand the principle of CAN communication, and using CAN communication tools,  such as Vehicle-Spy、KVaser, to sample the test signal </li><li>Carry out on-board system function module test, and complete data detection, calibration, log acquisition and analysis</li><li>Participate in on-board system test of multiple models, and update test cases according to requirements and feedback</li></ul><p><em>Software Design Engineer Intern in Shenzhen Lan-You Technology Co. ,Ltd. (2021.08-2021.11)</em></p><ul><li>Assisted in the implementation of simulation software of automatic vehicle, design test scenarios in ACC、AEB、LKA , complete design documents and scenario scripts</li><li>Responsible for the parking area map design and visualization, compile the program scripts for parsing XML files, and using QT software for visual display</li><li>Complete the preliminary project and generate 858 test scenario scripts totally,  and  using the  parking area visualization program to help verify the reliability of map file data</li></ul><h2 id="Research-Experience"><a href="#Research-Experience" class="headerlink" title="Research Experience"></a>Research Experience</h2><ul><li>Participate in the Innovation training program for college students in Anhui Province 2018, Intelligent lane changing auxiliary system Based on longitudinal and lateral dynamic control,  responsible for building vehicle dynamics model and using CarSim software for simulation</li><li>Participate in the Innovation training program for college students in Anhui Province 2019, Design and motion control of multi-mode reconfigurable for self-driving vehicle, responsible for help generate physical model using Catia drawing software, and Assisted in the implementation of the printed circuit board design</li><li>Research on driver fatigue detection method based on facial features, the graduation project, used CNN for facial landmarks detection and a pre-trained network for training on the data set, using SVM algorithm to generate model of facial fatigue feature classification </li></ul><h2 id="Campus-Experience"><a href="#Campus-Experience" class="headerlink" title="Campus Experience"></a>Campus Experience</h2><p><em>Commissary in charge of studies, School of Automotive &amp; Transportation Engineering, Hefei University of Technology (2016-2020)</em></p><ul><li>Responsible for the study management in class and communicate with teachers to arrange experimental courses</li><li>Planning and hosting the meeting for exchange of learning experience, responsible for inviting outstanding graduates to give speeches and more than 300 college students participate in the Event</li></ul><h2 id="Social-Practice-Experience"><a href="#Social-Practice-Experience" class="headerlink" title="Social Practice Experience"></a>Social Practice Experience</h2><p><em>Support Teacher of Feng huang primary school, Chaohu, Anhui Province (2017)</em></p><ul><li>As a math teacher and physical education teacher for primary school students, spent a pleasant and meaningful summer with them</li><li>Planted the seeds of learning and encouraged them to explore the world</li><li>Increased responsibilities and accountability through communication with primary school students</li></ul><h2 id="Awards"><a href="#Awards" class="headerlink" title="Awards"></a>Awards</h2><ul><li>Second-class scholarship(2x) and Third-class scholarship in Hefei University of Technology </li><li>Outstanding student cadres in HFUT</li><li>Excellent graduation project for Bachelor’s degree</li><li>No.7 of men’s team competition in the National Student Shuttlecock Championship College group </li></ul><h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul><li>CET-6</li><li>Familiar with C/C++, Python</li><li>Familiar with the Linux operating system</li></ul><h2 id="Self-evaluation"><a href="#Self-evaluation" class="headerlink" title="Self-evaluation"></a>Self-evaluation</h2><p>I am an optimistic and positive person and interested in the emergence of new things and new ideas. I can set goals with others and accomplish them through the power of teamwork and communication. My main research interest is computer vision and deep learning,  and I have an understanding of machine learning, sensor fusion and computer science.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="cab758c2bbf29e310f607855e3e7e51f21bbfea904ea7a8ed26da8da89de8fc9">1b693c4938223286468132b2f7068bf6098157620d78df6a8d32bb51e3f325b181ab70623eeb2a3f7a6bc681afafbdfe713bdd1c6f193890fe2449d416193fec46af80b0cd7431187dd1f97bc499b3a9ff9add79cea27c3015bb48123e899a7fb3295784c80b5d0b121aef398aca2f36d3661e78c54305f10d7d8f9de07de7e9a370641812f840a8f68bb7686e6e75bf5aaa69b4f328fe94d17a00647b6bdeefac5ff68db076f26d217b7be239abd3dad05c88857aa0945ec9bbce8c501724e9cddcda090e0b5dd17670bc5b0aa146e5c15ead49d5bedec7e2d0ba426f9bac50c6fb7f935f8a01d86b0fb15bfc31774d8b2e748468978a57c9f314cf3474a8908c962e62d793d4202cc789c89f172859f6c45d905ca5828e4fcc14dcd0b72bc60fed7d44f9e29b4be00939342e416c9e56c67e04b79fdec1dcef56c7602d391c51365f0885c5f1e7daa21ef5f34ec737ba851e91be020d6b473ff53dc5082093a33f1899d7be4ed55ecb8a865ada024c8a8ccf66b6e0c51f2843e1248a0f483d118e82308bd4ea916657024bf2c31a5fb01da6ef08a8316c44e217bc4792319d995741257cca7ddaab847de991c6537d986a79b83e8cee1d44c948ed237bbcc65fe83890021b84452bd350bbc4b8eace2cf7b56a5ee838ce3f76d847cd9b091176a88ddd8759125c5ef6f3a128951a6a60b4eb9b3000103e3fc21e28fefb5237e8dff0724bbe862d7bd8b9bf0bed10f0b85b68b8267130266e872060622d62bcab8182471f42324384a307a3f7cf68a591c3e5123d7d983dde563a046f30df65686ba53da8448fba75896080e1fc7bfc6685c2bd7cd91d28907af15fdc166854210f6d488a3c62336376333997a4440bd58288eeb52b359fd4fa62455ee3f5f10c53851924baa240880212ebf3801c2f496b21c0fb67bddddc6b3884e9dca3b6f3742e05f59e3fb3035436dce19683e5ecbb48d4df737592b11ece81856380177c37c7309f768d3b64c48649aa82ebe5d29649bdba9af2df082e771827d4835afab8fe8e69b87e8b2404de6c41cc60fa45c843bf89bc83d73d1a8b7d55dc6f00f0e1e9480890bf6a324e584fc0c45ae457e9031622981ee83f0f275eb5682b05f2cd81b5f6b4776c9f3b90bf1857e78a3ea5bb4c83a4654de516eadfd438a5f4d9c25c2e48b6d7fead8c1cedb027faf44d8d9ce375ffc87532cc56f002835e0e55b75b96dad4592e56417416aaa6d22e08af6e5c565e005c516dfe25927804e35c11ed470916d60e9e941489205c98c96a1c888ec4fcabf2cd59cf7ed77d51cb5d4b8aa1a0837099b37341d56b907e8ddeec5e34bff8bbefffa2c864d1ef7de812c4e874d2b420505ae8e4416dd9a33cd3713be4adbe572af303bc6904b8a281f9df07fd21b063fc85f7540f2b44976f593cbd622314605f4e2e391b20c0ea22f3895d13e668c979815c9bdfda25095fb79ef6c023139f1d0f3acf0ab15ef22a6373a11b906fb98209de8a83f85444cb96081129e2c7c8421791beecabb01241aa70f09346209d23bfe18d60338ba3abb4792d594197c9abc95d1d962a49bbc34c25e156e252f6510f8441a614bea22f2f7116575536cd4d2b8f12df6d82d2d65026003aa1cd2996ddd6c1d93fd308591391dd88d7d70cca7d5f9fea6f9500b11312df71132d053f8da3910d17eb455a1dd11462bd65159ecc86cfb61b3f130c2f1be650e86328833e99d8d121a1a5632a250b3ab29980d598255adab11607e9da1b5156f399c285e3d748d84aa460fc4b3c71d8120e0d056fa0707e1d876213ddcefae8b856a0a8384b037dfc6ed753ac31508f19bd2321a9da8adb4b9fbbd3e28be1d495e338871e63b948a663665d9671a349abbc5aa7d895e794785302d5260eede14246baa774210d9d0fea4bf36853a865a781b35c8c482b46675e2ef1161d78856120df62ab968a5e8726f7d58f7f4d7824daff425475d82858438b9a4d06ede3f489262c13637eab07914138236b60f73ebef728d93aa59e789a6c21e4868886308f79701a80cce6098a7d050424f478e9151a87e9de5c53b3c2bc81b15b601a40ac452486f1149a6af9d4f70d4dbb9cc233e8cc2703e8bf13aa35a4fca77bcb9cec9e6f1195475ac4af9952e31a4319c1ad417666c224efa7eb95a7f957cffa0541af71a66bdb3759cf72a3bca8bbb5036ebf135ee0f0ad0fcc1170aefc5c9881466f69582a0bd565161355fc447fc0121359014e08b1533f1c896eedef7e15e3c770fe2c2f4068bdae19fc24d286ec5fd0f0925586cb2b481031bded5c5e1ff5fcc581d17df686aca3266e519cbb70c9189e4145ff103d5facc16bf1d9f7660967180fe8795f400729b8422768e0af1b32dfbdbe6414a5b94b593247c2cb2c9b10ec80be7d55726ded5c724c7c8ce4f2a76ca5021331ba0286ae6b94c3fb0b137d2b826ad083f4c2d1e1ae70fcbb8fe81d638464af4d326d60b621db96b26194ab2fb1fcb2913b0634ac96c2e9a62baaaf0816cc903f1a5e96c6db24c9217efa7494bc43e85cc8016ac2cb7e31b7b63fbebcd70b47ea05a756893dd823673bd077b20bd5bf23ba92ebfc0556679994403d835e852da90fbaf894e326028fe892fc04fe5b32d965877af6b24e4f3f924e54a3d3cbf4518c36662dca2cb4afaefbe8600cb747e49e0e2212149a02961e3a9cecd985188fcb7217e7fe08172a65d854b5aa33a7365a6c28cb1ad4a2e05de66c8c404f1a39f3ee5d858d42c0d5f9276b6ce0c28190d7db0b3c8606f1c420e17d74e241c44756c9aff1789827b3a00b20d0d87f7f2ac159df12d8389c7eed139660934d7be7bb284f7529fb1e8bb000685742a6a1bff1bf41a0cbc05736e8fcec2428f54bcc6570c75cc89fc2894d87e0f1c5e64750f197b02fca53580902f57818e9e08988555ea17ff42bb449dd547e955ce96f2fe96eaa09708b4dde5098748432d8ea7491ad60e20930453b941a79c0f6ce9721cb6f34e915abc5e8be238e448d573d435ba3ba7f04efabd82896385e9747a56a5f2fd83fb874031ca98abe25cd3f5059a05b7242ef1147aad5dba834d3eefac1e0d04b36b8b2c6fca0bb35349ab66544cd487b47ca08d12da5a2a443129b16b4326f17b5d94d3787e2d4a3110f2bbb3aab5078e00c4c4b52045d41178d8e2db055a27f02630aae58b8716794d7e29aaf458840d948b33836a125e88e529d2fc5962f7e335cb78aefaa79db64da39d46419b3c7ab1091cd3820a4f7dd1016b1983e73c8dc12e5f2e4d0a4cb16ac57d47fface000b5d837fc1adecec7cda5d50581465c6d42796ce4c3a7eb31176b447a6841d6094a77856f6c8540d081849875aa46f856ec14d74469803af62af5f41b389dc1d57ab410775381bb0e7ab0d7b993edfdb1f4b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
