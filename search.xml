<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>刷题小知识：数组/链表</title>
    <url>/posts/a0fdfee0/</url>
    <content><![CDATA[<h1 id="数组-链表"><a href="#数组-链表" class="headerlink" title="数组/链表"></a>数组/链表</h1><p>数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储。</p>
<p>主要算法：双指针，可分为</p>
<ul>
<li>中间向两端扩散</li>
<li>两端向中间收缩</li>
<li>快慢指针</li>
</ul>
<hr>
<span id="more"></span>

<h2 id="1-前缀和数组"><a href="#1-前缀和数组" class="headerlink" title="1. 前缀和数组"></a>1. 前缀和数组</h2><p>前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。</p>
<p><strong>注：原始数组/矩阵不可变，频繁查询某个区间的累加和。</strong></p>
<blockquote>
<p>相关题目：</p>
<ol start="303">
<li><p>区域和检索 - 数组不可变（中等） </p>
</li>
<li><p>⼆维区域和检索 - 矩阵不可变（中等） </p>
</li>
<li><p>和为K的⼦数组（中等） </p>
</li>
</ol>
</blockquote>
<p>一维数组的前缀和</p>
<img src="/posts/a0fdfee0/image-20220310181632054.png" alt="image-image-20220310181632054" style="zoom:50%;">

<p>新建一个<code>preSum</code>数组，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p>
<p>如果我想求索引区间<code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1] </code>得出。 </p>
<p>核心代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixSum</span> &#123;</span></span><br><span class="line"> <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; prefix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">     <span class="built_in">PrefixSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">     prefix.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">         prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> 	<span class="comment">/* 查询闭区间 [i, j] 的累加和 */</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"> 	 	<span class="keyword">return</span> prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组前缀和</p>
<img src="/posts/a0fdfee0/image-20220310183903115.png" alt="image-20220310183903115" style="zoom:33%;">

<p>如果我想计算红⾊的这个⼦矩阵的元素之和，可以⽤绿⾊矩阵减去蓝⾊矩阵减去橙⾊矩阵最后加上粉⾊矩 阵，⽽绿蓝橙粉这四个矩阵有⼀个共同的特点，就是左上⻆就是 (0, 0) 原点。 </p>
<p>那么我们可以维护⼀个⼆维 <code>preSum </code>数组，专⻔记录以原点为顶点的矩阵的元素之和，就可以⽤⼏次加减运算算出任何⼀个⼦矩阵的元素和：</p>
<h2 id="2-差分数组"><a href="#2-差分数组" class="headerlink" title="2. 差分数组"></a>2. 差分数组</h2><blockquote>
<p>相关题目：</p>
<ol start="370">
<li><p>区间加法（中等） </p>
</li>
<li><p>航班预订统计（中等） </p>
</li>
<li><p>拼⻋（中等）</p>
</li>
</ol>
</blockquote>
<p>差分数组的主要适⽤场景是<strong>频繁对原始数组的某个区间的元素进⾏增减</strong>。 </p>
<p>对 <code>nums</code> 数组构造⼀个 <code>diff</code> 差分数组，**<code>diff[i]</code>** 就是 <strong><code>nums[i]</code></strong> 和 <strong><code>nums[i-1]</code></strong> 之差：</p>
<img src="/posts/a0fdfee0/image-20220311120935829.jpg" alt="image-20220311120935829" style="zoom:50%;">

<p>这样构造差分数组 **<code>diff</code>**，就可以快速进⾏区间增减的操作，如果你想对区间 <code>nums[i..j] </code>的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让<code> diff[j+1] -= 3</code> 即可：</p>
<p>把差分数组抽象成⼀个类，包含 increment ⽅法和 result ⽅法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差分数组⼯具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span>   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; diff;	<span class="comment">//差分数组</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        assert nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">        diff,<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        	diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123; <span class="comment">//当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff数组减 val 了。</span></span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h2><blockquote>
<p>相关题目：</p>
<ol start="76">
<li><p>最⼩覆盖⼦串（困难） </p>
</li>
<li><p>字符串的排列（中等） </p>
</li>
<li><p>找到字符串中所有字⺟异位词（中等） </p>
</li>
<li><p>⽆重复字符的最⻓⼦串（中等） </p>
</li>
</ol>
</blockquote>
<p>滑动窗⼝算法的代码框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗⼝算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"> 	<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;	</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// c 是将移⼊窗⼝的字符</span></span><br><span class="line">		<span class="keyword">char</span> c = s[right];</span><br><span class="line">		<span class="comment">// 右移窗⼝</span></span><br><span class="line">		right++;</span><br><span class="line">		<span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line">		 ...</span><br><span class="line">		<span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">		<span class="comment">/********************/</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 判断左侧窗⼝是否要收缩</span></span><br><span class="line">		<span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line"> 		<span class="comment">// d 是将移出窗⼝的字符</span></span><br><span class="line"> 		<span class="keyword">char</span> d = s[left];</span><br><span class="line"> 		<span class="comment">// 左移窗⼝</span></span><br><span class="line"> 		left++;</span><br><span class="line"> 		<span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> 		...</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二分搜索"><a href="#4-二分搜索" class="headerlink" title="4. 二分搜索"></a>4. 二分搜索</h2><blockquote>
<p>相关题目：</p>
<ol start="704">
<li><p>⼆分查找（简单） </p>
</li>
<li><p>在排序数组中查找元素的第⼀个和最后⼀个位置（中等） </p>
</li>
</ol>
</blockquote>
<p>搜索一个元素，搜索区间两端闭，while带等号</p>
<p>搜索左右边界，左闭右开常用，while用小于号</p>
<p>零、二分查找框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。</p>
<h3 id="寻找一个数：存在返回其索引，不存在返回-1"><a href="#寻找一个数：存在返回其索引，不存在返回-1" class="headerlink" title="寻找一个数：存在返回其索引，不存在返回-1."></a>寻找一个数：存在返回其索引，不存在返回-1.</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找左侧边界的二分搜索："><a href="#寻找左侧边界的二分搜索：" class="headerlink" title="寻找左侧边界的二分搜索："></a>寻找左侧边界的二分搜索：</h3><p>左闭右开区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target ⽐所有数都⼤</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 类似之前算法的处理⽅式</span></span><br><span class="line">	<span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全闭区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找右侧边界的⼆分查找"><a href="#寻找右侧边界的⼆分查找" class="headerlink" title="寻找右侧边界的⼆分查找:"></a>寻找右侧边界的⼆分查找:</h3><p>左闭右开写法（常见）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全闭区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议搜索区间全都统⼀成了<strong>两端都闭</strong>，便于记忆，只要修改两处即可变化出三种写法</p>
<h2 id="5-原地修改数组"><a href="#5-原地修改数组" class="headerlink" title="5. 原地修改数组"></a>5. 原地修改数组</h2><blockquote>
<p>相关题目：</p>
<ol start="26">
<li><p>删除有序数组中的重复项（简单） </p>
</li>
<li><p>删除排序链表中的重复元素（简单） </p>
</li>
<li><p>移除元素（简单） </p>
</li>
<li><p>移动零（简单） </p>
</li>
</ol>
</blockquote>
<h3 id="有序数组-链表去重"><a href="#有序数组-链表去重" class="headerlink" title="有序数组/链表去重"></a>有序数组/链表去重</h3><p>通⽤解法：快慢指针技巧</p>
<h3 id="有序数组去重："><a href="#有序数组去重：" class="headerlink" title="有序数组去重："></a>有序数组去重：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != num[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] ⽆重复</span></span><br><span class="line">            num[slow] = num[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组⻓度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序链表去重："><a href="#有序链表去重：" class="headerlink" title="有序链表去重："></a>有序链表去重：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast -&gt; val != slow -&gt; val) &#123;</span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            slow -&gt; next = fast;</span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开与后⾯重复元素的连接</span></span><br><span class="line">    slow -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组原地删除元素："><a href="#数组原地删除元素：" class="headerlink" title="数组原地删除元素："></a>数组原地删除元素：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原地修改，将数组中的所有值为-0-的元素移到数组末尾："><a href="#原地修改，将数组中的所有值为-0-的元素移到数组末尾：" class="headerlink" title="原地修改，将数组中的所有值为 0 的元素移到数组末尾："></a>原地修改，将数组中的所有值为 0 的元素移到数组末尾：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 去除 nums 中的所有 0</span></span><br><span class="line">	<span class="comment">// 返回去除 0 之后的数组⻓度</span></span><br><span class="line">	<span class="keyword">int</span> p = <span class="built_in">removeElement</span>(nums, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 将 p 之后的所有元素赋值为 0</span></span><br><span class="line">	<span class="keyword">for</span> (; p &lt; nums.length; p++) &#123;</span><br><span class="line">		nums[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⻅上⽂代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-单链表"><a href="#6-单链表" class="headerlink" title="6. 单链表"></a>6. 单链表</h2><blockquote>
<p>相关题目：</p>
<ol start="21">
<li><p>合并两个有序链表（简单） </p>
</li>
<li><p>合并K个升序链表（困难） </p>
</li>
<li><p>环形链表（简单） </p>
</li>
<li><p>环形链表 II（中等） </p>
</li>
<li><p>链表的中间结点（简单） </p>
</li>
<li><p>相交链表（简单） </p>
</li>
<li><p>删除链表的倒数第 N 个结点（中等）</p>
</li>
</ol>
</blockquote>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>给定输⼊两个有序链表，把他俩合并成⼀个新的有序链表。</p>
<p>输入：<code>l1 = [1, 2, 4], l2 = [1, 3, 4]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4]</code></p>
<p>解法：设立虚拟头节点<code>dummy</code>，避免处理空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// ⽐较 p1 和 p2 两个指针</span></span><br><span class="line"> 		<span class="comment">// 将值较⼩的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span>(p1 -&gt; val &gt; p2 -&gt; val) &#123;</span><br><span class="line">            p -&gt; next = p2;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p -&gt; next = p1;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h3><p>给定输⼊k个有序链表，把他们合并成⼀个新的有序链表。</p>
<p>输入：<code>lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4, 5, 6]</code></p>
<p>解法：优先级队列（二叉堆），把链表节点放⼊⼀个最⼩堆，就可以每次获得 k 个节点中的最⼩节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; n) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.val &lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 优先级队列，最⼩堆</span></span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 k 个链表的头结点加⼊最⼩堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;head -&gt; val, head&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取最⼩节点，接到结果链表中</span></span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>().p;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            p -&gt; next = node;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;node -&gt; next -&gt; val, node -&gt; next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h3><p>要点：只遍历⼀次链表，就算出倒数第 k 个节点</p>
<img src="/posts/a0fdfee0/image-20220314210806020.png" alt="image-20220314210806020" style="zoom:50%;">

<p>指针<code>p1</code>指向<code>head</code>节点，开始走<code>k</code>步；</p>
<img src="/posts/a0fdfee0/image-20220314211006249.png" alt="image-20220314211006249" style="zoom:50%;">

<p>指针<code>p2</code>指向<code>head</code>节点，<code>p1</code>和<code>p2</code>同时走，<code>n-k</code>步后<code>p1</code>走到链表末尾空指针结束，返回<code>p2</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    <span class="comment">// p1 先⾛ k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时⾛ n - k 步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p2 = p2 -&gt; next;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表中点"><a href="#单链表中点" class="headerlink" title="单链表中点"></a>单链表中点</h3><p>解法：让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点<code> head</code>。 每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> ⾛到链表末尾时，<code>slow</code> 就指向了链 表中点。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> 	ListNode* slow = head, *fast = head;</span><br><span class="line"> 	<span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> 		slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果链表⻓度为偶数，也就是说中点有两个的时候，这个解法返回的节点是靠后的那个节点。 </p>
<h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><p>解法：快慢指针，每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast </code>最终和<code>slow</code>相遇，那肯定是<code> fast</code> 超过了<code>slow</code> ⼀圈，说明链表中含有环。</p>
<p>只需要把寻找链表中点的代码稍加修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> 	ListNode* slow = head, *fast = head;</span><br><span class="line"> 	<span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> 		slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算环的起点*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> 		<span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line">	 slow = head;</span><br><span class="line"> 	<span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"> 	<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"> 		fast = fast -&gt; next;</span><br><span class="line">     	slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>输⼊两个链表的头结点<code>headA</code>和<code> headB</code>，这两个链表可能存在相交。如果相交，应该返回相交的那个节点；如果没相交，则返回 <code>nullptr</code>。</p>
<p>解法：可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让<code> p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表<code> A</code>，这样相 当于「逻辑上」两条链表接在了⼀起。让<code> p1</code> 和<code> p2</code> 同时进⼊公共部分，也就是同时到达相交节点<code> c1</code></p>
<img src="/posts/a0fdfee0/image-20220315104422008.png" alt="image-20220315104422008" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode* p1 = headA, *p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-链表操作的递归实现"><a href="#7-链表操作的递归实现" class="headerlink" title="7. 链表操作的递归实现"></a>7. 链表操作的递归实现</h2><blockquote>
<p>相关题目：</p>
<ol start="206">
<li><p>反转链表（简单） </p>
</li>
<li><p>反转链表II（中等） </p>
</li>
</ol>
</blockquote>
<h3 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h3><p>输⼊⼀个节点 <code>head</code>，将以<code>head</code>为起点的链表反转，并返回反转之后的头结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归函数base case，如果链表只有⼀个节点的时候，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的头结点是last, 将head之后部分反转</span></span><br><span class="line">    ListNode* last = <span class="built_in">reverse</span>(head -&gt; next);</span><br><span class="line">    head -&gt; next -&gt; next = head;</span><br><span class="line">    <span class="comment">//head 变成了最后⼀个节点，别忘了链表的末尾要指向 null</span></span><br><span class="line">    head -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h3><p>解决思路和反转整个链表差不多，稍加修改即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* successor = <span class="literal">nullptr</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"> 		<span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line"> 		successor = head -&gt; next;</span><br><span class="line"> 		<span class="keyword">return</span> head;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line"> 	ListNode* last = <span class="built_in">reverseN</span>(head -&gt; next, n - <span class="number">1</span>);</span><br><span class="line"> 	head -&gt; next -&gt; next = head;</span><br><span class="line">	<span class="comment">// 让反转之后的 head 节点和后⾯的节点连起来</span></span><br><span class="line"> 	head -&gt; next = successor;</span><br><span class="line"> 	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h3><p>给⼀个索引区间<code> [left, right]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接上部分反转链表代码</span></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="52444d4cb1ffc588615b9d0abc49282209d3ebce20a5bcf437b678a72bf16e52">1b693c4938223286468132b2f7068bf6098157620d78df6a8d32bb51e3f325b181ab70623eeb2a3f7a6bc681afafbdfe713bdd1c6f193890fe2449d416193fec46af80b0cd7431187dd1f97bc499b3a9ff9add79cea27c3015bb48123e899a7fb3295784c80b5d0b121aef398aca2f36d3661e78c54305f10d7d8f9de07de7e9a370641812f840a8f68bb7686e6e75bf5aaa69b4f328fe94d17a00647b6bdeefac5ff68db076f26d217b7be239abd3dad05c88857aa0945ec9bbce8c501724e9cddcda090e0b5dd17670bc5b0aa146e5c15ead49d5bedec7e2d0ba426f9bac50c6fb7f935f8a01d86b0fb15bfc31774d8b2e748468978a57c9f314cf3474a8908c962e62d793d4202cc789c89f172859f6c45d905ca5828e4fcc14dcd0b72bc60fed7d44f9e29b4be00939342e416c9e56c67e04b79fdec1dcef56c7602d391c51365f0885c5f1e7daa21ef5f34ec737ba851e91be020d6b473ff53dc5082093a33f1899d7be4ed55ecb8a865ada024c8a8ccf66b6e0c51f2843e1248a0f483d118e82308bd4ea916657024bf2c31a5fb01da6ef08a8316c44e217bc4792319d995741257cca7ddaab847de991c6537d986a79b83e8cee1d44c948ed237bbcc65fe83890021b84452bd350bbc4b8eace2cf7b56a5ee838ce3f76d847cd9b091176a88ddd8759125c5ef6f3a128951a6a60b4eb9b3000103e3fc21e28fefb5237e8dff0724bbe862d7bd8b9bf0bed10f0b85b68b8267130266e872060622d62bcab8182471f42324384a307a3f7cf68a591c3e5123d7d983dde563a046f30df65686ba53da8448fba75896080e1fc7bfc6685c2bd7cd91d28907af15fdc166854210f6d488a3c62336376333997a4440bd58288eeb52b359fd4fa62455ee3f5f10c53851924baa240880212ebf3801c2f496b21c0fb67bddddc6b3884e9dca3b6f3742e05f59e3fb3035436dce19683e5ecbb48d4df737592b11ece81856380177c37c7309f768d3b64c48649aa82ebe5d29649bdba9af2df082e771827d4835afab8fe8e69b87e8b2404de6c41cc60fa45c843bf89bc83d73d1a8b7d55dc6f00f0e1e9480890bf6a324e584fc0c45ae457e9031622981ee83f0f275eb5682b05f2cd81b5f6b4776c9f3b90bf1857e78a3ea5bb4c83a4654de516eadfd438a5f4d9c25c2e48b6d7fead8c1cedb027faf44d8d9ce375ffc87532cc56f002835e0e55b75b96dad4592e56417416aaa6d22e08af6e5c565e005c516dfe25927804e35c11ed470916d60e9e941489205c98c96a1c888ec4fcabf2cd59cf7ed77d51cb5d4b8aa1a0837099b37341d56b907e8ddeec5e34bff8bbefffa2c864d1ef7de812c4e874d2b420505ae8e4416dd9a33cd3713be4adbe572af303bc6904b8a281f9df07fd21b063fc85f7540f2b44976f593cbd622314605f4e2e391b20c0ea22f3895d13e668c979815c9bdfda25095fb79ef6c023139f1d0f3acf0ab15ef22a6373a11b906fb98209de8a83f85444cb96081129e2c7c8421791beecabb01241aa70f09346209d23bfe18d60338ba3abb4792d594197c9abc95d1d962a49bbc34c25e156e252f6510f8441a614bea22f2f7116575536cd4d2b8f12df6d82d2d65026003aa1cd2996ddd6c1d93fd308591391dd88d7d70cca7d5f9fea6f9500b11312df71132d053f8da3910d17eb455a1dd11462bd65159ecc86cfb61b3f130c2f1be650e86328833e99d8d121a1a5632a250b3ab29980d598255adab11607e9da1b5156f399c285e3d748d84aa460fc4b3c71d8120e0d056fa0707e1d876213ddcefae8b856a0a8384b037dfc6ed753ac31508f19bd2321a9da8adb4b9fbbd3e28be1d495e338871e63b948a663665d9671a349abbc5aa7d895e794785302d5260eede14246baa774210d9d0fea4bf36853a865a781b35c8c482b46675e2ef1161d78856120df62ab968a5e8726f7d58f7f4d7824daff425475d82858438b9a4d06ede3f489262c13637eab07914138236b60f73ebef728d93aa59e789a6c21e4868886308f79701a80cce6098a7d050424f478e9151a87e9de5c53b3c2bc81b15b601a40ac452486f1149a6af9d4f70d4dbb9cc233e8cc2703e8bf13aa35a4fca77bcb9cec9e6f1195475ac4af9952e31a4319c1ad417666c224efa7eb95a7f957cffa0541af71a66bdb3759cf72a3bca8bbb5036ebf135ee0f0ad0fcc1170aefc5c9881466f69582a0bd565161355fc447fc0121359014e08b1533f1c896eedef7e15e3c770fe2c2f4068bdae19fc24d286ec5fd0f0925586cb2b481031bded5c5e1ff5fcc581d17df686aca3266e519cbb70c9189e4145ff103d5facc16bf1d9f7660967180fe8795f400729b8422768e0af1b32dfbdbe6414a5b94b593247c2cb2c9b10ec80be7d55726ded5c724c7c8ce4f2a76ca5021331ba0286ae6b94c3fb0b137d2b826ad083f4c2d1e1ae70fcbb8fe81d638464af4d326d60b621db96b26194ab2fb1fcb2913b0634ac96c2e9a62baaaf0816cc903f1a5e96c6db24c9217efa7494bc43e85cc8016ac2cb7e31b7b63fbebcd70b47ea05a756893dd823673bd077b20bd5bf23ba92ebfc0556679994403d835e852da90fbaf894e326028fe892fc04fe5b32d965877af6b24e4f3f924e54a3d3cbf4518c36662dca2cb4afaefbe8600cb747e49e0e2212149a02961e3a9cecd985188fcb7217e7fe08172a65d854b5aa33a7365a6c28cb1ad4a2e05de66c8c404f1a39f3ee5d858d42c0d5f9276b6ce0c28190d7db0b3c8606f1c420e17d74e241c44756c9aff1789827b3a00b20d0d87f7f2ac159df12d8389c7eed139660934d7be7bb284f7529fb1e8bb000685742a6a1bff1bf41a0cbc05736e8fcec2428f54bcc6570c75cc89fc2894d87e0f1c5e64750f197b02fca53580902f57818e9e08988555ea17ff42bb449dd547e955ce96f2fe96eaa09708b4dde5098748432d8ea7491ad60e20930453b941a79c0f6ce9721cb6f34e915abc5e8be238e448d573d435ba3ba7f04efabd82896385e9747a56a5f2fd83fb874031ca98abe25cd3f5059a05b7242ef1147aad5dba834d3eefac1e0d04b36b8b2c6fca0bb35349ab66544cd487b47ca08d12da5a2a443129b16b4326f17b5d94d3787e2d4a3110f2bbb3aab5078e00cdc3ddcb1327d98763f419487ec2f2535</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
  <entry>
    <title>Self-introduction</title>
    <url>/posts/676dd596/</url>
    <content><![CDATA[<h1 id="Zhang-Tong-CV"><a href="#Zhang-Tong-CV" class="headerlink" title="Zhang-Tong-CV"></a>Zhang-Tong-CV</h1><span id="more"></span>

<table>
    <tr>
        <td width="80%">
            <table>
                <tr>                    
                    <td align="left"><b>Master</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>School of Mechanical & Automotive Engineering, South China University of Technology</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Mail: zt_scut@163.com</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Phone: +86-18603372600</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Address: 381 Wushan Road, Tianhe District, Guangzhou,Guangdong, China</b></td>
                </tr>                
            </table>
        </td>
        <td width="30%" height="100%">
            <img src="/images/image-20220306.jpg">
        </td>
    </tr>
</table>



<h2 id="Educational-Qualification"><a href="#Educational-Qualification" class="headerlink" title="Educational Qualification"></a>Educational Qualification</h2><ul>
<li><strong>Master</strong> in Vehicle Engineering(2023)<br>South China University of Technology,Guangzhou, China</li>
<li><strong>B.Eng</strong> in Vehicle Engineering(2020)<br>Hefei University of Technology, China</li>
</ul>
<h2 id="Project-amp-Internship-Experience"><a href="#Project-amp-Internship-Experience" class="headerlink" title="Project &amp; Internship Experience"></a>Project &amp; Internship Experience</h2><p><em>Software Testing Engineer Intern in Kaizeli Technology Co. ,Ltd. (2020.07-2020.09)</em></p>
<ul>
<li>Write test scripts according to requirements documents, using Linux command and shell language</li>
<li>Responsible for the on-board OTA and IVI module testing projects, complete the test unit and upload test reports</li>
<li>Participated in the project of automated test platform, and improve the design of the testing interface, carry out a detailed needs analysis and use case design. </li>
</ul>
<p><em>Software Testing Engineer Intern in GAC R&amp;D Center. (2020.10—2020.12)</em></p>
<ul>
<li>Understand the principle of CAN communication, and using CAN communication tools,  such as Vehicle-Spy、KVaser, to sample the test signal </li>
<li>Carry out on-board system function module test, and complete data detection, calibration, log acquisition and analysis</li>
<li>Participate in on-board system test of multiple models, and update test cases according to requirements and feedback</li>
</ul>
<p><em>Software Design Engineer Intern in Shenzhen Lan-You Technology Co. ,Ltd. (2021.08-2021.11)</em></p>
<ul>
<li>Assisted in the implementation of simulation software of automatic vehicle, design test scenarios in ACC、AEB、LKA , complete design documents and scenario scripts</li>
<li>Responsible for the parking area map design and visualization, compile the program scripts for parsing XML files, and using QT software for visual display</li>
<li>Complete the preliminary project and generate 858 test scenario scripts totally,  and  using the  parking area visualization program to help verify the reliability of map file data</li>
</ul>
<h2 id="Research-Experience"><a href="#Research-Experience" class="headerlink" title="Research Experience"></a>Research Experience</h2><ul>
<li>Participate in the Innovation training program for college students in Anhui Province 2018, Intelligent lane changing auxiliary system Based on longitudinal and lateral dynamic control,  responsible for building vehicle dynamics model and using CarSim software for simulation</li>
<li>Participate in the Innovation training program for college students in Anhui Province 2019, Design and motion control of multi-mode reconfigurable for self-driving vehicle, responsible for help generate physical model using Catia drawing software, and Assisted in the implementation of the printed circuit board design</li>
<li>Research on driver fatigue detection method based on facial features, the graduation project, used CNN for facial landmarks detection and a pre-trained network for training on the data set, using SVM algorithm to generate model of facial fatigue feature classification </li>
</ul>
<h2 id="Campus-Experience"><a href="#Campus-Experience" class="headerlink" title="Campus Experience"></a>Campus Experience</h2><p><em>Commissary in charge of studies, School of Automotive &amp; Transportation Engineering, Hefei University of Technology (2016-2020)</em></p>
<ul>
<li>Responsible for the study management in class and communicate with teachers to arrange experimental courses</li>
<li>Planning and hosting the meeting for exchange of learning experience, responsible for inviting outstanding graduates to give speeches and more than 300 college students participate in the Event</li>
</ul>
<h2 id="Social-Practice-Experience"><a href="#Social-Practice-Experience" class="headerlink" title="Social Practice Experience"></a>Social Practice Experience</h2><p><em>Support Teacher of Feng huang primary school, Chaohu, Anhui Province (2017)</em></p>
<ul>
<li>As a math teacher and physical education teacher for primary school students, spent a pleasant and meaningful summer with them</li>
<li>Planted the seeds of learning and encouraged them to explore the world</li>
<li>Increased responsibilities and accountability through communication with primary school students</li>
</ul>
<h2 id="Awards"><a href="#Awards" class="headerlink" title="Awards"></a>Awards</h2><ul>
<li>Second-class scholarship(2x) and Third-class scholarship in Hefei University of Technology </li>
<li>Outstanding student cadres in HFUT</li>
<li>Excellent graduation project for Bachelor’s degree</li>
<li>No.7 of men’s team competition in the National Student Shuttlecock Championship College group </li>
</ul>
<h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul>
<li>CET-6</li>
<li>Familiar with C/C++, Python</li>
<li>Familiar with the Linux operating system</li>
</ul>
<h2 id="Self-evaluation"><a href="#Self-evaluation" class="headerlink" title="Self-evaluation"></a>Self-evaluation</h2><p>I am an optimistic and positive person and interested in the emergence of new things and new ideas. I can set goals with others and accomplish them through the power of teamwork and communication. My main research interest is computer vision and deep learning,  and I have an understanding of machine learning, sensor fusion and computer science.</p>
]]></content>
  </entry>
  <entry>
    <title>刷题小知识：数组/链表</title>
    <url>/posts/a0fdfee0/</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
  </entry>
</search>
