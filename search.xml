<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>I/O复用</title>
      <link href="/posts/bbbdabf8/"/>
      <url>/posts/bbbdabf8/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>I/O复用使得程序能同时监听多个文件描述符，使用I/O复用的情况：</p><ul><li>客户端程序要同时处理多个socket。</li><li>客户端程序要同时处理用户输入和网络连接。</li><li>TCP服务器要同时处理监听socket和连接socket。这是I/O复用使用最多的场合。</li><li>服务器要同时处理TCP请求和UDP请求。</li><li>服务器要同时监听多个端口，或者处理多种服务。</li></ul><p>I/O复用虽然能同时监听多个文件描述符，但它本身是阻塞的。并且当多个文件描述符同时就绪时，如果不采取额外的措施，程序就只能按顺序依次处理其中的每一个文件描述符，这使得服务器程序看起来像是串行工作的。如果要实现并发，只能使用多进程或多线程等编程手段。</p><p>Linux下实现I/O复用的系统调用主要有<strong>select、poll和epoll</strong></p><h2 id="select系统调用"><a href="#select系统调用" class="headerlink" title="select系统调用"></a>select系统调用</h2><p>select系统调用：在一段指定时间内，监听用户感兴趣的文件描述符上的可读、可写和异常等事件。</p><h3 id="select-API"><a href="#select-API" class="headerlink" title="select API"></a>select API</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/select.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">select</span><span class="params">(<span class="keyword">int</span> nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, struct timeval* timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">nfds：指定被监听的文件描述符总数。通常被设置为select监听的所有文件描述符中的最大值加1。</span></span><br><span class="line"><span class="comment">readfds：指向可读事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">writefds：指向可写事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">exceptfds：指向异常事件对应的文件描述符集合</span></span><br><span class="line"><span class="comment">timeout：设置select函数的超时时间，指针类型可以内核将修改它以告诉应用程序select等待了多久。</span></span><br><span class="line"><span class="comment">如果给timeout变量的tv_sec成员和tv_usec成员都传递0，则select将立即返回。</span></span><br><span class="line"><span class="comment">如果给timeout传递NULL，则select将一直阻塞，直到某个文件描述符就绪。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回就绪（可读、可写和异常）文件描述符的总数；</span></span><br><span class="line"><span class="comment">如果在超时时间内没有任何文件描述符就绪，select将返回0；</span></span><br><span class="line"><span class="comment">select失败时返回-1并设置errno；</span></span><br><span class="line"><span class="comment">如果在select等待期间，程序接收到信号，则select立即返回-1，并设置errno为EINTR。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// timeval结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> &#123;</span></span><br><span class="line">    <span class="keyword">long</span> tv_sec;<span class="comment">/*秒数*/</span> </span><br><span class="line">    <span class="keyword">long</span> tv_usec;<span class="comment">/*微秒数*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="文件描述符就绪条件"><a href="#文件描述符就绪条件" class="headerlink" title="文件描述符就绪条件"></a>文件描述符就绪条件</h3><p>socket可读的情况：</p><ul><li>socket内核接收缓存区中的字节数大于或等于其低水位标记SO_RCVLOWAT。此时我们可以无阻塞地读该socket，并且读操作返回的字节数大于0。</li><li>socket通信的对方关闭连接。此时对该socket的读操作将返回0。</li><li>监听socket上有新的连接请求。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。 </li></ul><p>socket可写的情况：</p><ul><li>socket内核发送缓存区中的可用字节数大于或等于其低水位标记SO_SNDLOWAT。此时我们可以无阻塞地写该socket，并且写操作返回的字节数大于0。</li><li>socket的写操作被关闭。对写操作被关闭的socket执行写操作将触发一个SIGPIPE信号。</li><li>socket使用非阻塞connect连接成功或者失败（超时）之后。</li><li>socket上有未处理的错误。此时我们可以使用getsockopt来读取和清除该错误。</li></ul><p>socket异常情况：</p><ul><li>socket上接收到带外数据。</li></ul><h3 id="处理带外数据"><a href="#处理带外数据" class="headerlink" title="处理带外数据"></a>处理带外数据</h3><p>socket上接收到普通数据和带外数据都将使select返回，但socket处于不同的就绪状态：前者处于可读状态，后者处于异常状态。</p><p>同时接收普通数据和带外数据:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9-1use_select.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;ip is %s and port is %d\n&quot;</span>, ip, port );</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">        <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">        address.sin_family = AF_INET;</span><br><span class="line">        <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">        address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">        <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line"><span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line"><span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line"><span class="built_in">close</span>( listenfd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> remote_addr[INET_ADDRSTRLEN];</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, <span class="built_in">inet_ntop</span>( AF_INET, &amp;client_address.sin_addr, remote_addr, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client_address.sin_port ) );</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1024</span>];</span><br><span class="line">        fd_set read_fds;</span><br><span class="line">        fd_set exception_fds;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">FD_ZERO</span>( &amp;read_fds );</span><br><span class="line">        <span class="built_in">FD_ZERO</span>( &amp;exception_fds );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> nReuseAddr = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">setsockopt</span>( connfd, SOL_SOCKET, SO_OOBINLINE, &amp;nReuseAddr, <span class="built_in"><span class="keyword">sizeof</span></span>( nReuseAddr ) );</span><br><span class="line"><span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">&#123;</span><br><span class="line">        <span class="comment">// 每次调用select前都要重新在read_fds和exception_fds中设置文件描述符connfd，</span></span><br><span class="line">        <span class="comment">// 因为事件发生之后，文件描述符集合将被内核修改</span></span><br><span class="line"><span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, <span class="built_in"><span class="keyword">sizeof</span></span>( buf ) );</span><br><span class="line"><span class="built_in">FD_SET</span>( connfd, &amp;read_fds );</span><br><span class="line"><span class="built_in">FD_SET</span>( connfd, &amp;exception_fds );</span><br><span class="line"></span><br><span class="line">        ret = <span class="built_in">select</span>( connfd + <span class="number">1</span>, &amp;read_fds, <span class="literal">NULL</span>, &amp;exception_fds, <span class="literal">NULL</span> );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;select one\n&quot;</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;selection failure\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">FD_ISSET</span>( connfd, &amp;read_fds ) )</span><br><span class="line">&#123; <span class="comment">// 对于可读事件，采用普通的recv函数读取数据</span></span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>( buf )<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of normal data: %s\n&quot;</span>, ret, buf );</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>( <span class="built_in">FD_ISSET</span>( connfd, &amp;exception_fds ) )</span><br><span class="line">        &#123; <span class="comment">// 对于异常事件，采用带MSG_OOB标志的recv函数读取带外数据</span></span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buf, <span class="built_in"><span class="keyword">sizeof</span></span>( buf )<span class="number">-1</span>, MSG_OOB );</span><br><span class="line"><span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of oob data: %s\n&quot;</span>, ret, buf );</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>( connfd );</span><br><span class="line"><span class="built_in">close</span>( listenfd );</span><br><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="poll系统调用"><a href="#poll系统调用" class="headerlink" title="poll系统调用"></a>poll系统调用</h2><p>poll系统调用：在指定时间内轮询一定数量的文件描述符，以测试其中是否有就绪者。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜poll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">poll</span><span class="params">(struct pollfd* fds, <span class="keyword">nfds_t</span> nfds, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fds：pollfd结构类型的数组，它指定所有感兴趣的文件描述符上发生的可读、可写和异常等事件。</span></span><br><span class="line"><span class="comment">nfds：指定被监听事件集合fds的大小，无符号长整数unsigned long int</span></span><br><span class="line"><span class="comment">timeout：指定poll的超时值，单位是毫秒；</span></span><br><span class="line"><span class="comment">timeout为-1，poll调用将永远阻塞，直到某个事件发生；</span></span><br><span class="line"><span class="comment">timeout为0，poll调用将立即返回。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回值的含义与select相同。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// pollfd结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pollfd</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> fd;<span class="comment">/*文件描述符*/</span> </span><br><span class="line">    <span class="keyword">short</span> events;<span class="comment">/*注册的事件，告诉poll监听fd上的哪些事件，一系列事件的按位或*/</span></span><br><span class="line">    <span class="keyword">short</span> revents;<span class="comment">/*实际发生的事件，由内核填充*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>poll支持的事件类型：</p><img src="/posts/bbbdabf8/image-20220728115950782.png" alt="image-20220728115950782" style="zoom: 80%;"><h2 id="epoll系列系统调用"><a href="#epoll系列系统调用" class="headerlink" title="epoll系列系统调用"></a>epoll系列系统调用</h2><h3 id="内核事件表"><a href="#内核事件表" class="headerlink" title="内核事件表"></a>内核事件表</h3><p>epoll是Linux特有的I/O复用函数。它在实现和使用上与select、poll有很大差异。</p><ul><li>epoll使用一组函数来完成任务，而不是单个函数。</li><li>epoll把用户关心的文件描述符上的事件放在内核里的一个事件表中，从而无须像select和poll那样每次调用都要重复传入文件描述符集或事件集。</li><li>需要使用一个额外的文件描述符，来唯一标识内核中的这个事件表。</li></ul><p>创建epoll一个额外的文件描述符：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_create</span><span class="params">(<span class="keyword">int</span> size)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">size：现在并不起作用，只是给内核一个提示，告诉它事件表需要多大。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回一个文件描述符，将用作其他所有epoll系统调用的第一个参数，以指定要访问的内核事件表。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>操作epoll的内核事件表：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_ctl</span><span class="params">(<span class="keyword">int</span> epfd, <span class="keyword">int</span> op, <span class="keyword">int</span> fd, struct epoll_event* event)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">epfd：epoll_create返回的文件描述符，指定要访问的内核事件表</span></span><br><span class="line"><span class="comment">fd：要操作的文件描述符</span></span><br><span class="line"><span class="comment">op：指定操作类型。</span></span><br><span class="line"><span class="comment">EPOLL_CTL_ADD，往事件表中注册fd上的事件。</span></span><br><span class="line"><span class="comment">EPOLL_CTL_MOD，修改fd上的注册事件。</span></span><br><span class="line"><span class="comment">EPOLL_CTL_DEL，删除fd上的注册事件。</span></span><br><span class="line"><span class="comment">event：指定事件，epoll_event结构指针类型</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// epoll_event的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">epoll_event</span> &#123;</span></span><br><span class="line">    <span class="keyword">__uint32_t</span> events;<span class="comment">/*epoll事件*/</span> </span><br><span class="line">    <span class="keyword">epoll_data_t</span> data;<span class="comment">/*用户数据*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="epoll-wait函数"><a href="#epoll-wait函数" class="headerlink" title="epoll_wait函数"></a>epoll_wait函数</h3><p>epoll系列系统调用的主要接口是epoll_wait函数。它在一段超时时间内等待一组文件描述符上的事件，其原型如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/epoll.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">epoll_wait</span><span class="params">(<span class="keyword">int</span> epfd, struct epoll_event* events, <span class="keyword">int</span> maxevents, <span class="keyword">int</span> timeout)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数:</span></span><br><span class="line"><span class="comment">epfd：epoll_create返回的文件描述符，指定要访问的内核事件表</span></span><br><span class="line"><span class="comment">events：指定事件，epoll_event结构指针类型</span></span><br><span class="line"><span class="comment">maxevents：指定最多监听多少个事件，它必须大于0。</span></span><br><span class="line"><span class="comment">timeout：指定超时值，单位是毫秒；</span></span><br><span class="line"><span class="comment">timeout为-1，调用将永远阻塞，直到某个事件发生；</span></span><br><span class="line"><span class="comment">timeout为0，调用将立即返回。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回就绪的文件描述符的个数，失败时返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>epoll_wait函数如果检测到事件，就将所有就绪的事件从内核事件表（由epfd参数指定）中复制到它的第二个参数events指向的数组中。这个数组只用于<strong>输出epoll_wait检测到的就绪事件</strong>，而不像select和poll的数组参数那样既用于传入用户注册的事件，又用于输出内核检测到的就绪事件。这就极大地提高了应用程序索引就绪文件描述符的效率。</p><p>poll和epoll在使用上的差别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*如何索引poll返回的就绪文件描述符*/</span> </span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">poll</span>(fds, MAX_EVENT_NUMBER, <span class="number">-1</span>); </span><br><span class="line"><span class="comment">/*必须遍历所有已注册文件描述符并找到其中的就绪者（当然，可以利用ret来稍做优化）*/</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i ＜ MAX_EVENT_NUMBER; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span>(fds[i].revents＆POLLIN)<span class="comment">/*判断第i个文件描述符是否就绪*/</span> </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd=fds[i].fd; </span><br><span class="line">        <span class="comment">/*处理sockfd*/</span> </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*如何索引epoll返回的就绪文件描述符*/</span> </span><br><span class="line"><span class="keyword">int</span> ret = <span class="built_in">epoll_wait</span>(epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span>);</span><br><span class="line"><span class="comment">/*仅遍历就绪的ret个文件描述符*/</span> </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i ＜ ret; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = events[i].data.fd; </span><br><span class="line">    <span class="comment">/*sockfd肯定就绪，直接处理*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="LT和ET模式"><a href="#LT和ET模式" class="headerlink" title="LT和ET模式"></a>LT和ET模式</h3><p>epoll对文件描述符的操作有两种模式：</p><ul><li>LT（Level Trigger，电平触发）模式。epoll的默认的工作模式，epoll相当于一个效率较高的poll。</li><li>ET（Edge Trigger，边沿触发）模式。epoll的高效工作模式，当epoll内核事件表中注册一个文件描述符上的EPOLLET事件时，epoll将以ET模式来操作该文件描述符。</li></ul><p>对于采用LT工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序可以不立即处理该事件。这样，当应用程序下一次调用epoll_wait时，epoll_wait还会再次向应用程序通告此事件，直到该事件被处理。</p><p>对于采用ET工作模式的文件描述符，当epoll_wait检测到其上有事件发生并将此事件通知应用程序后，应用程序必须立即处理该事件，因为后续的epoll_wait调用将不再向应用程序通知这一事件。</p><p><strong>ET模式在很大程度上降低了同一个epoll事件被重复触发的次数，因此效率要比LT模式高。</strong></p><p>LT和ET在工作方式上的差异：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9-3mtlt.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符设置成非阻塞的</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将文件描述符fd上的EPOLLIN注册到epollfd指示的epoll内核事件表中</span></span><br><span class="line"><span class="comment">// 参数 enable_et指定是否对fd启用ET模式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> enable_et )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN;</span><br><span class="line">    <span class="keyword">if</span>( enable_et )</span><br><span class="line">    &#123;</span><br><span class="line">        event.events |= EPOLLET;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// LT模式的工作流程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">lt</span><span class="params">( epoll_event* events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> ( sockfd == listenfd )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">            <span class="built_in">addfd</span>( epollfd, connfd, <span class="literal">false</span> ); <span class="comment">// 调用addfd函数，对connfd禁用ET模式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;<span class="comment">// 只要socket读缓存中还有未读出的数据，这段代码就被触发</span></span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;event trigger once\n&quot;</span> );</span><br><span class="line">            <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">            <span class="keyword">int</span> ret = <span class="built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">            <span class="keyword">if</span>( ret &lt;= <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">close</span>( sockfd );</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;something else happened \n&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ET模式的工作流程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">et</span><span class="params">( epoll_event* events, <span class="keyword">int</span> number, <span class="keyword">int</span> epollfd, <span class="keyword">int</span> listenfd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; number; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">        <span class="keyword">if</span> ( sockfd == listenfd )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">            <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line">            <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">            <span class="built_in">addfd</span>( epollfd, connfd, <span class="literal">true</span> ); <span class="comment">// 对connfd开启ET模式</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">        &#123;<span class="comment">// 这段代码不会被重复触发，所以循环读取数据，以确保把socket读缓存中的所有数据读出</span></span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;event trigger once\n&quot;</span> );</span><br><span class="line">            <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">                <span class="keyword">int</span> ret = <span class="built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">                <span class="keyword">if</span>( ret &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;<span class="comment">// 对于非阻塞IO，下面的条件成立表示数据已经全部读取完毕。</span></span><br><span class="line">                    <span class="comment">// 此后，epoll就能再次触发sockfd上的EPOLLIN事件，以驱动下一次读操作</span></span><br><span class="line">                    <span class="keyword">if</span>( ( errno == EAGAIN ) || ( errno == EWOULDBLOCK ) )</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">printf</span>( <span class="string">&quot;read later\n&quot;</span> );</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="built_in">close</span>( sockfd );</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">close</span>( sockfd );</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>( <span class="string">&quot;get %d bytes of content: %s\n&quot;</span>, ret, buf );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;something else happened \n&quot;</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="keyword">int</span> epollfd = <span class="built_in">epoll_create</span>( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( epollfd != <span class="number">-1</span> );</span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, listenfd, <span class="literal">true</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="built_in">lt</span>( events, ret, epollfd, listenfd ); <span class="comment">// 使用LT模式</span></span><br><span class="line">        <span class="comment">//et( events, ret, epollfd, listenfd ); // 使用ET模式</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( listenfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器程序运行该代码，然后telnet到这个服务器程序上并一次传输超过10字节（BUFFER_SIZE的大小）的数据，会发现ET模式下事件被触发的次数要比LT模式下少很多。</p><p>注意：每个使用ET模式的文件描述符都应该是非阻塞的。如果文件描述符是阻塞的，那么读或写操作将会因为没有后续的事件而一直处于阻塞状态（饥渴状态）。</p><h3 id="EPOLLONESHOT事件"><a href="#EPOLLONESHOT事件" class="headerlink" title="EPOLLONESHOT事件"></a>EPOLLONESHOT事件</h3><p>并发程序中，一个线程（或进程），在读取完某个socket上的数据数据后开始处理这些数据，而在数据的处理过程中该socket上又有新数据可读（EPOLLIN再次被触发），此时另外一个线程被唤醒来读取这些新的数据。于是就出现了两个线程同时操作一个socket的局面。</p><p>EPOLLONESHOT事件：使得一个socket连接在任一时刻都只被一个线程处理。</p><p>对于注册了EPOLLONESHOT事件的文件描述符，操作系统最多触发其上注册的一个可读、可写或者异常事件，且只触发一次，除非使用epoll_ctl函数重置该文件描述符上注册的EPOLLONESHOT事件。当一个线程在处理某个socket时，其他线程是不可能有机会操作该socket的。</p><p>注册了EPOLLONESHOT事件的socket一旦被某个线程处理完毕，该线程就应该立即重置这个socket上的 EPOLLONESHOT事件，以确保这个socket下一次可读时，其EPOLLIN事件能被触发，进而让其他工作线程有机会继续处理这个socket。</p><p>EPOLLONESHOT事件的使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 9-4oneshot.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/epoll.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX_EVENT_NUMBER 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 存放内核事件表fd和socket连接fd</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fds</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> epollfd;</span><br><span class="line">   <span class="keyword">int</span> sockfd;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将socket连接fd设置为非阻塞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">( <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>( fd, F_GETFL );</span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK;</span><br><span class="line">    <span class="built_in">fcntl</span>( fd, F_SETFL, new_option );</span><br><span class="line">    <span class="keyword">return</span> old_option;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将fd上的EPOLLIN和EPOLLET事件注册到epollfd指示的epoll内核事件表中 </span></span><br><span class="line"><span class="comment">// 参数oneshot指定是否注册fd上的EPOLLONESHOT事件</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">addfd</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd, <span class="keyword">bool</span> oneshot )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET;</span><br><span class="line">    <span class="keyword">if</span>( oneshot )</span><br><span class="line">    &#123;</span><br><span class="line">        event.events |= EPOLLONESHOT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_ADD, fd, &amp;event );</span><br><span class="line">    <span class="built_in">setnonblocking</span>( fd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置fd上的事件。这样操作之后，尽管fd上的EPOLLONESHOT事件被注册，</span></span><br><span class="line"><span class="comment">// 但是操作系统仍然会触发fd上的EPOLLIN事件，且只触发一次</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reset_oneshot</span><span class="params">( <span class="keyword">int</span> epollfd, <span class="keyword">int</span> fd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    epoll_event event;</span><br><span class="line">    event.data.fd = fd;</span><br><span class="line">    event.events = EPOLLIN | EPOLLET | EPOLLONESHOT;</span><br><span class="line">    <span class="built_in">epoll_ctl</span>( epollfd, EPOLL_CTL_MOD, fd, &amp;event );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 工作线程</span></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">worker</span><span class="params">( <span class="keyword">void</span>* arg )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = ( (fds*)arg )-&gt;sockfd;</span><br><span class="line">    <span class="keyword">int</span> epollfd = ( (fds*)arg )-&gt;epollfd;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;start new thread to receive data on fd: %d\n&quot;</span>, sockfd );</span><br><span class="line">    <span class="keyword">char</span> buf[ BUFFER_SIZE ];</span><br><span class="line">    <span class="built_in">memset</span>( buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 循环读取sockfd上的数据，直到遇到EAGAIN错误</span></span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">recv</span>( sockfd, buf, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="keyword">if</span>( ret == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>( sockfd );</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;foreiner closed the connection\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( errno == EAGAIN )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">reset_oneshot</span>( epollfd, sockfd );</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;read later\n&quot;</span> );</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;get content: %s\n&quot;</span>, buf );</span><br><span class="line">            <span class="built_in">sleep</span>( <span class="number">5</span> ); <span class="comment">// 休眠5s。模拟数据处理过程</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;end thread receiving data on fd: %d\n&quot;</span>, sockfd );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> listenfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( listenfd &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">bind</span>( listenfd, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( listenfd, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    epoll_event events[ MAX_EVENT_NUMBER ];</span><br><span class="line">    <span class="keyword">int</span> epollfd = <span class="built_in">epoll_create</span>( <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( epollfd != <span class="number">-1</span> );</span><br><span class="line">    <span class="comment">// 注意，监听socket listenfd上是不能注册EPOLLONESHOT事件的，否则应用程序只能处理一个客户连接</span></span><br><span class="line">    <span class="comment">// 因为后续的客户连接请求将不再触发listenfd上的EPOLLIN事件</span></span><br><span class="line">    <span class="built_in">addfd</span>( epollfd, listenfd, <span class="literal">false</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">epoll_wait</span>( epollfd, events, MAX_EVENT_NUMBER, <span class="number">-1</span> );</span><br><span class="line">        <span class="keyword">if</span> ( ret &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>( <span class="string">&quot;epoll failure\n&quot;</span> );</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">for</span> ( <span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> sockfd = events[i].data.fd;</span><br><span class="line">            <span class="keyword">if</span> ( sockfd == listenfd )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client_address</span>;</span></span><br><span class="line">                <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client_address );</span><br><span class="line">                <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( listenfd, ( struct sockaddr* )&amp;client_address, &amp;client_addrlength );</span><br><span class="line">                <span class="comment">// 对每个非监听文件描述符都注册POLLONESHOT事件</span></span><br><span class="line">                <span class="built_in">addfd</span>( epollfd, connfd, <span class="literal">true</span> ); </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ( events[i].events &amp; EPOLLIN )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">pthread_t</span> thread;</span><br><span class="line">                fds fds_for_new_worker;</span><br><span class="line">                fds_for_new_worker.epollfd = epollfd;</span><br><span class="line">                fds_for_new_worker.sockfd = sockfd;</span><br><span class="line">                <span class="comment">// 新启动一个工作线程为sockfd服务</span></span><br><span class="line">                <span class="built_in">pthread_create</span>( &amp;thread, <span class="literal">NULL</span>, worker, ( <span class="keyword">void</span>* )&amp;fds_for_new_worker );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>( <span class="string">&quot;something else happened \n&quot;</span> );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( listenfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>工作线程函数worker中，如果一个工作线程处理完某个socket上的一次请求（用休眠5s来模拟这个过程）之后，又接收到该socket上新的客户请求，则该线程将继续为这个socket服务。并且因为该 socket上注册了EPOLLONESHOT事件，其他线程没有机会接触这个socket，如果工作线程等待5s后仍然没收到该socket上的下一批客户数据，则它将放弃为该socket服务。同时，它调用reset_oneshot函数来重置该socket上的注册事件，这将使epoll有机会再次检测到该socket上的EPOLLIN事件，进而使得其他线程有机会为该socket服务。</p><p>尽管一个socket在不同时间可能被不同的线程处理，但同一时刻肯定只有一个线程在为它服务。这就保证了连接的完整性，从而避免了很多可能的竞态条件。</p><h2 id="三组I-O复用函数的比较"><a href="#三组I-O复用函数的比较" class="headerlink" title="三组I/O复用函数的比较"></a>三组I/O复用函数的比较</h2><p>select、poll、epoll三组I/O复用系统调用。</p><p>这三组系统调用都能同时监听多个文件描述符</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高性能服务器程序框架</title>
      <link href="/posts/81ce2909/"/>
      <url>/posts/81ce2909/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>按照服务器程序的一般原理，将服务器解构为如下三个主要模块：</p><ul><li>I/O处理单元。四种I/O模型和两种高效事件处理模式。</li><li>逻辑单元。两种高效并发模式，以及高效的逻辑处理方式——有限状态机。</li><li>存储单元。服务器程序的可选模块。</li></ul><h2 id="服务器模型"><a href="#服务器模型" class="headerlink" title="服务器模型"></a>服务器模型</h2><h3 id="C-S模型"><a href="#C-S模型" class="headerlink" title="C/S模型"></a>C/S模型</h3><p>C/S（客户端/服务器）模型：所有客户端都通过访问服务器来获取所需的资源。</p><img src="/posts/81ce2909/image-20220726231329183.png" alt="image-20220726231329183" style="zoom:50%;"><p>采用C/S模型的TCP服务器和TCP客户端的工作流程：</p><img src="/posts/81ce2909/image-20220726231424223.png" alt="image-20220726231424223" style="zoom:75%;"><p>服务器启动后，首先创建一个（或多个）监听socket，并调用bind函数将其绑定到服务器感兴趣的端口上，然后调用listen函数等待客户连接。<br>服务器稳定运行之后，客户端就可以调用connect函数向服务器发起连接了。由于客户连接请求是随机到达的异步事件，服务器需要使用某种I/O模型来监听这一事件。这里服务器使用的是I/O复用技术之一的select系统调用。<br>当监听到连接请求后，服务器就调用accept函数接受它，并分配一个逻辑单元为新的连接服务。逻辑单元可以是新创建的子进程、子线程或者其他。服务器给客户端分配的逻辑单元是由fork系统调用创建的子进 程。逻辑单元读取客户请求，处理该请求，然后将处理结果返回给客户端。<br>客户端接收到服务器反馈的结果之后，可以继续向服务器发送请求，也可以立即主动关闭连接。如果客户端主动关闭连接，则服务器执行被动关闭连接。至此，双方的通信结束。</p><p>注意：服务器在处理一个客户请求的同时还会继续监听其他客户请求，否则就变成了效率低下的串行服务器了（必须先处理完前一个客户的请求，才能继续处理下一个客户请求）。这里服务器同时监听多个客户请求是通过select系统调用实现的。</p><p>优点：非常适合资源相对集中的场合，实现简单。</p><p>缺点：服务器是通信的中心，当访问量过大时，可能所有客户都将得到很慢的响应。</p><h3 id="P2P模型"><a href="#P2P模型" class="headerlink" title="P2P模型"></a>P2P模型</h3><p>P2P（Peer to Peer，点对点）模型，摒弃了以服务器为中心的格局，让网络上所有主机重新回归对等的地位。两种P2P模型：</p><img src="/posts/81ce2909/image-20220726232111418.png" alt="image-20220726232111418" style="zoom:80%;"><p>优点：每台机器在消耗服务的同时也给别人提供服务，这样资源能够充分、自由地共享。</p><p>缺点：当用户之间传输的请求过多时，网络的负载将加重。</p><p>图a的P2P模型的问题，主机之间很难互相发现。实际使用中，需要加入一个专门的发现服务器，如图b，发现服务器通常还提供查找服务（甚至还可以提供内容服务），使每个客户都能尽快地找到自己需要的资源。</p><p>从编程角度来讲，P2P模型可以看作C/S模型的扩展：每台主机既是客户端，又是服务器。</p><h2 id="服务器编程框架"><a href="#服务器编程框架" class="headerlink" title="服务器编程框架"></a>服务器编程框架</h2><p>虽然服务器程序种类繁多，但其基本框架都一样，不同之处在于逻辑处理。</p><p>服务器基本框架如下：</p><img src="/posts/81ce2909/image-20220726232518637.png" alt="image-20220726232518637" style="zoom:80%;"><p>服务器基本模块的功能概述：</p><table><thead><tr><th align="center">模块</th><th align="center">单个服务器程序</th><th align="center">服务器机群</th></tr></thead><tbody><tr><td align="center">I/O处理单元</td><td align="center">处理客户连接，读写网络数据</td><td align="center">作为接入服务器，实现负载均衡</td></tr><tr><td align="center">逻辑单元</td><td align="center">业务进程或线程</td><td align="center">逻辑服务器</td></tr><tr><td align="center">网络存储单元</td><td align="center">本地数据库、文件或缓存</td><td align="center">数据库服务器</td></tr><tr><td align="center">请求队列</td><td align="center">各单元之间的通信方式</td><td align="center">各服务器之间的永久TCP连接</td></tr></tbody></table><p><strong>I/O处理单元：</strong>服务器管理客户连接的模块。主要工作：等待并接受新的客户连接，接收客户数据，将服务器响应数据返回给客户端。但是，数据的收发不一定只在I/O处理单元中执行，也可能在逻辑单元中执行。对于一个服务器机群来说，I/O处理单元是一个专门的接入服务器。它实现负载均衡，从所有逻辑服务器中选取负荷最小的一台来为新客户服务。</p><p><strong>逻辑单元：</strong>通常是一个进程或线程。主要工作：分析并处理客户数据，然后将结果传递给I/O处理单元，或者直接发送给客户端（取决于事件处理模式）。对于服务器机群来说，一个逻辑单元本身就是一台逻辑服务器。服务器通常拥有多个逻辑单元，以实现对多个客户任务的并行处理。</p><p><strong>网络存储单元：</strong>可以是数据库、缓存和文件，甚至是一台独立的服务器。但它不是必须的，比如ssh、telnet等登录服务就不需要这个单元。</p><p><strong>请求队列：</strong>是各单元之间的通信方式的抽象。I/O处理单元接收到客户请求时，需要以某种方式通知一个逻辑单元来处理该请求。多个逻辑单元同时访问一个存储单元时，也需要采用某种机制来协调处理竞态条件。对于服务器机群而言，请求队列是各台服务器之间预先建立的、静态的、永久的TCP连接。这种TCP连接能提高服务器之间交换数据的效率，因为它避免了动态建立TCP连接导致的额外的系统开销。</p><h2 id="I-O模型"><a href="#I-O模型" class="headerlink" title="I/O模型"></a>I/O模型</h2><p>阻塞与非阻塞应用于文件描述符包括socket。阻塞的文件描述符为阻塞I/O，非阻塞的文件描述符为非阻塞I/O。</p><p><strong>阻塞I/O：</strong>执行的系统调用可能因为无法立即完成而被操作系统挂起，直到等待的事件发生为止。例如，客户端通过connect向服务器发起连接时，connect将首先发送同步报文段给服务器，然后等待服务器返回确认报文段。如果服务器的确认报文段没有立即到达客户端，则connect调用将被挂起，直到客户端收到确认报文段并唤醒connect调用。<br>socket基础API中，可能被阻塞的系统调用包括：accept、send、recv和connect。</p><p><strong>非阻塞I/O：</strong>执行的系统调用总是立即返回，而不管事件是否已经发送。如果事件没有立即发生，这些系统调用就返回-1，和出错的情况一样。此时必须根据errno来区分这两种情况。<br>对accept、send和recv而言，事件未发生时errno通常被设置成EAGAIN（意为“再来一次”）或者EWOULDBLOCK（意为“期望阻塞”）；对connect而言，errno则被设置成EINPROGRESS（意为“在处理中”）。</p><p>使用条件：只有在事件已经发送的情况下操作非阻塞I/O（读、写等），才能提高程序的效率。非阻塞I/O通常要和其他I/O通知机制一起使用，比如I/O复用和SIGIO信号。</p><p><strong>I/O复用：</strong>最常使用的I/O通知机制。应用程序通过I/O复用函数向内核注册一组事件，内核通过I/O复用函数把其中就绪的事件通知给应用程序。Linux常用的I/O复用函数是select、poll和epoll_wait。<strong>I/O复用函数本身是阻塞的</strong>，它们能提高程序效率的原因在于它们<strong>具有同时监听多个I/O事件的能力</strong>。</p><p>SIGIO信号：可以用来报告I/O事件。可以为一个目标文件描述符指定宿主进程，那么被指定的宿主进程将捕获到SIGIO信号。这样，当目标文件描述符上有事件发生时，SIGIO信号的信号处理函数将被触发，也就可以在该信号处理函数中对目标文件描述符执行非阻塞I/O操作了。</p><p>从理论上说，阻塞I/O、I/O复用和信号驱动I/O都是<strong>同步I/O模型</strong>。这三种I/O模型中，I/O的读写操作，都是在I/O事件发生之后，由应用程序来完成的。</p><p>POSIX规范所定义的<strong>异步I/O模型</strong>，用户可以直接对I/O执行读写操作，这些操作告诉内核用户读写缓冲区的位置，以及I/O操作完成之后内核通知应用程序的方式。</p><p>同步I/O模型：要求用户代码自行执行I/O操作（将数据从内核缓冲区读入用户缓冲区，或将数据从用户缓冲区写入内核缓冲区）</p><p>异步I/O机制：由内核来执行I/O操作（数据在内核缓冲区和用户缓冲区之间的移动是由内核在“后台”完成的）。异步I/O的读写操作总是立即返回，而不论I/O是否是阻塞的，因为真正的读写操作已由内核接管。</p><p>同步I/O向应用程序通知的是I/O就绪事件，而异步I/O向应用程序通知的是I/O完成事件</p><p>几种I/O模型的差异对比：</p><table><thead><tr><th align="left">I/O模型</th><th>读写操作和阻塞阶段</th></tr></thead><tbody><tr><td align="left">阻塞I/O</td><td>程序阻塞于读写函数</td></tr><tr><td align="left">I/O复用</td><td>程序阻塞于I/O复用系统调用，但可以同时监听多个I/O事件。对I/O本身的读写操作是非阻塞的</td></tr><tr><td align="left">SIGIO信号</td><td>信号触发读写就绪事件，用户程序执行读写操作。程序没有阻塞阶段</td></tr><tr><td align="left">异步I/O</td><td>内核执行读写操作并触发读写完成事件。程序没有阻塞阶段</td></tr></tbody></table><h2 id="两种高效的事件处理模式"><a href="#两种高效的事件处理模式" class="headerlink" title="两种高效的事件处理模式"></a>两种高效的事件处理模式</h2><p>服务器程序需要处理的三类事件：I/O事件、信号、定时事件。</p><p>两种高效的事件处理模式：Reactor（同步I/O模型）和Proactor（异步I/O模型）。</p><h3 id="Reactor模式"><a href="#Reactor模式" class="headerlink" title="Reactor模式"></a>Reactor模式</h3><p>Reactor模式：要求主线程（I/O处理单元，下同）只负责监听文件描述符上是否有事件发生，有的话就立即将该事件通知工作线程（逻辑单元，下同）。除此之外，主线程不做任何其他实质性的工作。读写数据，接受新的连接，以及处理客户请求均在工作线程中完成。</p><p>使用同步I/O模型（以epoll_wait为例）实现的Reactor模式的工作流程：</p><img src="/posts/81ce2909/image-20220727120151684.png" alt="image-20220727120151684" style="zoom:80%;"><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程则将socket可读事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它从socket读取数据，并处理客户请求，然后往epoll内核事件表中注册该socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程将socket可写事件放入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它往socket上写入服务器处理客户请求的结果。</li></ol><h3 id="Proactor模式"><a href="#Proactor模式" class="headerlink" title="Proactor模式"></a>Proactor模式</h3><p>Proactor模式：将所有I/O操作都交给主线程和内核来处理，工作线程仅仅负责业务逻辑。</p><p>Proactor模式的工作流程：</p><img src="/posts/81ce2909/image-20220727150928621.png" alt="image-20220727150928621" style="zoom:80%;"><ol><li>主线程调用aio_read函数向内核注册socket上的读完成事件，并告诉内核用户读缓冲区的位置，以及读操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当socket上的数据被读入用户缓冲区后，内核将向应用程序发送一个信号，以通知应用程序数据已经可用。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来处理客户请求。工作线程处理完客户请求之后，调用aio_write函数向内核注册socket上的写完成事件，并告诉内核用户写缓冲区的位置，以及写操作完成时如何通知应用程序。</li><li>主线程继续处理其他逻辑。</li><li>当用户缓冲区的数据被写入socket之后，内核将向应用程序发送一个信号，以通知应用程序数据已经发送完毕。</li><li>应用程序预先定义好的信号处理函数选择一个工作线程来做善后处理，比如决定是否关闭socket。 </li></ol><p>连接socket上的读写事件是通过aio_read/aio_write向内核注册的，因此内核将通过信号来向应用程序报告连接socket上的读写事件。主线程中的epoll_wait调用，仅能用来检测监听socket上的连接请求事件，而不能用来检测连接socket上的读写事件。</p><h3 id="模拟Proactor模式"><a href="#模拟Proactor模式" class="headerlink" title="模拟Proactor模式"></a>模拟Proactor模式</h3><p>使用同步I/O方式模拟出Proactor模式的一种方法：主线程执行数据读写操作，读写完成之后，主线程向工作线程通知这一“完成事件”。那么从工作线程的角度来看，它们就直接获得了数据读写的结果，接下来要做的只是对读写的结果进行逻辑处理。</p><p>用同步I/O模拟出的Proactor模式工作流程：</p><img src="/posts/81ce2909/image-20220727152705121.png" alt="image-20220727152705121" style="zoom: 67%;"><ol><li>主线程往epoll内核事件表中注册socket上的读就绪事件。</li><li>主线程调用epoll_wait等待socket上有数据可读。</li><li>当socket上有数据可读时，epoll_wait通知主线程。主线程从socket循环读取数据，直到没有更多数据可读，然后将读取到的数据封装成一个请求对象并插入请求队列。</li><li>睡眠在请求队列上的某个工作线程被唤醒，它获得请求对象并处理客户请求，然后往epoll内核事件表中注册socket上的写就绪事件。</li><li>主线程调用epoll_wait等待socket可写。</li><li>当socket可写时，epoll_wait通知主线程。主线程往socket上写入服务器处理客户请求的结果。</li></ol><h2 id="两种高效的并发模式"><a href="#两种高效的并发模式" class="headerlink" title="两种高效的并发模式"></a>两种高效的并发模式</h2><p>对于I/O密集型的程序，如经常读写文件、访问数据库等，由于I/O操作的速度远没有CPU的计算速度快，让程序阻塞于I/O将浪费大量的CPU时间，并发编程让程序“同时”执行多个任务。</p><p>如果程序有多个执行线程，则当前被I/O操作所阻塞的执行线程可主动放弃CPU（或由操作系统来调度），并将执行权转移到其他线程。这样一来，CPU就可以用来做更加有意义的事情（除非所有线程都同时被I/O操作所阻塞），而不是等待I/O操作完成，因此CPU的利用率显著提升。</p><p>并发编程主要有多进程和多线程两种方式。</p><p>并发模式：I/O处理单元和多个逻辑单元之间协调完成任务的方法。</p><p>服务器主要有两种并发编程模式：</p><ul><li>半同步/半异步（half-sync/half-async）模式</li><li>领导者/追随者（Leader/Followers）模式。</li></ul><h3 id="半同步-半异步模式"><a href="#半同步-半异步模式" class="headerlink" title="半同步/半异步模式"></a>半同步/半异步模式</h3><p>I/O模型中的同步与异步的区分：</p><ul><li>内核向应用程序通知的是何种I/O事件（是就绪事件还是完成事件）。</li><li>该由谁来完成I/O读写（是应用程序还是内核）。</li></ul><p>并发模式中的同步与异步：</p><ul><li>同步：程序完全按照代码序列的顺序执行。</li><li>异步：程序的执行需要由系统事件来驱动。常见的系统事件包括中断、信号等。</li></ul><img src="/posts/81ce2909/image-20220727155301767.png" alt="image-20220727155301767" style="zoom: 67%;"><p>按照同步方式运行的线程称为同步线程，按照异步方式运行的线程称为异步线程。</p><p>异步线程：执行效率高，实时性强，这是很多嵌入式程序采用的模型。但编写以异步方式执行的程序相对复杂，难于调 试和扩展，而且不适合于大量的并发。</p><p>同步线程：虽然效率相对较低，实时性较差，但逻辑简单。</p><p><strong>半同步/半异步模式：</strong>同步线程用于处理客户逻辑，相当于逻辑处理单元；异步线程用于处理I/O事件，相当于I/O处理单元。</p><p>异步线程监听到客户请求后，就将其封装成请求对象并插入请求队列中。请求队列将通知某个工作在同步模式的工作线程来读取并处理该请求对象。具体选择哪个工作线程来为新的客户请求服务，则取决于请求队列的设计。</p><p>半同步/半异步模式的工作流程：</p><img src="/posts/81ce2909/image-20220727155822372.png" alt="image-20220727155822372" style="zoom:67%;"><p>服务器程序中，结合考虑两种事件处理模式和几种I/O模型，其中有一种变体称为半同步/半反应堆（half-sync/half-reactive）模式：</p><img src="/posts/81ce2909/image-20220727160014636.png" alt="image-20220727160014636" style="zoom:67%;"><p>图8-10中，异步线程只有一个，由主线程来充当。它负责监听所有socket上的事件。如果监听socket上有可读事件发生，即有新的连接请求到来，主线程就接受之以得到新的连接socket，然后往epoll内核事件表中注册该socket上的读写事件。如果连接socket上有读写事件发生，即有新的客户请求到来或有数据要发送至客户端，主线程就将该连接socket插入请求队列中。<br>所有工作线程都睡眠在请求队列上，当有任务到来时，它们将通过竞争（比如申请互斥锁）获得任务的接管权。这种竞争机制使得只有空闲的工作线程才有机会来处理新任务，这是很合理的。</p><p>主线程插入请求队列中的任务是就绪的连接socket。这说明该图所示的半同步/半反应堆模式采用的事件处理模式是Reactor模式：它要求工作线程自己从socket上读取客户请求和往socket写入服务器应答。这就是该模式的名称中“half-reactive”的含义。</p><p>半同步/半反应堆模式存在如下缺点：</p><ul><li>主线程和工作线程共享请求队列。主线程往请求队列中添加任务，或者工作线程从请求队列中取出任务，都需要对请求队列加锁保护，从而白白耗费CPU时间。</li><li>每个工作线程在同一时间只能处理一个客户请求。如果客户数量较多，而工作线程较少，则请求队列中将堆积很多任务对象，客户端的响应速度将越来越慢。如果通过增加工作线程来解决这一问题，则工作线程的切换也将耗费大量CPU时间。</li></ul><p>一种相对高效的半同步/半异步模式，它的每个工作线程都能同时处理多个客户连接：</p><img src="/posts/81ce2909/image-20220727161338185.png" alt="image-20220727161338185" style="zoom:67%;"><p>主线程只管理监听socket，连接socket由工作线程来管理。当有新的连接到来时，主线程就接受之并将新返回的连接socket派发给某个工作线程，此后该新socket上的任何I/O操作都由被选中的工作线程来处理，直到客户关闭连接。<br>主线程向工作线程派发socket的最简单的方式，是往它和工作线程之间的管道里写数据。工作线程检测到管道上有数据可读时，就分析是否是一个新的客户连接请求到来。如果是，则把该新socket上的读写事件注册到自己的epoll内核事件表中。<br>图8-11中，每个线程（主线程和工作线程）都维持自己的事件循环，它们各自独立地监听不同的事件。因此，在这种高效的半同步/半异步模式中，每个线程都工作在异步模式，所以它并非严格意义上的半同步/半异步模式。</p><h3 id="领导者-追随者模式"><a href="#领导者-追随者模式" class="headerlink" title="领导者/追随者模式"></a>领导者/追随者模式</h3><p><strong>领导者/追随者模式：</strong>多个工作线程轮流获得事件源集合，轮流监听、分发并处理事件的一种模式。</p><p>在任意时间点，程序都仅有一个领导者线程，它负责监听I/O事件。而其他线程则都是追随者，它们休眠在线程池中等待成为新的领导者。当前的领导者如果检测到I/O事件，首先要从线程池中推选出新的领导者线程，然后处理I/O事件。此时，新的领导者等待新的I/O事件，而原来的领导者则处理I/O事件，二者实现了并发。</p><p>领导者/追随者模式的组件：句柄集（HandleSet）、线程集（ThreadSet）、事件处理器（EventHandler）和具体的事件处理器（ConcreteEventHandler）。</p><img src="/posts/81ce2909/image-20220727162049774.png" alt="image-20220727162049774" style="zoom:67%;"><h4 id="句柄集"><a href="#句柄集" class="headerlink" title="句柄集"></a>句柄集</h4><p>句柄（Handle）用于表示I/O资源，在Linux下通常就是一个文件描述符。<br>句柄集管理众多句柄，它使用wait_for_event方法来监听这些句柄上的I/O事件，并将其中的就绪事件通知给领导者线程。<br>领导者则调用绑定到Handle上的事件处理器来处理事件。领导者将Handle和事件处理器绑定是通过调用句柄集中的register_handle方法实现的。</p><h4 id="线程集"><a href="#线程集" class="headerlink" title="线程集"></a>线程集</h4><p>这个组件是所有工作线程（包括领导者线程和追随者线程）的管理者。它负责各线程之间的同步，以及新领导者线程的推选。线程集中的线程在任一时间必处于如下三种状态之一：</p><ul><li>Leader：线程当前处于领导者身份，负责等待句柄集上的I/O事件。</li><li>Processing：线程正在处理事件。领导者检测到I/O事件之后，可以转移到Processing状态来处理该事件，并调用promote_new_leader方法推选新的领导者；也可以指定其他追随者来处理事件（Event Handoff），此时领导者的地位不变。<br>当处于Processing状态的线程处理完事件之后，如果当前线程集中没有领导者，则它将成为新的领导者，否则它就直接转变为追随者。</li><li>Follower：线程当前处于追随者身份，通过调用线程集的join方法等待成为新的领导者，也可能被当前的领导者指定来处理新的任务。</li></ul><p>三种状态之间的转换关系：</p><img src="/posts/81ce2909/image-20220727162626955.png" alt="image-20220727162626955" style="zoom: 50%;"><p>注意：领导者线程推选新的领导者和追随者等待成为新领导者这两个操作都将修改线程集，因此线程集提供一个成员Synchronizer来同步这两个操作，以避免竞态条件。</p><h4 id="事件处理器和具体的事件处理器"><a href="#事件处理器和具体的事件处理器" class="headerlink" title="事件处理器和具体的事件处理器"></a>事件处理器和具体的事件处理器</h4><p>事件处理器通常包含一个或多个回调函数handle_event。这些回调函数用于处理事件对应的业务逻辑。<br>事件处理器在使用前需要被绑定到某个句柄上，当该句柄上有事件发生时，领导者就执行与之绑定的事件处理器中的回调函数。具体的事件处理器是事件处理器的派生类。它们必须重新实现基类的handle_event方法，以处理特定的任务。</p><p>领导者/追随者模式的工作流程总结：</p><img src="/posts/81ce2909/image-20220727163037306.png" alt="image-20220727163037306" style="zoom: 67%;"><p>优点：由于领导者线程自己监听I/O事件并处理客户请求，因而领导者/追随者模式不需要在线程之间传递任何额外的数据，也无须像半同步/半反应堆模式那样在线程之间同步对请求队列的访问。</p><p>缺点：仅支持一个事件源集合，因此也无法像图8-11所示的那样，让每个工作线程独立地管理多个客户连接。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux服务器程序规范</title>
      <link href="/posts/7295db68/"/>
      <url>/posts/7295db68/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>Linux服务器程序规范包括：</p><ul><li>Linux服务器程序一般以后台进程（守护进程）运行，没有控制终端，因而也不会意外接收到用户输入。守护进程的父进程通常是init进程（PID为1的进程）。</li><li>日志系统，至少能输出日志到文件，有的高级服务器还能输出日志到专门的UDP服务器。大部分后台进程都在/var/log目录下拥有自己的日志目录。</li><li>Linux服务器程序一般以某个专门的非root身份运行，比如mysqld、httpd、syslogd等后台进程，分别拥有自己的运行账户mysql、apache和syslog。 </li><li>Linux服务器程序通常是可配置的。服务器程序通常能处理很多命令行选项，如果一次运行的选项太多，则可以用配置文件来管理。绝大多数服务器程序都有配置文件，并存放在/etc目录下。</li><li>Linux服务器进程通常会在启动的时候生成一个PID文件并存入/var/run目录中，以记录该后台进程的PID。比如syslogd的PID文件是/var/run/syslogd.pid。</li><li>Linux服务器程序通常需要考虑系统资源和限制，以预测自身能承受多大负荷，比如进程可用文件描述符总数和内存总量等。</li></ul><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><h3 id="Linux系统日志"><a href="#Linux系统日志" class="headerlink" title="Linux系统日志"></a>Linux系统日志</h3><p>守护进程syslogd，处理系统日志。现在的Linux系统上使用的都是它的升级版——rsyslogd。 rsyslogd守护进程既能接收用户进程输出的日志，又能接收内核日志。</p><p>用户进程是通过调用syslog函数生成系统日志的。该函数将日志输出到一个UNIX本地域socket类型（AF_UNIX）的文件/dev/log中，rsyslogd则监听该文件以获取用户进程的输出。</p><p>内核日志由printk等函数打印至内核的环状缓存（ring buffer）中。环状缓存的内容直接映射到/proc/kmsg文件中。rsyslogd则通过读取该文件获得内核日志。 </p><p>rsyslogd的主配置文件是/etc/rsyslog.conf，其中主要可以设置的项包括：内核日志输入路径，是否接收UDP日志及其监听端口（默认是514，见/etc/services文件），是否接收TCP日志及其监听端口，日志文件的权限，包含哪些子配置文件（比如/etc/rsyslog.d/*.conf）。rsyslogd的子配置文件则指定各类日志的目标存储文件。</p><p>Linux的系统日志体系：</p><p><img src="/20220726/image-20220726200803717.png" alt="image-20220726200803717"></p><h3 id="syslog函数"><a href="#syslog函数" class="headerlink" title="syslog函数"></a>syslog函数</h3><p>应用程序使用syslog函数与rsyslogd守护进程通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">syslog</span><span class="params">(<span class="keyword">int</span> priority, <span class="keyword">const</span> <span class="keyword">char</span>* message,...)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">priority：设施值与日志级别的按位或，设施值的默认值是LOG_USER</span></span><br><span class="line"><span class="comment">message, ...：可变参数，结构化输出</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 日志级别：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_EMERG 0<span class="comment">/*系统不可用*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ALERT 1<span class="comment">/*报警，需要立即采取动作*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CRIT 2<span class="comment">/*非常严重的情况*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ERR 3<span class="comment">/*错误*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_WARNING 4<span class="comment">/*警告*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NOTICE 5<span class="comment">/*通知*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_INFO 6<span class="comment">/*信息*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_DEBUG 7<span class="comment">/*调试*/</span></span></span><br></pre></td></tr></table></figure><p>改变syslog的默认输出方式，进一步结构化日志内容：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">openlog</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* ident, <span class="keyword">int</span> logopt, <span class="keyword">int</span> facility)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">ident：指定的字符串将被添加到日志消息的日期和时间之后，通常为程序的名字</span></span><br><span class="line"><span class="comment">logopt：对后续syslog调用的行为进行配 置，它可取下列值的按位或</span></span><br><span class="line"><span class="comment">facility：用来修改syslog函数中的默认设施值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_PID 0x01<span class="comment">/*在日志消息中包含程序PID*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_CONS 0x02<span class="comment">/*如果消息不能记录到日志文件，则打印至终端*/</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_ODELAY 0x04<span class="comment">/*延迟打开日志功能直到第一次调用syslog*/</span> </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG_NDELAY 0x08<span class="comment">/*不延迟打开日志功能*/</span></span></span><br></pre></td></tr></table></figure><p>日志的过滤，设置日志掩码，使日志级别大于日志掩码的日志信息被系统忽略。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setlogmask</span><span class="params">(<span class="keyword">int</span> maskpri)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">maskpri：指定日志掩码值</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">该函数始终会成功，它返回调用进程先前的日志掩码值。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>关闭日志功能：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜syslog.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">closelog</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure><h2 id="用户信息"><a href="#用户信息" class="headerlink" title="用户信息"></a>用户信息</h2><h3 id="UID、EUID、GID和EGID"><a href="#UID、EUID、GID和EGID" class="headerlink" title="UID、EUID、GID和EGID"></a>UID、EUID、GID和EGID</h3><p>UID：真实用户ID<br>EUID：有效用户ID<br>GID：真实组<br>EGID：有效组ID</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">getuid</span><span class="params">()</span></span>;<span class="comment">/*获取真实用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">uid_t</span> <span class="title">geteuid</span><span class="params">()</span></span>;<span class="comment">/*获取有效用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getgid</span><span class="params">()</span></span>;<span class="comment">/*获取真实组ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">gid_t</span> <span class="title">getegid</span><span class="params">()</span></span>;<span class="comment">/*获取有效组ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置真实用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">seteuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;<span class="comment">/*设置有效用户ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置真实组ID*/</span> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setegid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;<span class="comment">/*设置有效组ID*/</span></span><br></pre></td></tr></table></figure><p>一个进程拥有两个用户ID：UID和EUID。<br>EUID存在的目的是方便资源访问：它使得运行程序的用户拥有该程序的有效用户的权限。</p><p>任何普通用户运行su程序时，其有效用户就是该程序的所有者root。任何运行su程序的普通用户都能够访问/etc/passwd文件。</p><p>有效用户为root的进程称为特权进程（privileged processes）。EGID的含义与EUID类似：给运行目标程序的组用户提供有效组的权限。</p><p>测试进程的UID和EUID的区别：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">uid_t</span> uid = <span class="built_in">getuid</span>();</span><br><span class="line">    <span class="keyword">uid_t</span> euid = <span class="built_in">geteuid</span>();</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;userid is %d, effective userid is: %d\n&quot;</span>, uid, euid );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译该文件，将生成的可执行文件（名为test_uid）的所有者设置为root，并设置该文件的set-user-id标志，然后运行该程序以查看UID和EUID。具体操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">sudo chown root:root test_uid<span class="comment">#修改目标文件的所有者为root</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">sudo chmod+s test_uid<span class="comment">#设置目标文件的set-user-id标志</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">./test_uid<span class="comment">#运行程序</span></span> </span><br><span class="line">userid is 1000,effective userid is:0</span><br></pre></td></tr></table></figure><p>从测试程序的输出来看，进程的UID是启动程序的用户的ID，而 EUID则是root账户（文件所有者）的ID。</p><h3 id="切换用户"><a href="#切换用户" class="headerlink" title="切换用户"></a>切换用户</h3><p>将以root身份启动的进程切换为以一个普通用户身份运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">bool</span> <span class="title">switch_to_user</span><span class="params">( <span class="keyword">uid_t</span> user_id, <span class="keyword">gid_t</span> gp_id )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 确保目标用户不是root</span></span><br><span class="line">    <span class="keyword">if</span> ( ( user_id == <span class="number">0</span> ) &amp;&amp; ( gp_id == <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确保当前用户是合法用户：root或者目标用户</span></span><br><span class="line">    <span class="keyword">gid_t</span> gid = <span class="built_in">getgid</span>();</span><br><span class="line">    <span class="keyword">uid_t</span> uid = <span class="built_in">getuid</span>();</span><br><span class="line">    <span class="keyword">if</span> ( ( ( gid != <span class="number">0</span> ) || ( uid != <span class="number">0</span> ) ) &amp;&amp; ( ( gid != gp_id ) || ( uid != user_id ) ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果不是root</span></span><br><span class="line">    <span class="keyword">if</span> ( uid != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换到目标用户</span></span><br><span class="line">    <span class="keyword">if</span> ( ( <span class="built_in">setgid</span>( gp_id ) &lt; <span class="number">0</span> ) || ( <span class="built_in">setuid</span>( user_id ) &lt; <span class="number">0</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="进程间关系"><a href="#进程间关系" class="headerlink" title="进程间关系"></a>进程间关系</h2><h3 id="进程组"><a href="#进程组" class="headerlink" title="进程组"></a>进程组</h3><p>Linux下每个进程都隶属于一个进程组，除了PID信息外，还有进程组ID（PGID）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getpgid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取指定进程的PGID</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">pid：进程识别号</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">返回进程pid所属进程组的PGID，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>每个进程组都有一个首领进程，其PGID和PID相同。进程组将一直存在，直到其中所有进程都退出，或者加入到其他进程组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setpgid</span><span class="params">(<span class="keyword">pid_t</span> pid, <span class="keyword">pid_t</span> pgid)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置PGID，将PID为pid的进程的PGID设置为pgid</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">pid：进程号</span></span><br><span class="line"><span class="comment">pgid：进程组号</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>如果pid和pgid相同，则由pid指定的进程将被设置为进程组首领；如果pid为0，则表示设置当前进程的PGID为pgid；如果pgid为0，则使用pid作为目标PGID。</p><p>一个进程只能设置自己或者其子进程的PGID。并且，当子进程调用exec系列函数后，我们也不能再在父进程中对它设置PGID。</p><h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><p>一些有关联的进程组将形成一个会话（session）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">setsid</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：创建一个会话</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回新的进程组的PGID，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>该函数不能由进程组的首领进程调用，否则将产生一个错误。对于非组首领的进程，调用该函数不仅创建新会话，而且有如下额外效果：</p><ul><li>调用进程成为会话的首领，此时该进程是新会话的唯一成员。</li><li>新建一个进程组，其PGID就是调用进程的PID，调用进程成为该组的首领。</li><li>调用进程将甩开终端（如果有的话）。</li></ul><p>Linux进程并未提供所谓会话ID（SID）的概念，但Linux系统认为它等于会话首领所在的进程组的PGID，并提供了如下函数来读取SID：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">pid_t</span> <span class="title">getsid</span><span class="params">(<span class="keyword">pid_t</span> pid)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="用ps命令查看进程关系"><a href="#用ps命令查看进程关系" class="headerlink" title="用ps命令查看进程关系"></a>用ps命令查看进程关系</h3><p>执行ps命令可查看进程、进程组和会话之间的关系：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">ps-o pid,ppid,pgid,sid,comm|less</span></span><br><span class="line">PID PPID PGID SID COMMAND </span><br><span class="line">1943 1942 1943 1943 bash </span><br><span class="line">2298 1943 2298 1943 ps</span><br><span class="line">2299 1943 2298 1943 less</span><br></pre></td></tr></table></figure><p>bash shell下执行ps和less命令，因此以ps和less命令的父进程是bash命令，这可以从PPID（父进程PID）一列看出。这3条命令创建了1个会话（SID是1943）和2个进程组（PGID分别是1943和2298）。bash命令的PID、PGID和SID都相同，很明显它既是会话的首领，也是组1943的首领。ps命令则是组2298的首领，因为其PID也是2298。</p><p>进程间关系：</p><img src="/posts/7295db68/image-20220726214000802.png" alt="image-20220726214000802" style="zoom:67%;"><h2 id="系统资源限制"><a href="#系统资源限制" class="headerlink" title="系统资源限制"></a>系统资源限制</h2><p>读取和设置Linux系统资源限制的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/resource.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getrlimit</span><span class="params">(<span class="keyword">int</span> resource, struct rlimit* rlim)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取系统资源限制</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">resource：指定资源限制类型，见表7-1</span></span><br><span class="line"><span class="comment">rlim：指向rlimit结构体</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setrlimit</span><span class="params">(<span class="keyword">int</span> resource, <span class="keyword">const</span> struct rlimit* rlim)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置系统资源限制</span></span><br><span class="line"><span class="comment">参数，返回值：参考getrlimit</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// rlimit结构体的定义</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rlimit</span> &#123;</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_cur; <span class="comment">// 描述资源级别，指定资源的软限制，软限制是一个建议性的、最好不要超越的限制，如果超越的话，系统可能向进程发送信号以终止其运行。</span></span><br><span class="line">    <span class="keyword">rlim_t</span> rlim_max; <span class="comment">// 指定资源的硬限制，软限制的上限，只有以root身份运行的程序才能增加硬限制</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/20220726/image-20220726214838702.png" alt="image-20220726214838702"></p><h2 id="改变工作目录和根目录"><a href="#改变工作目录和根目录" class="headerlink" title="改变工作目录和根目录"></a>改变工作目录和根目录</h2><p>一般来说，Web服务器的逻辑根目录并非文件系统的根目录“/”，而是站点的根目录（对于Linux的Web服务来说，该目录一般是/var/www/）。</p><p>获取进程当前工作目录的改变进程工作目录的函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">getcwd</span><span class="params">(<span class="keyword">char</span>* buf, <span class="keyword">size_t</span> size)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取当前工作目录</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">buf：指向的内存存储当前工作路径的绝对路径名</span></span><br><span class="line"><span class="comment">size：buf路径的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">如果当前工作目录的绝对路径的长度（再加上一个空结束字符“\0”）超过了size，则getcwd将返回NULL，并设置errno为 ERANGE；</span></span><br><span class="line"><span class="comment">如果buf为NULL并且size非0，则getcwd可能在内部使用 malloc动态分配内存，并将进程的当前工作目录存储在其中。（需自己释放getcwd在内部创建的这块内存）；</span></span><br><span class="line"><span class="comment">成功返回一个指向目标存储区的指针，失败返回NULL。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chdir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：修改当前工作路径</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">path：指定要切换到的目标目录</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">chroot</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：修改进程根目录</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">path：指定要切换到的目标根目录</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>chroot并不改变进程的当前工作目录，所以调用chroot之后，仍然需要使用chdir(“/”)来将工作目录切换至新的根目录。</p><p>改变进程的根目录之后，程序可能无法访问类似/dev的文件（和目录），因为这些文件（和目录）并非处于新的根目录之下。不过好在调用chroot之后，进程原先打开的文件描述符依然生效，所以可以利用这些早先打开的文件描述符，来访问调用chroot之后不能直接访问的文件（和目录），尤其是一些日志文件。此外，只有特权进程才能改变根目录。</p><h2 id="服务器程序后台化"><a href="#服务器程序后台化" class="headerlink" title="服务器程序后台化"></a>服务器程序后台化</h2><p>在代码中让一个服务器进程以守护进程的方式运行：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">daemonize</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 创建子进程，父进程关闭，这样可使程序在后台运行</span></span><br><span class="line">    <span class="keyword">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> ( pid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ( pid &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">exit</span>( <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 设置文件权掩码。当进程创建新文件（使用open(const char*pathname,int flags,mode_t mode)系统调用）时，文件的权限将是mode＆0777</span></span><br><span class="line">    <span class="built_in">umask</span>( <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新的会话，设置本进程为进程组的首领</span></span><br><span class="line">    <span class="keyword">pid_t</span> sid = <span class="built_in">setsid</span>();</span><br><span class="line">    <span class="keyword">if</span> ( sid &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切换工作目录</span></span><br><span class="line">    <span class="keyword">if</span> ( ( <span class="built_in">chdir</span>( <span class="string">&quot;/&quot;</span> ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">/* Log the failure */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭标准输入设备、标准输出设备和标准错误输出设备</span></span><br><span class="line">    <span class="built_in">close</span>( STDIN_FILENO );</span><br><span class="line">    <span class="built_in">close</span>( STDOUT_FILENO );</span><br><span class="line">    <span class="built_in">close</span>( STDERR_FILENO );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 关闭其他已经打开的文件描述符，代码省略</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// 将标准输入、标准输出和标准错误输出都定向到/dev/null文件</span></span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDONLY );</span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="built_in">open</span>( <span class="string">&quot;/dev/null&quot;</span>, O_RDWR );</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实际上，Linux提供了完成同样功能的库函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">daemon</span><span class="params">(<span class="keyword">int</span> nochdir, <span class="keyword">int</span> noclose)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">nochdir：用于指定是否改变工作目录，传值为0，则工作目录被设置为“/”（根目录），否则继续使用当前工作目录。</span></span><br><span class="line"><span class="comment">noclose：参数为0时，标准输入、标准输出和标准错误输出都被重定向到/dev/null文件，否则依然使用原来的设备。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败 则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux高级I/O函数</title>
      <link href="/posts/4131876a/"/>
      <url>/posts/4131876a/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>常用Linux网络编程相关的高级I/O函数：</p><ul><li>用于创建文件描述符的函数，包括pipe、dup/dup2函数</li><li>用于读写数据的函数，包括readv/writev、sendfile、mmap/munmap、splice和tee函数</li><li>用于控制I/O行为和属性的函数，包括fctnl函数</li></ul><h2 id="pipe函数"><a href="#pipe函数" class="headerlink" title="pipe函数"></a>pipe函数</h2><p>pipe函数：创建一个管道，以实现进程间的通信。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：创建管道的两端fd[0]和fd[1]，向fd[1]写入的数据可以从fd[0]读出。fd[0]只能用于从管道读出数据，fd[1]只能用于向管道写入数据，不可以反过来用。</span></span><br><span class="line"><span class="comment">如果要实现双向传输，需要建立两个管道。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd[2]：包含两个int型的数组指针（传出参数）</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，并将一对打开的文件描述符值，填入参数指向的数组；</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>默认情况下，一对文件描述符都是阻塞的。如果用read系统调用来读取一个空的管道，则read将被阻塞，直到管道内有数据可读；如果用write系统调用来往一个满的管道中写入数据，则write亦将被阻塞，直到管道有足够多的空闲空间可用。<br>如果应用程序将fd[0]和fd[1]都设置为非阻塞的，则read和write会有不同的行为。</p><p>如果写端fd[1]的引用计数减少到0，表面没有任何进程需要向管道内写入数据，则该管道的读端fd[0]和read操作将返回0，即读取到了文件结束标记EOF。</p><p>如果读端fd[0]的引用计数减少到0，表面没有任何进程需要从管道内读取数据，则该管道的写端fd[1]和write操作将失败，并引发SIGPIPE信号。</p><p>管道内部传输的数据是字节流。管道容量的大小默认是65536字节。可以使用fcntl函数来修改管道容量。</p><p>socket的基础API中有一个socketpair函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socketpair</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol, <span class="keyword">int</span> fd[<span class="number">2</span>])</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：创建双向管道，这对文件描述符都是既可读又可写的。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">domain：底层的协议族。只能使用UNIX本地域协议族AF_UNIX，仅能在本地使用双向管道。</span></span><br><span class="line"><span class="comment">type：指定服务类型。</span></span><br><span class="line"><span class="comment">SOCK_STREAM（TCP）、SOCK_UGRAM（UDP）、SOCK_NONBLOCK（非阻塞的）、SOCK_CLOEXEC</span></span><br><span class="line"><span class="comment">protocol：选择协议，通常由前两个参数决定。</span></span><br><span class="line"><span class="comment">设置为0，使用默认协议</span></span><br><span class="line"><span class="comment">fd[2]：指向两个int型整数。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，并将一对打开的文件描述符值，填入参数指向的数组；</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="dup和dup2函数"><a href="#dup和dup2函数" class="headerlink" title="dup和dup2函数"></a>dup和dup2函数</h2><p>把标准输入重定向到一个文件，或者把标准输出重定向到一个网络连接。通过用于复制文件描述符的dup或dup2函数实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup</span><span class="params">(<span class="keyword">int</span> file_descriptor)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：复制文件描述符</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">file_descriptor：旧的文件描述符</span></span><br><span class="line"><span class="comment">返回值：成功，返回新的文件描述符；失败，返回-1</span></span><br><span class="line"><span class="comment">fd = 3, int fd1 = dup(fd);</span></span><br><span class="line"><span class="comment">fd指向a.txt, fd1也指向a.txt，从空闲的文件描述符表中找一个最小的，作为新的拷贝的文件描述符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dup2</span><span class="params">(<span class="keyword">int</span> file_descriptor_one, <span class="keyword">int</span> file_descriptor_two)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：重定向文件描述符</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">file_descriptor_one：旧的文件描述符，必须是一个有效的文件描述符</span></span><br><span class="line"><span class="comment">file_descriptor_two：新的文件描述符，和file_descriptor_one相同，相当于什么都没做</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功，返回新的文件描述符；失败，返回-1</span></span><br><span class="line"><span class="comment">file_descriptor_one 指向a.txt，file_descriptor_two 指向b.txt，</span></span><br><span class="line"><span class="comment">调用函数成功后：file_descriptor_two 和b.txt 做close，file_descriptor_two 指向a.txt</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注意：通过dup和dup2创建的文件描述符并不继承原文件描述符的属性，比如close-on-exec和non-blocking等。</p><p>利用dup函数实现了一个基本的CGI服务器：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-1testdup.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP类型的socket</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="comment">// 接受客户端的连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="built_in">close</span>( STDOUT_FILENO ); <span class="comment">// 关闭标准输出文件描述符（STDOUT_FILENO值为1）</span></span><br><span class="line">        <span class="built_in">dup</span>( connfd ); <span class="comment">// 复制connfd，这里dup返回值实际上是1，即之前关闭的标准输出文件描述符的值</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;abcd\n&quot;</span> ); <span class="comment">// 服务器输出到标准输出的内容，会直接发送到与客户连接对应的socket上</span></span><br><span class="line">        <span class="comment">// 此printf调用的输出将被客户端获得（而不是显示在服务器 程序的终端上）</span></span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="readv和writev函数"><a href="#readv和writev函数" class="headerlink" title="readv和writev函数"></a>readv和writev函数</h2><p>readv函数：将数据从文件描述符读到分散的内存块中，分散读。<br>writev函数：将多块分散的内存数据一并写入文件描述符中，集中写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/uio.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">readv</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* vector, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd：目标文件描述符</span></span><br><span class="line"><span class="comment">vector：指向iovec结构数组，该结构体描述一块内存区</span></span><br><span class="line"><span class="comment">count：vector数组的长度，即有多少内存数据需要从fd读出。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回读出fd的字节数，失败则返回-1并设置errno，简化版的recvmsg函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">writev</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct iovec* vector, <span class="keyword">int</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd：目标文件描述符</span></span><br><span class="line"><span class="comment">vector：指向iovec结构数组，该结构体描述一块内存区</span></span><br><span class="line"><span class="comment">count：vector数组的长度，即有多少内存数据需要写入到fd。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回写入fd的字节数，失败则返回-1并设置errno，简化版的sendmsg函数</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>Web服务器上的集中写：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-2testwritev.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/uio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义两种HTTP状态码和状态信息</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="keyword">char</span>* status_line[<span class="number">2</span>] = &#123; <span class="string">&quot;200 OK&quot;</span>, <span class="string">&quot;500 Internal server error&quot;</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* file_name = argv[<span class="number">3</span>]; <span class="comment">// 将目标文件作为程序的第三个参数传入</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址信息</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="comment">// 接受socket连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="comment">// 设置缓冲区，用于保存HTTP应答的状态行、头部字段和一个空行</span></span><br><span class="line">        <span class="keyword">char</span> header_buf[ BUFFER_SIZE ]; </span><br><span class="line">        <span class="built_in">memset</span>( header_buf, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line"></span><br><span class="line">        <span class="keyword">char</span>* file_buf; <span class="comment">// 用于存放目标文件内容的应用程序缓存</span></span><br><span class="line"></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">file_stat</span>;</span> <span class="comment">// 用于获取目标文件的属性，比如是否为目录，文件大小等</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">bool</span> valid = <span class="literal">true</span>; <span class="comment">// 记录目标文件是否是有效文件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">0</span>; <span class="comment">// 缓存区header_buf目前已经使用了多少字节的空间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">stat</span>( file_name, &amp;file_stat ) &lt; <span class="number">0</span> ) <span class="comment">// 目标文件不存在</span></span><br><span class="line">        &#123;</span><br><span class="line">            valid = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">S_ISDIR</span>( file_stat.st_mode ) ) <span class="comment">// 目标文件是一个目录</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( file_stat.st_mode &amp; S_IROTH ) <span class="comment">// 当前用户有读取目标文件的权限</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// *动态分配缓存区file_buf，并指定其大小为目标文件的大小file_stat.st_size加1，</span></span><br><span class="line">                <span class="comment">// 然后将目标文件读入缓存区file_buf中</span></span><br><span class="line">                <span class="keyword">int</span> fd = <span class="built_in">open</span>( file_name, O_RDONLY );</span><br><span class="line">                file_buf = <span class="keyword">new</span> <span class="keyword">char</span> [ file_stat.st_size + <span class="number">1</span> ];</span><br><span class="line">                <span class="built_in">memset</span>( file_buf, <span class="string">&#x27;\0&#x27;</span>, file_stat.st_size + <span class="number">1</span> );</span><br><span class="line">                <span class="keyword">if</span> ( <span class="built_in">read</span>( fd, file_buf, file_stat.st_size ) &lt; <span class="number">0</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    valid = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                valid = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>( valid ) <span class="comment">// 如果目标文件有效，则发送正常的HTTP应答</span></span><br><span class="line">        &#123;   </span><br><span class="line">            <span class="comment">// 将HTTP应答的状态行、“Content-Length”头部字段和一个空行依次 加入header_buf中</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">0</span>] );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, </span><br><span class="line">                             <span class="string">&quot;Content-Length: %d\r\n&quot;</span>, file_stat.st_size );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 利用writev将header_buf和file_buf的内容一并写出</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> <span class="title">iv</span>[2];</span></span><br><span class="line">            iv[ <span class="number">0</span> ].iov_base = header_buf;</span><br><span class="line">            iv[ <span class="number">0</span> ].iov_len = <span class="built_in">strlen</span>( header_buf );</span><br><span class="line">            iv[ <span class="number">1</span> ].iov_base = file_buf;</span><br><span class="line">            iv[ <span class="number">1</span> ].iov_len = file_stat.st_size;</span><br><span class="line">            ret = <span class="built_in">writev</span>( connfd, iv, <span class="number">2</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;   <span class="comment">// 如果目标文件无效，则通知客户端服务器发生了“内部错误”</span></span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf, BUFFER_SIZE<span class="number">-1</span>, <span class="string">&quot;%s %s\r\n&quot;</span>, <span class="string">&quot;HTTP/1.1&quot;</span>, status_line[<span class="number">1</span>] );</span><br><span class="line">            len += ret;</span><br><span class="line">            ret = <span class="built_in">snprintf</span>( header_buf + len, BUFFER_SIZE<span class="number">-1</span>-len, <span class="string">&quot;%s&quot;</span>, <span class="string">&quot;\r\n&quot;</span> );</span><br><span class="line">            <span class="built_in">send</span>( connfd, header_buf, <span class="built_in">strlen</span>( header_buf ), <span class="number">0</span> );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">        <span class="keyword">delete</span> [] file_buf;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="sendfile函数"><a href="#sendfile函数" class="headerlink" title="sendfile函数"></a>sendfile函数</h2><p>sendfile函数：在两个文件描述符之间直接传递数据（完全在内核中操作），避免了内核缓冲区和用户缓冲区之间的数据拷贝，效率很高，这被称为零拷贝。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/sendfile.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendfile</span><span class="params">(<span class="keyword">int</span> out_fd, <span class="keyword">int</span> in_fd, <span class="keyword">off_t</span>* offset, <span class="keyword">size_t</span> count)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">out_fd：待写入内容的文件描述符</span></span><br><span class="line"><span class="comment">in_fd：待读出内容的文件描述符</span></span><br><span class="line"><span class="comment">offset：指定从读入文件流的哪个位置开始读，若为空，则使用读入文件流默认的起始位置</span></span><br><span class="line"><span class="comment">count：指定在文件描述符in_fd和out_fd之间传输的字节数</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回传输的字节数，失 败则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>注：in_fd必须是支持类似mmap函数的文件描述符，即它必须指向真实的文件，不能是socket和管道；out_fd必须是一个socket。</p><p>利用sendfile函数将服务器上的一个文件传送给客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-3testsendfile.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/sendfile.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number filename\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* file_name = argv[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 打开本地文件</span></span><br><span class="line">    <span class="keyword">int</span> filefd = <span class="built_in">open</span>( file_name, O_RDONLY );</span><br><span class="line">    <span class="built_in">assert</span>( filefd &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取目标文件属性</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">stat_buf</span>;</span></span><br><span class="line">    <span class="built_in">fstat</span>( filefd, &amp;stat_buf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="comment">// 接收连接成功，使用sendfile发送数据</span></span><br><span class="line">        <span class="built_in">sendfile</span>( connfd, filefd, <span class="literal">NULL</span>, stat_buf.st_size );</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将目标文件作为第3个参数传递给服务器程序，客户telnet到该服务器上即可获得该文件。<br>与6-2estwritev.cpp相比，6-3testsendfile.cpp没有为目标文件分布任何用户空间的缓存，也没有执行读取文件的操作，同样实现了文件的发送，显然效率更高。</p><h2 id="mmap和munmap函数"><a href="#mmap和munmap函数" class="headerlink" title="mmap和munmap函数"></a>mmap和munmap函数</h2><p>mmap函数：用于申请一段内存空间。可以将这段内存作为进程间通信的共享内存，也可以将文件直接映射到其中。<br>munmap函数：释放由mmap创建的这段内存空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/mman.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span>* <span class="title">mmap</span><span class="params">(<span class="keyword">void</span>* start, <span class="keyword">size_t</span> length, <span class="keyword">int</span> prot, <span class="keyword">int</span> flags, <span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：申请内存空间，以实现进程间共享内存</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">start：允许用户使用某个特定的地址作为这段内存的起始地址，设置成NULL，则系统自动分配一个地址</span></span><br><span class="line"><span class="comment">length：指定内存的长度</span></span><br><span class="line"><span class="comment">prot：设置内存段的访问权限，取值有：</span></span><br><span class="line"><span class="comment">PROT_READ，内存段可读</span></span><br><span class="line"><span class="comment">PROT_WRITE，内存段可写</span></span><br><span class="line"><span class="comment">PROT_EXEC，内存段可执行</span></span><br><span class="line"><span class="comment">PROT_NONE，内存段不能被访问</span></span><br><span class="line"><span class="comment">flags：控制内存段内容被修改后程序的行为，见表6-1按位或</span></span><br><span class="line"><span class="comment">（MAP_SHARED和MAP_PRIVATE是互斥的，不能同时指定）</span></span><br><span class="line"><span class="comment">fd：被映射文件对应的文件描述符</span></span><br><span class="line"><span class="comment">offset：设置从文件的何处开始映射</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回指向目标内存区域的指针，失败则返回 MAP_FAILED（(void*)-1）并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">munmap</span><span class="params">(<span class="keyword">void</span>* start,<span class="keyword">size_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：释放空间</span></span><br><span class="line"><span class="comment">参数：参考mmap</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/20220725/image-20220725234309852.png" alt="image-20220725234309852"></p><h2 id="splice函数"><a href="#splice函数" class="headerlink" title="splice函数"></a>splice函数</h2><p>splice函数：用于在两个文件描述符之间移动数据，也是零拷贝操作。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">splice</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">loff_t</span>* off_in, <span class="keyword">int</span> fd_out, <span class="keyword">loff_t</span>* off_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd_in：待输入数据的文件描述符</span></span><br><span class="line"><span class="comment">如果fd_in是一个管道文件 描述符，那么off_in参数必须被设置为NULL；</span></span><br><span class="line"><span class="comment">off_in：从输入数据流的何处开始读取数据，设置为NULL表示从输入数据流的当前偏移位置读入</span></span><br><span class="line"><span class="comment">fd_out：输出数据流的文件描述符</span></span><br><span class="line"><span class="comment">off_out：输出数据流的偏移量</span></span><br><span class="line"><span class="comment">len：指定移动数据的长度</span></span><br><span class="line"><span class="comment">flags：控制数据如何移动，它可以被设置为表6-2中的某些值的按位或</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回移动字节的数量。可能返回0，表示没有数据需要移动（从管道中读取数据（fd_in是管道文件描述 符）而该管道没有被写入任何数据）；</span></span><br><span class="line"><span class="comment">失败返回-1并设置 errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>使用splice函数时，fd_in和fd_out必须至少有一个是管道文件描述符。</p><p><img src="/20220725/image-20220725234325910.png" alt="image-20220725234325910"></p><p><img src="/20220725/image-20220725234520263.png" alt="image-20220725234520263"></p><p>使用splice函数来实现一个零拷贝的回射服务器，它将客户端发送的数据原样返回给客户端：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-4testsplice.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="comment">// 接收连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功</span></span><br><span class="line">        <span class="keyword">int</span> pipefd[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">        ret = <span class="built_in">pipe</span>( pipefd ); <span class="comment">// 创建管道</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将connfd上流入的客户数据定向到管道中，splice函数将客户端的内容读入到pipefd[1]中</span></span><br><span class="line">        ret = <span class="built_in">splice</span>( connfd, <span class="literal">NULL</span>, pipefd[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE ); </span><br><span class="line">        <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 将管道的输出定向到connfd客户连接文件描述符，splice函数从pipefd[0]中读出该内容到客户端</span></span><br><span class="line">        ret = <span class="built_in">splice</span>( pipefd[<span class="number">0</span>], <span class="literal">NULL</span>, connfd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line">        <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过splice函数将客户端的内容读入到pipefd[1]中，然后再使用splice函数从pipefd[0]中读出该内容到客户端，从而实现了简单高效的回射服务。整个过程未执行recv/send操作，因此也未涉及用户空间和内核空间之间的数据拷贝。</p><h2 id="tee函数"><a href="#tee函数" class="headerlink" title="tee函数"></a>tee函数</h2><p>tee函数：在两个管道文件描述符之间复制数据，也是零拷贝操作。它不消耗数据，因此源文件描述符上的数据仍然可以用于后续的读操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">tee</span><span class="params">(<span class="keyword">int</span> fd_in, <span class="keyword">int</span> fd_out, <span class="keyword">size_t</span> len, <span class="keyword">unsigned</span> <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd_in：待输入数据的管道文件描述符</span></span><br><span class="line"><span class="comment">fd_out：管道文件描述符</span></span><br><span class="line"><span class="comment">len：指定移动数据的长度</span></span><br><span class="line"><span class="comment">flags：控制数据如何移动</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回在两个文件描述符之间复制的数据数量（字节数）。</span></span><br><span class="line"><span class="comment">返回0表示没有复制任何数据。</span></span><br><span class="line"><span class="comment">失败时返回-1并设置 errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>利用tee函数和splice函数，实现Linux下tee程序的基本功能（同时输出数据到终端和文件的程序，不要和tee函数混淆）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 6-5testtee.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span> ( argc != <span class="number">2</span> )</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;usage: %s &lt;file&gt;\n&quot;</span>, argv[<span class="number">0</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 打开本地文件</span></span><br><span class="line"><span class="keyword">int</span> filefd = <span class="built_in">open</span>( argv[<span class="number">1</span>], O_CREAT | O_WRONLY | O_TRUNC, <span class="number">0666</span> );</span><br><span class="line"><span class="built_in">assert</span>( filefd &gt; <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建管道</span></span><br><span class="line"><span class="keyword">int</span> pipefd_stdout[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> ret = <span class="built_in">pipe</span>( pipefd_stdout );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> pipefd_file[<span class="number">2</span>];</span><br><span class="line">        ret = <span class="built_in">pipe</span>( pipefd_file );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">//close( STDIN_FILENO );</span></span><br><span class="line"><span class="comment">// dup2( pipefd_stdout[1], STDIN_FILENO );</span></span><br><span class="line"><span class="comment">//write( pipefd_stdout[1], &quot;abc\n&quot;, 4 );</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将标准输入内容输入管道pipefd_stdout</span></span><br><span class="line">ret = <span class="built_in">splice</span>( STDIN_FILENO, <span class="literal">NULL</span>, pipefd_stdout[<span class="number">1</span>], <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道pipefd_stdout的输出复制到管道pipefd_file的输入端</span></span><br><span class="line">ret = <span class="built_in">tee</span>( pipefd_stdout[<span class="number">0</span>], pipefd_file[<span class="number">1</span>], <span class="number">32768</span>, SPLICE_F_NONBLOCK ); </span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道pipefd_file的输出定向到文件描述符filefd上，从而将标准输入的内容写入文件</span></span><br><span class="line">ret = <span class="built_in">splice</span>( pipefd_file[<span class="number">0</span>], <span class="literal">NULL</span>, filefd, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将管道pipefd_stdout的输出定向到标准输出，其内容和写入文件的内容完全一致</span></span><br><span class="line">ret = <span class="built_in">splice</span>( pipefd_stdout[<span class="number">0</span>], <span class="literal">NULL</span>, STDOUT_FILENO, <span class="literal">NULL</span>, <span class="number">32768</span>, SPLICE_F_MORE | SPLICE_F_MOVE );</span><br><span class="line"><span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="built_in">close</span>( filefd );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_stdout[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_stdout[<span class="number">1</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_file[<span class="number">0</span>] );</span><br><span class="line">        <span class="built_in">close</span>( pipefd_file[<span class="number">1</span>] );</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="fcntl函数"><a href="#fcntl函数" class="headerlink" title="fcntl函数"></a>fcntl函数</h2><p>fcntl函数：提供了对文件描述符的各种控制操作。对于控制文件描述符常用的属性和行为，fcntl函数是由POSIX规范指定的首选方法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜fcntl.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd,…)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取或修改文件的属性</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">fd：需要操作的文件描述符</span></span><br><span class="line"><span class="comment">cmd：对文件描述符进行如何操作</span></span><br><span class="line"><span class="comment">- F_DUPFD：复制第一个参数文件描述符fd，得到一个新的文件描述符（返回值）</span></span><br><span class="line"><span class="comment">int ret = fnctl(fd, F_DUPFD);</span></span><br><span class="line"><span class="comment">- F_GETFL：获取指定的文件描述符的文件状态flag（与open函数传递的文件权限flag是相同的）</span></span><br><span class="line"><span class="comment">- F_SETFL：设置文件描述符的文件状态flag</span></span><br><span class="line"><span class="comment">            必选项：O_RONLY, O_WRONLY, O_RDWR 不可以被修改（文件访问、创建权限）</span></span><br><span class="line"><span class="comment">            可选项：O_APPEND, O_NONBLOCK</span></span><br><span class="line"><span class="comment">                O_APPEND 表示追加数据</span></span><br><span class="line"><span class="comment">                O_NONBLOCK 设置成非阻塞</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>在网络编程中，fcntl函数通常用来将一个文件描述符设置为非阻塞的。</p><p>将文件描述符设置成非阻塞的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setnonblocking</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> old_option = <span class="built_in">fcntl</span>(fd, F_GETFL); <span class="comment">/*获取文件描述符旧的状态标志*/</span> </span><br><span class="line">    <span class="keyword">int</span> new_option = old_option | O_NONBLOCK; <span class="comment">/*设置非阻塞标志*/</span> </span><br><span class="line">    <span class="built_in">fcntl</span>(fd,F_SETFL,new_option); </span><br><span class="line">    <span class="keyword">return</span> old_option; <span class="comment">/*返回文件描述符旧的状态标志，以便日后恢复该状态标志*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="/20220725/image-20220726152218986.png" alt="image-20220726152218986"></p><p><img src="/20220725/image-20220726152238201.png" alt="image-20220726152238201"></p><p>SIGIO和SIGURG这两个信号与其他Linux信号不同，它们必须与某个文件描述符相关联方可使用：当被关联的文件描述符可读或可写时，系统将触发SIGIO信号；当被关联的文件描述符（而且必须是一个socket）上有带外数据可读时，系统将触发SIGURG信号。<br>使用SIGIO时，还需要利用fcntl设置其O_ASYNC标志（异步I/O标志，不过SIGIO信号模型并非真正意义上的异步I/O模型）。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux网络编程基础API</title>
      <link href="/posts/47fa327/"/>
      <url>/posts/47fa327/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>Linux网络API：</p><ul><li>socket地址API。一个ip地址和端口对(ip, port)。唯一表示使用TCP通信的一端</li><li>socket基础API。头文件&lt;sys/socket.h&gt;，包括创建socket、命名socket、监听socket、接受连接、发起连接、读写数据、获取地址信息、检测带外标记，以及读取和设置socket选项。</li><li>网络信息API。Linux提供的网络信息API，实现主机名和IP地址之间的转换，以及服务名称和端口号之间的转换。头文件&lt;netdb.h&gt;中。</li></ul><h2 id="1-socket地址API"><a href="#1-socket地址API" class="headerlink" title="1.socket地址API"></a>1.socket地址API</h2><h3 id="主机字节序和网络字节序"><a href="#主机字节序和网络字节序" class="headerlink" title="主机字节序和网络字节序"></a>主机字节序和网络字节序</h3><ul><li>大端字节序：一个整数的高位字节（23～31 bit）存储在内存的低地址处，低位字节（0～7bit）存储在内存的高地址处</li><li>小端字节序：整数的高位字节存储在内存的高地址处，而低位字节则存储在内存的低地址处</li></ul><p><strong>现代PC大多采用小端字节序，因此小端字节序又被称为主机字节序。</strong><br>Linux提供了如下4个函数来完成主机字节序和网络字节序之间的转换：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞ </span></span><br><span class="line"><span class="comment">// host to network long 将长整型（32bit）的主机字节序数据转化为网络字节序数据</span></span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">htonl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> hostlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">htons</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> hostshort)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> <span class="title">ntohl</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> netlong)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> <span class="title">ntohs</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">short</span> <span class="keyword">int</span> netshort)</span></span>;</span><br></pre></td></tr></table></figure><p>长整型函数通常用来转换IP地址，短整型函数用来转换端口号。</p><h3 id="通用socket地址"><a href="#通用socket地址" class="headerlink" title="通用socket地址"></a>通用socket地址</h3><p>结构体sockaddr，定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family; <span class="comment">// 地址族类型，与协议族类型相对应</span></span><br><span class="line">    <span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 存放socket地址值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>常见协议族与对应的地址族的关系：</p><table><thead><tr><th align="center">协议族</th><th align="center">地址族</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">PF_UNIX</td><td align="center">AF_UNIX</td><td align="center">UNIX本地域协议族</td></tr><tr><td align="center">PF_INET</td><td align="center">AF_INET</td><td align="center">TCP/IPv4协议族</td></tr><tr><td align="center">PF_INET6</td><td align="center">AF_INET6</td><td align="center">TCP/IPv6协议族</td></tr></tbody></table><p>宏<code>PF_*</code>和<code>AF_*</code>都定义在<code>bits/socket.h</code>头文件中，且后者与前者有完全相同的值，所以二者通常混用。</p><p>不同的协议族的地址值具有不同的含义和长度。14字节的sa_data根本无法完全容纳多数协议族的地址值。因此，Linux定义了下面这个新的通用socket地址结构体：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜bits/socket.h＞</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_storage</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sa_family;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">long</span> int__ss_align;</span><br><span class="line">char__ss_padding[<span class="number">128</span>-<span class="built_in"><span class="keyword">sizeof</span></span>(__ss_align)]; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不仅提供了足够大的空间用于存放地址值，而且是内存对齐的（这是<code>__ss_align</code>成员的作用）</p><h3 id="专用socket地址"><a href="#专用socket地址" class="headerlink" title="专用socket地址"></a>专用socket地址</h3><p>Linux为各个协议族提供了专门的socket地址结构体。  </p><p>UNIX本地域协议族的专用socket地址<code>sockaddr_un</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/un.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_un</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_UNIX*/</span> </span><br><span class="line">    <span class="keyword">char</span> sun_path[<span class="number">108</span>];<span class="comment">/*文件路径名*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>TCP/IP协议族:<code>sockaddr_in</code>(IPV4)和<code>sockaddr_in6</code>(IPV6)地址结构体</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin_family;<span class="comment">/*地址族：AF_INET*/</span> </span><br><span class="line">    <span class="keyword">u_int16_t</span> sin_port;<span class="comment">/*端口号，要用网络字节序表示*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span><span class="comment">/*IPv4地址结构体，见下面*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> s_addr;<span class="comment">/*IPv4地址，要用网络字节序表示*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in6</span> &#123;</span></span><br><span class="line">    <span class="keyword">sa_family_t</span> sin6_family;<span class="comment">/*地址族：AF_INET6*/</span></span><br><span class="line">    <span class="keyword">u_int16_t</span> sin6_port;<span class="comment">/*端口号，要用网络字节序表示*/</span></span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_flowinfo;<span class="comment">/*流信息，应设置为0*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> <span class="title">sin6_addr</span>;</span><span class="comment">/*IPv6地址结构体，见下面*/</span> </span><br><span class="line">    <span class="keyword">u_int32_t</span> sin6_scope_id;<span class="comment">/*scope ID，尚处于实验阶段*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in6_addr</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> sa_addr[<span class="number">16</span>];<span class="comment">/*IPv6地址，要用网络字节序表示*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>所有专用socket地址（以及sockaddr_storage）类型的变量在实际使用时都需要转化为通用socket地址类型sockaddr（强制转换即可），因为所有socket编程接口使用的地址参数的类型都是sockaddr。 </p><h3 id="IP地址转换函数"><a href="#IP地址转换函数" class="headerlink" title="IP地址转换函数"></a>IP地址转换函数</h3><p>IPV4地址：点分十进制字符串<br>IPV6地址：十六进制字符串<br>编程中需要将他们转化为整数（二进制数）使用，记录日志则相反，需要由整数转化为可读的字符串。</p><p>用于用点分十进制字符串表示的IPv4地址和用网络字节序整数表示的IPv4地址之间的转换： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">in_addr_t</span> <span class="title">inet_addr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*strptr)</span></span>; </span><br><span class="line"><span class="comment">// 点分十进制字符串-&gt;网络字节序整数，失败返回INADDR_NONE</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>*cp,struct in_addr*inp)</span></span>; </span><br><span class="line"><span class="comment">// 功能与inet_addr相同，结果存在inp指向的地址结构（传出参数），成功返回1，失败返回0</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>*<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>;</span><br><span class="line"><span class="comment">// 网络字节序整数-&gt;点分十进制字符串。函数内部用一个静态变量存储转化结果，函数的返回值指向该静态内存</span></span><br><span class="line"><span class="comment">// inet_ntoa是不 可重入的，例如：</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span>* szValue1 = <span class="built_in">inet_ntoa</span>(“<span class="number">1.2</span><span class="number">.3</span><span class="number">.4</span>”); </span><br><span class="line"><span class="keyword">char</span>* szValue2 = <span class="built_in">inet_ntoa</span>(“<span class="number">10.194</span><span class="number">.71</span><span class="number">.60</span>”); </span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">1</span>:%s\n”, szValue1); </span><br><span class="line"><span class="built_in">printf</span>(“address <span class="number">2</span>:%s\n”, szValue2);</span><br><span class="line"><span class="comment">// 返回结果为：</span></span><br><span class="line"><span class="comment">// address1:10.194.71.60 </span></span><br><span class="line"><span class="comment">// address2:10.194.71.60</span></span><br></pre></td></tr></table></figure><p>更新函数适用于IPV4和IPV6：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜arpa/inet.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span>* src, <span class="keyword">void</span>* dst)</span></span>;</span><br><span class="line"><span class="comment">// 字符串IP地址src-&gt;网络字节序整数，结果存储在dst指向的内存中</span></span><br><span class="line"><span class="comment">// 参数af：指定地址族，AF_INET或者AF_INET6</span></span><br><span class="line"><span class="comment">// 成功返回1，失败返回0并设置errno</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span>* src, <span class="keyword">char</span>* dst,<span class="keyword">socklen_t</span> cnt)</span></span>;</span><br><span class="line"><span class="comment">// 网络字节序整数-&gt;字符串IP地址src，前三个参数与之前的函数相同</span></span><br><span class="line"><span class="comment">// 参数cnt：指定目标存储单元的大小，定义两个宏帮助指定大小（分别用于IPV4和IPV6）</span></span><br><span class="line"><span class="comment">// 成功返回目标存储单元的地址，失败返回NULL并设置errno</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netinet/in.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET_ADDRSTRLEN 16 </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INET6_ADDRSTRLEN 46</span></span><br></pre></td></tr></table></figure><h2 id="创建socket"><a href="#创建socket" class="headerlink" title="创建socket"></a>创建socket</h2><p>UNIX/Linux系统中：所有东西都是文件。<br>socket，可读可写、可控制、可关闭的文件描述符。<br>socket系统调用创建一个socket：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain,<span class="keyword">int</span> type,<span class="keyword">int</span> protocol)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">domain：底层的协议族。</span></span><br><span class="line"><span class="comment">PF_INET（IPv4）、 PF_INET6（IPv6）、PF_UNIX（本地域）</span></span><br><span class="line"><span class="comment">type：指定服务类型。</span></span><br><span class="line"><span class="comment">SOCK_STREAM（TCP）、SOCK_UGRAM（UDP）、SOCK_NONBLOCK（非阻塞的）、SOCK_CLOEXEC</span></span><br><span class="line"><span class="comment">protocol：选择协议，通常由前两个参数决定。</span></span><br><span class="line"><span class="comment">设置为0，使用默认协议</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回一个socket文件描述符，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="命名socket"><a href="#命名socket" class="headerlink" title="命名socket"></a>命名socket</h2><p>命名socket：将一个socket与socket地址绑定。<br>服务器程序中，命名后客户端才知道如何连接它。<br>命名socket的系统调用：bind函数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* my_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：未命名的sockfd文件描述符</span></span><br><span class="line"><span class="comment">my_addr：指向socket地址</span></span><br><span class="line"><span class="comment">addrlen：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">错误：</span></span><br><span class="line"><span class="comment">EACCES，被绑定的地址是受保护的地址，仅超级用户能够访问。</span></span><br><span class="line"><span class="comment">EADDRINUSE，被绑定的地址正在使用中。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="监听socket"><a href="#监听socket" class="headerlink" title="监听socket"></a>监听socket</h2><p>创建一个监听队列以存放待处理的客户连接，listen函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：指定被监听的socket</span></span><br><span class="line"><span class="comment">backlog：提示内核监听队列的最大长度。如果监听队列的长度超过backlog，服务器不受理新的客户连接，客户端收到ECONNREFUSED错误信息。backlog典型值为5</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>backlog函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-3testlisten.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">bool</span> stop = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">// SIGTERM信号的处理函数，触发时结束主程序中的循环</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_term</span><span class="params">( <span class="keyword">int</span> sig )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    stop = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testlisten函数接收三个参数：IP地址，端口号，backlog值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">signal</span>( SIGTERM, handle_term );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number backlog\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>]; <span class="comment">// ip地址</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ); <span class="comment">// 端口号</span></span><br><span class="line">    <span class="keyword">int</span> backlog = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] ); <span class="comment">// backlog值</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> ); <span class="comment">// 创建ipv4 socket文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">// 创建一个ipv4 socket地址</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr ); <span class="comment">// 字符串ip地址转化为网络字节序整数</span></span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port ); <span class="comment">// 主机字节序转化为网络字节序，短整型函数转化端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, backlog );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 循环等待连接，直到有SIGTERM信号将它中断</span></span><br><span class="line">    <span class="keyword">while</span> ( ! stop )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sleep</span>( <span class="number">1</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器程序testlisten，接受3个参数：IP地址，端口号，backlog值。<br>服务器运行该程序，客户端多次执行telnet命令连接该服务器程序。使用telnet建立连接，执行netstat命令查看服务器上连接的状态。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testlisten 192.168.1.109 12345 5<span class="comment">#监听12345端口，给backlog传递典型 值5</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">telnet 192.168.1.109 12345<span class="comment">#多次执行之</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 12345<span class="comment">#多次执行之</span></span></span><br></pre></td></tr></table></figure><p>在监听队列中，处于ESTABLISHED状态的连接只有6个（backlog值加1），其他的连接都处于SYN_RCVD状态。即完整连接最多有（backlog+1）个。在不同的系统上，运行结果会有些差别，不过监听队列中完整连接的上限通常比backlog值略大。</p><h2 id="接受连接"><a href="#接受连接" class="headerlink" title="接受连接"></a>接受连接</h2><p>从listen监听队列中接受一个连接，accept函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr*addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：执行过listen系统调用的监听socket（处于LISTEN状态的socket，而所有处于ESTABLISHED状态的socket则称为连接socket）</span></span><br><span class="line"><span class="comment">addr：获取被接受的远端socket地址</span></span><br><span class="line"><span class="comment">addrlen：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回一个新的连接socket，该socket唯一地标识了被接受的这个连接，服务器可通过读写该socket来与被接受连接对应的客户端通信；</span></span><br><span class="line"><span class="comment">失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>接受一个异常的连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-5testaccept.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>]; <span class="comment">// ipv4地址</span></span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] ); <span class="comment">// 端口号</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span> <span class="comment">// 创建socket地址结构体，传入ip地址和端口号</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> ); <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址结构体与socket文件描述符，命名socket</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> ); <span class="comment">// 监听socket</span></span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*暂停20秒以等待客户端连接和相关操作（掉线或者退出）完成*/</span> </span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">20</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span> <span class="comment">// 客户端socket地址结构体</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// accept接收连接调用，返回值connfd</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 接受连接成功，打印客户端地址和端口号</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭socket</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器运行testaccept程序，在客户端执行telnet命令连接该服务器的程序：<br>(服务器ip地址：192.168.1.109)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testaccept 192.168.1.109 54321<span class="comment">#监听54321端口</span></span></span><br><span class="line"><span class="meta">$</span><span class="bash">telnet 192.168.1.109 54321</span></span><br></pre></td></tr></table></figure><p>启动telnet客户端程序，立即断开该客户端的网络连接（建立和断开连接的过程要在服务器启动后20秒内完成）。结果发现accept调用能够正常返回，服务器输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">connected with ip:192.168.1.108 and port:38545</span><br></pre></td></tr></table></figure><p>服务器运行netstat命令查看accept返回socket连接的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 54321</span></span><br><span class="line">tcp 0 0 192.168.1.109:54321 192.168.1.108:38545 ESTABLISHED</span><br></pre></td></tr></table></figure><p>accept调用对于客户端网络断开毫不知情。重新执行上述过程，不过这次不断开客户端网络连接，而是在建立连接后立即退出客户端程序。这次accept调用同样正常返回。服务器运行netstat命令查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">netstat-nt|grep 54321</span></span><br><span class="line">tcp 1 0 192.168.1.109:54321 192.168.1.108:52070 CLOSE_WAIT</span><br></pre></td></tr></table></figure><p>由此可见，accept只是从监听队列中取出连接，而不论连接处于何种状态（如上面的ESTABLISHED状态和CLOSE_WAIT状态），更不关心任何网络状况的变化。</p><h2 id="发起连接"><a href="#发起连接" class="headerlink" title="发起连接"></a>发起连接</h2><p>服务器通过listen调用，被动接受连接；客户端通过connect调用，主动与服务器建立连接：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* serv_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：socket系统调用返回的socket文件描述符</span></span><br><span class="line"><span class="comment">serv_addr：服务器监听的socket地址</span></span><br><span class="line"><span class="comment">addrlen：指定地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，一旦成功建立连接，sockfd就唯一地标识了这个连接，客户端就可以通过读写sockfd来与服务器通信。失败返回-1并设置errno。</span></span><br><span class="line"><span class="comment">常见错误：</span></span><br><span class="line"><span class="comment">ECONNREFUSED：目标端口不存在，连接被拒绝</span></span><br><span class="line"><span class="comment">ETIMEDOUT：连接超时</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="关闭连接"><a href="#关闭连接" class="headerlink" title="关闭连接"></a>关闭连接</h2><p>关闭该连接所对应的socket，通过关闭普通文件描述符的系统调用完成：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜unistd.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数fd：待关闭的socket</span></span><br><span class="line"><span class="comment">close函数将fd的引用计数减1，只有当fd的引用计数为0时，才真正关闭连接。</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>多进程程序中，一次fork系统调用默认使父进程中打开的socket的引用计数加1，因此，必须在父进程和子进程中都对该socket执行close调用，才能将连接关闭。</p><p>如果无论如何都要立即终止连接（而不是将socket的引用计数减1），可以使用如下的shutdown系统调用（相对于close来说，它是专门为网络编程设计的）：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shutdown</span><span class="params">(<span class="keyword">int</span> sockfd,<span class="keyword">int</span> howto)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：待关闭的socket</span></span><br><span class="line"><span class="comment">howto：决定shutdown的行为，可选择：</span></span><br><span class="line"><span class="comment">SHUT_RD：关闭sockfd的读，应用程序无法对socket文件描述符执行读操作</span></span><br><span class="line"><span class="comment">SHUT_WR：关闭sockfd的写，应用程序无法对socket文件描述符指向写操作，连接处于半关闭状态</span></span><br><span class="line"><span class="comment">SHUT_RDWD：同时关闭sockfd上的读和写</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>shutdown能够分别关闭socket上的读或写，或者都关闭。而close在关闭连接时只能将socket上的读和写同时关闭。</p><h2 id="数据读写"><a href="#数据读写" class="headerlink" title="数据读写"></a>数据读写</h2><h3 id="TCP数据读写"><a href="#TCP数据读写" class="headerlink" title="TCP数据读写"></a>TCP数据读写</h3><p>对文件的读写操作read和write同样适用于socket。用于TCP流数据读写的系统调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recv</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">recv作用：读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要读取的sockfd文件描述符</span></span><br><span class="line"><span class="comment">buf：指定读缓冲区的位置（传出参数）</span></span><br><span class="line"><span class="comment">len：缓冲区大小</span></span><br><span class="line"><span class="comment">flags：通常设置为0</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">可能要多次调用recv，才能读取到完整的数据。</span></span><br><span class="line"><span class="comment">返回0表示通信对方已经关闭连接，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">send</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">send作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">sockfd：要写入数据的sockfd文件描述符</span></span><br><span class="line"><span class="comment">buf：指定读缓冲区的位置（传出参数）</span></span><br><span class="line"><span class="comment">len：缓冲区大小</span></span><br><span class="line"><span class="comment">flags：数据收发的额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>发送带外数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-6oobsend.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// ip地址与端口号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sockfd &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sockfd, ( struct sockaddr* )&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) ) &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connection failed\n&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 发起连接成功</span></span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;send oob data out\n&quot;</span> );</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* oob_data = <span class="string">&quot;abc&quot;</span>;</span><br><span class="line">        <span class="keyword">const</span> <span class="keyword">char</span>* normal_data = <span class="string">&quot;123&quot;</span>;</span><br><span class="line">        <span class="comment">// 写入数据发送</span></span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">send</span>( sockfd, oob_data, <span class="built_in">strlen</span>( oob_data ), MSG_OOB ); <span class="comment">// 发送或接受紧急数据</span></span><br><span class="line">        <span class="built_in">send</span>( sockfd, normal_data, <span class="built_in">strlen</span>( normal_data ), <span class="number">0</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接受带外数据：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-7oobrecv.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取ip地址与端口号</span></span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接受地址socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket文件描述符与socket地址信息</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// socket地址监听</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址结构体</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听的socket接受连接</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123; <span class="comment">// 接受连接成功</span></span><br><span class="line">        <span class="keyword">char</span> buffer[ BUF_SIZE ]; <span class="comment">// 缓冲区</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 读取socket中的数据，写入到buffer缓冲区中，打印缓冲区</span></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, MSG_OOB );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of oob data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUF_SIZE );</span><br><span class="line">        ret = <span class="built_in">recv</span>( connfd, buffer, BUF_SIZE<span class="number">-1</span>, <span class="number">0</span> );</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;got %d bytes of normal data &#x27;%s&#x27;\n&quot;</span>, ret, buffer );</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭socket</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在服务器上启动5-7oobrecv.cpp服务器程序testoobrecv，客户端执行5-6oobsend.cpp客户端程序testoobsend，向服务器发送带外数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./testoobrecv 192.168.1.109 54321 <span class="comment">#在Kongming20上执行服务器程序，监听 54321端口 $./testoobsend 192.168.1.109 54321 #在ernest-laptop上执行客户端程序</span></span> </span><br><span class="line"><span class="meta">$</span><span class="bash">sudo tcpdump-ntx-i eth0 port 54321</span></span><br></pre></td></tr></table></figure><p>服务器的输出如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">got 5 bytes of normal data&#x27;123ab&#x27; </span><br><span class="line">got 1 bytes of oob data&#x27;c&#x27; </span><br><span class="line">got 3 bytes of normal data&#x27;123&#x27;</span><br></pre></td></tr></table></figure><p>客户端发送给服务器的3字节的带外数据“abc”中，仅有最后一个字符“c”被服务器当成真正的带外数据接收。并且，服务器对正常数据的接收将被带外数据截断，即前一部分正常数据“123ab”和后续的正常数据“123”是不能被一个recv调用全部读出的。</p><h3 id="UDP数据读写"><a href="#UDP数据读写" class="headerlink" title="UDP数据读写"></a>UDP数据读写</h3><p>用于UDP数据报读写的系统调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/types.h＞ </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvfrom</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, struct sockaddr* src_addr, <span class="keyword">socklen_t</span>* addrlen)</span></span>; </span><br><span class="line"><span class="comment">/* recvfrom调用</span></span><br><span class="line"><span class="comment">作用：读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要读取的socket文件描述符</span></span><br><span class="line"><span class="comment">buf：指定缓冲区位置</span></span><br><span class="line"><span class="comment">len：缓冲区的大小</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">src_addr：获取发送端的socket的地址</span></span><br><span class="line"><span class="comment">addrlen：发送端socket地址的大小</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendto</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> len, <span class="keyword">int</span> flags, <span class="keyword">const</span> struct sockaddr* dest_addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br><span class="line"><span class="comment">/* sendto调用：</span></span><br><span class="line"><span class="comment">作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要写入数据的socket文件描述符</span></span><br><span class="line"><span class="comment">buf：指定缓冲区位置</span></span><br><span class="line"><span class="comment">len：缓冲区的大小</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">dest_addr：指定接收端的socket的地址</span></span><br><span class="line"><span class="comment">addrlen：接收端socket地址的大小</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p>recvfrom/sendto系统调用也可以用于面向连接（STREAM）的socket的数据读写，只需要把最后两个参数都设置为NULL以忽略发送端/接收端的socket地址（因为我们已经和对方建立了连接，所以已经知道其socket地址了）。</p><h3 id="通用数据读写函数"><a href="#通用数据读写函数" class="headerlink" title="通用数据读写函数"></a>通用数据读写函数</h3><p>不仅适用于TCP流数据，也能用于UDP数据报：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">recvmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr* msg, <span class="keyword">int</span> flags)</span></span>; </span><br><span class="line"><span class="comment">/* recvmsg调用：</span></span><br><span class="line"><span class="comment">作用：接收读取sockfd上的数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要读取的socket文件描述符</span></span><br><span class="line"><span class="comment">msg：指向msghdr结构体</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">ssize_t</span> <span class="title">sendmsg</span><span class="params">(<span class="keyword">int</span> sockfd, struct msghdr *msg, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：向sockfd上写入数据</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：要写入数据的socket文件描述符</span></span><br><span class="line"><span class="comment">msg：指向msghdr结构体</span></span><br><span class="line"><span class="comment">flags：额外控制</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// msghdr结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* msg_name; <span class="comment">/*socket地址*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_namelen; <span class="comment">/*socket地址的长度*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">iovec</span>* <span class="title">msg_iov</span>;</span> <span class="comment">/*分散的内存块，见后文*/</span> </span><br><span class="line">    <span class="keyword">int</span> msg_iovlen; <span class="comment">/*分散内存块的数量*/</span></span><br><span class="line">    <span class="keyword">void</span>* msg_control; <span class="comment">/*指向辅助数据的起始位置*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> msg_controllen; <span class="comment">/*辅助数据的大小*/</span></span><br><span class="line">    <span class="keyword">int</span> msg_flags; <span class="comment">/*复制函数中的flags参数，并在调用过程中更新*/</span> </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// iovec结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iovec</span> &#123;</span></span><br><span class="line">    <span class="keyword">void</span>* iov_base; <span class="comment">/*内存起始地址*/</span> </span><br><span class="line">    <span class="keyword">size_t</span> iov_len; <span class="comment">/*这块内存的长度*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>msghdr结构体中，msg_name成员指向一个socket地址结构变量。它指定通信对方的socket地址。对于面向连接的TCP协议，该成员没有意义，必须被设置为NULL。这是因为对数据流socket而言，对方的地址已经知道。</p><p>iovec结构体封装了一块内存的起始位置和长度。</p><p>分散读（scatter read）：recvmsg调用，数据将被读取并存放在msg_iovlen块分散的内存中，这些内存的位置和长度则由msg_iov指向的数组指定。</p><p>集中写（gather write）：sendmsg调用，msg_iovlen块分散内存中的数据将被一并发送。</p><p>msg_flags成员无须设定，它会复制recvmsg/sendmsg的flags参数的内容以影响数据读写过程。recvmsg还会在调用结束前，将某些更新后的标志设置到msg_flags中。</p><h2 id="带外标记"><a href="#带外标记" class="headerlink" title="带外标记"></a>带外标记</h2><p>内核通知应用进程带外数据抵达的两种方式：</p><ul><li>I/O复用产生的异常事件</li><li>SIGURG信号</li></ul><p>即使应用程序得到了有带外数据需要接收的通知，还需要知道带外数据在数据流中的具体位置，才能准确接收带外数据。使用sockatmark调用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sockatmark</span><span class="params">(<span class="keyword">int</span> sockfd)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：判断sockfd是否处于带外标记，即下一个被读取的数据是否是带外数据</span></span><br><span class="line"><span class="comment">参数fd：需要判断的socket文件描述符</span></span><br><span class="line"><span class="comment">返回值：若是带外数据，返回1，此时可以利用带MSG_OOB标志的recv调用来接收带外数据；若不是，返回0</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="地址信息函数"><a href="#地址信息函数" class="headerlink" title="地址信息函数"></a>地址信息函数</h2><p>获取一个连接socket的本端socket地址，以及远端的socket地址。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockname</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取sockfd对应的本端socket地址，存储在address指向的内存中。如果实际socket地址的长度大于address所指内存区的大小，那么该socket地址将被截断。</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：需要获取的socket文件描述符</span></span><br><span class="line"><span class="comment">address：指向socket地址结构体的指针，传出参数</span></span><br><span class="line"><span class="comment">address_len：socket地址的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getpeername</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* address, <span class="keyword">socklen_t</span>* address_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：获取sockfd对应的远端socket地址</span></span><br><span class="line"><span class="comment">参数，返回值的含义与getsockname调用的相同</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h2 id="socket选项"><a href="#socket选项" class="headerlink" title="socket选项"></a>socket选项</h2><p>读取和设置socket文件描述符属性的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span>* <span class="keyword">restrict</span> option_len)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：读取sockfd的属性</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockfd：指定被操作的目标socket文件描述符</span></span><br><span class="line"><span class="comment">level：指定要操作的协议属性（IPV4、IPV6、TCP等）</span></span><br><span class="line"><span class="comment">option_name：指定选项的名字，socket选项</span></span><br><span class="line"><span class="comment">option_value：被操作选项的值</span></span><br><span class="line"><span class="comment">option_len：被操作选项的长度</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功返回0，失败时返回-1并设置errno</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">setsockopt</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> level, <span class="keyword">int</span> option_name, <span class="keyword">const</span> <span class="keyword">void</span>* option_value, <span class="keyword">socklen_t</span> option_len)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">作用：设置sockfd的属性</span></span><br><span class="line"><span class="comment">参数，返回值：参照getsockopt调用</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/20220723/image-20220724232946013.png" alt="image-20220724232946013"></p><p>对于服务器，有部分socket选项只能在调用listen系统调用前针对监听socket设置才有效。因为连接socket只能由accept调用返回，而accept从listen监听队列中接受的连接至少已经完成了TCP三次握手的前两个步骤，这说明服务器已经往被接受连接上发送出了TCP同步报文段。但有的socket选项却应该在TCP同步报文段中设置，比如TCP最大报文段选项。</p><p>解决方法：对监听socket设置socket选项，那么accept返回的连接socket将自动继承这些选项。这些socket选项包括：SO_DEBUG、SO_DONTROUTE、SO_KEEPALIVE、SO_LINGER、SO_OOBINLINE、SO_RCVBUF、SO_RCVLOWAT、SO_SNDBUF、SO_SNDLOWAT、TCP_MAXSEG和TCP_NODELAY。</p><p>对于客户端，socket选项则应该在调用connect函数之前设置，因为connect调用成功返回之后，TCP三次握手已完成。</p><h3 id="SO-REUSEADDR选项"><a href="#SO-REUSEADDR选项" class="headerlink" title="SO_REUSEADDR选项"></a>SO_REUSEADDR选项</h3><p>服务器程序可以通过设置socket选项SO_REUSEADDR，来强制使用被处于TIME_WAIT状态的连接占用的socket地址。重用本地地址：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-9reuse_address.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">2</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建TCP socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="comment">// 设置socket属性为SO_REUSEADDR，重用本地地址</span></span><br><span class="line">    <span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="built_in"><span class="keyword">sizeof</span></span>( reuse ) );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket地址并绑定socket</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端接收socket地址，accept调用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功并打印</span></span><br><span class="line">        <span class="keyword">char</span> remote[INET_ADDRSTRLEN ];</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;connected with ip: %s and port: %d\n&quot;</span>, </span><br><span class="line">            <span class="built_in">inet_ntop</span>( AF_INET, &amp;client.sin_addr, remote, INET_ADDRSTRLEN ), <span class="built_in">ntohs</span>( client.sin_port ) );</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭服务器连接</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="SO-RCVBUF和SO-SNDBUF选项"><a href="#SO-RCVBUF和SO-SNDBUF选项" class="headerlink" title="SO_RCVBUF和SO_SNDBUF选项"></a>SO_RCVBUF和SO_SNDBUF选项</h3><p>SO_RCVBUF选项：TCP接收缓冲区的大小，最小值256字节<br>SO_SNDBUF选项：TCP发送缓冲区的大小，最小值2048字节<br>用setsockopt来设置TCP的接收缓冲区和发送缓冲区的大小时，系统都会将其值加倍，并且不得小于某个最小值。系统这样做的目的，主要是确保一个TCP连接拥有足够的空闲缓冲区来处理拥塞。</p><p>修改TCP发送缓冲区的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-10set_send_buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number send_bufer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 服务器socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">server_address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) );</span><br><span class="line">    server_address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;server_address.sin_addr );</span><br><span class="line">    server_address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置TCP发送缓冲区的大小</span></span><br><span class="line">    <span class="keyword">int</span> sendbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>( sendbuf );</span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, <span class="built_in"><span class="keyword">sizeof</span></span>( sendbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_SNDBUF, &amp;sendbuf, ( <span class="keyword">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the tcp send buffer size after setting is %d\n&quot;</span>, sendbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 主动发起连接成功</span></span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">connect</span>( sock, ( struct sockaddr* )&amp;server_address, <span class="built_in"><span class="keyword">sizeof</span></span>( server_address ) ) != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;a&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="built_in">send</span>( sock, buffer, BUFFER_SIZE, <span class="number">0</span> ); <span class="comment">// 发送数据</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改TCP接收缓存区的大小：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-11set_recv_buffer.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( argc &lt;= <span class="number">3</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;usage: %s ip_address port_number receive_buffer_size\n&quot;</span>, <span class="built_in">basename</span>( argv[<span class="number">0</span>] ) );</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span>* ip = argv[<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> port = <span class="built_in">atoi</span>( argv[<span class="number">2</span>] );</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">    <span class="built_in">bzero</span>( &amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    address.sin_family = AF_INET;</span><br><span class="line">    <span class="built_in">inet_pton</span>( AF_INET, ip, &amp;address.sin_addr );</span><br><span class="line">    address.sin_port = <span class="built_in">htons</span>( port );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sock = <span class="built_in">socket</span>( PF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line">    <span class="built_in">assert</span>( sock &gt;= <span class="number">0</span> );</span><br><span class="line">    <span class="keyword">int</span> recvbuf = <span class="built_in">atoi</span>( argv[<span class="number">3</span>] );</span><br><span class="line">    <span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>( recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置socket属性，设置接收缓冲区大小</span></span><br><span class="line">    <span class="built_in">setsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, <span class="built_in"><span class="keyword">sizeof</span></span>( recvbuf ) );</span><br><span class="line">    <span class="built_in">getsockopt</span>( sock, SOL_SOCKET, SO_RCVBUF, &amp;recvbuf, ( <span class="keyword">socklen_t</span>* )&amp;len );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;the receive buffer size after settting is %d\n&quot;</span>, recvbuf );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 绑定socket地址与socket文件描述符</span></span><br><span class="line">    <span class="keyword">int</span> ret = <span class="built_in">bind</span>( sock, ( struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 监听socket连接</span></span><br><span class="line">    ret = <span class="built_in">listen</span>( sock, <span class="number">5</span> );</span><br><span class="line">    <span class="built_in">assert</span>( ret != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 客户端socket地址</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">client</span>;</span></span><br><span class="line">    <span class="keyword">socklen_t</span> client_addrlength = <span class="built_in"><span class="keyword">sizeof</span></span>( client );</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 接收连接accept调用</span></span><br><span class="line">    <span class="keyword">int</span> connfd = <span class="built_in">accept</span>( sock, ( struct sockaddr* )&amp;client, &amp;client_addrlength );</span><br><span class="line">    <span class="keyword">if</span> ( connfd &lt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;errno is: %d\n&quot;</span>, errno );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;   <span class="comment">// 接收连接成功</span></span><br><span class="line">        <span class="keyword">char</span> buffer[ BUFFER_SIZE ];</span><br><span class="line">        <span class="built_in">memset</span>( buffer, <span class="string">&#x27;\0&#x27;</span>, BUFFER_SIZE );</span><br><span class="line">        <span class="keyword">while</span>( <span class="built_in">recv</span>( connfd, buffer, BUFFER_SIZE<span class="number">-1</span>, <span class="number">0</span> ) &gt; <span class="number">0</span> )&#123;&#125;</span><br><span class="line">        <span class="built_in">close</span>( connfd ); <span class="comment">// 关闭客户端连接</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">close</span>( sock ); <span class="comment">// 关闭本地连接</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务器端运行5-11set_recv_buffer.cpp（set_recv_buffer程序），在客户端上运行5-10set_send_buffer.cpp（set_send_buffer程序），客户端向服务器发送512字节的数据。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">./set_recv_buffer 192.168.1.108 12345 50<span class="comment">#将TCP接收缓冲区的大小设置为 50字节</span></span></span><br><span class="line">the tcp receive buffer size after settting is 256 </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash">./set_send_buffer 192.168.1.108 12345 2000<span class="comment">#将TCP发送缓冲区的大小设置 为2000字节</span></span> </span><br><span class="line">the tcp send buffer size after setting is 4000</span><br></pre></td></tr></table></figure><p>从服务器的输出来看，系统允许的TCP接收缓冲区最小为256字节。当我们设置TCP接收缓冲区的大小为50字节时，系统将忽略我们的设置。从客户端的输出来看，我们设置的TCP发送缓冲区的大小被系统增加了一倍。</p><h3 id="SO-RCVLOWAT和SO-SNDLOWAT选项"><a href="#SO-RCVLOWAT和SO-SNDLOWAT选项" class="headerlink" title="SO_RCVLOWAT和SO_SNDLOWAT选项"></a>SO_RCVLOWAT和SO_SNDLOWAT选项</h3><p>SO_RCVLOWAT选项：TCP接收缓冲区的低水位标记，可读数据总数大于其低水位标记，I/O复用系统调用将通知应用程序可以从对应的socket上读取数据。<br>SO_SNDLOWAT选项：TCP发送缓冲区的低水位标记，缓冲区的空闲空间（可写入数据的空间）大于其低水位标记，I/O复用系统调用将通知应用程序可以往对应的socke上写入数据。<br>一般被I/O复用系统调用，用来判断socket是否可读或可写</p><p>默认情况下，TCP接收缓冲区的低水位标记和TCP发送缓冲区的低水位标记均为1字节。 </p><h3 id="SO-LINGER选项"><a href="#SO-LINGER选项" class="headerlink" title="SO_LINGER选项"></a>SO_LINGER选项</h3><p>SO_LINGER选项：用于控制close系统调用在关闭TCP连接时的行为。</p><p>默认情况下，使用close系统调用来关闭一个socket时，close将立即返回，TCP模块负责把该socket对应的TCP发送缓冲区中残留的数据发送给对方。</p><p>设置（获取）SO_LINGER选项的值时，需要给setsockopt（getsockopt）系统调用传递一个linger类型的结构体，其定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜sys/socket.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">linger</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> l_onoff;<span class="comment">/*开启（非0）还是关闭（0）该选项*/</span> </span><br><span class="line">    <span class="keyword">int</span> l_linger;<span class="comment">/*滞留时间*/</span> </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>close系统调用可能产生的3种行为：</p><ul><li>l_onoff等于0。此时SO_LINGER选项不起作用，close用默认行为关闭socket。</li><li>l_onoff不为0，l_linger等于0。此时close系统调用立即返回，TCP模块将丢弃被关闭的socket对应的TCP发送缓冲区中残留的数据，同时给对方发送一个复位报文段。因此，这种情况给服务器提供了异常终止一个连接的方法。</li><li>l_onoff不为0，l_linger大于0。close的行为取决于两个条件： <ul><li>被关闭的socket对应的TCP发送缓冲区中是否还有残留的数据。</li><li>该socket是阻塞的，还是非阻塞的。<br>对于阻塞的socket，close将等待一段长为l_linger的时间，直到TCP模块发送完所有残留数据并得到对方的确认。如果这段时间内TCP模块没有发送完残留数据并得到对方的确认，那么close系统调用将返回-1并设置errno为EWOULDBLOCK。<br>如果socket是非阻塞的，close将立即返回，此时我们需要根据其返回值和errno来判断残留数据是否已经发送完毕。</li></ul></li></ul><h2 id="网络信息API"><a href="#网络信息API" class="headerlink" title="网络信息API"></a>网络信息API</h2><p>socket地址的两个要素，即IP地址和端口号，都是用数值表示的。这不便于记忆，也不便于扩展（比如从IPv4转移到IPv6）。可以用主机名来访问一台机器，而避免直接使用其IP地址，用服务名称来代替端口号。比如，下面两条telnet命令具有完全相同的作用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">telnet 127.0.0.1 80 </span><br><span class="line">telnet localhost www</span><br></pre></td></tr></table></figure><p>telnet客户端程序，通过调用某些网络信息API，来实现主机名到IP地址的转换，以及服务名称到端口号的转换。</p><h3 id="gethostbyname和gethostbyaddr"><a href="#gethostbyname和gethostbyaddr" class="headerlink" title="gethostbyname和gethostbyaddr"></a>gethostbyname和gethostbyaddr</h3><p>gethostbyname函数：根据主机名称获取主机的完整信息。通常先在本地的/etc/hosts配置文件中查找主机，如果没有找到，再去访问DNS服务器。<br>gethostbyaddr函数：根据IP地址获取主机的完整信息。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数name：指定目标主机的主机名</span></span><br><span class="line"><span class="comment">返回值：指向hostent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct hostent* <span class="title">gethostbyaddr</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span>* addr, <span class="keyword">size_t</span> len, <span class="keyword">int</span> type)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">addr：指定目标主机的IP地址</span></span><br><span class="line"><span class="comment">len：IP地址的长度</span></span><br><span class="line"><span class="comment">type：IP地址的类型，合法取值有AF_INET（用于IPv4地址）和AF_INET6（用于IPv6地址）</span></span><br><span class="line"><span class="comment">返回值：指向hostent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// hostnet结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* h_name; <span class="comment">/*主机名*/</span> </span><br><span class="line">    <span class="keyword">char</span>** h_aliases; <span class="comment">/*主机别名列表，可能有多个*/</span> </span><br><span class="line">    <span class="keyword">int</span> h_addrtype; <span class="comment">/*地址类型（地址族）*/</span> </span><br><span class="line">    <span class="keyword">int</span> h_length; <span class="comment">/*地址长度*/</span> </span><br><span class="line">    <span class="keyword">char</span>** h_addr_list <span class="comment">/*按网络字节序列出的主机IP地址列表*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="getservbyname和getservbyport"><a href="#getservbyname和getservbyport" class="headerlink" title="getservbyname和getservbyport"></a>getservbyname和getservbyport</h3><p>getservbyname函数：根据名称获取某个服务的完整信息。<br>getservbyport函数：根据端口号获取某个服务的完整信息。<br>它们实际上都是通过读取/etc/services文件来获取服务的信息的。这两个函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyname</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* name, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>; </span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">name：指定服务的名字</span></span><br><span class="line"><span class="comment">proto：指定服务类型</span></span><br><span class="line"><span class="comment">返回值：指向servent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function">struct servent* <span class="title">getservbyport</span><span class="params">(<span class="keyword">int</span> port, <span class="keyword">const</span> <span class="keyword">char</span>* proto)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">port：指定目标服务对应的端口号</span></span><br><span class="line"><span class="comment">proto：指定服务类型</span></span><br><span class="line"><span class="comment">返回值：指向servent结构体类型</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// servent结构体定义：</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span>* s_name; <span class="comment">/*服务名称*/</span></span><br><span class="line">    <span class="keyword">char</span>** s_aliases; <span class="comment">/*服务的别名列表，可能有多个*/</span></span><br><span class="line">    <span class="keyword">int</span> s_port; <span class="comment">/*端口号*/</span> </span><br><span class="line">    <span class="keyword">char</span>* s_proto; <span class="comment">/*服务类型,通常是tcp或者udp*/</span> &#125;;</span><br></pre></td></tr></table></figure><p>通过主机名和服务名来访问目标服务器上的daytime服务，以获取该机器的系统时间：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 5-12access_daytime.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netdb.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">assert</span>( argc == <span class="number">2</span> );</span><br><span class="line"><span class="keyword">char</span> *host = argv[<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取目标主机的地址信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hostent</span>* <span class="title">hostinfo</span> =</span> <span class="built_in">gethostbyname</span>( host );</span><br><span class="line"><span class="built_in">assert</span>( hostinfo );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取daytime服务信息</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">servent</span>* <span class="title">servinfo</span> =</span> <span class="built_in">getservbyname</span>( <span class="string">&quot;daytime&quot;</span>, <span class="string">&quot;tcp&quot;</span> );</span><br><span class="line"><span class="built_in">assert</span>( servinfo );</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;daytime port is %d\n&quot;</span>, <span class="built_in">ntohs</span>( servinfo-&gt;s_port ) );</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建socket地址</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">address</span>;</span></span><br><span class="line">address.sin_family = AF_INET;</span><br><span class="line">address.sin_port = servinfo-&gt;s_port;</span><br><span class="line"><span class="comment">// 因为h_addr_list本身是使用网络字节序的地址列表，所以使用其中的IP地址时，无须对目标IP地址转换字节序</span></span><br><span class="line">address.sin_addr = *( struct in_addr* )*hostinfo-&gt;h_addr_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建socket文件描述符，主动发起连接</span></span><br><span class="line"><span class="keyword">int</span> sockfd = <span class="built_in">socket</span>( AF_INET, SOCK_STREAM, <span class="number">0</span> );</span><br><span class="line"><span class="keyword">int</span> result = <span class="built_in">connect</span>( sockfd, (struct sockaddr* )&amp;address, <span class="built_in"><span class="keyword">sizeof</span></span>( address ) );</span><br><span class="line"><span class="built_in">assert</span>( result != <span class="number">-1</span> );</span><br><span class="line"></span><br><span class="line"><span class="keyword">char</span> buffer[<span class="number">128</span>];</span><br><span class="line">result = <span class="built_in">read</span>( sockfd, buffer, <span class="built_in"><span class="keyword">sizeof</span></span>( buffer ) );</span><br><span class="line"><span class="built_in">assert</span>( result &gt; <span class="number">0</span> );</span><br><span class="line">buffer[ result ] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"><span class="built_in">printf</span>( <span class="string">&quot;the day item is: %s&quot;</span>, buffer );</span><br><span class="line"><span class="built_in">close</span>( sockfd );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注：以上讨论的4个函数都是不可重入的，即非线程安全的。不过netdb.h头文件给出了它们的可重入版本。这些函数的函数名是在原函数名尾部加上_r（re-entrant）。</p><h3 id="getaddrinfo"><a href="#getaddrinfo" class="headerlink" title="getaddrinfo"></a>getaddrinfo</h3><p>getaddrinfo函数：既能通过主机名获得IP地址（内部使用的是gethostbyname函数），也能通过服务名获得端口号（内部使用的是getservbyname函数）。<br>是否可重入取决于其内部调用的gethostbyname和getservbyname函数是否是它们的可重入版本。该函数的定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getaddrinfo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* hostname, <span class="keyword">const</span> <span class="keyword">char</span>* service, <span class="keyword">const</span> struct addrinfo* hints, struct addrinfo** result)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">hostname：可以接收主机名，也可接收字符串表示的IP地址。</span></span><br><span class="line"><span class="comment">service：可以接收服务名，也可以接收字符串表示的十进制端口号。</span></span><br><span class="line"><span class="comment">hints：应用程序给getaddrinfo的一个提示，以对getaddrinfo的输出进行更精确的控制。</span></span><br><span class="line"><span class="comment">可以设置为NULL，表示允许getaddrinfo反馈任何可用的结果。</span></span><br><span class="line"><span class="comment">result：指向一个链表，存储getaddrinfo反馈的结果（传出参数）。</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// addrinfo结构体定义：</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> ai_flags; <span class="comment">/*标志位，可以按位与*/</span></span><br><span class="line">    <span class="keyword">int</span> ai_family; <span class="comment">/*地址族*/</span> </span><br><span class="line">    <span class="keyword">int</span> ai_socktype; <span class="comment">/*服务类型，SOCK_STREAM或SOCK_DGRAM*/</span></span><br><span class="line">    <span class="keyword">int</span> ai_protocol; <span class="comment">/*具体的网络协议，通常设置为0*/</span> </span><br><span class="line">    <span class="keyword">socklen_t</span> ai_addrlen; <span class="comment">/*socket地址ai_addr的长度*/</span> </span><br><span class="line">    <span class="keyword">char</span>* ai_canonname; <span class="comment">/*主机的别名*/</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span>* <span class="title">ai_addr</span>;</span> <span class="comment">/*指向socket地址*/</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">ai_next</span>;</span> <span class="comment">/*指向下一个sockinfo结构的对象*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="/20220723/image-20220725111725849.png" alt="image-20220725111725849"></p><p>使用hints参数的时候，可以设置其ai_flags，ai_family，ai_socktype和ai_protocol四个字段，其他字段则必须被设置为NULL。</p><p>利用hints参数获取主机ernest-laptop上的“daytime”流服务信息：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span> <span class="title">hints</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">addrinfo</span>* <span class="title">res</span>;</span></span><br><span class="line"><span class="built_in">bzero</span>(＆hints, <span class="built_in"><span class="keyword">sizeof</span></span>(hints)); </span><br><span class="line">hints.ai_socktype = SOCK_STREAM;</span><br><span class="line"><span class="built_in">getaddrinfo</span>(<span class="string">&quot;ernest-laptop&quot;</span>, <span class="string">&quot;daytime&quot;</span>, ＆hints, ＆res);</span><br></pre></td></tr></table></figure><p> getaddrinfo将隐式地分配堆内存（可以通过valgrind等工具查看），因为res指针原本是没有指向一块合法内存的，所以，getaddrinfo调用结束后，我们必须使用如下配对函数来释放这块内存： </p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">freeaddrinfo</span><span class="params">(struct addrinfo* res)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="getnameinfo"><a href="#getnameinfo" class="headerlink" title="getnameinfo"></a>getnameinfo</h3><p>getnameinfo函数：通过socket地址同时获得以字符串表示的主机名（内部使用的是gethostbyaddr函数）和服务名（内部使用的是getservbyport函数）。函数定义如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞ </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getnameinfo</span><span class="params">(<span class="keyword">const</span> struct sockaddr* sockaddr, <span class="keyword">socklen_t</span> addrlen, <span class="keyword">char</span>* host, <span class="keyword">socklen_t</span> hostlen, <span class="keyword">char</span>* serv, <span class="keyword">socklen_t</span> servlen, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">参数：</span></span><br><span class="line"><span class="comment">sockaddr：socket地址结构体</span></span><br><span class="line"><span class="comment">addrlen：socket地址长度</span></span><br><span class="line"><span class="comment">host：存储主机名</span></span><br><span class="line"><span class="comment">hostlen：主机名长度</span></span><br><span class="line"><span class="comment">serv：存储服务名</span></span><br><span class="line"><span class="comment">servlen：服务名长度</span></span><br><span class="line"><span class="comment">flags：控制getnameinfo的行为</span></span><br><span class="line"><span class="comment">返回值：</span></span><br><span class="line"><span class="comment">成功时返回0，失败则返回错误码</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><p><img src="/20220723/image-20220725112716763.png" alt="image-20220725112716763"></p><p><img src="/20220723/image-20220725112747241.png" alt="image-20220725112747241"></p><p>Linux下strerror函数能将数值错误码errno转换成易读的字符串形式。同样，下面的函数可将表5-8中的错误码转换成其字符串形式：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span>＜netdb.h＞</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">gai_strerror</span><span class="params">(<span class="keyword">int</span> error)</span></span>;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Linux网络编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试金典题解</title>
      <link href="/posts/e017732d/"/>
      <url>/posts/e017732d/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="数组与字符串"><a href="#数组与字符串" class="headerlink" title="数组与字符串"></a>数组与字符串</h2><h3 id="1-1-确定字符互异"><a href="#1-1-确定字符互异" class="headerlink" title="1.1 确定字符互异"></a>1.1 确定字符互异</h3><p>描述：</p><p>给定一个字符串string str，请返回一个bool值,<strong>True</strong>代表字符串的所有字符全都不同，<strong>False</strong>代表存在相同的字符。保证字符串中的字符为ASCII字符且不允许使用额外的存储结构，字符串的长度小于等于3000。大小写字母算不同的字符</p><p>测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;aeiou&quot;</span><br><span class="line">返回：True</span><br><span class="line">&quot;BarackObama&quot;</span><br><span class="line">返回：False</span><br></pre></td></tr></table></figure><p>假设不使用额外的数据结构。</p><p>解法：</p><p>假定字符集为ASCII，若字符串的长度大于字母表的字符个数，直接返回false；字母表一共只有256个字符。<br>构建一个布尔值的数组，索引值i对应的标记该字符串是否含有字母表的第i个字符。若这个字符第二次出现，返回false。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkDifferent</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() &gt; <span class="number">256</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">char_set</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> val = str[i];</span><br><span class="line">        <span class="keyword">if</span> (char_set[val]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 这个字符已在字符串中出现过</span></span><br><span class="line">        char_set[val] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-原串翻转"><a href="#1-2-原串翻转" class="headerlink" title="1.2 原串翻转"></a>1.2 原串翻转</h3><p>描述：</p><p>给定一个string <strong>iniString</strong>，请返回一个string，为该字符串翻转后的结果。要求不使用额外数据结构和储存空间，可以使用单个过程变量，保证字符串的长度小于等于5000。</p><p>测试样例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;This is nowcoder&quot;</span><br><span class="line">返回：&quot;redocwon si sihT&quot;</span><br></pre></td></tr></table></figure><p>解法：</p><p>不分配额外空间，直接就地翻转字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">reverseString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (iniString.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> iniString;</span><br><span class="line">    <span class="keyword">char</span> tmp;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = iniString.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123; <span class="comment">// 字符串首尾开始交换两个字符，直至两个指针在中间碰头</span></span><br><span class="line">        tmp = iniString[i];</span><br><span class="line">        iniString[i++] = iniString[j];</span><br><span class="line">        iniString[j--] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> iniString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-3-确定两串乱序同构"><a href="#1-3-确定两串乱序同构" class="headerlink" title="1.3 确定两串乱序同构"></a>1.3 确定两串乱序同构</h3><p>描述：</p><p>给定string <strong>stringA</strong>和string <strong>stringB</strong>，编写程序确认两字符串包含的字符是否完全相同，注意大小写为不同字符，且考虑字符串中的空格，返回一个bool，代表两串是否由一样的字符组成。保证两串的长度都小于等于5000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：&quot;This is nowcoder&quot;,&quot;is This nowcoder&quot;</span><br><span class="line">返回值：true</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;Here you are&quot;,&quot;Are you here&quot;</span><br><span class="line">返回值：false</span><br></pre></td></tr></table></figure><p>注：变位词区分大小写，空白也考虑在内。比较两个如果长度不同，就不可能是变位词。</p><p>解法1：排序字符串</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (stringA.<span class="built_in">size</span>() != stringB.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">sort</span>(stringA.<span class="built_in">begin</span>(), stringA.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">sort</span>(stringB.<span class="built_in">begin</span>(), stringB.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> stringA == stringB;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：检查两个字符串的各字符数是否相等</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkSam</span><span class="params">(string stringA, string stringB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (stringA.<span class="built_in">size</span>() != stringB.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">letters</span><span class="params">(<span class="number">256</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : stringA) &#123;</span><br><span class="line">        letters[c]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> d : stringB) &#123;</span><br><span class="line">        letters[d]--;</span><br><span class="line">        <span class="keyword">if</span> (letters[d] &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-4-空格替换"><a href="#1-4-空格替换" class="headerlink" title="1.4 空格替换"></a>1.4 空格替换</h3><p>描述：</p><p>给定一个string <strong>iniString</strong> 及其长度 int <strong>len</strong>, 已知该字符串中有空格，现要求编写程序将字符串中空格替换为“%20”。返回更改后的string。假设该字符串有足够的空间存放新增的字符，并且知道原字符的长度(小于等于1000)，同时保证字符串由大小写的英文字母组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：&quot;Mr John Smith&quot;,13</span><br><span class="line">返回值：&quot;Mr%20John%20Smith&quot;</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;Hello  World&quot;,12</span><br><span class="line">返回值：&quot;Hello%20%20World&quot;</span><br></pre></td></tr></table></figure><p>解法：</p><p>处理字符串操作问题，常用做法是从字符串尾部开始编辑，从后向前反向操作。因为字符串尾部有额外的缓存，可以直接修改，不必担心会覆写原来的数据。</p><p>两次扫描，一次先数出字符串中有多少空格，从而算出最终的字符串的长度；第二次扫描反向编辑字符串。检测到空格将%20复制到下一个位置，若不是空白，就复制原来的字符。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">replaceSpace</span><span class="params">(string iniString, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>, newLength = <span class="number">0</span>, i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == <span class="string">&#x27; &#x27;</span>) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    newLength = length + <span class="number">2</span> * count;</span><br><span class="line">    <span class="function">string <span class="title">res</span><span class="params">(newLength, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = length - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == <span class="string">&#x27; &#x27;</span>) &#123;</span><br><span class="line">            res[newLength - <span class="number">1</span>] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            res[newLength - <span class="number">2</span>] = <span class="string">&#x27;2&#x27;</span>;</span><br><span class="line">            res[newLength - <span class="number">3</span>] = <span class="string">&#x27;%&#x27;</span>;</span><br><span class="line">            newLength -= <span class="number">3</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res[newLength - <span class="number">1</span>] = iniString[i];</span><br><span class="line">            newLength--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-5-基本字符串压缩"><a href="#1-5-基本字符串压缩" class="headerlink" title="1.5 基本字符串压缩"></a>1.5 基本字符串压缩</h3><p>描述：</p><p>现给定一个string iniString字符串(长度小于等于10000)，请按连续重复字母压缩的方式将该字符串压缩，返回结果为string，比如，字符串“aabbcccccaaa”经压缩会变成“a2b2c5a3”，若压缩后的字符串没有变短，则返回原先的字符串。注意保证串内字符均由大小写英文字母组成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">示例1</span><br><span class="line">输入：&quot;aabcccccaaa&quot;</span><br><span class="line">返回值：&quot;a2b1c5a3&quot;</span><br><span class="line"></span><br><span class="line">示例2</span><br><span class="line">输入：&quot;welcometonowcoderrrrr&quot;</span><br><span class="line">返回值：&quot;welcometonowcoderrrrr&quot;</span><br><span class="line"></span><br><span class="line">说明：welcometonowcoderrrrr转换成重复字母压缩的结果是w1e1l1c1o1m1e1t1o1n1o1w1c1o1d1e1r5，比原字符串的长度还要长，所以返回原先的字符串。 </span><br></pre></td></tr></table></figure><p>解法：</p><p>加入压缩长度检查，算出压缩后的长度，构建相应大小的字符串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">zipString</span><span class="params">(string iniString)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> size = <span class="built_in">countCompression</span>(iniString);</span><br><span class="line">    <span class="keyword">if</span> (size &gt;= iniString.<span class="built_in">size</span>()) <span class="keyword">return</span> iniString;</span><br><span class="line">    <span class="function">string <span class="title">res</span><span class="params">(size, <span class="string">&#x27; &#x27;</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">1</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">char</span> last = iniString[<span class="number">0</span>];</span><br><span class="line">    res[<span class="number">0</span>] = last;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; iniString.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (iniString[i] == last) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = iniString[i];</span><br><span class="line">            string tmp = <span class="built_in">to_string</span>(count);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">char</span> d : tmp) &#123;</span><br><span class="line">                res[index++] = d;</span><br><span class="line">            &#125;</span><br><span class="line">            res[index++] = last;</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    string tmp = <span class="built_in">to_string</span>(count);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> d : tmp) &#123;</span><br><span class="line">        res[index++] = d;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countCompression</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (str.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> last = str[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> size = <span class="number">0</span>, count = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (str[i] == last) &#123;</span><br><span class="line">            count++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            last = str[i];</span><br><span class="line">            size += <span class="number">1</span> + <span class="built_in">to_string</span>(count).<span class="built_in">size</span>();</span><br><span class="line">            count = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    size += <span class="number">1</span> + <span class="built_in">to_string</span>(count).<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">return</span> size;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-6-像素翻转"><a href="#1-6-像素翻转" class="headerlink" title="1.6 像素翻转"></a>1.6 像素翻转</h3><p>描述：</p><p>现有一个NxN的矩阵，阶数为N，请编写一个算法将矩阵顺时针旋转90度并将其作为返回值。要求不使用缓存矩阵，保证N不大于500，元素不大于256，每个元素用int表示。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[[1,2,3],[4,5,6],[7,8,9]],3</span><br><span class="line">返回：[[7,4,1],[8,5,2],[9,6,3]]</span><br></pre></td></tr></table></figure><p>解法：</p><p>按索引一个一个进行交换，从最外层开始逐渐向里，在每一层进行交换。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">transformImage</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> layer = <span class="number">0</span>; layer &lt; n / <span class="number">2</span>; layer++) &#123;</span><br><span class="line">        <span class="keyword">int</span> first = layer, last = n - <span class="number">1</span> - layer;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = first; i &lt; last; i++) &#123;</span><br><span class="line">            <span class="keyword">int</span> offset = i - first;</span><br><span class="line">            <span class="comment">// 存储上边</span></span><br><span class="line">            <span class="keyword">int</span> top = mat[first][i];</span><br><span class="line">            mat[first][i] = mat[last - offset][first]; <span class="comment">// 左到上</span></span><br><span class="line">            mat[last - offset][first] = mat[last][last - offset]; <span class="comment">// 下到左</span></span><br><span class="line">            mat[last][last - offset] = mat[i][last]; <span class="comment">// 右到下</span></span><br><span class="line">            mat[i][last] = top; <span class="comment">// 上到右</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-7-清除行列"><a href="#1-7-清除行列" class="headerlink" title="1.7 清除行列"></a>1.7 清除行列</h3><p>描述：给定一个N阶方阵<code>int[][]</code>(C++中为<code>vector&lt;vector&gt;&lt;int&gt;&gt;</code>)<strong>mat</strong>及其阶数<strong>n</strong>，若方阵中某个元素为0，则将其所在的行与列清零。返回改变后的<code>int[][]</code>方阵(C++中为<code>vector&lt;vector&gt;&lt;int&gt;&gt;</code>)，保证n小于等于300，矩阵中的元素在nt范围内。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[[1,2,3],[0,1,2],[0,0,1]]</span><br><span class="line">返回：[[0,0,3],[0,0,0],[0,0,0]]</span><br></pre></td></tr></table></figure><p>解法：</p><p>避免陷阱将矩阵所有元素清零。用两个数组记录包含零的所有行与列，第二次遍历矩阵时，若所在行或列标记为零，则将元素清零。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">clearZero</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; mat, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">row</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">col</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mat[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                row[i] = <span class="literal">true</span>;</span><br><span class="line">                col[j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (row[i] || col[j]) &#123;</span><br><span class="line">                mat[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mat;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-8-翻转子串"><a href="#1-8-翻转子串" class="headerlink" title="1.8 翻转子串"></a>1.8 翻转子串</h3><p>描述：</p><p>给定2个字符串s1和s2，请判断s2是否为s1旋转而成，返回bool值。字符串中字符为英文字母和空格，区分大小写，字符串长度小于等于1000。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&quot;Hello world&quot;,&quot;worldhello &quot;</span><br><span class="line">返回：false</span><br><span class="line">&quot;waterbottle&quot;,&quot;erbottlewat&quot;</span><br><span class="line">返回：true</span><br></pre></td></tr></table></figure><p>解法：</p><p>假定s2由s1旋转而成，将s1划分为两部分：x和y，满足xy = s1和yx = s2.无论分割点在哪里，yx肯定是xyxy的子串，即s2为s1s1的子串。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkReverseEqual</span><span class="params">(string s1, string s2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = s1.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (len == s2.<span class="built_in">size</span>() &amp;&amp; len &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        string s1s1 = s1 + s1;</span><br><span class="line">        <span class="keyword">if</span> (s1s1.<span class="built_in">find</span>(s2) != <span class="number">-1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><h3 id="2-1-访问单个节点的删除"><a href="#2-1-访问单个节点的删除" class="headerlink" title="2.1 访问单个节点的删除"></a>2.1 访问单个节点的删除</h3><p>描述：</p><p>编写代码，移除未排序链表中的重复节点。<br>进阶：不使用临时缓冲区</p><p>解法：</p><p>使用散列表，直接迭代访问整个链表，将每个节点加入散列表，若发现重复元素，将该节点从链表中删除，然后继续迭代。一次扫描完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(ListNode* n)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    ListNode* pre = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">while</span> (n != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.<span class="built_in">find</span>(n-&gt;val) != map.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            pre-&gt;next = n-&gt;next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            map[n-&gt;val] = <span class="number">1</span>;</span><br><span class="line">            pre = n;</span><br><span class="line">        &#125;</span><br><span class="line">        n = n-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶：不使用缓冲区。<br>用两个指针来迭代：current迭代访问整个链表，runner用于检查后续的节点是否重复。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">deleteDups</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    ListNode* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除后续值相同的节点</span></span><br><span class="line">        ListNode* runner = current;</span><br><span class="line">        <span class="keyword">while</span> (runner-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (runner-&gt;next-&gt;val == current-&gt;val) &#123;</span><br><span class="line">                runner-&gt;next = runner-&gt;next-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                runner = runner-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 空间复杂度O(1), 时间复杂度O(N^2)</span></span><br></pre></td></tr></table></figure><h3 id="2-2-倒数第k个节点"><a href="#2-2-倒数第k个节点" class="headerlink" title="2.2 倒数第k个节点"></a>2.2 倒数第k个节点</h3><p>描述：</p><p>实现一个算法，找出单向链表中倒数第K个节点。</p><p>解法1：链表长度已知</p><p>若链表长度已知，那么倒数第k个节点就是第(length - k)个节点，直接迭代访问即可，比较简单。</p><p>解法2：递归</p><p>递归访问整个链表，当抵达链表末端时，该方法回传一个置为零的计数器，之后每次调用都会计数器加一。当计数器等于k时，表示访问的是倒数第k个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">nthToLast</span><span class="params">(ListNode* head, <span class="keyword">int</span> k, <span class="keyword">int</span>&amp; i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* node = <span class="built_in">nthToLast</span>(head-&gt;next, k, i);</span><br><span class="line">    i++;</span><br><span class="line">    <span class="keyword">if</span> (i == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ListNode* l1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">10</span>);</span><br><span class="line">    l1 = <span class="built_in">fun</span>(l1);</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    ListNode* node = <span class="built_in">nthToLast</span>(l1, <span class="number">3</span>, i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-删除某个节点"><a href="#2-3-删除某个节点" class="headerlink" title="2.3 删除某个节点"></a>2.3 删除某个节点</h3><p>描述：</p><p>实现一个算法，删除单向链表中间的某个节点，假定只能访问该节点。</p><p>解法：</p><p>访问不到链表的首节点，只能访问待删除节点。解法很简单，直接将后继节点的数据复制到当前节点，然后删除该节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">deleteNode</span><span class="params">(ListNode* n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="literal">nullptr</span> || n-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* next = n-&gt;next;</span><br><span class="line">    n-&gt;val = next-&gt;val;</span><br><span class="line">    n-&gt;next = next-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> next;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意，若待删除节点为链表的尾节点，则这个问题无解。</p><h3 id="2-4-链表分割"><a href="#2-4-链表分割" class="headerlink" title="2.4 链表分割"></a>2.4 链表分割</h3><p>描述：</p><p>现有一链表的头指针 ListNode* <strong>pHead</strong>，给一定值x，以x为基准将链表分割成两部分，编写一段代码将所有小于x的结点排在其余结点之前，且不能改变原来的数据顺序，返回重新排列后的链表的头指针。</p><p>解法：</p><p>不必移动和交换元素，直接创建两个链表，一个链表存储小于x的元素，一个链表存储大于等于x的元素。迭代访问整个链表，将元素插入before或after链表中。一旦抵达链表末端，表面拆分完成，最后合并两个链表。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">partition</span><span class="params">(ListNode* pHead, in</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// write code here</span></span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* beforeStart = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* beforeEnd = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* afterStart = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* afterEnd = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">    ListNode* cur = pHead;</span></span></span><br><span class="line"><span class="params"><span class="function">    </span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 分割链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        ListNode* next = cur-&gt;next; <span class="comment">// 临时变量记录后继结点</span></span></span></span><br><span class="line"><span class="params"><span class="function">        cur-&gt;next = <span class="literal">nullptr</span>;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">if</span> (cur-&gt;val &lt; x) &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="comment">// 将节点插入before链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (beforeStart == <span class="literal">nullptr</span>)</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeStart = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd-&gt;next = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                beforeEnd = beforeEnd-&gt;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="comment">// 将节点插入after链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">            <span class="keyword">if</span> (afterStart == <span class="literal">nullptr</span>) </span></span></span><br><span class="line"><span class="params"><span class="function">                afterStart = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125; <span class="keyword">else</span> &#123;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd-&gt;next = cur;</span></span></span><br><span class="line"><span class="params"><span class="function">                afterEnd = afterEnd-&gt;ne</span></span></span><br><span class="line"><span class="params"><span class="function">            &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">        cur = next;</span></span></span><br><span class="line"><span class="params"><span class="function">    &#125;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">if</span> (beforeStart == <span class="literal">nullptr</span>) <span class="keyword">return</span> afterStart;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="comment">// 合并链表</span></span></span></span><br><span class="line"><span class="params"><span class="function">    beforeEnd-&gt;next = afterStart;</span></span></span><br><span class="line"><span class="params"><span class="function">    <span class="keyword">return</span> beforeStart;</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;</span></span></span><br></pre></td></tr></table></figure><h3 id="2-5-链式A-B"><a href="#2-5-链式A-B" class="headerlink" title="2.5 链式A+B"></a>2.5 链式A+B</h3><p>描述：</p><p>将两个反向存储在链表中的整数求和（即整数的个位存放在了链表首部，一位数对应一个节点），返回的结果仍用链表形式。给定两个链表ListNode* <strong>A</strong>，ListNode* <strong>B</strong>，请返回A+B的结果(ListNode*)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&#123;1,2,3&#125;,&#123;3,2,1&#125;</span><br><span class="line">返回：&#123;4,4,4&#125;</span><br><span class="line">&#123;7,1,6&#125;,&#123;5,9,2&#125;</span><br><span class="line">返回：&#123;2,1,9&#125;</span><br></pre></td></tr></table></figure><p>解法：</p><p>递归模拟，两个节点的值相加，如有进位则转入下一节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">addList</span>(a, b, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">ListNode* <span class="title">addList</span><span class="params">(ListNode* a, ListNode* b, <span class="keyword">int</span> carry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span> &amp;&amp; carry == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">int</span> val = carry;</span><br><span class="line">    <span class="keyword">if</span> (a != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val += a-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        val += b-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">    res-&gt;val = val % <span class="number">10</span>;</span><br><span class="line">    ListNode* more = <span class="built_in">addList</span>(a == <span class="literal">nullptr</span> ? <span class="literal">nullptr</span> : a-&gt;next, b == <span class="literal">nullptr</span> ?</span><br><span class="line">                             <span class="literal">nullptr</span> : b-&gt;next, val &gt;= <span class="number">10</span> ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    res-&gt;next = more;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代遍历：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">plusAB</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode* haha = b;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        b-&gt;val += a-&gt;val;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;val &gt;= <span class="number">10</span>) &#123;</span><br><span class="line">            b-&gt;val %= <span class="number">10</span>;</span><br><span class="line">            <span class="keyword">if</span> (b-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">                b-&gt;next = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                b-&gt;next-&gt;val++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (b-&gt;next == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            b-&gt;next = a-&gt;next;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> haha;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-6-有环链表的环路开头节点"><a href="#2-6-有环链表的环路开头节点" class="headerlink" title="2.6 有环链表的环路开头节点"></a>2.6 有环链表的环路开头节点</h3><p>描述：</p><p>给定一个有环链表，实现一个算法返回环路的开头节点。</p><p>解法：</p><ul><li>创建两个指针：fast和slow；</li><li>slow每走1步，fast走2步；</li><li>两者碰在一起时，将slow指向链表的头节点head，fast保持不变</li><li>以相同的速度移动slow和fast，一次走1步，返回新的碰撞处。</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findBeginning</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = head;</span><br><span class="line">    ListNode* fast = head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 找出第一次相遇的位置</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast) <span class="keyword">break</span>;<span class="comment">// 碰撞</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 错误检查：没有碰撞即没有环路</span></span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast-&gt;next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// slow指向链表首部，fast不变，直到第二次相遇</span></span><br><span class="line">    slow = head;</span><br><span class="line">    <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回环路起始点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-回文链表"><a href="#2-7-回文链表" class="headerlink" title="2.7 回文链表"></a>2.7 回文链表</h3><p>描述：编写一个函数，检查链表是否为回文。 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">&#123;1,2,3,2,1&#125;</span><br><span class="line">返回：true</span><br><span class="line">&#123;1,2,3,2,3&#125;</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure><p>解法1：反转并比较</p><p>反转整个链表，然后比较反转链表和原始链表。若两者相同，则该链表为回文。<br>注意，在比较原始链表和反转链表时，其实只需比较链表的前半部分。若原始链表和反转链表的前半部分相同，那么，两者的后半部分肯定相同。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    ListNode* revered = <span class="built_in">reverseList</span>(pHead);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isEqual</span>(pHead, revered);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* res = <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode* cur = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        ListNode* n = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">        n-&gt;next = res;</span><br><span class="line">        res = n;</span><br><span class="line">        cur = cur-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isEqual</span><span class="params">(ListNode* a, ListNode* b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (a != <span class="literal">nullptr</span> &amp;&amp; b != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a-&gt;val != b-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        a = a-&gt;next;</span><br><span class="line">        b = b-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a == <span class="literal">nullptr</span> &amp;&amp; b == <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：迭代法</p><p>将链表前半部分反转，利用栈来实现。<br>入栈有两种方式，若链表长度已知：可以用for循环迭代访问前半部分节点，将每个节点入栈；<br>若链表长度未知，使用快慢指针，迭代访问链表，在快指针到达链表尾部时，慢指针刚好在链表中间位置。<br>至此，栈里就存放了链表前半部分的所有节点，不过顺序是相反的。接下来，只需迭代访问链表余下节点。每次迭代时，比较当前节点和栈顶元素，若完成迭代时比较结果完全相同，则该链表是回文序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    ListNode* slow = pHead;</span><br><span class="line">    ListNode* fast = pHead;</span><br><span class="line"></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; st;</span><br><span class="line"><span class="comment">// 链表前半部分元素入栈，偶数个节点fast最后指向nullptr，奇数个节点fast最后指向最后一个节点</span></span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        st.<span class="built_in">push</span>(slow-&gt;val);</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">        fast = fast-&gt;next-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 奇数个节点，跳过中间节点</span></span><br><span class="line">    <span class="keyword">if</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (slow != <span class="literal">nullptr</span> &amp;&amp; !st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = st.<span class="built_in">top</span>();</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="comment">// 判断回文</span></span><br><span class="line">        <span class="keyword">if</span> (top != slow-&gt;val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        slow = slow-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法3：递归法</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ListNode* myLeft = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">    myLeft = pHead;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">tranverse</span>(pHead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">tranverse</span><span class="params">(ListNode* right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(right == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;       </span><br><span class="line">    <span class="keyword">bool</span> res = <span class="built_in">tranverse</span>(right-&gt;next);       </span><br><span class="line">    res = (res &amp;&amp; right-&gt;val == myLeft-&gt;val);</span><br><span class="line">    myLeft = myLeft-&gt;next;                  </span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><h3 id="3-1-三合一"><a href="#3-1-三合一" class="headerlink" title="3.1 三合一"></a>3.1 三合一</h3><p>描述：</p><p>如何只用一个数组来实现三个栈。</p><p>解法：</p><p>固定分割：将整个数组三等分，并将每个栈的增长限制在各自的空间里。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedMultiStack</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">int</span> numberOfStacks = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> stackCapacity;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; values;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; sizes;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FixedMultiStack</span>(<span class="keyword">int</span> stackSize) : <span class="built_in">stackCapacity</span>(stackSize) &#123;</span><br><span class="line">        values.<span class="built_in">resize</span>(stackSize * numberOfStacks);</span><br><span class="line">        sizes.<span class="built_in">resize</span>(numberOfStacks);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将值压入栈</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> stackNum, <span class="keyword">int</span> value)</span> throws FullStackException </span>&#123; </span><br><span class="line"><span class="comment">/* 检查有空间容纳下一个元素 */</span> </span><br><span class="line"><span class="keyword">if</span> (<span class="built_in">isFull</span>(stackNum)) &#123; </span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">FullStackException</span>(); </span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line">        <span class="comment">/* 对栈顶指针加 1 并更新顶部的值 */</span> </span><br><span class="line">        sizes[stackNum]++; </span><br><span class="line">        values[<span class="built_in">indexOfTop</span>(stackNum)] = value; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 出栈</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isEmpty</span>(stackNum)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">EmptyStackException</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> topIndex = <span class="built_in">indexOfTop</span>(stackNum);</span><br><span class="line">        <span class="keyword">int</span> value = values[topIndex]; <span class="comment">// 获取顶部元素</span></span><br><span class="line">        values[topIndex] = <span class="number">0</span>; <span class="comment">// 清零</span></span><br><span class="line">        sizes[stackNum]--; <span class="comment">// 缩减大小</span></span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否为空</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isEmpty</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizes[stackNum] == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查栈是否已满</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isFull</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sizes[stackNum] == stackCapacity;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回栈顶元素索引</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">IndexOfTop</span><span class="params">(<span class="keyword">int</span> stackNum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> offset = stackNum * stackCapacity;</span><br><span class="line">        <span class="keyword">int</span> size = sizes[stackNum];</span><br><span class="line">        <span class="keyword">return</span> offset + size - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-2-栈的最小值"><a href="#3-2-栈的最小值" class="headerlink" title="3.2 栈的最小值"></a>3.2 栈的最小值</h3><p>描述：</p><p>请设计一个栈，除了 pop 与 push 函数，还支持 min 函数，其可返回栈元素中的最小值。执行 push、pop 和 min 操作的时间复杂度必须为O(1)。</p><p>解法：</p><p>每个节点记录当前最小值。这么一来，要找到 min，直接查看栈顶元素就能得到最小值。缺点是栈很大时，每个元素都要记录min，会浪费大量空间。改进：用其他的栈来记录。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StackWithMin</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1; <span class="comment">// 数据栈</span></span><br><span class="line">    satck&lt;<span class="keyword">int</span>&gt; s2; <span class="comment">// 辅助栈</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (val &lt;= <span class="built_in">min</span>()) &#123;</span><br><span class="line">            s2.<span class="built_in">push</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">push</span>(val);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val = s1.<span class="built_in">top</span>();</span><br><span class="line">        <span class="keyword">if</span> (val == <span class="built_in">min</span>()) &#123;</span><br><span class="line">            s2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">min</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> INT_MAX;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="3-3-集合栈"><a href="#3-3-集合栈" class="headerlink" title="3.3 集合栈"></a>3.3 集合栈</h3><p>描述：</p><p>请实现一种数据结构SetOfStacks，由多个大小为size的栈组成，当前一个栈填满时，则新建一个栈，且也可以与普通栈一样拥有相同的push和pop操作。<br>现给定一个操作序列<code>int[][2] </code>ope(C++为<code>vector&lt;vector&lt;int&gt;&gt;</code>)，若执行push操作则第一个数为1，第二个数为应push的数字；若执行pop操作，则第一个数为2，第二个数为空。返回值为int[]<a href="C++%E4%B8%BA%60vector%3Cvector%3Cint%3E%3E%60"></a>，即为变动后的SetOfStacks，顺序从下到上，初始SetOfStacks为空，并保证数据合法。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">setOfStacks</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; ope, <span class="keyword">int</span> size) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = ope.<span class="built_in">size</span>();</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; ans;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (ope[i][<span class="number">0</span>] == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">empty</span>() || ans.<span class="built_in">back</span>().<span class="built_in">size</span>() == size) &#123;</span><br><span class="line">                ans.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">push_back</span>(ope[i][<span class="number">1</span>]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ans.<span class="built_in">back</span>().<span class="built_in">pop_back</span>();</span><br><span class="line">            <span class="keyword">if</span> (ans.<span class="built_in">back</span>().<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                ans.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-4-双栈排序"><a href="#3-4-双栈排序" class="headerlink" title="3.4 双栈排序"></a>3.4 双栈排序</h3><p>描述：</p><p>给定一个<code>int[] numbers</code>(C++中为<code>vector&lt;int&gt;</code>)，其中第一个元素为栈顶，请编写程序将栈进行升序排列（即<strong>最大元素位于栈顶</strong>），返回排序后的栈。要求最多使用一个额外的栈存放临时数据，但不得将元素复制到别的数据结构中。并注意这是一个栈，意味着排序过程中只能访问到最后一个元素。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">返回：[5,4,3,2,1]</span><br></pre></td></tr></table></figure><p>解法：</p><p>s1为原先的栈，s2为最终排好序的栈，若要对s1排序，可以从s1逐一弹出元素，然后按顺序插入s2中。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">twoStacksSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; numbers)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : numbers) &#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(num);</span><br><span class="line">    &#125;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">    <span class="keyword">while</span> (!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="comment">// 把s1中的每个元素有序地插入到tmp中</span></span><br><span class="line">        <span class="keyword">int</span> top = s1.<span class="built_in">top</span>();</span><br><span class="line">        s1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>() &amp;&amp; tmp.<span class="built_in">top</span>() &gt; top) &#123;</span><br><span class="line">            s1.<span class="built_in">push</span>(tmp.<span class="built_in">top</span>());</span><br><span class="line">            tmp.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        tmp.<span class="built_in">push</span>(top);</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    <span class="comment">// 将tmp中元素复制回s</span></span><br><span class="line">    <span class="keyword">while</span> (!tmp.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> top = tmp.<span class="built_in">top</span>();</span><br><span class="line">        s1.<span class="built_in">push</span>(top);</span><br><span class="line">        res.<span class="built_in">push_back</span>(top);</span><br><span class="line">        tmp.<span class="built_in">pop</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="树与图"><a href="#树与图" class="headerlink" title="树与图"></a>树与图</h2><h3 id="4-1-二叉树平衡检查"><a href="#4-1-二叉树平衡检查" class="headerlink" title="4.1 二叉树平衡检查"></a>4.1 二叉树平衡检查</h3><p>描述：</p><p>平衡的定义如下，已知对于树中的任意一个结点，若其两颗子树的高度差不超过1，则我们称该树平衡。现给定指向树根结点的指针<code>TreeNode* root</code>，请编写函数返回一个bool，表示该二叉树是否平衡。</p><p>解法：</p><p>递归访问整棵树，计算每个节点的两个子树的高度。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">struct TreeNode &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    struct TreeNode *left;</span></span><br><span class="line"><span class="comment">    struct TreeNode *right;</span></span><br><span class="line"><span class="comment">    TreeNode(int x) :</span></span><br><span class="line"><span class="comment">            val(x), left(NULL), right(NULL) &#123;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;;*/</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">int</span> diff = <span class="built_in">getHeight</span>(root-&gt;left) - <span class="built_in">getHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(diff) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 递归</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">isBalance</span>(root-&gt;left) &amp;&amp; <span class="built_in">isBalance</span>(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 计算树的高度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root -&gt; left), <span class="built_in">getHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：<code>getHeight</code>函数不仅可以检查高度，还能检查这棵树是否平衡。从根节点递归向下检查每棵子树的高度，设计<code>checkHeight</code>函数，若子树平衡返回子树的实际高度，若子树不平衡返回-1并中断执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBalance</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">checkHeight</span>(root) == <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">checkHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 高度为0</span></span><br><span class="line">    <span class="comment">// 检查左子树是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> leftHeight = <span class="built_in">checkHeight</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">if</span> (leftHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 检查右子树是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> rightHeight = <span class="built_in">checkHeight</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">if</span> (rightHeight == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 检查当前节点是否平衡</span></span><br><span class="line">    <span class="keyword">int</span> diff = leftHeight - rightHeight;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(diff) &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>; <span class="comment">// 不平衡</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(leftHeight, rightHeight) + <span class="number">1</span>; <span class="comment">// 返回高度</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-2-高度最小的BST"><a href="#4-2-高度最小的BST" class="headerlink" title="4.2 高度最小的BST"></a>4.2 高度最小的BST</h3><p>描述：</p><p>给定一个元素各不相同的有序序列int[] vals（升序排列）,请编写算法创建一棵高度最小的二叉查找树，并返回二叉查找树的高度。</p><p>解法：</p><p>递归方法创建高度最小的BST。将数组中间位置的元素插入树中，数组左半部分插入左子树，数组右半部分插入右子树，递归处理。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">buildMinimalBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vals)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    TreeNode* root = <span class="built_in">createMinBST</span>(vals, <span class="number">0</span>, vals.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">getHeight</span>(root);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">TreeNode* <span class="title">createMinBST</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; vals, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (end &lt; start) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    TreeNode* n = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(vals[mid]);</span><br><span class="line">    n-&gt;left = <span class="built_in">createMinBST</span>(vals, start, mid - <span class="number">1</span>);</span><br><span class="line">    n-&gt;right = <span class="built_in">createMinBST</span>(vals, mid + <span class="number">1</span>, end);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 终止条件</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(<span class="built_in">getHeight</span>(root -&gt; left), <span class="built_in">getHeight</span>(root-&gt;right)) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-3-输出单层节点"><a href="#4-3-输出单层节点" class="headerlink" title="4.3 输出单层节点"></a>4.3 输出单层节点</h3><p>描述：</p><p>已知二叉树的根结点指针TreeNode* root以及链表上结点的深度，请设计算法返回一个链表ListNode，该链表代表该深度上所有结点的值，并按树上从左往右的顺序链接，深度不能超过树的高度，且树上结点的值为不大于100000的非负整数。</p><p>解法：</p><p>广度优先遍历，从根节点开始迭代，处于第i层时，表明访问过第i-1层的所有节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">getTreeLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> dep)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    queue&lt;TreeNode*&gt; q;</span><br><span class="line">    ListNode* node = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">    ListNode* res = node;</span><br><span class="line">    q.<span class="built_in">push</span>(root);</span><br><span class="line">    <span class="keyword">int</span> deep = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        <span class="keyword">int</span> len = q.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">            TreeNode* cur = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span> (deep == dep - <span class="number">1</span>) &#123;</span><br><span class="line">                ListNode* tmp = <span class="keyword">new</span> <span class="built_in">ListNode</span>(cur-&gt;val);</span><br><span class="line">                node-&gt;next = tmp;</span><br><span class="line">                node = node-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;left) q.<span class="built_in">push</span>(cur-&gt;left);</span><br><span class="line">            <span class="keyword">if</span> (cur-&gt;right) q.<span class="built_in">push</span>(cur-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">        deep++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-4-检查是否为BST"><a href="#4-4-检查是否为BST" class="headerlink" title="4.4 检查是否为BST"></a>4.4 检查是否为BST</h3><p>描述：</p><p>现给定树的根结点指针TreeNode* <strong>root</strong>，编辑函数返回一个bool值，判断该树是否为二叉查找树。</p><p>解法：</p><p>假定没有重复的值，可以采用中序遍历。BST中序遍历结果为递增序列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr;</span><br><span class="line">    <span class="built_in">process</span>(arr, root);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i<span class="number">-1</span>] &gt; arr[i]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 中序遍历BST</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">process</span>(arr, root-&gt;left);</span><br><span class="line">    arr.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">    <span class="built_in">process</span>(arr, root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法二：最小与最大法</p><p>二叉搜索树的条件：所有左边的节点必须小于或等于当前节点，而当前节点必须小于所有右边的节点。<br>迭代遍历整个树，自上而下传递最小与最大值，逐渐变窄的范围检查各个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">checkBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, INT_MIN, INT_MAX);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(TreeNode* root, <span class="keyword">int</span> minval, <span class="keyword">int</span> maxval)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val &lt; minval || root-&gt;val &gt; maxval) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left, minval, root-&gt;val) &amp;&amp; </span><br><span class="line">        <span class="built_in">check</span>(root-&gt;right, root-&gt;val, maxval);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-5-寻找下一个节点"><a href="#4-5-寻找下一个节点" class="headerlink" title="4.5 寻找下一个节点"></a>4.5 寻找下一个节点</h3><p>描述：</p><p>给定树的根结点指针TreeNode* root和结点的值int p，编写一个函数，寻找该二叉树中指定结点的下一个结点（即中序遍历的后继），并返回p结点的后继结点的值。保证结点的值是小于等于100000的正数且没有重复值，若不存在后继返回-1。</p><p>解法：</p><p>递归中序遍历。当节点值等于p，标记为true，返回遍历的下一个节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSucc</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">bool</span> sign = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findSuccCore</span>(root, p, sign);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findSuccCore</span><span class="params">(TreeNode* root, <span class="keyword">int</span> p, <span class="keyword">bool</span>&amp; sign)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 左子树中寻找</span></span><br><span class="line">    <span class="keyword">int</span> left = <span class="built_in">findSuccCore</span>(root-&gt;left, p, sign);</span><br><span class="line">    <span class="keyword">if</span> (left != <span class="number">-1</span>) <span class="keyword">return</span> left;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (sign == <span class="literal">true</span>) <span class="keyword">return</span> root-&gt;val;</span><br><span class="line">    <span class="comment">// 当前值等于p，将标记置为true</span></span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val == p) sign = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">findSuccCore</span>(root-&gt;right, p, sign);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-6-最近公共祖先"><a href="#4-6-最近公共祖先" class="headerlink" title="4.6 最近公共祖先"></a>4.6 最近公共祖先</h3><p>描述：</p><p>设计并实现一个算法，找出二叉树中某两个节点的第一个共同祖先。不得将其他的节点存储在另外的数据结构中。注意：这不一定是二叉搜索树。</p><p>解法：</p><p>顺着一条 p 和 q 都在同一边的链子查找，也就是说，若 p 和 q 都在某节点的左边，就到左子树中查找共同祖先，若都在右边，则在右子树中查找共同祖先。要是 p 和 q不在同一边，那就表示已经找到第一个共同祖先。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">commonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 错误检查，一个节点不在树中</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">cover</span>(root, p) || !<span class="built_in">cover</span>(root, q)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(root, p, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">helper</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span> || root == p || root == q) &#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">bool</span> pIsOnLeft = <span class="built_in">cover</span>(root-&gt;left, p);</span><br><span class="line">    <span class="keyword">bool</span> pIsOnRight = <span class="built_in">cover</span>(root-&gt;right, q);</span><br><span class="line">    <span class="keyword">if</span> (pIsOnLeft != pIsOnRight) &#123; <span class="comment">// 两个节点位于不同的两边</span></span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode* childSize = pIsOnLeft ? root-&gt;left : root-&gt;right;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">helper</span>(childSize, p, q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 检查函数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cover</span><span class="params">(TreeNode* root, TreeNode* p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (root == p) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">cover</span>(root-&gt;left, p) || <span class="built_in">cover</span>(root-&gt;right, p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="4-7-求和路径"><a href="#4-7-求和路径" class="headerlink" title="4.7 求和路径"></a>4.7 求和路径</h3><p>描述：</p><p>给定一棵二叉树，其中每个节点都含有一个整数数值（该值或正或负）。设计一个算法，打印节点数值总和等于某个给定值的所有路径。注意，路径不一定非得从二叉树的根节点或叶节点开始或结束，但是其方向必须向下（只能从父节点指向子节点方向）。</p><p>解法1：暴力解法</p><p>遍历每个节点。对于每个节点，用递归法尝试所有向下的路径，并随着递归的进行跟踪路径的和。每当得到目标和，将发现的路径数目加一。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 从root开始，符合目标和的路径进行计数</span></span><br><span class="line">    <span class="keyword">int</span> pathFromRoot = <span class="built_in">countPathWithSumFromRoot</span>(root, target, <span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 左节点与右节点</span></span><br><span class="line">    <span class="keyword">int</span> pathFromLeft = <span class="built_in">countPathWithSum</span>(root-&gt;left, target);</span><br><span class="line">    <span class="keyword">int</span> pathFromRight = <span class="built_in">countPathWithSum</span>(root-&gt;right, target);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> pathFromRoot + pathFromLeft + pathFromRight;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回从根节点开始，符合目标和的路径总数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSumFromRoot</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    sum += node-&gt;val;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> totalPath = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123; <span class="comment">// 找到一条从root开始的路径</span></span><br><span class="line">        totalPath++;</span><br><span class="line">    &#125;</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSumFromRoot</span>(node-&gt;left, target, sum);</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSumFromRoot</span>(node-&gt;right, target, sum);</span><br><span class="line">    <span class="keyword">return</span> totalPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解法2：优化算法</p><p>使用哈希表减少重复计算。使用深度优先查找对树进行遍历。当我们访问每个节点时，执行以下操作。(1) 跟踪 runningSum 的值。我们将使该变量成为函数的一个参数，并对其增加 node.value。<br>(2) 在散列表中查找 runningSum - targetSum。我们从散列表获得的值为路径的总数。将变量 totalPaths 的值设置为该值。<br>(3) 如果 runningSum == targetSum，则发现了另外一条从根节点开始的路径。将变量 totalPaths加 1。<br>(4) 将 runningSum 加入到散列表中（如果 runningSum 已经存在，则将增加其值）。<br>(5) 对左子树和右子树进行递归，计算和为 targetSum 的路径的条数。<br>(6) 对左子树和右子树的递归调用结束后，减少散列表中 runningSum 对应的值。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPathWithSum</span><span class="params">(TreeNode* root, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; map;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(root, target, <span class="number">0</span>, map);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(TreeNode* node, <span class="keyword">int</span> target, <span class="keyword">int</span> sum, unordered_map&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&amp; map)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">// 基础情况</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 对终止于该节点，符合目标和的路径进行计数</span></span><br><span class="line">    sum += node-&gt;val;</span><br><span class="line">    <span class="keyword">int</span> diff = sum - target;</span><br><span class="line">    <span class="comment">//map[diff] = 0;</span></span><br><span class="line">    <span class="keyword">int</span> totalPath = map[diff];</span><br><span class="line">    <span class="keyword">if</span> (sum == target) &#123;</span><br><span class="line">        totalPath++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    map[sum]++;</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSum</span>(node-&gt;left, target, sum, map);</span><br><span class="line">    totalPath += <span class="built_in">countPathWithSum</span>(node-&gt;right, target, sum, map);</span><br><span class="line">    map[sum]--;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> totalPath;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归与动态规划"><a href="#递归与动态规划" class="headerlink" title="递归与动态规划"></a>递归与动态规划</h2><h3 id="5-1-加到n"><a href="#5-1-加到n" class="headerlink" title="5.1 加到n"></a>5.1 加到n</h3><p>描述：</p><p>给定一个正整数int <strong>n</strong>，从0开始加到n，每次可增加1、2或3，直到其大于等于n，请返回一个数，代表加到n的方案的个数。保证n小于等于100000，并为了防止溢出，请将结果Mod 1000000007。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">测试样例1：</span><br><span class="line">1</span><br><span class="line">返回：1</span><br><span class="line">测试样例2：</span><br><span class="line">3</span><br><span class="line">返回：4</span><br><span class="line">测试样例3：</span><br><span class="line">4</span><br><span class="line">返回：7</span><br></pre></td></tr></table></figure><p>解法：</p><p>暴力解求解：递归，指数级增长，会超时。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">countWays</span>(n - <span class="number">1</span>) + <span class="built_in">countWays</span>(n - <span class="number">2</span>) + <span class="built_in">countWays</span>(n - <span class="number">3</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>改进：制表法，利用memo数组记录中间过程的值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">memo</span><span class="params">(n + <span class="number">1</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">    <span class="comment">//memo[1] = 1;</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">countWaysCore</span>(n, memo);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWaysCore</span><span class="params">(<span class="keyword">int</span> n, vector&lt;<span class="keyword">int</span>&gt;&amp; memo)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (memo[n] &gt; <span class="number">-1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        memo[n] = ((<span class="built_in">countWaysCore</span>(n - <span class="number">1</span>, memo)  </span><br><span class="line">                    + <span class="built_in">countWaysCore</span>(n - <span class="number">2</span>, memo))% <span class="number">1000000007</span></span><br><span class="line">                   + <span class="built_in">countWaysCore</span>(n - <span class="number">3</span>, memo))% <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">return</span> memo[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-2-机器人走方格I"><a href="#5-2-机器人走方格I" class="headerlink" title="5.2 机器人走方格I"></a>5.2 机器人走方格I</h3><p>描述：</p><p>给定两个正整数int <strong>x</strong>,int <strong>y</strong>，代表一个x乘y的网格，现有一个机器人要从网格左上角顶点走到右下角，每次只能走一步且只能向右或向下走，返回机器人有多少种走法。保证x＋y小于等于12。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">2,2</span><br><span class="line">返回：2</span><br></pre></td></tr></table></figure><p>解法：</p><p>假设网格r行c列，移动到(r, c), 需要先移动到相邻点(r-1, c)或(r, c-1)。<br>动态规划，用一个二维表dp记录每个点的走法，<code>dp[r][c] = dp[r - 1][c] + dp[r][c - 1]</code>.<br>需要注意边界的情况。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> dp[x + <span class="number">1</span>][y + <span class="number">1</span>];</span><br><span class="line">    <span class="comment">//dp[1][1] = 1;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        dp[i][<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= y; j++) &#123;</span><br><span class="line">        dp[<span class="number">1</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">2</span>; j &lt;= y; j++) &#123;</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j] + dp[i][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x][y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-3-机器人走方格II"><a href="#5-3-机器人走方格II" class="headerlink" title="5.3 机器人走方格II"></a>5.3 机器人走方格II</h3><p>描述：</p><p>给定一个int[][] <strong>map</strong>(C++ 中为vector &gt;)网格图，若map[i][j]为1则该点不是障碍点，否则为障碍点。另外给定int <strong>x</strong>,int <strong>y</strong>，表示网格的大小。现有一个机器人要从网格左上角走到右下角，只能走格点且只能向右或向下走。请返回机器人从(0,0)走到(x - 1,y - 1)有多少种走法。请将结果Mod 1000000007以防止溢出，并保证x和y均小于等于50。</p><p>解法：</p><p>动态规划，建立dp表存储中间结果，如果<code>map[r][c]</code>值不为1，则<code>dp[r][c] = 0</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countWays</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; map, <span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(x, vector&lt;<span class="keyword">int</span>&gt;(y, <span class="number">0</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[i][<span class="number">0</span>] != <span class="number">1</span>) &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; y; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map[<span class="number">0</span>][j] != <span class="number">1</span>) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; x; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; y; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (map[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                dp[i][j] = (dp[i<span class="number">-1</span>][j] + dp[i][j<span class="number">-1</span>]) % <span class="number">1000000007</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                dp[i][j] = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[x - <span class="number">1</span>][y - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-魔术索引"><a href="#5-4-魔术索引" class="headerlink" title="5.4 魔术索引"></a>5.4 魔术索引</h3><p>描述：</p><p>已知数组<strong>A</strong>[0..n-1]和数组大小<strong>n</strong>（升序数组，元素值各不相同），若存在A[i]=i则称该数组有魔术索引，请判断该数组是否存在魔术索引，返回值为bool，要求复杂度优于o(n)。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[1,2,3,4,5]</span><br><span class="line">返回：false</span><br></pre></td></tr></table></figure><p>解法：</p><p>有序数组，二分查找，要找出元素k，会先拿它跟数组中间的元素 x比较，确定k位于x的左边还是右边。递归二分查找：（数组中没有重复的值）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findMagicIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; mid)&#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, start, mid - <span class="number">1</span>); </span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, end); </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进阶：数组中有重复的值，判断是否存在魔术索引。</p><p>解法：如果数组元素有重复值，前面的算法就会失效。如果 A[mid] &lt; mid，我们无法断定魔术索引位于数组哪一边。它可能在数组右侧，也可能在左侧。<br>二分递归：（也适用于不存在重复的值，暴力解法）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">findMagicIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(A, <span class="number">0</span>, A.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start &gt; end) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = start + (end - start) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[mid] == mid) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, start, mid - <span class="number">1</span>) || <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, end); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-5-子集"><a href="#5-5-子集" class="headerlink" title="5.5 子集"></a>5.5 子集</h3><p>描述：</p><p>已知数组<strong>A</strong>和其大小<strong>n</strong>，请返回A的所有非空子集。要求A中元素个数不大于20且互异。各子集内部从大到小排序,子集间字典逆序排序。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">测试样例：</span><br><span class="line">[123,456,789]</span><br><span class="line">返回：&#123;[789,456,123],[789,456],[789,123],[789],[456 123],[456],[123]&#125;</span><br></pre></td></tr></table></figure><p>解法：</p><p>递归，path记录中间过程。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; <span class="built_in">getSubsets</span>(vector&lt;<span class="keyword">int</span>&gt; A, <span class="keyword">int</span> n) &#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="built_in">sort</span>(A.<span class="built_in">begin</span>(), A.<span class="built_in">end</span>(),[](<span class="keyword">int</span> a, <span class="keyword">int</span> b) &#123;<span class="keyword">return</span> a &gt; b;&#125;);</span><br><span class="line">    <span class="comment">// res.clear();</span></span><br><span class="line">    <span class="comment">// path.clear();</span></span><br><span class="line">    <span class="built_in">recur</span>(A, <span class="number">0</span>);</span><br><span class="line">    <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">recur</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!path.<span class="built_in">empty</span>()) res.<span class="built_in">push_back</span>(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (index &gt;= arr.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = arr.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= index; i--) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">        <span class="built_in">recur</span>(arr, i + <span class="number">1</span>);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>C++并发编程笔记</title>
      <link href="/posts/20a59019/"/>
      <url>/posts/20a59019/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="1-并发"><a href="#1-并发" class="headerlink" title="1.并发"></a>1.并发</h1><p>并发，指两个或两个以上的独立活动同时发生。</p><p>计算机的并发，指在单个系统里同时执行多个独立的任务。</p><p>并发的两种方式：真正并行 vs 任务切换</p><p><img src="/20220627/1-1.png" alt="1-1"></p><p>四个任务在双核处理器上的任务切换，仍是将任务整齐地划分为同等大小子任务块的理想情况。实际上，许多因素会使得任务分割不均或调度不规则。</p><p><img src="/20220627/1-2.png" alt="1-2"></p><p>四个任务在两个核心之间的切换</p><h2 id="并发的方式"><a href="#并发的方式" class="headerlink" title="并发的方式"></a>并发的方式</h2><ul><li>多进程并发</li><li>多线程并发</li></ul><p><strong>多进程并发：</strong>将应用程序分为多个独立的进程同时运行，就像同时进行网页浏览和文字处理一样。</p><p>独立的进程可以通过进程间的通信渠道传递讯息(信号、套接字、文件、管道等等)。</p><p><img src="/20220627/1-3.png" alt="1-3"></p><p>缺点：</p><ul><li>进程间的通信非常复杂，速度很慢，因为操作系统会对进程进行保护，以避免一个进程去修改另一个进程的数据。</li><li>运行多个进程的固定开销大：需要时间启动进程，操作系统需要资源来管理进程等等。</li></ul><p><strong>多线程并发：</strong>在单进程中运行多个线程。</p><p>线程很像轻量级的进程：每个线程相互独立运行，并且可以在不同的指令序列中运行。不过，进程中的所有线程都共享地址空间，并且能访问到大部分数据———全局变量仍然是全局的，指针、对象的引用或数据可以在线程之间传递。</p><p><img src="/20220627/1-4.png" alt="1-4"></p><p>一个进程中的两个线程，正在通过共享内存进行通信。</p><p>地址空间共享，以及缺少线程间的数据保护，使得操作系统记录的工作量减小，所以使用多线程的开销远远小于多进程。不过，共享内存的灵活性是有代价的：如果多个线程访问数据，那么必须确保每个线程所访问到的数据一致，这就需要对线程通信做大量的工作。</p><h2 id="使用并发的原因"><a href="#使用并发的原因" class="headerlink" title="使用并发的原因"></a>使用并发的原因</h2><p>原因有二：分离关注点（SOC）、性能</p><ul><li><p>分离关注点。通过将相关的代码与无关的代码分离，可以使程序更容易理解和测试，从而减少出错的可能。即使一些操作需要同时进行，依旧可以使用并发，分离不同的功能区域。</p></li><li><p>性能。两种利用并发提高性能的方式：</p><ul><li>任务并行：将一个单个任务分成几部分并行运行，从而降低总运行时间</li><li>数据并行：一个线程执行算法的一部分，而另一个线程执行算法的另一个部分，每个线程在不同的数据块上执行相同的操作</li></ul></li></ul><p><strong>什么时候不使用并发：</strong></p><p>收益比不上成本。使用并发的代码在很多情况下难以理解，因此编写和维护多线程代码会产生脑力成本，而增加的复杂性也可能会引起更多的错误。</p><p>线程的资源有限。如果太多的线程同时运行，则会消耗很多操作系统资源，从而使得操作系统整体上运行得更加缓慢。不仅如此，因为每个线程都需要一个独立的堆栈，所以运行太多的线程也会耗尽进程的可用内存或地址空间。</p><p>运行越多的线程，操作系统就需要越多的上下文切换，每一次切换都需要耗费时间。所以在某些时候，增加线程实际上会降低应用的整体性能。</p><h2 id="并发程序"><a href="#并发程序" class="headerlink" title="并发程序"></a>并发程序</h2><p>C++多线程程序和其他C++程序差不多。唯一的区别在于某些函数可以并发运行，所以需要确保共享数据在并发访问时是安全的。</p><p>例子：打印“Hello World”的程序</p><p>单线程运行：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello World\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>启动独立的线程显示信息：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span>  <span class="comment">// 1 标准库中对多线程支持的声明</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span>  <span class="comment">// 2 独立的函数打印信息</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout &lt;&lt; <span class="string">&quot;Hello Concurrent World\n&quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(hello)</span></span>;  <span class="comment">// 3 构造名为t的std::thread对象拥有新函数hello()作为其执行函数</span></span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">// 4 当前线程等待t线程终止之后才从t.join()返回。创建线程等待std::thread对象创建的线程</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-线程管理"><a href="#2-线程管理" class="headerlink" title="2.线程管理"></a>2.线程管理</h1><h2 id="线程基本操作"><a href="#线程基本操作" class="headerlink" title="线程基本操作"></a>线程基本操作</h2><h3 id="启动线程"><a href="#启动线程" class="headerlink" title="启动线程"></a>启动线程</h3><p>使用C++线程库启动线程，就是构造<code>std::thread</code>对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_some_work</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(do_some_work)</span></span>;</span><br></pre></td></tr></table></figure><p>需要包含<code>&lt;thread&gt;</code>头文件，<code>std::thread</code>可以通过有函数操作符类型的实例进行构造：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">background_task</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">do_something</span>();</span><br><span class="line">    <span class="built_in">do_something_else</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">background_task f;</span><br><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">(f)</span></span>;</span><br></pre></td></tr></table></figure><p>代码中，提供的函数对象会复制到新线程的存储空间中，函数对象的执行和调用都在线程的内存空间中进行。</p><p>Lambda表达式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">my_thread</span><span class="params">([]&#123;</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something();</span></span></span><br><span class="line"><span class="params"><span class="function">  do_something_else();</span></span></span><br><span class="line"><span class="params"><span class="function">&#125;)</span></span>;</span><br></pre></td></tr></table></figure><p>线程启动后是要等待线程结束，还是让其自主运行。</p><p>当<code>std::thread</code>对象销毁之前还没有做出决定，程序就会终止。</p><p>即便是有异常存在，也需要确保线程能够正确<em>汇入</em>(joined)或<em>分离</em>(detached)。</p><p>如果不等待线程汇入 ，就必须保证线程结束之前，访问数据的有效性。</p><p>代码2.1：函数已经返回，线程依旧访问局部变量</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span>&amp; i;</span><br><span class="line">  <span class="built_in">func</span>(<span class="keyword">int</span>&amp; i_) : <span class="built_in">i</span>(i_) &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span> <span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">unsigned</span> j=<span class="number">0</span> ; j&lt;<span class="number">1000000</span> ; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">do_something</span>(i);           <span class="comment">// 1 潜在访问隐患：空引用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">my_thread</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  my_thread.<span class="built_in">detach</span>();          <span class="comment">// 2 不等待线程结束</span></span><br><span class="line">&#125;                              <span class="comment">// 3 新线程可能还在运行</span></span><br></pre></td></tr></table></figure><p>可能会出现新线程访问已经销毁的变量。过程如下：</p><table><thead><tr><th align="center">主线程</th><th align="center">新线程</th></tr></thead><tbody><tr><td align="center">使用some_local_state构造my_func</td><td align="center"></td></tr><tr><td align="center">开启新线程my_thread</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">启动</td></tr><tr><td align="center"></td><td align="center">调用func::operator()</td></tr><tr><td align="center">将my_thread分离</td><td align="center">执行func::operator();可能会在do_something中调用some_local_state的引用</td></tr><tr><td align="center">销毁some_local_state</td><td align="center">持续运行</td></tr><tr><td align="center">退出oops函数</td><td align="center">持续执行func::operator()；可能会在do_something中调用some_local_state的引用 –&gt; 导致未定义行为</td></tr></tbody></table><p>常规处理方法：</p><ul><li><p>将数据复制到线程中。对于对象中包含的指针和引用需谨慎。使用访问局部变量的函数去创建线程是一个糟糕的主意。</p></li><li><p>可以通过join()函数来确保线程在主函数完成前结束。</p></li></ul><h3 id="等待线程完成"><a href="#等待线程完成" class="headerlink" title="等待线程完成"></a>等待线程完成</h3><p>如需等待线程，需要使用**join()**。</p><p>将例2-1中的<code>my_thread.detach()</code>替换为<code>my_thread.join()</code>，就可以确保局部变量在线程完成后才销毁。</p><p>只能对一个线程使用一次join()，一旦使用过join()，<code>std::thread</code>对象就不能再次汇入了。当对其使用joinable()时，将返回false。</p><h3 id="特殊情况下的等待"><a href="#特殊情况下的等待" class="headerlink" title="特殊情况下的等待"></a>特殊情况下的等待</h3><p>避免应用被抛出的异常所终止。通常，在无异常的情况下使用join()时，需要在异常处理过程中调用join()，从而避免生命周期的问题。</p><p>代码2.2 等待线程完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在代码2.1中</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="keyword">try</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in"><span class="keyword">catch</span></span>(...)</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>();  <span class="comment">// 1 抛出异常</span></span><br><span class="line">    <span class="keyword">throw</span>;</span><br><span class="line">  &#125; </span><br><span class="line">  t.<span class="built_in">join</span>();  <span class="comment">// 2 正常退出</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用“资源获取即初始化方式”(RAII，Resource Acquisition Is Initialization)，提供一个类，在析构函数中使用join()。</p><p>代码2.3 使用RAII等待线程完成</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">thread_guard</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread&amp; t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">thread_guard</span><span class="params">(std::thread&amp; t_)</span>:</span></span><br><span class="line"><span class="function">    t(t_)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  ~<span class="built_in">thread_guard</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(t.<span class="built_in">joinable</span>()) <span class="comment">// 1 判断线程是否可以汇入</span></span><br><span class="line">    &#123;</span><br><span class="line">      t.<span class="built_in">join</span>();      <span class="comment">// 2 汇入</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">thread_guard</span>(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;   <span class="comment">// 3 不让编译器自动生成拷贝或赋值</span></span><br><span class="line">  thread_guard&amp; <span class="keyword">operator</span>=(thread_guard <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在代码2.1中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state=<span class="number">0</span>;</span><br><span class="line">  <span class="function">func <span class="title">my_func</span><span class="params">(some_local_state)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(my_func)</span></span>;</span><br><span class="line">  <span class="function">thread_guard <span class="title">g</span><span class="params">(t)</span></span>;</span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125;    <span class="comment">// 4 thread_guard对象g是第一个被销毁的，</span></span><br><span class="line"><span class="comment">// 即使do_something_in_current_thread抛出一个异常，这个销毁依旧会发生。</span></span><br></pre></td></tr></table></figure><h3 id="后台运行线程"><a href="#后台运行线程" class="headerlink" title="后台运行线程"></a>后台运行线程</h3><p>detach()会让线程在后台运行，这就意味着与主线程不能直接交互。</p><p>守护线程（daemon threads）：分离线程，UNIX中是指没有任何显示的接口，在后台运行的线程。特点是长时间运行。</p><p>分离线程只能确定线程什么时候结束，发后即忘的任务使用分离线程。</p><p>代码2-4 使用分离线程处理文档</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">edit_document</span><span class="params">(std::string <span class="keyword">const</span>&amp; filename)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">open_document_and_display_gui</span>(filename);</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done_editing</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    user_command cmd=<span class="built_in">get_user_input</span>();</span><br><span class="line">    <span class="keyword">if</span>(cmd.type==open_new_document)</span><br><span class="line">    &#123;</span><br><span class="line">      std::string <span class="keyword">const</span> new_name=<span class="built_in">get_filename_from_user</span>();</span><br><span class="line">      <span class="function">std::thread <span class="title">t</span><span class="params">(edit_document,new_name)</span></span>;  <span class="comment">// 1 打开新文档，可以传入函数名和函数所需参数</span></span><br><span class="line">      t.<span class="built_in">detach</span>();  <span class="comment">// 2 分离线程，新线程打开另一个文件，edit_document函数可以复用，并通过传参的形式打开新的文件</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">       <span class="built_in">process_user_input</span>(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="传递参数"><a href="#传递参数" class="headerlink" title="传递参数"></a>传递参数</h2><p>向可调用对象或函数传递参数很简单，只需要将这些参数作为 <code>std::thread</code>构造函数的附加参数即可。</p><p>即使函数中的参数是引用的形式，拷贝操作也会执行。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i, std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(f, <span class="number">3</span>, <span class="string">&quot;hello&quot;</span>)</span></span>;</span><br></pre></td></tr></table></figure><p>代码创建了一个调用f(3, “hello”)的线程。函数f需要一个<code>std::string</code>对象作为第二个参数，但这里使用的是字符串的字面值，也就是<code>char const *</code>类型，线程的上下文完成字面值向<code>std::string</code>的转化。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> i,std::string <span class="keyword">const</span>&amp; s)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">not_oops</span><span class="params">(<span class="keyword">int</span> some_param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">char</span> buffer[<span class="number">1024</span>]; <span class="comment">// buffer是一个指针变量，指向局部变量</span></span><br><span class="line">  <span class="built_in">sprintf</span>(buffer,<span class="string">&quot;%i&quot;</span>,some_param);</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(f,<span class="number">3</span>,std::string(buffer))</span></span>;  <span class="comment">// 使用std::string，将字面值转化为std::string避免悬空指针</span></span><br><span class="line">  t.<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>内部代码会将拷贝的参数以右值的方式进行传递，这是为了那些只支持移动的类型</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_data_for_widget</span><span class="params">(widget_id w,widget_data&amp; data)</span></span>; <span class="comment">// 1</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops_again</span><span class="params">(widget_id w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  widget_data data;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,data)</span></span>; <span class="comment">// 2</span></span><br><span class="line">  <span class="built_in">display_status</span>();</span><br><span class="line">  t.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">process_widget_data</span>(data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为函数期望的是一个非常量引用作为参数(而非右值)，所以会在编译时出错。可以使用<code>std::ref</code>将参数转换成引用的形式。因此可将线程的调用改为以下形式：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(update_data_for_widget,w,std::ref(data))</span></span>;</span><br></pre></td></tr></table></figure><p>update_data_for_widget就会收到data的引用，而非data的拷贝副本，这样代码就能顺利的通过编译了。</p><p>如果提供的参数支持移动（move），不能拷贝。</p><p><code>std::unique_ptr</code>(C++11中的智能指针)，为动态分配的对象提供内存自动管理机制(类似垃圾回收机制)。同一时间内，只允许一个<code>std::unique_ptr</code>实例指向一个对象，并且当这个实例销毁时，指向的对象也将被删除。</p><p><em>移动构造函数</em>(move constructor)和<em>移动赋值操作符</em>(move assignment operator)允许一个对象的所有权在多个<code>std::unique_ptr</code>实例中传递。使用“移动”转移对象所有权后，就会留下一个空指针。</p><p><code>std::move</code>转移动态对象的所有权到线程中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_big_object</span><span class="params">(std::unique_ptr&lt;big_object&gt;)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function">std::unique_ptr&lt;big_object&gt; <span class="title">p</span><span class="params">(<span class="keyword">new</span> big_object)</span></span>;</span><br><span class="line">p-&gt;<span class="built_in">prepare_data</span>(<span class="number">42</span>);</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(process_big_object,std::move(p))</span></span>;</span><br><span class="line"><span class="comment">// big_object 对象的所有权首先被转移到新创建线程的的内部存储中，之后再传递给process_big_object函数。</span></span><br></pre></td></tr></table></figure><p>线程的所有权可以在多个<code>std::thread</code>实例中转移，这依赖于<code>std::thread</code>实例的<strong>可移动</strong>且<strong>不可复制</strong>性。</p><p>可移动性：使得开发者可以自己决定，哪个实例拥有线程实际执行的所有权。</p><p>不可复制性：在某一时间点，一个<code>std::thread</code>实例只能关联一个执行线程。</p><h2 id="转移所有权"><a href="#转移所有权" class="headerlink" title="转移所有权"></a>转移所有权</h2><p>例子，创建两个执行进程，并在<code>std::thread</code>实例之间(t1，t2和t3)转移所有权：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">std::thread <span class="title">t1</span><span class="params">(some_function)</span></span>;            <span class="comment">// 1 新线程与t1相关联</span></span><br><span class="line">std::thread t2 = std::<span class="built_in">move</span>(t1);            <span class="comment">// 2 t1所有权转移给t2，执行some_function的函数线程与t2关联。</span></span><br><span class="line">t1=std::<span class="built_in">thread</span>(some_other_function);    <span class="comment">// 3 临时std::thread对象相关的线程启动</span></span><br><span class="line">std::thread t3;                            <span class="comment">// 4 默认构造方式创建，没有与任何线程进行关联</span></span><br><span class="line">t3=std::<span class="built_in">move</span>(t2); <span class="comment">// 5 移动操作后，t1与执行some_other_function的线程相关联，t2与任何线程都无关联，t3与执行some_function的线程相关联。</span></span><br><span class="line">t1=std::<span class="built_in">move</span>(t3);                        <span class="comment">// 6 赋值操作将使程序崩溃</span></span><br></pre></td></tr></table></figure><p>最后的移动操作，将some_function线程的所有权转移给t1，但是t1已经有了一个关联的线程（执行some_other_function的线程），所以这里系统直接调用<code>std::terminate()</code>终止程序继续运行。</p><p><code>std::terminate()</code>不抛出异常，是noexpect函数，保证与<code>std::thread</code>的析构函数的行为一致。</p><p>线程对象析构前，显式的等待线程完成或分离它，即不能通过赋新值给<code>std::thread</code>对象的方式”丢弃“一个线程。</p><p><code>std::thread</code>支持移动，线程的所有权可以在函数外进行转移。</p><p>代码2.5 函数返回<code>std::thread</code>对象</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::thread <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">thread</span>(some_function);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_other_function</span><span class="params">(<span class="keyword">int</span>)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(some_other_function,<span class="number">42</span>)</span></span>;</span><br><span class="line">  <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所有权可以在函数内部传递，允许<code>std::thread</code>实例作为参数进行传递：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(std::thread t)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">g</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">some_function</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="built_in">f</span>(std::<span class="built_in">thread</span>(some_function));</span><br><span class="line">  <span class="function">std::thread <span class="title">t</span><span class="params">(some_function)</span></span>;</span><br><span class="line">  <span class="built_in">f</span>(std::<span class="built_in">move</span>(t));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了确保线程在程序退出前完成，定义了scoped_thread类。</p><p>代码2.6 scoped_thread的用法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">scoped_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">scoped_thread</span><span class="params">(std::thread t_)</span>: // <span class="number">1</span></span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span></span><br><span class="line">    <span class="keyword">if</span>(!t.<span class="built_in">joinable</span>())  <span class="comment">// 2 检测线程是否可汇入放在构造函数中，不可汇入则抛出异常</span></span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“No thread”);</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">scoped_thread</span>()</span><br><span class="line">  &#123;</span><br><span class="line">    t.<span class="built_in">join</span>(); <span class="comment">// 3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">scoped_thread</span>(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">  scoped_thread&amp; <span class="keyword">operator</span>=(scoped_thread <span class="keyword">const</span>&amp;)=<span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">func</span>;</span> <span class="comment">// 定义在代码2.1中</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> some_local_state;</span><br><span class="line">  <span class="function">scoped_thread <span class="title">t</span><span class="params">(std::thread(func(some_local_state)))</span></span>;    <span class="comment">// 4 新线程会直接传递到scoped_thread中</span></span><br><span class="line">  <span class="built_in">do_something_in_current_thread</span>();</span><br><span class="line">&#125; <span class="comment">// 5 scoped_thread对象就会销毁，然后在析构函数中完成汇入3</span></span><br></pre></td></tr></table></figure><p>代码2.7 joining_thread类的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">joining_thread</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::thread t;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span>=<span class="keyword">default</span>;</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable,<span class="keyword">typename</span> ... Args&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(Callable&amp;&amp; func,Args&amp;&amp; ... args)</span>:</span></span><br><span class="line"><span class="function">    t(std::forward&lt;Callable&gt;(func),std::forward&lt;Args&gt;(args)...)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">joining_thread</span><span class="params">(std::thread t_)</span> <span class="keyword">noexcept</span>:</span></span><br><span class="line"><span class="function">    t(std::move(t_))</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  <span class="built_in">joining_thread</span>(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span>:</span><br><span class="line">    <span class="built_in">t</span>(std::<span class="built_in">move</span>(other.t))</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  joining_thread&amp; <span class="keyword">operator</span>=(joining_thread&amp;&amp; other) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>（<span class="built_in">joinable</span>()）&#123;</span><br><span class="line">      <span class="built_in">join</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    t = std::<span class="built_in">move</span>(other.t);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  joining_thread&amp; <span class="keyword">operator</span>=(std::thread other) <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">      <span class="built_in">join</span>();</span><br><span class="line">    t=std::<span class="built_in">move</span>(other);</span><br><span class="line">    <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ~<span class="built_in">joining_thread</span>() <span class="keyword">noexcept</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">joinable</span>())</span><br><span class="line">    <span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(joining_thread&amp; other)</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t.<span class="built_in">swap</span>(other.t);</span><br><span class="line">  &#125;</span><br><span class="line">  std::<span class="function">thread::id <span class="title">get_id</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">get_id</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">joinable</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.<span class="built_in">joinable</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t.<span class="built_in">join</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">detach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    t.<span class="built_in">detach</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> std::thread&amp; <span class="title">as_thread</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">noexcept</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::thread</code>中对移动语义的支持，也适用于使用<code>std::thread</code>的<strong>移动敏感</strong>(move-aware)容器(比如，<code>std::vector&lt;&gt;</code>)。了解这些后，就可以量产了一些线程，并且等待它们结束，代码如下所示。</p><p>代码2.8 量产线程，等待它们结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_work</span><span class="params">(<span class="keyword">unsigned</span> id)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::vector&lt;std::thread&gt; threads;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">unsigned</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    threads.<span class="built_in">emplace_back</span>(do_work,i); <span class="comment">// 产生线程</span></span><br><span class="line">  &#125; </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads) <span class="comment">// 对每个线程调用 join()</span></span><br><span class="line">    entry.<span class="built_in">join</span>();       </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码2.8中每个线程所做的工作都是独立的，并且结果会受到共享数据的影响。</p><p>如果f()有返回值，这个返回值就依赖于线程得到的结果。写入返回值之前，程序会检查使用共享数据的线程是否终止。</p><h2 id="确定线程数量"><a href="#确定线程数量" class="headerlink" title="确定线程数量"></a>确定线程数量</h2><p><code>std::thread::hardware_concurrency()</code>在新版C++中非常有用，返回并发线程的数量。</p><p>代码2.9将整体工作拆分成小任务，交给每个线程去做，并设置最小任务数，避免产生太多的线程，程序会在操作数量为0时抛出异常。比如，<code>std::thread</code>无法启动线程，就会抛出异常。</p><p>代码2.9 并行版的<code>std::accumulate</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">accumulate_block</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(Iterator first,Iterator last,T&amp; result)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    result=std::<span class="built_in">accumulate</span>(first,last,result);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Iterator,<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function">T <span class="title">parallel_accumulate</span><span class="params">(Iterator first,Iterator last,T init)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> length=std::<span class="built_in">distance</span>(first,last);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(!length) <span class="comment">// 1 输入范围为空，返回init的值</span></span><br><span class="line">    <span class="keyword">return</span> init;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> min_per_thread=<span class="number">25</span>; <span class="comment">// 线程中最小任务数</span></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> max_threads=</span><br><span class="line">      (length+min_per_thread<span class="number">-1</span>)/min_per_thread; <span class="comment">// 2 启动线程最大数量</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hardware_threads=</span><br><span class="line">      std::thread::<span class="built_in">hardware_concurrency</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> num_threads= <span class="comment">// 3 std::thread::hardware_concurrency()返回0时，选择一个合适数字</span></span><br><span class="line">      std::<span class="built_in">min</span>(hardware_threads != <span class="number">0</span> ? hardware_threads : <span class="number">2</span>, max_threads);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> block_size=length/num_threads; <span class="comment">// 4 每个线程中处理的元素数量</span></span><br><span class="line"></span><br><span class="line">  <span class="function">std::vector&lt;T&gt; <span class="title">results</span><span class="params">(num_threads)</span></span>; <span class="comment">//  存放中间结果</span></span><br><span class="line">  <span class="function">std::vector&lt;std::thread&gt; <span class="title">threads</span><span class="params">(num_threads<span class="number">-1</span>)</span></span>;  <span class="comment">// 5 在启动之前已经有了一个线程(主线程)，所以启动的线程数必须比num_threads少1</span></span><br><span class="line"></span><br><span class="line">  Iterator block_start=first;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">long</span> i=<span class="number">0</span>; i &lt; (num_threads<span class="number">-1</span>); ++i)</span><br><span class="line">  &#123;</span><br><span class="line">    Iterator block_end=block_start;</span><br><span class="line">    std::<span class="built_in">advance</span>(block_end,block_size);  <span class="comment">// 6 block_end迭代器指向当前块的末尾，把一个迭代器移动 n 个位置</span></span><br><span class="line">    threads[i]=std::<span class="built_in">thread</span>(     <span class="comment">// 7 启动一个新线程为当前块累加结果</span></span><br><span class="line">        accumulate_block&lt;Iterator,T&gt;(),</span><br><span class="line">        block_start,block_end,std::<span class="built_in">ref</span>(results[i]));</span><br><span class="line">    block_start=block_end;  <span class="comment">// 8 当迭代器指向当前块的末尾时，启动下一个块</span></span><br><span class="line">  &#125;</span><br><span class="line">  accumulate_block&lt;Iterator,T&gt;()(</span><br><span class="line">      block_start,last,results[num_threads<span class="number">-1</span>]); <span class="comment">// 9 处理最终块的结果</span></span><br><span class="line">      </span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; entry : threads)</span><br><span class="line">    entry.<span class="built_in">join</span>();  <span class="comment">// 10 创建线程</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">accumulate</span>(results.<span class="built_in">begin</span>(),results.<span class="built_in">end</span>(),init); <span class="comment">// 11 累加所有结果</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：</p><ul><li><p>T类型的加法不满足结合律(比如，对于float型或double型，在进行加法操作时，系统很可能会做截断操作)，因为对范围中元素的分组，会导致parallel_accumulate得到的结果可能与<code>std::accumulate</code>的结果不同。</p></li><li><p>迭代器必须是前向迭代器。</p></li><li><p>对于results容器，需要保证T有默认构造函数。</p></li></ul><h2 id="线程标识"><a href="#线程标识" class="headerlink" title="线程标识"></a>线程标识</h2><p><code>std::thread::id</code>类型，获取方式：</p><ul><li>调用<code>std::thread</code>对象的成员函数<code>get_id()</code>来直接获取。如果<code>std::thread</code>对象没有与任何执行线程相关联，<code>get_id()</code>将返回<code>std::thread::type</code>默认构造值，这个值表示“无线程”。</li><li>当前线程中调用<code>std::this_thread::get_id()</code>(这个函数定义在<code>&lt;thread&gt;</code>头文件中)也可以获得线程标识。</li></ul><p><code>std::thread::id</code>对象可以<strong>自由的拷贝和对比</strong>，因为<strong>标识符可以复用</strong>。</p><p>如果两个对象的<code>std::thread::id</code>相等，那就是同一个线程，或者都“无线程”。</p><p>如果不等，那么就代表了两个不同线程，或者一个有线程，另一没有线程。</p><p>标准库提供<code>std::hash&lt;std::thread::id&gt;</code>容器，<code>std::thread::id</code>也可以作为无序容器的键值。</p><p>启动其他线程前，可以通过<code>std::this_thread::get_id()</code>得到自己的线程ID。每个线程都要检查一下，其拥有的线程ID是否与初始线程的ID相同。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::thread::id master_thread;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">some_core_part_of_algorithm</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(std::this_thread::<span class="built_in">get_id</span>()==master_thread)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">do_master_thread_work</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">do_common_work</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程ID在容器中可作为键值.</p><p>可以使用输出流(<code>std::cout</code>)来记录一个<code>std::thread::id</code>对象的值。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>();</span><br></pre></td></tr></table></figure><h1 id="3-共享数据"><a href="#3-共享数据" class="headerlink" title="3.共享数据"></a>3.共享数据</h1><p>线程间的问题在于修改共享数据，会使不变量遭到破坏。</p><p>并行中常见错误：条件竞争(race condition)。</p><h2 id="共享数据的问题"><a href="#共享数据的问题" class="headerlink" title="共享数据的问题"></a>共享数据的问题</h2><h3 id="条件竞争"><a href="#条件竞争" class="headerlink" title="条件竞争"></a>条件竞争</h3><p>并发中的竞争条件，取决于一个以上线程的执行顺序，每个线程都抢着完成自己的任务。</p><p>当不变量遭到破坏时，才会产生条件竞争。</p><p>操作要访问两个独立的数据块，独立的指令会对数据块将进行修改，并且其中一个线程可能正在进行修改，另一个线程就对数据块进行了访问。因为出现的概率低，很难查找，也很难复现。</p><h3 id="避免恶性条件竞争"><a href="#避免恶性条件竞争" class="headerlink" title="避免恶性条件竞争"></a>避免恶性条件竞争</h3><ul><li><p>最简单的办法：对数据结构采用某种保护机制，确保只有修改线程才能看到不变量的中间状态。</p><p>从其他访问线程的角度来看，修改不是已经完成了，就是还没开始。</p></li><li><p>对数据结构和不变量进行修改，修改完的结构必须能完成一系列不可分割的变化，也就保证了每个不变量的状态，这就是所谓的<strong>无锁编程</strong>。</p></li><li><p>使用事务的方式去处理数据结构的更新。一些数据和读取都存储在事务日志中，然后将之前的操作进行合并，再进行提交。当数据结构被另一个线程修改后，或处理已经重启的情况下，提交就会无法进行，这称作为“软件事务内存”(software transactional memory (STM))</p></li></ul><h2 id="使用互斥量"><a href="#使用互斥量" class="headerlink" title="使用互斥量"></a>使用互斥量</h2><p>访问共享数据前，将数据锁住，在访问结束后，再将数据解锁。线程库需要保证，当线程使用互斥量锁住共享数据时，其他的线程都必须等到之前那个线程对数据进行解锁后，才能进行访问数据。</p><p>互斥量会造成死锁，或对数据保护的太多(或太少)</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>实例化<code>std::mutex</code>创建互斥量实例，成员函数lock()可对互斥量上锁，unlock()为解锁。</p><p>不推荐直接去调用成员函数，调用成员函数就意味着，必须在每个函数出口都要去调用unlock()(包括异常的情况)。</p><p><code>std::lock_guard</code>：在构造时就能提供已锁的互斥量，并在析构时进行解锁，从而保证了互斥量能被正确解锁。</p><p>代码3.1 使用互斥量保护列表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::list&lt;<span class="keyword">int</span>&gt; some_list;    <span class="comment">// 1 全局变量</span></span><br><span class="line">std::mutex some_mutex;    <span class="comment">// 2 全局的互斥量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">add_to_list</span><span class="params">(<span class="keyword">int</span> new_value)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 3 加锁，对数据访问互斥的</span></span><br><span class="line">  some_list.<span class="built_in">push_back</span>(new_value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">list_contains</span><span class="params">(<span class="keyword">int</span> value_to_find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(some_mutex)</span></span>;    <span class="comment">// 4 加锁后，看不到add_to_list()修改的列表</span></span><br><span class="line">  <span class="keyword">return</span> std::<span class="built_in">find</span>(some_list.<span class="built_in">begin</span>(),some_list.<span class="built_in">end</span>(),value_to_find) != some_list.<span class="built_in">end</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17中添加了一个新特性，称为模板类参数推导，类似<code>std::lock_guard</code>这样简单的模板类型，其模板参数列表可以省略。③和④的代码可以简化成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::lock_guard <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>C++17中的一种加强版数据保护机制——<code>std::scoped_lock</code>，所以在C++17的环境下，上面的这行代码也可以写成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(some_mutex)</span></span>;</span><br></pre></td></tr></table></figure><p>大多数情况下，互斥量通常会与需要保护的数据放在同一类中，而不是定义成全局变量。</p><p>当其中一个成员函数返回的是保护数据的指针或引用时，也会破坏数据。具有访问能力的指针或引用可以访问(并可能修改)保护数据，而不会被互斥锁限制。这就需要对接口谨慎设计，要确保互斥量能锁住数据访问，并且不留后门。</p><h3 id="保护共享数据"><a href="#保护共享数据" class="headerlink" title="保护共享数据"></a>保护共享数据</h3><p>代码3.2 无意中传递了保护数据的引用</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_data</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  std::string b;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">do_something</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">data_wrapper</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_data data;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Function&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">void</span> <span class="title">process_data</span><span class="params">(Function func)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">l</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="built_in">func</span>(data);    <span class="comment">// 1 传递“保护”数据给用户函数</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">some_data* unprotected;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">malicious_function</span><span class="params">(some_data&amp; protected_data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  unprotected=&amp;protected_data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">data_wrapper x;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">process_data</span>(malicious_function);    <span class="comment">// 2 传递一个恶意函数</span></span><br><span class="line">  unprotected-&gt;<span class="built_in">do_something</span>();    <span class="comment">// 3 在无保护的情况下访问保护数据</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>例子中process_data看起来没有问题，<code>std::lock_guard</code>对数据做了很好的保护，但调用用户提供的函数func①，就意味着foo能够绕过保护机制将函数<code>malicious_function</code>传递进去②，可以在没有锁定互斥量的情况下调用<code>do_something()</code>。</p><p>函数<code>foo()</code>中调用<code>unprotected-&gt;do_something()</code>的代码未能被标记为互斥。</p><p>切勿将受保护数据的指针或引用传递到互斥锁作用域之外。</p><h3 id="接口间的条件竞争"><a href="#接口间的条件竞争" class="headerlink" title="接口间的条件竞争"></a>接口间的条件竞争</h3><p>代码3.3 <code>std::stack</code>容器的实现</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T,<span class="keyword">typename</span> Container=std::deque&lt;T&gt; &gt;</span><br><span class="line">class stack</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="keyword">explicit</span> <span class="built_in">stack</span>(<span class="keyword">const</span> Container&amp;);</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(Container&amp;&amp; = Container())</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="function"><span class="keyword">explicit</span> <span class="title">stack</span><span class="params">(<span class="keyword">const</span> Alloc&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="built_in">stack</span>(<span class="keyword">const</span> Container&amp;, <span class="keyword">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="built_in">stack</span>(Container&amp;&amp;, <span class="keyword">const</span> Alloc&amp;);</span><br><span class="line">  <span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">Alloc</span>&gt;</span> <span class="built_in">stack</span>(stack&amp;&amp;, <span class="keyword">const</span> Alloc&amp;);</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">size_t</span> <span class="title">size</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function">T&amp; <span class="title">top</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function">T <span class="keyword">const</span>&amp; <span class="title">top</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(stack&amp;&amp;)</span></span>;</span><br><span class="line">  <span class="keyword">template</span> &lt;class... Args&gt; <span class="function"><span class="keyword">void</span> <span class="title">emplace</span><span class="params">(Args&amp;&amp;... args)</span></span>; <span class="comment">// C++14的新特性</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>虽然empty()和size()可能在返回时是正确的，但结果不可靠。当返回后，其他线程就可以自由地访问栈，并且可能push()多个新元素到栈中，也可能pop()一些已在栈中的元素。这样的话，之前从empty()和size()得到的数值就有问题了。</p><p>非共享的栈对象，如果栈非空，使用empty()检查再调用top()访问栈顶部的元素是安全的。如下代码所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line"><span class="keyword">if</span> (! s.<span class="built_in">empty</span>())&#123;    <span class="comment">// 1 判断栈是否为空</span></span><br><span class="line">  <span class="keyword">int</span> <span class="keyword">const</span> value = s.<span class="built_in">top</span>();    <span class="comment">// 2 非空调用栈顶</span></span><br><span class="line">  s.<span class="built_in">pop</span>();    <span class="comment">// 3 弹出栈顶元素</span></span><br><span class="line">  <span class="built_in">do_something</span>(value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于共享的栈对象，这样的调用顺序就不再安全，因为在调用empty()①和调用top()②之间，可能有来自另一个线程的pop()调用并删除了最后一个元素。这是一个经典的条件竞争，使用互斥量对栈内部数据进行保护，但依旧不能阻止条件竞争的发生，这就是接口固有的问题。</p><p>解决：改变接口的设计</p><p>先获取顶部元素(top())，然后从栈中移除(pop())。这样，在不能安全的将元素拷贝出去的情况下，栈中的这个数据还依旧存在，没有丢失。当问题是堆空间不足，应用可能会释放一些内存，然后再进行尝试。</p><p>不幸的是，这样的分割却制造了本想避免的条件竞争。</p><p><strong>选项1：传入一个引用</strong></p><p>将变量的引用作为参数，传入pop()函数中获取“弹出值”：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">some_stack.<span class="built_in">pop</span>(result);</span><br></pre></td></tr></table></figure><p>缺点：需要构造出一个栈中类型的实例，用于接收目标值。对于一些类型，这样做是不现实的，因为临时构造一个实例，从时间和资源的角度上来看都不划算。</p><p><strong>选项2：无异常抛出的拷贝构造函数或移动构造函数</strong></p><p>一个有用的选项可以限制对线程安全栈的使用，并且能让栈安全的返回所需的值，而不抛出异常。虽然安全，但非可靠。</p><p>那些有抛出异常的拷贝构造函数，但没有移动构造函数的类型往往更多。</p><p><strong>选项3：返回指向弹出值的指针</strong></p><p>指针的优势是自由拷贝，并且不会产生异常，这样就能避免Cargill提到的异常问题了。</p><p>缺点就是返回指针需要对对象的内存分配进行管理，对于简单数据类型(比如:int)，内存管理的开销要远大于直接返回值。</p><p>使用<code>std::shared_ptr</code>，不仅能避免内存泄露(因为当对象中指针销毁时，对象也会被销毁)，而且标准库能够完全控制内存分配方案，就不需要new和delete操作。</p><p><strong>例：定义线程安全的堆栈</strong></p><p>代码3.4中是一个接口没有条件竞争的堆栈类定义，它实现了选项1和选项3：重载了pop()，使用局部引用去存储弹出值，并返回<code>std::shared_ptr&lt;&gt;</code>对象。它有一个简单的接口，只有两个函数：push()和pop();</p><p>代码3.4 线程安全的堆栈类定义(概述)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span>  <span class="comment">// For std::shared_ptr&lt;&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>();</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="keyword">const</span> threadsafe_stack&amp;);</span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>; <span class="comment">// 1 赋值操作被删除</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当栈为空时，pop()函数会抛出一个empty_stack异常，所以在empty()函数被调用后，其他部件还能正常工作。</p><p>使用<code>std::shared_ptr</code>可以避免内存分配管理的问题，并避免多次使用new和delete操作。堆栈中的五个操作，现在就剩下三个：push(), pop()和empty()(这里empty()都有些多余)。</p><p>简化接口更有利于数据控制，可以保证互斥量将操作完全锁住。</p><p>代码3.5 扩充(线程安全)堆栈</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;exception&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stack&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">empty_stack</span>:</span> std::exception</span><br><span class="line">&#123;</span><br><span class="line">  <span class="function"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="title">what</span><span class="params">()</span> <span class="keyword">const</span> <span class="title">throw</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">&quot;empty stack!&quot;</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::stack&lt;T&gt; data;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_stack</span>()</span><br><span class="line">: <span class="built_in">data</span>(std::stack&lt;T&gt;())&#123;&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">threadsafe_stack</span>(<span class="keyword">const</span> threadsafe_stack&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(other.m)</span></span>;</span><br><span class="line">    data = other.data; <span class="comment">// 1 在构造函数体中的执行拷贝</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  threadsafe_stack&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> threadsafe_stack&amp;) = <span class="keyword">delete</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    data.<span class="built_in">push</span>(new_value);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>(); <span class="comment">// 在调用pop前，检查栈是否为空</span></span><br><span class="line"></span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="keyword">const</span> <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data.top()))</span></span>; <span class="comment">// 在修改堆栈前，分配出返回值</span></span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data.<span class="built_in">empty</span>()) <span class="keyword">throw</span> <span class="built_in">empty_stack</span>();</span><br><span class="line"></span><br><span class="line">    value=data.<span class="built_in">top</span>();</span><br><span class="line">    data.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(m)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>堆栈可以拷贝——拷贝构造函数对互斥量上锁，再拷贝堆栈。构造函数体中①的拷贝使用互斥量来确保复制结果的正确性，这样的方式比成员初始化列表好。</p><p>一个给定操作需要两个或两个以上的互斥量时，另一个潜在的问题将出现：死锁。与条件竞争完全相反——不同的两个线程会互相等待，从而什么都没做。</p><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><p>线程有对锁的竞争：一对线程需要对他们所有的互斥量做一些操作，其中每个线程都有一个互斥量，且等待另一个解锁。因为他们都在等待对方释放互斥量，没有线程能工作。</p><p>避免死锁：让两个互斥量以相同顺序上锁。某些情况下是可以这样用，因为不同的互斥量用于不同的地方。</p><p>选择一个固定的顺序(例如，实例提供的第一互斥量作为第一个参数，提供的第二个互斥量为第二个参数)，可能会适得其反：在参数交换了之后，两个线程试图在相同的两个实例间进行数据交换时，程序又死锁了！</p><p><code>std::lock</code>——可以一次性锁住多个(两个以上)的互斥量，并且没有副作用(死锁风险)。</p><p>代码3.6 交换操作中使用<code>std::lock()</code>和<code>std::lock_guard</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 这里的std::lock()需要包含&lt;mutex&gt;头文件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    std::<span class="built_in">lock</span>(lhs.m,rhs.m); <span class="comment">// 1 锁住两个互斥量</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::adopt_lock)</span></span>; <span class="comment">// 2 创建实例</span></span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::adopt_lock)</span></span>; <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::adopt_lock</code>参数除了表示<code>std::lock_guard</code>可获取锁之外，还将锁交由<code>std::lock_guard</code>管理，就不需要<code>std::lock_guard</code>再去构建新的锁了。</p><p><code>std::lock</code>要么将两个锁都锁住，要不一个都不锁。</p><p>C++17中，<code>std::scoped_lock&lt;&gt;</code>是一种新的RAII模板类型，与<code> std::lock_guard&lt;&gt;</code>的功能相同，这个新类型能接受不定数量的互斥量类型作为模板参数，以及相应的互斥量(数量和类型)作为构造参数。</p><p>互斥量支持构造时上锁，与<code>std::lock</code>的用法相同，解锁在析构中进行。代码3.6中swap()操作可以重写如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line"><span class="function">std::scoped_lock <span class="title">guard</span><span class="params">(lhs.m,rhs.m)</span></span>; <span class="comment">// 1 通过传递的对象类型来构造实例，等价于</span></span><br><span class="line">  <span class="comment">//std::scoped_lock&lt;std::mutex,std::mutex&gt; guard(lhs.m,rhs.m);</span></span><br><span class="line"><span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++17新特性：自动推导模板参数。隐式参数模板类型推导机制。</p><p><code> std::scoped_lock</code>的好处在于，可以将所有<code>std::lock</code>替换掉，从而减少错误的发生。</p><h3 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h3><p>无锁的情况下，仅需要两个线程<code>std::thread</code>对象互相调用join()就能产生死锁。这种情况下，没有线程可以继续运行，因为他们正在互相等待。</p><p><strong>避免嵌套锁</strong></p><p>线程获得一个锁时，就别再去获取第二个。每个线程只持有一个锁，就不会产生死锁。</p><p>当需要获取多个锁，使用<code>std::lock</code>来做这件事(对获取锁的操作上锁)，避免产生死锁。</p><p><strong>避免在持有锁时调用外部代码</strong></p><p>外部程序可能做任何事情，包括获取锁。在持有锁的情况下，如果用外部代码要获取一个锁，就会违反第一个指导意见，并造成死锁。</p><p><strong>使用固定顺序获取锁</strong></p><p>当硬性要求获取两个或两个以上的锁，并且不能使用<code>std::lock</code>单独操作来获取它们时，最好在每个线程上，用固定的顺序获取它们(锁)。</p><p>例如，不同线程以相反顺序访问列表所造成的死锁。当节点A和B在列表中相邻，当前线程可能会同时尝试获取A和B上的锁。另一个线程可能已经获取了节点B上的锁，并试图获取节点A上的锁——经典的死锁场景。</p><table><thead><tr><th align="center">线程1</th><th align="center">线程2</th></tr></thead><tbody><tr><td align="center">锁住主入口的互斥量</td><td align="center"></td></tr><tr><td align="center">读取头结点指针</td><td align="center"></td></tr><tr><td align="center">锁住头结点互斥量</td><td align="center"></td></tr><tr><td align="center">解锁主入口互斥量</td><td align="center"></td></tr><tr><td align="center"></td><td align="center">锁住主入口互斥量</td></tr><tr><td align="center">读取head-&gt;next指针</td><td align="center">锁住尾结点互斥量</td></tr><tr><td align="center">锁住next结点的互斥量</td><td align="center">读取tail-&gt;prev指针</td></tr><tr><td align="center">读取next-&gt;next指针</td><td align="center">解锁尾结点的互斥量</td></tr><tr><td align="center">…</td><td align="center">…</td></tr><tr><td align="center">锁住A结点的互斥量</td><td align="center">锁住C结点的互斥量</td></tr><tr><td align="center">读取A-&gt;next指针(也就是B结点)</td><td align="center">读取C-&gt;next指针(也就是B结点)</td></tr><tr><td align="center"></td><td align="center">锁住B结点互斥量</td></tr><tr><td align="center">阻塞，尝试锁住B结点的互斥量</td><td align="center">解锁C结点互斥量</td></tr><tr><td align="center"></td><td align="center">读取B-&gt;prev指针(也就是A结点)</td></tr><tr><td align="center"></td><td align="center">阻塞，尝试锁住A结点的互斥量</td></tr><tr><td align="center">死锁！</td><td align="center"></td></tr></tbody></table><p>当A、C节点中间的B节点删除时，有线程在已获取A和C上的锁后，还要获取B节点上的锁时，就可能发生死锁。</p><p>解决：定义遍历的顺序，一个线程必须先锁住A才能获取B的锁，在锁住B之后才能获取C的锁。这将消除死锁，不允许反向遍历链表。</p><p><strong>使用层次锁结构</strong></p><p>当代码试图对互斥量上锁，而低层已持有该层锁时，不允许锁定。可以通过每个互斥量对应的层数，以及每个线程使用的互斥量，在运行时检查锁定操作是否可以进行。</p><p>层级互斥量不可能死锁，因为互斥量本身会严格遵循约定进行上锁。当多个互斥量在是在同一级上时，不能同时持有多个锁。</p><p>代码3.7 使用层次锁来避免死锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">hierarchical_mutex <span class="title">high_level_mutex</span><span class="params">(<span class="number">10000</span>)</span></span>; <span class="comment">// 1 3个hierarchical_mutex实例，逐渐递减的层级构造</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">low_level_mutex</span><span class="params">(<span class="number">5000</span>)</span></span>;  <span class="comment">// 2</span></span><br><span class="line"><span class="function">hierarchical_mutex <span class="title">other_mutex</span><span class="params">(<span class="number">6000</span>)</span></span>; <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_low_level_stuff</span><span class="params">()</span></span>; <span class="comment">// 假设do_low_level_stuff不会对任何互斥量进行上锁</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">low_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(low_level_mutex)</span></span>; <span class="comment">// 4 low_level_func为层级最低的函数，并且会对low_level_mutex进行上锁</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">do_low_level_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_stuff</span><span class="params">(<span class="keyword">int</span> some_param)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">high_level_func</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(high_level_mutex)</span></span>; <span class="comment">// 6 锁的层级更高</span></span><br><span class="line">  <span class="built_in">high_level_stuff</span>(<span class="built_in">low_level_func</span>()); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_a</span><span class="params">()</span>  <span class="comment">// 7 遵守规则，运行成功</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">other_stuff</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">high_level_func</span>();  <span class="comment">// 10</span></span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_b</span><span class="params">()</span> <span class="comment">// 8 other_stuff()调用high_level_func()时，就违反了层级结构,运行失败</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::lock_guard&lt;hierarchical_mutex&gt; <span class="title">lk</span><span class="params">(other_mutex)</span></span>; <span class="comment">// 9 中层级的数据已被保护</span></span><br><span class="line">  <span class="built_in">other_stuff</span>(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码3.8 简单的层级互斥量实现</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">hierarchical_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::mutex internal_mutex;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">const</span> hierarchy_value;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">long</span> previous_hierarchy_value;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span> this_thread_hierarchy_value;  <span class="comment">// 1 当前线程的层级值</span></span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">check_for_hierarchy_violation</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value &lt;= hierarchy_value)  <span class="comment">// 2 判断层级抛出异常</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_hierarchy_value</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    previous_hierarchy_value=this_thread_hierarchy_value;  <span class="comment">// 3</span></span><br><span class="line">    this_thread_hierarchy_value=hierarchy_value;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">hierarchical_mutex</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> value)</span>:</span></span><br><span class="line"><span class="function">      hierarchy_value(value),</span></span><br><span class="line"><span class="function">      previous_hierarchy_value(<span class="number">0</span>)</span></span><br><span class="line"><span class="function">  &#123;</span>&#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    internal_mutex.<span class="built_in">lock</span>();  <span class="comment">// 4 lock()代表内部互斥锁已锁住</span></span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();  <span class="comment">// 5 一旦成功锁住，更新层级值</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(this_thread_hierarchy_value!=hierarchy_value)</span><br><span class="line">      <span class="keyword">throw</span> std::<span class="built_in">logic_error</span>(“mutex hierarchy violated”);  <span class="comment">// 9</span></span><br><span class="line">    this_thread_hierarchy_value=previous_hierarchy_value;  <span class="comment">// 6 对层级值进行保存</span></span><br><span class="line">    internal_mutex.<span class="built_in">unlock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="built_in">check_for_hierarchy_violation</span>();</span><br><span class="line">    <span class="keyword">if</span>(!internal_mutex.<span class="built_in">try_lock</span>())  <span class="comment">// 7 try_lock()与lock()的功能相似，除了在调用internal_mutex的try_lock()失败时，不能持有对应锁，所以不必更新层级值，并直接返回false。</span></span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="built_in">update_hierarchy_value</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">thread_local</span> <span class="keyword">unsigned</span> <span class="keyword">long</span></span></span><br><span class="line"><span class="function">     <span class="title">hierarchical_mutex::this_thread_hierarchy_value</span><span class="params">(ULONG_MAX)</span></span>;  <span class="comment">// 8 初始化为最大值</span></span><br></pre></td></tr></table></figure><p><strong>超越锁的延伸扩展</strong></p><p>死锁不仅仅会发生在锁之间，也会发生在同步构造中(可能会产生一个等待循环)</p><p>如果去等待一个线程结束，应该确定这个线程的层级，这样一个线程只需要等待比其层级低的线程结束即可。</p><p><code>std::lock()</code>和<code>std::lock_guard</code>可组成简单的锁，并覆盖大多数情况，但有时需要更多的灵活性，可以使用标准库提供的<code>std::unique_lock</code>模板。</p><h3 id="std-unique-lock——灵活的锁"><a href="#std-unique-lock——灵活的锁" class="headerlink" title="std::unique_lock——灵活的锁"></a><code>std::unique_lock</code>——灵活的锁</h3><p><code>std::unique_lock</code>实例不带互斥量：信息已存储，且已更新。在创建时自动加锁，在销毁时自动解锁****</p><p><strong>unique_lock是对lock_guard的扩展，允许在生命周期内再调用lock和unlock来加解锁以切换锁的状态。</strong></p><p>但是内存会占用比较多的空间，并且比<code>std::lock_guard</code>稍慢一些。</p><p>使用时<code>std::lock_guard&lt;std::mutex&gt; lk(mtx);</code>直接替换成<code>std::unique_lock&lt;std::mutex&gt; lk(mtx);</code></p><p><strong>lock_guard和unique_lock第二参数的作用:</strong></p><ul><li><p><code>std::adopt_lock</code>: 假设调用一方已经拥有了互斥量的所有权（已经lock成功了）；通知lock_guard不需要再构造函数中lock这个互斥量了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mtx, std::adopt_lock)</span></span>;</span><br><span class="line">    g_mtx.<span class="built_in">lock</span>();</span><br><span class="line">    临界区或临界资源</span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure><p>对于lock_guard第二参数类型只有一种，锁管理器构造的时候不会自动对可锁对象上锁；由可锁对象自己加锁；等锁管理器析构的时候自动解锁。</p><p>如果指定了第二参数，但是没有lock，锁管理器析构的时候解锁了无拥有权的可锁对象，导致异常。</p><p>多锁场景下，会调用<code>std::lock</code>避免死锁的出现，但是这个方法要求锁管理器不能拥有可锁对象，由<code>std::lock</code>方法执行锁操作。如果没有提供第二参数构造函数，那么就无法使用该方法。</p><p>注意：使用该参数类型构造的锁管理器必须只能通过可锁对象进行lock，不可通过锁管理器进行lock，误用会导致程序异常。</p></li><li><p><code>std::defer_lock</code>: 初始化了一个没有加锁的mutex。前提是自己不能先lock否则报异常。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock</span><span class="params">(g_mtx, std::defer_lock)</span></span>;</span><br><span class="line">    lock.<span class="built_in">lock</span>();           <span class="comment">// 不能用g_mtx.lock()，第二次锁的时候会崩溃</span></span><br><span class="line">    临界区或临界资源</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>锁管理器在构造的时候不主动lock且不拥有可锁对象；如果后续执行lock，锁管理器析构的时候自动解锁。</p><p>注意：该类型构造的锁管理器只能通过锁管理器执行lock且拥有可锁对象。如果直接调用可锁对象进行锁操作后，会导致程序异常。</p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">some_big_object</span>;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(some_big_object&amp; lhs,some_big_object&amp; rhs)</span></span>;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  some_big_object some_detail;</span><br><span class="line">  std::mutex m;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(some_big_object <span class="keyword">const</span>&amp; sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">friend</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(X&amp; lhs, X&amp; rhs)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(lhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 </span></span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lock_b</span><span class="params">(rhs.m,std::defer_lock)</span></span>; <span class="comment">// 1 std::defer_lock 留下未上锁的互斥量</span></span><br><span class="line">    std::<span class="built_in">lock</span>(lock_a,lock_b); <span class="comment">// 2 互斥量在这里上锁</span></span><br><span class="line">    <span class="built_in">swap</span>(lhs.some_detail,rhs.some_detail);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>std::unique_lock</code>支持lock(), try_lock()和unlock()成员函数</p><h3 id="不同域中互斥量的传递"><a href="#不同域中互斥量的传递" class="headerlink" title="不同域中互斥量的传递"></a>不同域中互斥量的传递</h3><p><code>std::unique_lock</code>是可移动，但不可赋值的类型。</p><p>函数get_lock()锁住了互斥量，然后准备数据，返回锁的调用函数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">get_lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">extern</span> std::mutex some_mutex;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(some_mutex)</span></span>;</span><br><span class="line">  <span class="built_in">prepare_data</span>();</span><br><span class="line">  <span class="keyword">return</span> lk;  <span class="comment">// 1 lk在函数中被声明为自动变量，它不需要调用std::move()，可以直接返回</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(get_lock())</span></span>;  <span class="comment">// 2 process_data()函数直接转移std::unique_lock实例的所有权</span></span><br><span class="line">  <span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::unique_lock</code>的灵活性同样也允许实例在销毁之前放弃拥有的锁。可以使用unlock()来做这件事，如同一个互斥量：<code>std::unique_lock</code>的成员函数提供类似于锁定和解锁的功能。</p><h3 id="锁的粒度"><a href="#锁的粒度" class="headerlink" title="锁的粒度"></a>锁的粒度</h3><p>锁的粒度：用来描述通过一个锁保护着的数据量大小。<em>一个细粒度锁</em>(a fine-grained lock)能够保护较小的数据量，<em>一个粗粒度锁</em>(a coarse-grained lock)能够保护较多的数据量。</p><p>如果很多线程正在等待同一个资源(等待收银员对自己拿到的商品进行清点)，当有线程持有锁的时间过长，这就会增加等待的时间(别等到结账的时候，才想起来蔓越莓酱没拿)。</p><p><code>std::unique_lock</code>在这种情况下工作正常，调用unlock()时，代码不需要再访问共享数据。当再次需要对共享数据进行访问时，再调用lock()就可以了。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">my_lock</span><span class="params">(the_mutex)</span></span>;</span><br><span class="line">  some_class data_to_process=<span class="built_in">get_next_data_chunk</span>();</span><br><span class="line">  my_lock.<span class="built_in">unlock</span>();  <span class="comment">// 1 不要让锁住的互斥量越过process()函数的调用</span></span><br><span class="line">  result_type result=<span class="built_in">process</span>(data_to_process);</span><br><span class="line">  my_lock.<span class="built_in">lock</span>(); <span class="comment">// 2 为了写入数据，对互斥量再次上锁</span></span><br><span class="line">  <span class="built_in">write_result</span>(data_to_process,result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不需要让锁住的互斥量越过对process()函数的调用，所以可以在函数调用①前对互斥量进行手动解锁，之后对其再次上锁②。</p><p>代码3.10 比较操作符中一次锁住一个互斥量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">int</span> some_detail;</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex m;</span><br><span class="line">  <span class="function"><span class="keyword">int</span> <span class="title">get_detail</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lock_a</span><span class="params">(m)</span></span>;  <span class="comment">// 1</span></span><br><span class="line">    <span class="keyword">return</span> some_detail;</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">Y</span>(<span class="keyword">int</span> sd):<span class="built_in">some_detail</span>(sd)&#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span>==(Y <span class="keyword">const</span>&amp; lhs, Y <span class="keyword">const</span>&amp; rhs)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(&amp;lhs==&amp;rhs)</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> lhs_value=lhs.<span class="built_in">get_detail</span>();  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">int</span> <span class="keyword">const</span> rhs_value=rhs.<span class="built_in">get_detail</span>();  <span class="comment">// 3</span></span><br><span class="line">    <span class="keyword">return</span> lhs_value==rhs_value;  <span class="comment">// 4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>比较操作符首先通过调用get_detail()成员函数检索要比较的值②③，函数在索引时被锁保护着①。比较操作符会在之后比较索引出来的值④。</p><p>虽然锁只持有一次的操作能减少锁持有的时间(这样能消除死锁的可能性)，但这里有一个微妙的语义操作同时对两个锁住的值进行比较。</p><p>当操作符返回true时，就意味着在这个时间点上的lhs.some_detail与另一个时间点的rhs.some_detail相同。</p><p>这两个值在读取之后，可能会以任意方式修改。两个值会在②和③处进行交换，这样就会失去了比较的意义。比较可能会返回true，表明这两个值是相等的，实际上这两个值相等的情况可能就发生在一瞬间。</p><p>当持有锁的时间没有达到整个操作时间，就会让自己处于条件竞争的状态。</p><h2 id="保护共享数据的方式"><a href="#保护共享数据的方式" class="headerlink" title="保护共享数据的方式"></a>保护共享数据的方式</h2><h3 id="保护共享数据的初始化过程"><a href="#保护共享数据的初始化过程" class="headerlink" title="保护共享数据的初始化过程"></a>保护共享数据的初始化过程</h3><p>假设有一个共享源，构建代价很昂贵，它可能会打开一个数据库连接或分配出很多的内存。</p><p>延迟初始化(Lazy initialization)在单线程代码很常见————每一个操作都需要先对源进行检查，为了了解数据是否被初始化，然后在其使用前决定，数据是否需要初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 1</span></span><br><span class="line">  &#125;</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转为多线程代码时，只有①处需要保护，这样共享数据对于并发访问就是安全的。</p><p>代码3.11 使用延迟初始化(线程安全)的过程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;some_resource&gt; resource_ptr;</span><br><span class="line">std::mutex resource_mutex;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(resource_mutex)</span></span>;  <span class="comment">// 所有线程在此序列化 </span></span><br><span class="line">  <span class="keyword">if</span>(!resource_ptr)</span><br><span class="line">  &#123;</span><br><span class="line">    resource_ptr.<span class="built_in">reset</span>(<span class="keyword">new</span> some_resource);  <span class="comment">// 只有初始化过程需要保护 </span></span><br><span class="line">  &#125;</span><br><span class="line">  lk.<span class="built_in">unlock</span>();</span><br><span class="line">  resource_ptr-&gt;<span class="built_in">do_something</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码3.12 使用<code>std::call_once</code>作为类成员的延迟初始化(线程安全)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  connection_info connection_details;</span><br><span class="line">  connection_handle connection;</span><br><span class="line">  std::once_flag connection_init_flag;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">open_connection</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    connection=connection_manager.<span class="built_in">open</span>(connection_details);</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">X</span>(connection_info <span class="keyword">const</span>&amp; connection_details_):</span><br><span class="line">      <span class="built_in">connection_details</span>(connection_details_)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">send_data</span><span class="params">(data_packet <span class="keyword">const</span>&amp; data)</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  <span class="comment">// 2</span></span><br><span class="line">    connection.<span class="built_in">send_data</span>(data);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function">data_packet <span class="title">receive_data</span><span class="params">()</span>  <span class="comment">// 3</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    std::<span class="built_in">call_once</span>(connection_init_flag,&amp;X::open_connection,<span class="keyword">this</span>);  <span class="comment">// 2</span></span><br><span class="line">    <span class="keyword">return</span> connection.<span class="built_in">receive_data</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>例子中第一次调用send_data()①或receive_data()③的线程完成初始化过程。使用成员函数open_connection()去初始化数据，也需要将this指针传进去。</p><p><code>std::mutex</code>和<code>std::once_flag</code>的实例不能拷贝和移动，需要通过显式定义相应的成员函数，对这些类成员进行操作。</p><h3 id="保护不常更新的数据机构"><a href="#保护不常更新的数据机构" class="headerlink" title="保护不常更新的数据机构"></a>保护不常更新的数据机构</h3><p>互斥量“读者-作者锁”，其允许两种不同的使用方式：一个“作者”线程独占访问和共享访问，让多个“读者”线程并发访问。</p><p>c++17标准库提供了两种非常好的互斥量——<code>std::shared_mutex</code>和<code>std::shared_timed_mutex</code>。</p><p>对于更新操作，可以使用<code>std::lock_guard&lt;std::shared_mutex&gt;</code>和<code>std::unique_lock&lt;std::shared_mutex&gt;</code>上锁。</p><p>代码3.13 使用<code>std::shared_mutex</code>对数据结构进行保护</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;shared_mutex&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_entry</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">dns_cache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::map&lt;std::string,dns_entry&gt; entries;</span><br><span class="line">  <span class="keyword">mutable</span> std::shared_mutex entry_mutex;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function">dns_entry <span class="title">find_entry</span><span class="params">(std::string <span class="keyword">const</span>&amp; domain)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::shared_lock&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  <span class="comment">// 1 使用std::shared_lock&lt;&gt;来保护共享和只读权限</span></span><br><span class="line">    std::map&lt;std::string,dns_entry&gt;::const_iterator <span class="keyword">const</span> it=</span><br><span class="line">       entries.<span class="built_in">find</span>(domain);</span><br><span class="line">    <span class="keyword">return</span> (it==entries.<span class="built_in">end</span>())?<span class="built_in">dns_entry</span>():it-&gt;second;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">update_or_add_entry</span><span class="params">(std::string <span class="keyword">const</span>&amp; domain,</span></span></span><br><span class="line"><span class="params"><span class="function">                           dns_entry <span class="keyword">const</span>&amp; dns_details)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::shared_mutex&gt; <span class="title">lk</span><span class="params">(entry_mutex)</span></span>;  <span class="comment">// 2 使用std::lock_guard&lt;&gt;实例，当表格需要更新时②，为其提供独占访问权限</span></span><br><span class="line">    entries[domain]=dns_details;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>多线程可以同时调用find_entry()，且不会出错。</p><p>update_or_add_entry()函数调用时，独占锁会阻止其他线程对数据结构进行修改，并且阻止线程调用find_entry()。</p><h3 id="嵌套锁"><a href="#嵌套锁" class="headerlink" title="嵌套锁"></a>嵌套锁</h3><p>线程对已经获取的<code>std::mutex</code>(已经上锁)再次上锁是错误的，尝试这样做会导致未定义行为。</p><p>C++标准库提供了<code>std::recursive_mutex</code>类。除了可以在同一线程的单个实例上多次上锁，其他功能与<code>std::mutex</code>相同。</p><p>其他线程对互斥量上锁前，当前线程必须释放拥有的所有锁，所以如果你调用lock()三次，也必须调用unlock()三次。</p><p>使用<code>std::lock_guard&lt;std::recursive_mutex&gt;</code>和<code>std::unique_lock&lt;std::recursive_mutex&gt;</code></p><p>嵌套锁一般用在可并发访问的类上。每个公共成员函数都会对互斥量上锁，然后完成对应的操作后再解锁互斥量。不过，有时成员函数会调用另一个成员函数，这种情况下，第二个成员函数也会试图锁住互斥量，这就会导致未定义行为的发生。</p><p>解决方案为将互斥量转为嵌套锁，第二个成员函数就能成功的进行上锁，并且函数能继续执行。</p><p>缺点：对应类的不变量通常会被破坏。当不变量被破坏时，第二个成员函数还需要继续执行。</p><p>一个比较好的方式是，从中提取出一个函数作为类的私有成员，这个私有成员函数不会对互斥量进行上锁(调用前必须获得锁)。然后，需要仔细考虑一下，这种情况调用新函数时数据的状态。</p><h1 id="4-同步操作"><a href="#4-同步操作" class="headerlink" title="4.同步操作"></a>4.同步操作</h1><h2 id="等待事件或条件"><a href="#等待事件或条件" class="headerlink" title="等待事件或条件"></a>等待事件或条件</h2><p>当一个线程等待另一个线程完成时，可以持续的检查共享数据标志(用于做保护工作的互斥量)，直到另一线程完成工作时对这个标识进行重置。但是，这种方式会消耗线程的执行时间检查标识，并且当互斥量上锁后，其他线程就没有办法获取锁，就会持续等待。</p><p>在等待线程在检查间隙，使用<code>std::this_thread::sleep_for()</code>进行周期性的间歇</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> flag;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">wait_for_flag</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!flag)</span><br><span class="line">  &#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 1 解锁互斥量</span></span><br><span class="line">    std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">100</span>));  <span class="comment">// 2 休眠100ms</span></span><br><span class="line">    lk.<span class="built_in">lock</span>();   <span class="comment">// 3 再锁互斥量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当线程休眠时没有浪费执行时间，但很难确定正确的休眠时间。</p><p>条件变量：通过另一线程触发等待事件的机制是最基本的唤醒方式(例如：流水线上存在额外的任务时)</p><p>条件变量会与多个事件或其他条件相关，并且一个或多个线程会等待条件的达成。当某些线程被终止时，为了唤醒等待线程(允许等待线程继续执行)，终止线程将会向等待着的线程广播“条件达成”的信息。</p><h3 id="等待条件达成"><a href="#等待条件达成" class="headerlink" title="等待条件达成"></a>等待条件达成</h3><p>c++标准库条件变量的实现：<code>std::condition_variable</code>和<code>std::condition_variable_any</code>，这两个实现都包含在<code>&lt;condition_variable&gt;</code>头文件的声明中。</p><p>两者都需要与互斥量一起才能工作(互斥量是为了同步)，前者仅能与<code>std::mutex</code>一起工作，而后者可以和合适的互斥量一起工作，从而加上了<code>_any</code>的后缀。</p><p><code> std::condition_variable_any</code>更加通用，不过在性能和系统资源的使用方面会有更多的开销，所以通常会将<code>std::condition_variable</code>作为首选类型。</p><p>代码4.1 使用<code>std::condition_variable</code>处理数据等待</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">std::mutex mut;</span><br><span class="line">std::queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1 队列中中有两个线程，两个线程之间会对数据进行传递</span></span><br><span class="line">std::condition_variable data_cond;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2 数据压入队列</span></span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();  <span class="comment">// 3 对等待的线程(如果有等待线程)进行通知</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;  <span class="comment">// 4 对互斥量上锁</span></span><br><span class="line">    data_cond.<span class="built_in">wait</span>(</span><br><span class="line">         lk,[]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);  <span class="comment">// 5 传递一个锁和一个Lambda表达式(作为等待的条件)</span></span><br><span class="line">    data_chunk data=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    lk.<span class="built_in">unlock</span>();  <span class="comment">// 6</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>wait()会去检查这些条件(通过Lambda函数)，当条件满足(Lambda函数返回true)时返回。如果条件不满足(Lambda函数返回false)，wait()将解锁互斥量，并且将线程(处理数据的线程)置于阻塞或等待状态。当准备数据的线程调用notify_one()通知条件变量时，处理数据的线程从睡眠中苏醒，重新获取互斥锁，并且再次进行条件检查。在条件满足的情况下，从wait()返回并继续持有锁。当条件不满足时，线程将对互斥量解锁，并重新等待。</p><p>用<code>std::unique_lock</code>而不使用<code>std::lock_guard</code>的原因：等待中的线程必须在等待期间解锁互斥量，并对互斥量再次上锁，而<code>std::lock_guard</code>没有这么灵活。</p><p>可以不使用lambda表达式，写一个检查函数传入到wait()。调用wait()的过程中，在互斥量锁定时，可能会去检查条件变量若干次，当提供测试条件的函数返回true就会立即返回。</p><p><strong>伪唤醒：</strong>当等待线程重新获取互斥量并检查条件变量时，并非直接响应另一个线程的通知。</p><p>当多个线程同时在等待同一条件，此时条件满足发起唤醒则可能会唤醒多个线程，但是如果对应的资源不够所有唤醒线程使用，则剩余线程的唤醒就是无意义的，也就被称作虚假唤醒。</p><p>避免方法：在睡眠返回之后重新检查条件判断（while代替if）</p><p><code> std::condition_variable::wait</code>是“忙碌-等待”的优化。下面用简单的循环实现了一个“忙碌-等待”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Predicate&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">minimal_wait</span><span class="params">(std::unique_lock&lt;std::mutex&gt;&amp; lk, Predicate pred)</span></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">pred</span>())&#123;</span><br><span class="line">    lk.<span class="built_in">unlock</span>();</span><br><span class="line">    lk.<span class="built_in">lock</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构建线程安全队列"><a href="#构建线程安全队列" class="headerlink" title="构建线程安全队列"></a>构建线程安全队列</h3><p>代码4.3 线程安全队列的接口</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span> <span class="comment">// 为了使用std::shared_ptr</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>();</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>(<span class="keyword">const</span> threadsafe_queue&amp;);</span><br><span class="line">  threadsafe_queue&amp; <span class="keyword">operator</span>=(</span><br><span class="line">      <span class="keyword">const</span> threadsafe_queue&amp;) = <span class="keyword">delete</span>;  <span class="comment">// 不允许简单的赋值</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span>;  <span class="comment">// 1 返回队列中值的状态</span></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span>;  <span class="comment">// 2 直接返回检索值，当没有值可检索时，这个函数返回NULL。</span></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span>;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>裁剪了很多构造函数，并禁止简单赋值。需要提供两个版本的try_pop()和wait_for_pop()。</p><p>代码4.4 从代码4.1中提取push()和wait_and_pop()</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  std::mutex mut;</span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">threadsafe_queue&lt;data_chunk&gt; data_queue;  <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_preparation_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="built_in">more_data_to_prepare</span>())</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk <span class="keyword">const</span> data=<span class="built_in">prepare_data</span>();</span><br><span class="line">    data_queue.<span class="built_in">push</span>(data);  <span class="comment">// 2</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">data_processing_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    data_chunk data;</span><br><span class="line">    data_queue.<span class="built_in">wait_and_pop</span>(data);  <span class="comment">// 3</span></span><br><span class="line">    <span class="built_in">process</span>(data);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">is_last_chunk</span>(data))</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>线程队列中有互斥量和条件变量，所以独立的变量就不需要了①，并且push()不需要外部同步②。当然，wait_and_pop()还要兼顾条件变量的等待③。</p><p>代码4.5 使用条件变量的线程安全队列(完整版)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;memory&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">threadsafe_queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> std::mutex mut;  <span class="comment">// 1 互斥量必须是可变的 </span></span><br><span class="line">  std::queue&lt;T&gt; data_queue;</span><br><span class="line">  std::condition_variable data_cond;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>()</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="built_in">threadsafe_queue</span>(threadsafe_queue <span class="keyword">const</span>&amp; other)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(other.mut)</span></span>;</span><br><span class="line">    data_queue=other.data_queue;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(T new_value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">push</span>(new_value);</span><br><span class="line">    data_cond.<span class="built_in">notify_one</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">wait_and_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">wait_and_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    data_cond.<span class="built_in">wait</span>(lk,[<span class="keyword">this</span>]&#123;<span class="keyword">return</span> !data_queue.<span class="built_in">empty</span>();&#125;);</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">try_pop</span><span class="params">(T&amp; value)</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    value=data_queue.<span class="built_in">front</span>();</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::shared_ptr&lt;T&gt; <span class="title">try_pop</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">if</span>(data_queue.<span class="built_in">empty</span>())</span><br><span class="line">      <span class="keyword">return</span> std::shared_ptr&lt;T&gt;();</span><br><span class="line">    <span class="function">std::shared_ptr&lt;T&gt; <span class="title">res</span><span class="params">(std::make_shared&lt;T&gt;(data_queue.front()))</span></span>;</span><br><span class="line">    data_queue.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(mut)</span></span>;</span><br><span class="line">    <span class="keyword">return</span> data_queue.<span class="built_in">empty</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>empty()是一个const成员函数，并且传入拷贝构造函数的other形参是一个const引用。因为其他线程可能有非const引用对象，并调用变种成员函数，所以这里有必要对互斥量上锁。又因为锁住互斥量是个可变操作，所以互斥量成员必须为mutable①才能在empty()和拷贝构造函数中进行上锁。</p><p>当数据准备完成时，调用notify_one()将会唤醒一个正在wait()的线程，检查条件和wait()函数的返回状态(因为仅是向data_queue添加了一个数据项)。</p><h2 id="使用future"><a href="#使用future" class="headerlink" title="使用future"></a>使用future</h2><p>future：当线程需要等待特定事件时，某种程度上来说就需要知道期望的结果。之后，线程会周期性(较短的周期)的等待或检查事件是否触发(检查信息板)，检查期间也会执行其他任务(品尝昂贵的咖啡)。另外，等待任务期间也可以先执行另外的任务，直到对应的任务触发，而后等待future的状态会变为就绪状态。</p><p>当事件发生时(状态为就绪)，这个future就不能重置了。</p><p>c++标准库中，声明在<code>&lt;future&gt;</code>头文件中: unique future(<code>std::future&lt;&gt;</code>)和shared futures(<code>std::shared_future&lt;&gt;</code>)，与了<code>std::unique_ptr</code>和<code>std::shared_ptr</code>非常类似。</p><p><code>std::future</code>只能与指定事件相关联，而<code>std::shared_future</code>就能关联多个事件。后者的实现中，所有实例会在同时变为就绪状态，并且可以访问与事件相关的数据。</p><p>当多个线程需要访问一个独立future对象时，必须使用互斥量或类似同步机制进行保护。</p><h3 id="后台任务的返回值"><a href="#后台任务的返回值" class="headerlink" title="后台任务的返回值"></a>后台任务的返回值</h3><p>当不着急让任务结果时，可以使用<code>std::async</code>启动一个异步任务。与<code>std::thread</code>对象等待的方式不同，<code>std::async</code>会返回一个<code>std::future</code>对象，这个对象持有最终计算出来的结果。当需要这个值时，只需要调用这个对象的get()成员函数，就会阻塞线程直到future为就绪为止，并返回计算结果。</p><p>代码4.6 <code>std::future</code>从异步任务中获取返回值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_answer_to_ltuae</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_other_stuff</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::future&lt;<span class="keyword">int</span>&gt; the_answer=std::<span class="built_in">async</span>(find_the_answer_to_ltuae);</span><br><span class="line">  <span class="built_in">do_other_stuff</span>();</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer is &quot;</span>&lt;&lt;the_answer.<span class="built_in">get</span>()&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::async</code>允许通过添加额外的调用参数，向函数传递额外的参数。第一个参数是指向成员函数的指针，第二个参数提供这个函数成员类的具体对象(是通过指针，也可以包装在<code>std::ref</code>中)，剩余的参数可作为函数的参数传入。</p><p>代码4.7 使用<code>std::async</code>向函数传递参数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">X</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span>,std::string <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">  <span class="function">std::string <span class="title">bar</span><span class="params">(std::string <span class="keyword">const</span>&amp;)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">X x;</span><br><span class="line"><span class="keyword">auto</span> f1=std::<span class="built_in">async</span>(&amp;X::foo,&amp;x,<span class="number">42</span>,<span class="string">&quot;hello&quot;</span>);  <span class="comment">// 调用p-&gt;foo(42, &quot;hello&quot;)，p是指向x的指针</span></span><br><span class="line"><span class="keyword">auto</span> f2=std::<span class="built_in">async</span>(&amp;X::bar,x,<span class="string">&quot;goodbye&quot;</span>);  <span class="comment">// 调用tmpx.bar(&quot;goodbye&quot;)， tmpx是x的拷贝副本</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Y</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">double</span>)</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line">Y y;</span><br><span class="line"><span class="keyword">auto</span> f3=std::<span class="built_in">async</span>(<span class="built_in">Y</span>(),<span class="number">3.141</span>);  <span class="comment">// 调用tmpy(3.141)，tmpy通过Y的移动构造函数得到</span></span><br><span class="line"><span class="keyword">auto</span> f4=std::<span class="built_in">async</span>(std::<span class="built_in">ref</span>(y),<span class="number">2.718</span>);  <span class="comment">// 调用y(2.718)</span></span><br><span class="line"><span class="function">X <span class="title">baz</span><span class="params">(X&amp;)</span></span>;</span><br><span class="line">std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 调用baz(x)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">move_only</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">move_only</span>();</span><br><span class="line">  <span class="built_in">move_only</span>(move_only&amp;&amp;)</span><br><span class="line">  <span class="built_in">move_only</span>(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only&amp;&amp;);</span><br><span class="line">  move_only&amp; <span class="keyword">operator</span>=(move_only <span class="keyword">const</span>&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">auto</span> f5=std::<span class="built_in">async</span>(<span class="built_in">move_only</span>());  <span class="comment">// 调用tmp()，tmp是通过std::move(move_only())构造得到</span></span><br></pre></td></tr></table></figure><p>future的等待取决于<code>std::async</code>是否启动一个线程，或是否有任务在进行同步。</p><p>可以在函数调用之前向<code>std::async</code>传递一个额外参数:</p><p><code>std::launch::async</code>，表明函数必须在其所在的独立线程上执行；</p><p><code>std::launch::defered</code>，表明函数调用延迟到wait()或get()函数调用时才执行。</p><p><code>std::launch::deferred | std::launch::async</code>表明实现可以选择这两种方式的一种（默认选项）。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> f6=std::<span class="built_in">async</span>(std::launch::async,<span class="built_in">Y</span>(),<span class="number">1.2</span>);  <span class="comment">// 在新线程上执行</span></span><br><span class="line"><span class="keyword">auto</span> f7=std::<span class="built_in">async</span>(std::launch::deferred,baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 在wait()或get()调用时执行</span></span><br><span class="line"><span class="keyword">auto</span> f8=std::<span class="built_in">async</span>(</span><br><span class="line">              std::launch::deferred | std::launch::async,</span><br><span class="line">              baz,std::<span class="built_in">ref</span>(x));  <span class="comment">// 实现选择执行方式</span></span><br><span class="line"><span class="keyword">auto</span> f9=std::<span class="built_in">async</span>(baz,std::<span class="built_in">ref</span>(x));</span><br><span class="line">f7.<span class="built_in">wait</span>();  <span class="comment">//  调用延迟函数</span></span><br></pre></td></tr></table></figure><h3 id="future与任务关联"><a href="#future与任务关联" class="headerlink" title="future与任务关联"></a>future与任务关联</h3><p><code>std::packaged_task&lt;&gt;</code>会将future与函数或可调用对象进行绑定。当调用<code>std::packaged_task&lt;&gt;</code>对象时，就会调用相关函数或可调用对象，当future状态为就绪时，会存储返回值。</p><p>构造<code>std::packaged_task&lt;&gt;</code>实例时，就必须传入函数或可调用对象。这个函数或可调用的对象，需要能接收指定的参数和返回(可转换为指定返回类型的)值。类型可以不完全匹配，因为这里类型可以隐式转换，可以用int类型参数和返回float类型的函数，来构建<code>std::packaged_task&lt;double(double)&gt;</code>实例。</p><p>函数签名的返回类型可以用来标识从get_future()返回的<code>std::future&lt;&gt;</code>的类型，而函数签名的参数列表，可用来指定packaged_task的函数调用操作符。例如，模板偏特化</p><p>代码4.8 <code>std::packaged_task&lt;&gt;</code>的偏特化</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">packaged_task</span>&lt;</span>std::<span class="built_in">string</span>(std::vector&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)&gt;</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Callable&gt;</span></span><br><span class="line"><span class="function">  <span class="keyword">explicit</span> <span class="title">packaged_task</span><span class="params">(Callable&amp;&amp; f)</span></span>;</span><br><span class="line">  <span class="function">std::future&lt;std::string&gt; <span class="title">get_future</span><span class="params">()</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">operator</span><span class="params">()</span><span class="params">(std::vector&lt;<span class="keyword">char</span>&gt;*,<span class="keyword">int</span>)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>当<code>std::packaged_task</code>作为函数调用时，实参将由函数调用操作符传递至底层函数，并且返回值作为异步结果存储在<code>std::future</code>中，并且可通过get_future()获取。</p><p><code>std::packaged_task</code>对任务进行打包，并适时的取回future。当异步任务需要返回值时，可以等待future状态变为“就绪”。</p><p><strong>线程间传递任务</strong></p><p>代码4.9 使用<code>std::packaged_task</code>执行一个图形界面线程</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;deque&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utility&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::mutex m;</span><br><span class="line">std::deque&lt;std::packaged_task&lt;<span class="keyword">void</span>()&gt; &gt; tasks;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">gui_shutdown_message_received</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">get_and_process_gui_message</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gui_thread</span><span class="params">()</span>  <span class="comment">// 1</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">gui_shutdown_message_received</span>())  <span class="comment">// 2 关闭图形界面的信息</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="built_in">get_and_process_gui_message</span>();  <span class="comment">// 3 关闭界面前，进行轮询界面消息处理</span></span><br><span class="line">    std::packaged_task&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt; task;</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">      <span class="keyword">if</span>(tasks.<span class="built_in">empty</span>())  <span class="comment">// 4 当队列中没有任务时，循环将继续</span></span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">      task=std::<span class="built_in">move</span>(tasks.<span class="built_in">front</span>());  <span class="comment">// 5 能在队列中提取出一个任务</span></span><br><span class="line">      tasks.<span class="built_in">pop_front</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">task</span>();  <span class="comment">// 6 释放队列上的锁，并且执行任务</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">std::thread <span class="title">gui_bg_thread</span><span class="params">(gui_thread)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Func&gt;</span></span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">void</span>&gt; <span class="title">post_task_for_gui_thread</span><span class="params">(Func f)</span></span></span><br><span class="line"><span class="function"></span>&#123; </span><br><span class="line">  <span class="function">std::packaged_task&lt;<span class="title">void</span><span class="params">()</span>&gt; <span class="title">task</span><span class="params">(f)</span></span>;  <span class="comment">// 7 提供一个打包好的任务</span></span><br><span class="line">  std::future&lt;<span class="keyword">void</span>&gt; res=task.<span class="built_in">get_future</span>();  <span class="comment">// 8 用get_future()成员函数获取future对象</span></span><br><span class="line">  <span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  tasks.<span class="built_in">push_back</span>(std::<span class="built_in">move</span>(task));  <span class="comment">// 9 任务推入列表</span></span><br><span class="line">  <span class="keyword">return</span> res; <span class="comment">// 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>std::packaged_task</code>是一个类模板，顾名思义是用来打包的，将一个可调用对象封装起来，然后可以将其的返回值传给future。<code>std::packaged_task&lt;函数返回类型(参数类型)&gt; 变量名(函数名)</code>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">x++;</span><br><span class="line">x *= <span class="number">10</span>;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">std::this_thread::<span class="built_in">sleep_for</span>(std::chrono::<span class="built_in">seconds</span>(<span class="number">5</span>));</span><br><span class="line"><span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">std::packaged_task&lt;<span class="title">int</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">pt</span><span class="params">(fun)</span></span>;         <span class="comment">// 将函数打包起来</span></span><br><span class="line">std::future&lt;<span class="keyword">int</span>&gt; fu = pt.<span class="built_in">get_future</span>();        <span class="comment">// 并将结果返回给future</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::ref(pt), <span class="number">1</span>)</span></span>;</span><br><span class="line">std::cout &lt;&lt; fu.<span class="built_in">get</span>() &lt;&lt; std::endl;</span><br><span class="line">std::cout &lt;&lt; std::this_thread::<span class="built_in">get_id</span>() &lt;&lt; std::endl;</span><br><span class="line">t.<span class="built_in">join</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用std-promises"><a href="#使用std-promises" class="headerlink" title="使用std::promises"></a>使用std::promises</h3><p>当线程处理多个连接事件，来自不同的端口连接的数据包基本上以乱序方式进行处理。同样的，数据包也将以乱序的方式进入队列。很多情况下，一些应用不是等待数据成功的发送，就是等待(新的)指定网络接口数据的接收成功。</p><p><code>std::promise</code>是一个类模板，它的作用是在不同的线程中实现数据的同步，与future结合使用，也间接实现了future在不同线程间的同步。</p><p><code>std::promise/std::future</code>对提供一种机制：future可以阻塞等待线程，提供数据的线程可以使用promise对相关值进行设置，并将future的状态置为“就绪”。</p><p>当promise设置完毕(使用set_value()成员函数)时，对应的future状态就变为“就绪”，并且可用于检索已存储的值。当设置值之前销毁<code>std::promise</code>，将会存储一个异常。</p><p>代码4.10 使用promise解决单线程多连接问题</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;future&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_connections</span><span class="params">(connection_set&amp; connections)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!<span class="built_in">done</span>(connections))  <span class="comment">// 1 循环直到done()返回true为止</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">for</span>(connection_iterator  <span class="comment">// 2</span></span><br><span class="line">            connection=connections.<span class="built_in">begin</span>(),end=connections.<span class="built_in">end</span>();</span><br><span class="line">          connection!=end;</span><br><span class="line">          ++connection)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_incoming_data</span>())  <span class="comment">// 3 检索是否有数据</span></span><br><span class="line">      &#123;</span><br><span class="line">        data_packet data=connection-&gt;<span class="built_in">incoming</span>();</span><br><span class="line">        std::promise&lt;payload_type&gt;&amp; p=</span><br><span class="line">            connection-&gt;<span class="built_in">get_promise</span>(data.id);  <span class="comment">// 4</span></span><br><span class="line">        p.<span class="built_in">set_value</span>(data.payload);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span>(connection-&gt;<span class="built_in">has_outgoing_data</span>())  <span class="comment">// 5 检索是否正在发送已入队的传出数据</span></span><br><span class="line">      &#123;</span><br><span class="line">        outgoing_packet data=</span><br><span class="line">            connection-&gt;<span class="built_in">top_of_outgoing_queue</span>();</span><br><span class="line">        connection-&gt;<span class="built_in">send</span>(data.payload);</span><br><span class="line">        data.promise.<span class="built_in">set_value</span>(<span class="literal">true</span>);  <span class="comment">// 6 当发送完成，传出数据相关的promise将置为true，来表明传输成功</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>set_value()</code>则直接将future的状态设置为ready。需要注意的是在使用的过程中不能多次<code>set_value()</code>，也不能多次<code>get_future()</code>和多次<code>get()</code>，因为一个promise对象只能和一个对象相关联，否则就会抛出异常。</p><h2 id="将异常存于future中"><a href="#将异常存于future中" class="headerlink" title="将异常存于future中"></a>将异常存于future中</h2><p>函数作为<code>std::async</code>的一部分时，当调用抛出一个异常时，这个异常就会存储到future中，之后future的状态置为“就绪”，之后调用get()会抛出已存储的异常(注意：标准级别没有指定重新抛出的这个异常是原始的异常对象，还是一个拷贝。不同的编译器和库将会在这方面做出不同的选择)。</p><p>将函数打包入<code>std::packaged_task</code>任务包后，当任务调用时，同样的事情也会发生。打包函数抛出一个异常，这个异常将存储在future中，在get()调用时会再次抛出。</p><p><code>std::promise</code>也能提供同样的功能。当存入的是异常而非数值时，就需要调用set_exception()成员函数，而非set_value()。这通常是用在一个catch块中，并作为算法的一部分。为了捕获异常，这里使用异常填充promise：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> std::promise&lt;<span class="keyword">double</span>&gt; some_promise;</span><br><span class="line"><span class="keyword">try</span></span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_value</span>(<span class="built_in">calculate_value</span>());</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in"><span class="keyword">catch</span></span>(...)</span><br><span class="line">&#123;</span><br><span class="line">  some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">current_exception</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>std::current_exception()</code>来检索抛出的异常，可用<code>std::copy_exception()</code>作为替代方案，<code>std::copy_exception()</code>会直接存储新的异常而不抛出：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_promise.<span class="built_in">set_exception</span>(std::<span class="built_in">copy_exception</span>(std::<span class="built_in">logic_error</span>(<span class="string">&quot;foo &quot;</span>)));</span><br></pre></td></tr></table></figure><p>这比使用try/catch块更加清晰，当异常类型已知，就应该优先使用。</p><h3 id="多个线程的等待"><a href="#多个线程的等待" class="headerlink" title="多个线程的等待"></a>多个线程的等待</h3><p>多线程在没有额外同步的情况下，访问独立<code>std::future</code>对象时，就会有数据竞争和未定义行为。因为<code>std::future</code>独享同步结果，并且通过调用get()函数，一次性的获取数据，这就让并发访问变的毫无意义。</p><p><code>std::shared_future</code>：其所有权可以在不同的实例中互相传递，但只有一个实例可以获得特定的同步结果，而<code>std::shared_future</code>实例是可拷贝的，所以多个对象可以引用同一关联期望值的结果。</p><p>每一个<code>std::shared_future</code>的独立对象上，成员函数调用返回的结果还是不同步的，所以为了在多个线程访问一个独立对象时避免数据竞争，必须使用锁来对访问进行保护。优先使用的办法：为了替代只有一个拷贝对象的情况，可以让每个线程都拥有自己对应的拷贝对象。这样，当每个线程都通过自己拥有的<code>std::shared_future</code>对象获取结果，那么多个线程访问共享同步结果就是安全的。</p><p><code>std::shared_future</code>的实例同步<code>std::future</code>实例的状态。当<code>std::future</code>对象没有与其他对象共享同步状态所有权，那么所有权必须使用<code>std::move</code>将所有权传递到<code>std::shared_future</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;<span class="keyword">int</span>&gt; p;</span><br><span class="line"><span class="function">std::future&lt;<span class="keyword">int</span>&gt; <span class="title">f</span><span class="params">(p.get_future())</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(f.<span class="built_in">valid</span>());  <span class="comment">// 1 期望值 f 是合法的</span></span><br><span class="line"><span class="function">std::shared_future&lt;<span class="keyword">int</span>&gt; <span class="title">sf</span><span class="params">(std::move(f))</span></span>;</span><br><span class="line"><span class="built_in">assert</span>(!f.<span class="built_in">valid</span>());  <span class="comment">// 2 期望值 f 现在是不合法的</span></span><br><span class="line"><span class="built_in">assert</span>(sf.<span class="built_in">valid</span>());  <span class="comment">// 3 sf 现在是合法的</span></span><br></pre></td></tr></table></figure><p>期望值f开始是合法的①，因为引用的是promise p的同步状态，但是在转移sf的状态后，f就不合法了②，而sf就是合法的了③。</p><p>如其他可移动对象一样，转移所有权是对右值的隐式操作，所以可以通过<code>std::promise</code>对象的成员函数get_future()的返回值，直接构造一个<code>std::shared_future</code>对象，例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt;std::string&gt; p;</span><br><span class="line"><span class="function">std::shared_future&lt;std::string&gt; <span class="title">sf</span><span class="params">(p.get_future())</span></span>;  <span class="comment">// 1 隐式转移所有权</span></span><br></pre></td></tr></table></figure><p><code>std::future</code>有一个share()成员函数，可用来创建新的<code>std::shared_future</code> ，并且可以直接转移future的所有权。这样也就能保存很多类型，并且使得代码易于修改：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::promise&lt; std::map&lt; SomeIndexType, SomeDataType, SomeComparator,</span><br><span class="line">     SomeAllocator&gt;::iterator&gt; p;</span><br><span class="line"><span class="keyword">auto</span> sf=p.<span class="built_in">get_future</span>().<span class="built_in">share</span>();</span><br></pre></td></tr></table></figure><p>当比较器或分配器有所改动，只需要对promise的类型进行修改即可。future的类型会自动与promise的修改进行匹配。</p><h2 id="限时等待"><a href="#限时等待" class="headerlink" title="限时等待"></a>限时等待</h2><h3 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a>时钟</h3><p>时钟和与时间相关的工具，都在<code>&lt;chrono&gt;</code>库头文件中定义。</p><p>c++标准库中，时钟是一个类，提供了四种不同的信息：</p><p>当前时间可以通过静态成员函数now()从获取。例如，<code>std::chrono::system_clock::now()</code>会返回系统的当前时间。返回类型为some_clock::time_point</p><p>通常情况下，因为<code>std::chrono::system_clock</code>可调，所以是不稳定的。这可调可能造成首次调用now()返回的时间要早于上次调用now()所返回的时间，这就违反了节拍频率的均匀分布。</p><p>稳定时钟<code>std::chrono::steady_clock</code>。</p><h3 id="时间段"><a href="#时间段" class="headerlink" title="时间段"></a>时间段</h3><p><code>std::chrono::duration&lt;&gt;</code>函数模板能够对时间段进行处理(线程库使用到的所有C++时间处理工具，都在<code>std::chrono</code>命名空间内)。第一个模板参数是一个类型表示(比如，int，long或double)，第二个模板参数是定制部分，表示每一个单元所用秒数。</p><p>例如，<code>std::chrono::duration&lt;short, std::ratio&lt;60, 1&gt;&gt;</code>，几分钟的时间要存在short类型中，因为60秒是才是1分钟，所以第二个参数写成<code>std::ratio&lt;60, 1&gt;</code>。当需要将毫秒级计数存在double类型中时，可以写成<code>std::chrono::duration&lt;double, std::ratio&lt;1, 1000&gt;&gt;</code>，因为1秒等于1000毫秒</p><p>标准库在<code>std::chrono</code>命名空间内为时间段变量提供一系列预定义类型：nanoseconds[纳秒] , microseconds[微秒] , milliseconds[毫秒] , seconds[秒] , minutes[分]和hours[时]。</p><p>当不要求截断值的情况下(时转换成秒是没问题，但是秒转换成时就不行)时间段的转换是隐式的，显示转换可以由<code>std::chrono::duration_cast&lt;&gt;</code>来完成。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="function">chrono::milliseconds <span class="title">ms</span><span class="params">(<span class="number">54802</span>)</span></span>;</span><br><span class="line">std::chrono::seconds s=</span><br><span class="line">       std::chrono::duration_cast&lt;std::chrono::seconds&gt;(ms);</span><br></pre></td></tr></table></figure><p>这里的结果就是截断的，而不是进行了舍入，所以s最后的值为54。</p><p>时间值支持四则运算，所以能够对两个时间段进行加减，或者是对一个时间段乘除一个常数(模板的第一个参数)来获得一个新时间段变量。例如，5*seconds(1)与seconds(5)或minutes(1)-seconds(55)是一样。</p><p>在时间段中可以通过count()成员函数获得单位时间的数量。例如，<code>std::chrono::milliseconds(1234).count()</code>就是1234。</p><p>例如：等待future状态变为就绪需要35毫秒：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::future&lt;<span class="keyword">int</span>&gt; f=std::<span class="built_in">async</span>(some_task);</span><br><span class="line"><span class="keyword">if</span>(f.<span class="built_in">wait_for</span>(std::chrono::<span class="built_in">milliseconds</span>(<span class="number">35</span>))==std::future_status::ready)</span><br><span class="line">  <span class="built_in">do_something_with</span>(f.<span class="built_in">get</span>());</span><br></pre></td></tr></table></figure><p>等待函数会返回状态值，表示是等待是超时，还是继续等待。等待future时，超时时会返回<code>std::future_status::timeout</code>。当future状态改变，则会返回<code>std::future_status::ready</code>。当与future相关的任务延迟了，则会返回<code>std::future_status::deferred</code>。</p><p>系统调度的不确定性和不同操作系统的时钟精度意味着：线程调用和返回的实际时间间隔可能要比35毫秒长。</p><h3 id="时间点"><a href="#时间点" class="headerlink" title="时间点"></a>时间点</h3><p>时间点可用<code>std::chrono::time_point&lt;&gt;</code>来表示，第一个参数用来指定使用的时钟，第二个函数参数用来表示时间单位(特化的<code>std::chrono::duration&lt;&gt;</code>)。</p><p>可以通过对<code>std::chrono::time_point&lt;&gt;</code>实例进行加/减，来获得一个新的时间点，所以<code>std::chrono::hight_resolution_clock::now() + std::chrono::nanoseconds(500)</code>将得到500纳秒后的时间，这对于计算绝对时间来说非常方便。</p><p>可以减去一个时间点(二者需要共享同一个时钟)，结果是两个时间点的时间差：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">auto</span> start=std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line"><span class="built_in">do_something</span>();</span><br><span class="line"><span class="keyword">auto</span> stop=std::chrono::high_resolution_clock::<span class="built_in">now</span>();</span><br><span class="line">std::cout&lt;&lt;”<span class="built_in">do_something</span>() took “</span><br><span class="line">  &lt;&lt;std::chrono::duration&lt;<span class="keyword">double</span>,std::chrono::seconds&gt;(stop-start).<span class="built_in">count</span>()</span><br><span class="line">  &lt;&lt;” seconds”&lt;&lt;std::endl;</span><br></pre></td></tr></table></figure><p>代码4.11 等待条件变量满足条件——有超时功能</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;chrono&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::condition_variable cv;</span><br><span class="line"><span class="keyword">bool</span> done;</span><br><span class="line">std::mutex m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">wait_loop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">auto</span> <span class="keyword">const</span> timeout= std::chrono::steady_clock::<span class="built_in">now</span>()+</span><br><span class="line">      std::chrono::<span class="built_in">milliseconds</span>(<span class="number">500</span>);</span><br><span class="line">  <span class="function">std::unique_lock&lt;std::mutex&gt; <span class="title">lk</span><span class="params">(m)</span></span>;</span><br><span class="line">  <span class="keyword">while</span>(!done) <span class="comment">// while循环处理假唤醒</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(cv.<span class="built_in">wait_until</span>(lk,timeout)==std::cv_status::timeout) <span class="comment">// 等待函数wait_until()传入一个时间点</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当没有什么可以等待时，可在一定时限中等待条件变量。这种方式中，循环的整体长度有限。当循环中使用wait_for()时，可能在等待了足够长的时间后结束等待(在假唤醒之前)，且下一次等待又开始了。这可能重复很多次，出现无限等待的情况。</p><h3 id="使用超时"><a href="#使用超时" class="headerlink" title="使用超时"></a>使用超时</h3><p>最简单方式，对特定线程添加延迟处理。</p><p>例如循环检查“done”标志，两个处理函数分别是<code>std::this_thread::sleep_for()</code>和<code>std::this_thread::sleep_until()</code>。当线程因为指定时长而进入睡眠时，可使用sleep_for()唤醒，可指定休眠的时间点，之后可使用sleep_until唤醒。</p><p><code>std::mutex</code>和<code>std::recursive_mutex</code>都不支持超时，而<code>std::timed_mutex</code>和<code>std::recursive_timed_mutex</code>支持超时。这两种类型也有try_lock_for()和try_lock_until()成员函数，可以在一段时期内尝试获取锁，或在指定时间点前获取互斥锁。</p><p>表4.1 可接受超时的函数</p><table border="1">  <td>类型/命名空间</td>  <td>函数</td>  <td>返回值</td><tr>  <td rowspan="2"> std::this_thread 命名空间 </td>  <td> sleep_for(duration) </td>  <td rowspan="2">N/A</td></tr><tr>  <td>sleep_until(time_point)</td></tr><tr>  <td rowspan="2">std::condition_variable 或 std::condition_variable_any</td>  <td>wait_for(lock, duration)</td>  <td rowspan="2">std::cv_status::time_out 或 std::cv_status::no_timeout</td></tr><tr>  <td>wait_until(lock, time_point)</td></tr><tr>  <td rowspan="2"> </td>  <td> wait_for(lock, duration, predicate)</td>  <td rowspan="2">bool —— 当唤醒时，返回谓词的结果</td></tr><tr>  <td>wait_until(lock, duration, predicate)</td></tr><tr>  <td rowspan="2">std::timed_mutex 或 std::recursive_timed_mutex</td>  <td>try_lock_for(duration)</td>  <td rowspan="2"> bool —— 获取锁时返回true，否则返回fasle</td></tr><tr>  <td>try_lock_until(time_point)</td></tr><tr>  <td rowspan="2">std::unique_lock&lt;TimedLockable&gt;</td>  <td>unique_lock(lockable, duration)</td>  <td>N/A —— 对新构建的对象调用owns_lock();</td></tr><tr>  <td>unique_lock(lockable, time_point)</td>  <td>当获取锁时返回true，否则返回false</td></tr><tr>  <td rowspan="2"></td>  <td>try_lock_for(duration)</td>  <td rowspan="2">bool —— 当获取锁时返回true，否则返回false</td></tr><tr>  <td>try_lock_until(time_point)</td></tr><tr>  <td rowspan="3">std::future&lt;ValueType&gt;或std::shared_future&lt;ValueType&gt;</td>  <td>wait_for(duration)</td>  <td>当等待超时，返回std::future_status::timeout</td></tr><tr>  <td rowspan="2">wait_until(time_point)</td>  <td>当期望值准备就绪时，返回std::future_status::ready</td></tr><tr>  <td>当期望值持有一个为启动的延迟函数，返回std::future_status::deferred</td></tr></table><h1 id="5-内存模型和原子操作"><a href="#5-内存模型和原子操作" class="headerlink" title="5.内存模型和原子操作"></a>5.内存模型和原子操作</h1><h2 id="内存模型"><a href="#内存模型" class="headerlink" title="内存模型"></a>内存模型</h2><h3 id="对象和内存位置"><a href="#对象和内存位置" class="headerlink" title="对象和内存位置"></a>对象和内存位置</h3><p>图5.1 将一个struct分解为多个对象，展示每个对象的内存位置。</p><img src="/posts/20a59019/5-1.png" alt="5-1" style="zoom: 50%;"><p>完整的struct是一个有多个子对象(每一个成员变量)组成的对象。</p><p>四个原则：</p><ol><li>每个变量都是对象，包括其成员变量的对象。</li><li>每个对象至少占有一个内存位置。</li><li>基本类型都有确定的内存位置(无论类型大小如何，即使他们是相邻的，或是数组的一部分)。</li><li>相邻位域是相同内存中的一部分。</li></ol><h3 id="对象、内存位置和并发"><a href="#对象、内存位置和并发" class="headerlink" title="对象、内存位置和并发"></a>对象、内存位置和并发</h3><p>当两个线程访问同一个内存位置，如果线程不更新数据，只读数据不需要保护或同步。当线程对内存位置上的数据进行修改，就可能会产生<strong>条件竞争</strong>。</p><p>为了避免条件竞争，线程就要以一定的顺序执行：</p><ul><li>使用<strong>互斥量</strong>来确定访问的顺序。当同一互斥量在两个线程同时访问前锁住，那么在同一时间内就只有一个线程能够访问对应的内存位置。</li><li>使用<strong>原子操作</strong>决定两个线程的访问顺序，当多个线程访问同一个内存地址时，对每个访问者都需要设定顺序。</li></ul><p>如果不规定对同一内存地址访问的顺序，那么访问就不是原子的。当两个线程都是“写入者”时，就会产生数据竞争和未定义行为。</p><p>使用原子操作避免未定义行为。</p><h3 id="修改顺序"><a href="#修改顺序" class="headerlink" title="修改顺序"></a>修改顺序</h3><p>C++程序中的对象都有(由程序中的所有线程对象)在初始化开始阶段确定好修改顺序的。大多数情况下，这个顺序不同于执行中的顺序，但在给定的程序中，所有线程都需要遵守这个顺序。</p><p>如果使用原子操作，编译器就有责任去做同步。</p><h2 id="原子操作和原子类型"><a href="#原子操作和原子类型" class="headerlink" title="原子操作和原子类型"></a>原子操作和原子类型</h2><h3 id="标准原子类型"><a href="#标准原子类型" class="headerlink" title="标准原子类型"></a>标准原子类型</h3><p>标准原子类型定义在头文件<code>&lt;atomic&gt;</code>中。</p><p>原子操作可以替代互斥量，来完成同步操作。</p><p>表5.1 标准原子类型的备选名和与其相关的<code>std::atomic&lt;&gt;</code>特化类</p><table><thead><tr><th>原子类型</th><th>相关特化类</th></tr></thead><tbody><tr><td>atomic_bool</td><td>std::atomic&lt;bool&gt;</td></tr><tr><td>atomic_char</td><td>std::atomic&lt;char&gt;</td></tr><tr><td>atomic_schar</td><td>std::atomic&lt;signed char&gt;</td></tr><tr><td>atomic_uchar</td><td>std::atomic&lt;unsigned char&gt;</td></tr><tr><td>atomic_int</td><td>std::atomic&lt;int&gt;</td></tr><tr><td>atomic_uint</td><td>std::atomic&lt;unsigned&gt;</td></tr><tr><td>atomic_short</td><td>std::atomic&lt;short&gt;</td></tr><tr><td>atomic_ushort</td><td>std::atomic&lt;unsigned short&gt;</td></tr><tr><td>atomic_long</td><td>std::atomic&lt;long&gt;</td></tr><tr><td>atomic_ulong</td><td>std::atomic&lt;unsigned long&gt;</td></tr><tr><td>atomic_llong</td><td>std::atomic&lt;long long&gt;</td></tr><tr><td>atomic_ullong</td><td>std::atomic&lt;unsigned long long&gt;</td></tr><tr><td>atomic_char16_t</td><td>std::atomic&lt;char16_t&gt;</td></tr><tr><td>atomic_char32_t</td><td>std::atomic&lt;char32_t&gt;</td></tr><tr><td>atomic_wchar_t</td><td>std::atomic&lt;wchar_t&gt;</td></tr></tbody></table><p>C++标准库不仅提供基本原子类型，还定义了与原子类型对应的非原子类型，就如同标准库中的<code>std::size_t</code>。如表5.2所示这些类型:</p><p>表5.2 标准原子类型定义(typedefs)和对应的内置类型定义(typedefs)</p><table><thead><tr><th>原子类型定义</th><th>标准库中相关类型定义</th></tr></thead><tbody><tr><td>atomic_int_least8_t</td><td>int_least8_t</td></tr><tr><td>atomic_uint_least8_t</td><td>uint_least8_t</td></tr><tr><td>atomic_int_least16_t</td><td>int_least16_t</td></tr><tr><td>atomic_uint_least16_t</td><td>uint_least16_t</td></tr><tr><td>atomic_int_least32_t</td><td>int_least32_t</td></tr><tr><td>atomic_uint_least32_t</td><td>uint_least32_t</td></tr><tr><td>atomic_int_least64_t</td><td>int_least64_t</td></tr><tr><td>atomic_uint_least64_t</td><td>uint_least64_t</td></tr><tr><td>atomic_int_fast8_t</td><td>int_fast8_t</td></tr><tr><td>atomic_uint_fast8_t</td><td>uint_fast8_t</td></tr><tr><td>atomic_int_fast16_t</td><td>int_fast16_t</td></tr><tr><td>atomic_uint_fast16_t</td><td>uint_fast16_t</td></tr><tr><td>atomic_int_fast32_t</td><td>int_fast32_t</td></tr><tr><td>atomic_uint_fast32_t</td><td>uint_fast32_t</td></tr><tr><td>atomic_int_fast64_t</td><td>int_fast64_t</td></tr><tr><td>atomic_uint_fast64_t</td><td>uint_fast64_t</td></tr><tr><td>atomic_intptr_t</td><td>intptr_t</td></tr><tr><td>atomic_uintptr_t</td><td>uintptr_t</td></tr><tr><td>atomic_size_t</td><td>size_t</td></tr><tr><td>atomic_ptrdiff_t</td><td>ptrdiff_t</td></tr><tr><td>atomic_intmax_t</td><td>intmax_t</td></tr><tr><td>atomic_uintmax_t</td><td>uintmax_t</td></tr></tbody></table><p>对于标准类型进行typedef T，相关的原子类型就在原来的类型名前加上atomic_的前缀：atomic_T。</p><p>通常，标准原子类型不能进行拷贝和赋值，它们没有拷贝构造函数和拷贝赋值操作符。但是，可以隐式转化成对应的内置类型，所以这些类型依旧支持赋值，可以使用<code>load()</code>和<code>store()</code>、<code>exchange()</code>、<code>compare_exchange_weak()</code>和<code>compare_exchange_strong()</code>。</p><p>它们都支持复合赋值符：+=, -=, *=, |= 等等。并且使用整型和指针的特化类型还支持++和–操作。</p><p>每种函数类型的操作都有一个内存序参数，这个参数可以用来指定存储的顺序。操作分为三类：</p><ol><li><em>Store</em>操作，可选如下内存序：<code>memory_order_relaxed</code>, <code>memory_order_release</code>, <code>memory_order_seq_cst</code>。</li><li><em>Load</em>操作，可选如下内存序：<code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_seq_cst</code>。</li><li><em>Read-modify-write</em>(读-改-写)操作，可选如下内存序：<code>memory_order_relaxed</code>, <code>memory_order_consume</code>, <code>memory_order_acquire</code>, <code>memory_order_release</code>, <code>memory_order_acq_rel</code>, <code>memory_order_seq_cst</code>。</li></ol><h3 id="std-atomic-flag"><a href="#std-atomic-flag" class="headerlink" title="std::atomic_flag"></a><code>std::atomic_flag</code></h3><p><code>std::atomic_flag</code>是最简单的原子类型，这个类型的对象可以在两个状态间切换：设置和清除。</p><p><code>std::atomic_flag</code>类型的对象必须被ATOMIC_FLAG_INIT初始化。初始化标志位是“清除”状态。这里没得选择，这个标志总是初始化为“清除”：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">std::atomic_flag f = ATOMIC_FLAG_INIT;</span><br></pre></td></tr></table></figure><p>这适用于任何对象的声明，是唯一需要以如此特殊的方式初始化的原子类型，但也是唯一保证无锁的类型。首次使用时，需要初始化。如果<code>std::atomic_flag</code>是静态存储的，那么就的保证其是静态初始化的，也就意味着没有初始化顺序问题。</p><p>当标志对象已初始化，只能做三件事情：</p><ul><li>销毁，clear()成员函数，是一个存储操作，所以不能有memory_order_acquire或memory_order_acq_rel语义</li><li>清除或设置(查询之前的值)，test_and_set()成员函数，“读-改-写”操作，可以应用于任何内存顺序。</li></ul><p>每一个原子操作，默认的内存序都是memory_order_seq_cst。例如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">f.<span class="built_in">clear</span>(std::memory_order_release);  <span class="comment">// 1 使用释放语义清除标志</span></span><br><span class="line"><span class="keyword">bool</span> x=f.<span class="built_in">test_and_set</span>();  <span class="comment">// 2 使用默认内存序设置表示，并且检索旧值</span></span><br></pre></td></tr></table></figure><p>不能拷贝构造<code>std::atomic_flag</code>对象，不能将一个对象赋予另一个<code>std::atomic_flag</code>对象。这不是<code>std::atomic_flag</code>特有的属性，而是所有原子类型共有的属性。</p><p><strong>原子类型的所有操作都是原子的，而赋值和拷贝调用了两个对象，这就就破坏了操作的原子性。</strong></p><blockquote><p>互斥锁与自旋锁</p><p>同一时刻只能有一个线程获取到锁，没有获取到锁的线程通常有两种处理方式：</p><ul><li>没有获取到锁的线程就一直循环等待判断该资源是否已经释放锁，这种锁叫做自旋锁，它不用将线程阻塞起来(NON-BLOCKING)</li><li>把自己阻塞起来，等待重新调度请求，这种叫做互斥锁。</li></ul><p>自旋锁的定义：当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取(占用)，那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为自旋锁(spinlock)。</p><p>因为自旋锁避免了操作系统进程调度和线程切换，所以自旋锁通常适用在时间比较短的情况下。由于这个原因，<strong>操作系统的内核经常使用自旋锁</strong>。但是，如果长时间上锁的话，自旋锁会非常耗费性能，它阻止了其他线程的运行和调度。线程持有锁的时间越长，则持有该锁的线程将被 <code>OS(Operating System)</code> 调度程序中断的风险越大。</p></blockquote><p>代码5.1 使用<code>std::atomic_flag</code>实现自旋锁</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">spinlock_mutex</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  std::atomic_flag flag;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">spinlock_mutex</span>():</span><br><span class="line">    <span class="built_in">flag</span>(ATOMIC_FLAG_INIT)</span><br><span class="line">  &#123;&#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(flag.<span class="built_in">test_and_set</span>(std::memory_order_acquire));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span></span></span><br><span class="line"><span class="function">  </span>&#123;</span><br><span class="line">    flag.<span class="built_in">clear</span>(std::memory_order_release);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于<code>std::atomic_flag</code>的局限性太强，没有非修改查询操作，甚至不能像普通的布尔标志那样使用。所以，实际操作中最好使用<code>std::atomic&lt;bool&gt;</code></p><h3 id="std-atomic-lt-bool-gt"><a href="#std-atomic-lt-bool-gt" class="headerlink" title="std::atomic&lt;bool&gt;"></a><code>std::atomic&lt;bool&gt;</code></h3><p>最基本的原子整型类型就是<code>std::atomic&lt;bool&gt;</code>，它有着比<code>std::atomic_flag</code>更加齐全的布尔标志特性。</p><p>不能拷贝和拷贝赋值，但可以使用非原子的bool类型进行构造，所以可以初始化为true或false，并且可以从非原子bool变量赋值给<code>std::atomic&lt;bool&gt;</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">b</span><span class="params">(<span class="literal">true</span>)</span></span>;</span><br><span class="line">b=<span class="literal">false</span>;</span><br></pre></td></tr></table></figure><p>store()是一个存储操作，而load()是一个加载操作，exchange()是一个“读-改-写”操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> x=b.<span class="built_in">load</span>(std::memory_order_acquire);</span><br><span class="line">b.<span class="built_in">store</span>(<span class="literal">true</span>); <span class="comment">// 使用store()写入(true或false) </span></span><br><span class="line">x=b.<span class="built_in">exchange</span>(<span class="literal">false</span>, std::memory_order_acq_rel); <span class="comment">// exchange()允许使用新选的值替换已存储的值，并且会自动检索原始值</span></span><br></pre></td></tr></table></figure><p>另一种存储方式：当前值与预期值一致时，存储新值的操作。<strong>存储一个新值(或旧值)取决于当前值</strong></p><p>比较/交换：表现为compare_exchange_weak()和compare_exchange_strong()</p><p>比较原子变量的当前值和期望值，当两值相等时，存储所提供值。当两值不等，期望值就会被更新为原子变量中的值。</p><p>“比较/交换”函数值是一个bool变量，当返回true时执行存储操作，false则更新期望值。当存储完成(因为只相等)，则操作是成功的，否则即为失败。操作成功是返回true，失败时返回false。</p><p>因为<code>compare_exchange_weak()</code>可以伪失败，所以通常会配合一个循环使用：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> expected=<span class="literal">false</span>;</span><br><span class="line"><span class="keyword">extern</span> atomic&lt;<span class="keyword">bool</span>&gt; b; <span class="comment">// 设置些什么</span></span><br><span class="line"><span class="keyword">while</span>(!b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>) &amp;&amp; !expected);</span><br></pre></td></tr></table></figure><p>循环中expected的值始终是false，表示compare_exchange_weak()会莫名的失败。</p><p>另一方面，当实际值与<code>expected</code>不符，compare_exchange_strong()就能保证值返回false。这就能消除对循环的需要，就可以知道是否成功的改变了一个变量，或已让另一个线程完成。</p><p>“compare/exchange”另一点不同的是，它拥有对两个内存序的参数进行操作的能力，这就允许内存序语义在成功和失败的例子中有所不同。可能成功时使用memory_order_acq_rel，而失败时使用memory_order_relaxed。失败的“compare/exchange”将不会进行存储，所以“compare/exchange”操作不能拥有meory_order_release或memory_order_acq_rel。</p><p>下面对compare_exchange_weak()的两次调用是等价的：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; b;</span><br><span class="line"><span class="keyword">bool</span> expected;</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>,</span><br><span class="line">  memory_order_acq_rel,memory_order_acquire);</span><br><span class="line">b.<span class="built_in">compare_exchange_weak</span>(expected,<span class="literal">true</span>,memory_order_acq_rel);</span><br></pre></td></tr></table></figure><p><code>std::atomic&lt;bool&gt;</code>和<code>std::atomic_flag</code>的不同之处在于，<code>std::atomic&lt;bool&gt;</code>可能不是无锁的。为了保证操作的原子性，其实现中可能需要内置的互斥量。特殊情况时，可以使用is_lock_free()成员函数，检查<code>std::atomic&lt;bool&gt;</code>上的操作是否无锁。这是除了<code>std::atomic_flag</code>之外，另一个所有原子类型都拥有的特征(is_lock_free)。</p><h3 id="std-atomic-lt-T-gt"><a href="#std-atomic-lt-T-gt" class="headerlink" title="std::atomic&lt;T*&gt;"></a><code>std::atomic&lt;T*&gt;</code></h3><p>原子指针类型，可以使用内置类型或自定义类型T，通过特化<code>std::atomic&lt;T*&gt;</code>进行定义，操作是针对于相关类型的指针。</p><p>不能拷贝构造，也不能拷贝赋值，但是可以通过合适的类型指针进行构造和赋值。<code>std::atomic&lt;T*&gt;</code>也有load(), store(), exchange(), compare_exchange_weak()和compare_exchage_strong()成员函数，获取与返回的类型都是T*。</p><p><code>std::atomic&lt;T*&gt;</code>为指针运算提供新的操作。基本操作有fetch_add()和fetch_sub()，它们在存储地址上做原子加法和减法，为+=, -=, ++和–提供简易的封装。对于内置类型的操作，例如：如果x是<code>std::atomic&lt;Foo*&gt;</code>类型的数组的首地址，然后x+=3让其偏移到第四个元素的地址，并返回一个普通的<code>Foo*</code>类型值，这个指针值是指向数组中第四个元素。</p><p>fetch_add()和fetch_sub()的返回值略有不同(所以x.ftech_add(3)让x指向第四个元素，并且函数返回指向第一个元素的地址)。这种操作也被称为“交换-相加”，并且这是一个原子的“读-改-写”操作，如同exchange()和compare_exchange_weak()/compare_exchange_strong()一样。正像其他操作那样，返回值是一个普通的<code>T*</code>值，而非是<code>std::atomic&lt;T*&gt;</code>对象的引用，所以调用代码可以基于之前的值进行操作：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span>&#123;</span>&#125;;</span><br><span class="line">Foo some_array[<span class="number">5</span>];</span><br><span class="line"><span class="function">std::atomic&lt;Foo*&gt; <span class="title">p</span><span class="params">(some_array)</span></span>;</span><br><span class="line">Foo* x=p.<span class="built_in">fetch_add</span>(<span class="number">2</span>);  <span class="comment">// p加2，并返回原始值</span></span><br><span class="line"><span class="built_in">assert</span>(x==some_array);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>()==&amp;some_array[<span class="number">2</span>]);</span><br><span class="line">x=(p-=<span class="number">1</span>);  <span class="comment">// p减1，并返回原始值</span></span><br><span class="line"><span class="built_in">assert</span>(x==&amp;some_array[<span class="number">1</span>]);</span><br><span class="line"><span class="built_in">assert</span>(p.<span class="built_in">load</span>()==&amp;some_array[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><p>函数也允许内存序作为给定函数的参数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">p.<span class="built_in">fetch_add</span>(<span class="number">3</span>,std::memory_order_release);</span><br></pre></td></tr></table></figure><p>因为fetch_add()和fetch_sub()都是“读-改-写”操作，可以使用任意的内存序，以及加入到一个释放序列中。因为没办法提供必要的信息(这些形式都具有memory_order_seq_cst语义)，所以指定的语序不支持操作符形式。</p><h3 id="标准原子整型的相关操作"><a href="#标准原子整型的相关操作" class="headerlink" title="标准原子整型的相关操作"></a>标准原子整型的相关操作</h3><p>如同普通的操作集合一样(load(), store(), exchange(), compare_exchange_weak(), 和compare_exchange_strong())，<code>std::atomic&lt;int&gt;</code>和<code>std::atomic&lt;unsigned long long&gt;</code>也是有一套完整的操作可以供使用：fetch_add(), fetch_sub(), fetch_and(), fetch_or(), fetch_xor()，还有复合赋值方式((+=, -=, &amp;=, |=和^=)，以及++和–(++x, x++, –x和x–)。</p><p>虽然对于普通的整型来说，这些复合赋值方式还不完全：除法、乘法和移位操作不在其中。因为，整型原子值通常用来作计数器，或者是掩码，所以以上操作的缺失显得不是那么重要。如果需要，可以使用compare_exchange_weak()完成。</p><p>对于<code>std::atomic&lt;T*&gt;</code>类型，紧密相关的两个函数就是fetch_add()和fetch_sub()。函数原子化操作，并且返回旧值，而符合赋值运算会返回新值。前缀加减和后缀加减与普通用法一样：++x对变量进行自加，并且返回新值；而x++对变量自加，返回旧值。</p><h3 id="std-atomic-lt-gt-类模板"><a href="#std-atomic-lt-gt-类模板" class="headerlink" title="std::atomic&lt;&gt;类模板"></a><code>std::atomic&lt;&gt;</code>类模板</h3><p>模板允许用户使用自定义类型创建一个原子变量(除了标准原子类型之外)，需要满足一定的标准才可以使用<code>std::atomic&lt;&gt;</code>。</p><p>为了使用<code>std::atomic&lt;UDT&gt;</code>(UDT是用户定义类型)，这个类型必须有拷贝赋值运算符。这就意味着这个类型不能有任何虚函数或虚基类，以及必须使用编译器创建的拷贝赋值操作。自定义类型中所有的基类和非静态数据成员也都需要支持拷贝赋值操作。这(基本上)就允许编译器使用memcpy()或赋值操作的等价操作，因为实现中没有用户代码。</p><p><strong>不要将锁定区域内的数据以引用或指针的形式，作为参数传递给用户提供的函数。</strong></p><p>创建一个<code>std::atomic&lt;std::vector&lt;int&gt;&gt;</code>类型。不能使用包含有计数器，标志指针和简单数组的类型，作为特化类型。虽然这不会导致任何问题，但是越是复杂的数据结构，就有越多的操作，而非只有赋值和比较。如果这种情况发生了，最好使用<code>std::mutex</code>保护数据。</p><p>当使用用户定义类型T进行实例化时，<code>std::atomic&lt;T&gt;</code>的可用接口就只有: load(), store(), exchange(), compare_exchange_weak(), compare_exchange_strong()和赋值操作，以及向类型T转换的操作。</p><p>表5.3 每一个原子类型所能使用的操作</p><img src="/posts/20a59019/5-3-table.png" alt="5-3-table" style="zoom: 50%;"><h3 id="原子操作的非成员函数"><a href="#原子操作的非成员函数" class="headerlink" title="原子操作的非成员函数"></a>原子操作的非成员函数</h3><p>大多数非成员函数的命名与对应成员函数有关，需要<code>atomic_</code>作为前缀(比如，<code>std::atomic_load()</code>)。这些函数都会重载不同的原子类型，指定内存序时会分成两种：一种没有标签，另一种以<code>_explicit</code>为后缀，并且需要额外的参数，或将内存序作为标签，亦或只有标签(例如，<code>std::atomic_store(&amp;atomic_var,new_value)</code>与<code>std::atomic_store_explicit(&amp;atomic_var,new_value,std::memory_order_release</code>)。</p><p>成员函数隐式引用原子对象，所有非成员函数都持有一个指向原子对象的指针(作为第一个参数)。</p><p>例如，<code>std::atomic_is_lock_free()</code>只有一种类型(虽然会被其他类型所重载)，并且对于同一个对象a，<code>std::atomic_is_lock_free(&amp;a)</code>返回值与a.is_lock_free()相同。</p><p>同样的，<code>std::atomic_load(&amp;a)</code>和a.load()的作用一样。需要注意的是，<code>a.load(std::memory_order_acquire)</code>与<code>std::atomic_load_explicit(&amp;a, std::memory_order_acquire)</code>的操作相同。</p><p>非成员函数的设计是为了与C语言兼容，C语言中没有引用。</p><p>C++标准库也对原子类型中的<code>std::shared_ptr&lt;&gt;</code>智能指针类型提供非成员函数，这打破了“只有原子类型，才能提供原子操作”的原则。<code>std::shared_ptr&lt;&gt;</code>不是原子类型，但是C++标准委员会认为这很重要。可使用的原子操作有：load, store, exchange和compare/exchange，这些操作重载了标准原子类型的操作，并且可获取<code>std::shared_ptr&lt;&gt;*</code>作为第一个参数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">std::shared_ptr&lt;my_data&gt; p;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process_global_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::shared_ptr&lt;my_data&gt; local=std::<span class="built_in">atomic_load</span>(&amp;p);</span><br><span class="line">  <span class="built_in">process_data</span>(local);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">update_global_data</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::shared_ptr&lt;my_data&gt; <span class="title">local</span><span class="params">(<span class="keyword">new</span> my_data)</span></span>;</span><br><span class="line">  std::<span class="built_in">atomic_store</span>(&amp;p,local);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>标准原子类型不仅仅是为了避免数据竞争所造成的未定义行为，还允许用户对不同线程上的操作进行强制排序。这种强制排序是数据保护和同步操作的基础，例如：<code>std::mutex</code>和<code>std::future</code>。</p><h2 id="同步操作和强制排序"><a href="#同步操作和强制排序" class="headerlink" title="同步操作和强制排序"></a>同步操作和强制排序</h2><p>假设两个线程，一个向数据结构中填充数据，另一个读取数据结构中的数据。为了避免恶性条件竞争，第一个线程设置一个标志，用来表明数据已经准备就绪，从而第二个线程在这个标志设置前不能读取数据。</p><p>代码5.2 不同线程对数据的读写</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; data;</span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">data_ready</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reader_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!data_ready.<span class="built_in">load</span>())  <span class="comment">// 1</span></span><br><span class="line">  &#123;</span><br><span class="line">    std::this_thread::<span class="built_in">sleep</span>(std::<span class="built_in">milliseconds</span>(<span class="number">1</span>));</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout&lt;&lt;<span class="string">&quot;The answer=&quot;</span>&lt;&lt;data[<span class="number">0</span>]&lt;&lt;<span class="string">&quot;\m&quot;</span>;  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">writer_thread</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data.<span class="built_in">push_back</span>(<span class="number">42</span>);  <span class="comment">// 3</span></span><br><span class="line">  data_ready=<span class="literal">true</span>;  <span class="comment">// 4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问顺序通过对<code>std::atomic&lt;bool&gt;</code>类型的data_ready变量进行操作完成，这些操作通过*<a href="http://en.wikipedia.org/wiki/Happened-before">先行</a><em>(happens-before)和</em>同发*(synchronizes-with)确定顺序。写入数据③在写入data_ready④前发生，读取①发生在读取数据②之前。</p><p>强制了顺序：写入数据先行于读取数据。</p><p>当data_ready①为true，写操作就会与读操作同步，建立一个“先行”的关系。因为“先行”关系是可传递的，所以写入③先行于写入④，这两个行为又先行于读取操作①，之前的操作都先行于读取数据②。</p><img src="/posts/20a59019/5-2.png" alt="5-2" style="zoom: 67%;"><p>图5.2 对非原子操作，使用原子操作对操作进行强制排序</p><h3 id="同步发生"><a href="#同步发生" class="headerlink" title="同步发生"></a>同步发生</h3><p>“同发”只在原子类型之间进行。例如：操作一个数据结构(对互斥量上锁)，如果数据结构包含有原子类型，并且操作内部执行了一定的原子操作，那这些操作就是“同发”关系。</p><p>“同发”的基本想法：原子写操作W对变量x进行标记，同步与对x进行原子读操作，读取的是W操作写入的内容，或是W之后，同一线程上的原子写操作对x写入的值，亦或是任意线程对x的一系列原子读-改-写操作(例如，fetch_add()或compare_exchange_weak())。</p><p>因为对原子类型的操作默认都有“适当的标记”，如果线程A存储了一个值，并且线程B读取了这个值，线程A的存储操作与线程B的载入操作就是同步发生关系。</p><p>所有细微的差别都在“适当的标记”中，C++内存模型允许为原子类型提供各种约束顺序。</p><h3 id="先行发生"><a href="#先行发生" class="headerlink" title="先行发生"></a>先行发生</h3><p>“先行”关系是一个程序中基本构建块的操作顺序：指定了某个操作去影响另一个操作。</p><p>对于单线程来说：一个操作排在另一个之后，那这个操作就先执行。</p><p>如果源码中操作A发生在操作B之前，那A就先行于B。可以回看代码5.2：对data的写入③先于对data_ready④的写入。如果操作在同时发生，因为操作间无序执行，通常情况下就没有先行关系了。</p><p>代码5.3 对于参数中的函数调用顺序未指定顺序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::cout&lt;&lt;a&lt;&lt;”,”&lt;&lt;b&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_num</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> i=<span class="number">0</span>;</span><br><span class="line">  <span class="keyword">return</span> ++i;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">foo</span>(<span class="built_in">get_num</span>(),<span class="built_in">get_num</span>());  <span class="comment">// 无序调用get_num()</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序会输出“1，2”或“2，1”，因为两个get_num()的执行顺序未指定。</p><p>这种情况下，操作在单一声明中可测序，例如：逗号操作符的使用或是表达式的结果作为参数传给另一个表达式。通常情况下，操作在单一声明中不可排序，所以无法先行安排顺序(也就没有先行发生了)。</p><p>线程间先行可以与排序先行相结合：如果操作A排序先行于操作B，并且操作B线程间先行于操作C，那么A线程间先行于C。同样的，如果A同步于B，并且B排序先于C，那么A线程间先行于C。当对数据进行一系列修改(单线程)时，只需要对数据进行一次同步即可。</p><p>如果操作A与操作B同步，或操作A的顺序在操作B之前，那么A就是强先行于B。也适用于顺序传递：如果A强先行于B，并且B强先行于C，那么A就肯定强先行于C。</p><h3 id="原子操作的内存序"><a href="#原子操作的内存序" class="headerlink" title="原子操作的内存序"></a>原子操作的内存序</h3><p>有六个内存序列选项可应用于对原子类型的操作：</p><ol><li>memory_order_relaxed</li><li>memory_order_consume</li><li>memory_order_acquire</li><li>memory_order_release</li><li>memory_order_acq_rel</li><li>memory_order_seq_cst</li></ol><p>除非为特定的操作指定一个序列选项，要不内存序列默认都是memory_order_seq_cst。</p><p>三种内存模型：</p><ul><li>顺序一致性(sequentially consistent)</li><li>获取-释放序(memory_order_consume, memory_order_acquire, memory_order_release和memory_order_acq_rel)</li><li>自由序(memory_order_relaxed)。</li></ul><p>不同的内存序在不同的CPU架构下功耗不同。不同种类的内存序，允许使用其提升相关操作的性能。使用顺序一致序(相较于其他序列，它是最简单的)时，对于在通常情况来说就够用了。</p><p><strong>顺序一致性</strong></p><p>默认序命名为顺序一致性，因为程序中的行为从任意角度去看，序列都保持一定顺序。</p><p>如果原子实例的所有操作都是序列一致的，那么多线程就会如单线程那样以某种特殊的排序执行</p><p>不同的操作也要遵守相同的顺序。因为行为简单，可以使用原子变量进行编写。通过不同的线程，可以写出所有可能的操作消除那些不一致，以及确认代码的行为是否与预期相符。所以，操作都不能重排；如果代码在一个线程中，将一个操作放在另一个操作前面，那其他线程也需要了解这个顺序。</p><p>缺点：因为整个序列中的操作都必须在多个处理器上保持一致，可能需要对处理器间的同步操作进行扩展(代价很昂贵！)</p><p>代码5.4 全序——序列一致性</p><p>#include <atomic><br>#include <thread><br>#include &lt;assert.h&gt;</thread></atomic></p><p>std::atomic<bool> x,y;<br>std::atomic<int> z;</int></bool></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);  <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_seq_cst);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_seq_cst))  <span class="comment">// 3</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_seq_cst));</span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_seq_cst))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>assert⑤语句是永远不会触发的，因为不是存储x的操作①发生，就是存储y的操作②发生。</p><img src="/posts/20a59019/5-3.png" alt="5-3" style="zoom: 50%;"><p>图5.3 序列一致与先行关系</p><p>序列一致性是最简单、直观的序列，因为需要对所有线程进行全局同步，所以也是开销最大的内存序。多处理器设备上需要在处理期间，在信息交换上耗费大量的时间。</p><p>为了避免这种消耗，就需考虑使用其他内存序。</p><p><strong>非顺序一致性内存</strong></p><p>不同线程看到相同操作，不一定有着相同的顺序。</p><p>不仅是考虑事情同时发生的问题，还有<strong>线程没办法保证一致性</strong>。</p><p><strong>自由序</strong></p><p>原子类型上的操作以自由序执行。同一线程中对于同一变量的操作还是遵从先行关系，但不同线程不需要规定顺序。唯一的要求是在访问同一线程中的单个原子变量不能重排序，当给定线程看到原子变量的值时，随后线程的读操作就不会去检索较早的那个值。当使用memory_order_relaxed时，不需要任何额外的同步，对于每个变量的修改顺序只存在于线程间共享。</p><p>代码5.5 非限制操作只有非常少的顺序要求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这次assert⑤可能会触发，因为加载x的操作④可能读取到false，即使加载y的操作③读取到true，并且存储x的操作①先发与存储y的操作②。x和y是两个不同的变量，所以没有顺序去保证每个操作产生相关值的可见性。</p><p>非限制操作对于不同变量可以重排序，只要服从任意的先行关系即可(比如，在同一线程中)。</p><img src="/posts/20a59019/5-4.png" alt="5-4" style="zoom: 50%;"><p>图5.4 非限制原子操作与先发执行</p><p>代码5.6 非限制操作——多线程版</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">x</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">y</span><span class="params">(<span class="number">0</span>)</span>,<span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;  <span class="comment">// 1</span></span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">go</span><span class="params">(<span class="literal">false</span>)</span></span>;  <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">const</span> loop_count=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">read_values</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">  <span class="keyword">int</span> x,y,z;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">read_values values1[loop_count];</span><br><span class="line">read_values values2[loop_count];</span><br><span class="line">read_values values3[loop_count];</span><br><span class="line">read_values values4[loop_count];</span><br><span class="line">read_values values5[loop_count];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(std::atomic&lt;<span class="keyword">int</span>&gt;* var_to_inc,read_values* values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();  <span class="comment">// 3 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    values[i].x=x.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].z=z.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    var_to_inc-&gt;<span class="built_in">store</span>(i+<span class="number">1</span>,std::memory_order_relaxed);  <span class="comment">// 4</span></span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_vals</span><span class="params">(read_values* values)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!go)</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>(); <span class="comment">// 5 自旋，等待信号</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    values[i].x=x.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].y=y.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    values[i].z=z.<span class="built_in">load</span>(std::memory_order_relaxed);</span><br><span class="line">    std::this_thread::<span class="built_in">yield</span>();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print</span><span class="params">(read_values* v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;loop_count;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span>(i)</span><br><span class="line">      std::cout&lt;&lt;<span class="string">&quot;,&quot;</span>;</span><br><span class="line">    std::cout&lt;&lt;<span class="string">&quot;(&quot;</span>&lt;&lt;v[i].x&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].y&lt;&lt;<span class="string">&quot;,&quot;</span>&lt;&lt;v[i].z&lt;&lt;<span class="string">&quot;)&quot;</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  std::cout&lt;&lt;std::endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(increment,&amp;x,values1)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(increment,&amp;y,values2)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t3</span><span class="params">(increment,&amp;z,values3)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t4</span><span class="params">(read_vals,values4)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t5</span><span class="params">(read_vals,values5)</span></span>;</span><br><span class="line"></span><br><span class="line">  go=<span class="literal">true</span>;  <span class="comment">// 6 开始执行主循环的信号</span></span><br><span class="line"></span><br><span class="line">  t5.<span class="built_in">join</span>();</span><br><span class="line">  t4.<span class="built_in">join</span>();</span><br><span class="line">  t3.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="built_in">print</span>(values1);  <span class="comment">// 7 打印最终结果</span></span><br><span class="line">  <span class="built_in">print</span>(values2);</span><br><span class="line">  <span class="built_in">print</span>(values3);</span><br><span class="line">  <span class="built_in">print</span>(values4);</span><br><span class="line">  <span class="built_in">print</span>(values5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>三个全局原子变量①和五个线程。每一个线程循环10次，使用时memory_order_relaxed读取三个原子变量的值，并且将它们存储在一个数组上。其中三个线程每次通过循环④来更新其中一个原子变量，这时剩下的两个线程就负责读取。当线程都汇入主线程，就能打印出来每个线程存到数组上的值了。</p><p>原子变量go②用来确保线程同时退出。启动线程是昂贵的操作，并且没有明确的延迟，第一个线程可能在最后一个线程开始前结束。每个线程都在go变为true前，都在循环③⑤。并且当go设置为true时，所有线程都会开始运行⑥。</p><p>程序一种可能的输出为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(0,0,0),(1,0,0),(2,0,0),(3,0,0),(4,0,0),(5,7,0),(6,7,8),(7,9,8),(8,9,8),(9,9,10)</span><br><span class="line">(0,0,0),(0,1,0),(0,2,0),(1,3,5),(8,4,5),(8,5,5),(8,6,6),(8,7,9),(10,8,9),(10,9,10)</span><br><span class="line">(0,0,0),(0,0,1),(0,0,2),(0,0,3),(0,0,4),(0,0,5),(0,0,6),(0,0,7),(0,0,8),(0,0,9)</span><br><span class="line">(1,3,0),(2,3,0),(2,4,1),(3,6,4),(3,9,5),(5,10,6),(5,10,8),(5,10,10),(9,10,10),(10,10,10)</span><br><span class="line">(0,0,0),(0,0,0),(0,0,0),(6,3,7),(6,5,7),(7,7,7),(7,8,7),(8,8,7),(8,8,9),(8,8,9)</span><br></pre></td></tr></table></figure><p>前三行中线程都做了更新，后两行线程只是做读取。每三个值都是一组x，y和z，并按照这样的顺序依次循环。对于输出，需要注意的是：</p><ol><li>第一组值中x增1，第二组值中y增1，第三组中z增1。</li><li>x元素只在给定集中增加，y和z也一样，但是是不均匀增加，并且每个线程中的相对顺序都不同。</li><li>线程3看不到x或y的任何更新，它能看到的只有z的更新。这并不妨碍别的线程观察z的更新，并同时观察x和y的更新。</li></ol><p>对于非限制操作，这个结果没毛病(但是不是唯一合法的输出)。任意组都用三个变量保持一致，从0到10依次递增，并且线程对相应变量进行递增操作，所以打印出的值在0到10的范围内都合理。</p><p>要想获取额外的同步，且不使用全局排序一致，可以使用<em>获取-释放序</em>(acquire-release ordering)。</p><p><strong>获取-释放序</strong></p><p><em>自由序</em>(relaxed ordering)的加强版，虽然操作依旧没有统一顺序，但引入了同步。</p><p>原子加载就是<em>获取</em>(acquire)操作(memory_order_acquire)，原子存储就是<em>释放</em>(memory_order_release)操作，原子读-改-写操作(例如fetch_add()或exchange())在这里，不是“获取”就是“释放”，或者两者兼有的操作(memory_order_acq_rel)，同步在线程释放和获取间是<em>成对的</em>(pairwise)，释放操作与获取操作同步就能读取已写入的值。</p><p>代码5.7 获取-释放不意味着统一操作顺序 使用获取-释放序(而非序列一致方式)，对代码5.4的一次重写。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!x.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(y.<span class="built_in">load</span>(std::memory_order_acquire))  <span class="comment">// 1</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_acquire));</span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_acquire))  <span class="comment">// 2</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(write_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(read_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">d</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">  d.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>); <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>断言③可能会触发(就如同自由排序那样)，因为在加载x②和y①时，可能读取到false。因为x和y是由不同线程写入，所以序列中的每一次释放和获取都不会影响到其他线程的操作。</p><img src="/posts/20a59019/5-6.png" alt="5-6" style="zoom:50%;"><p>图5.6 获取-释放，以及先行过程</p><p>对于读取的结果，两个(读取)线程看到的是两个完全不同的世界。</p><p>代码5.8 获取-释放序操作会影响释放操作</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1 </span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);  <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 3 自旋，等待y被设置为true</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 4</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>读取y③时会得到true，和存储时写入的一样②。存储使用的是memory_order_release，读取使用的是memory_order_acquire，存储与读取就同步了。因为这两个操作是由同一个线程串行完成的，所以存储x①的操作先行于存储y②的操作。</p><p>对y的存储同步与对y的加载，存储x也就先行于对y的加载，并且扩展先行于x的读取。因此，加载x的值必为true，并且断言⑤不会触发。如果对于y的加载不是在while循环中，情况可能就会有所不同。加载y的时候可能会读取到false，这种情况下对于读取到的x是什么值没有要求了。为了保证同步，加载和释放操作必须成对。</p><p>释放操作存储的值必须要让获取操作看到。当存储②或加载③都是一个释放操作时，对x的访问就无序了，也就无法保证④处读到的是true，并且还会触发断言。</p><p><strong>获取-释放序传递同步</strong></p><p>为了考虑传递顺序，至少需要三个线程。第一个线程用来修改共享变量，第二个线程使用“加载-获取”读取由“存储-释放”操作过的变量，并且再对第二个变量进行“存储-释放”操作。最后，由第三个线程通过“加载-获取”读取第二个共享变量，并提供“加载-获取”操作来读取被“存储-释放”操作写入的值。为了保证同步关系，即便是中间线程没有对共享变量做任何操作，第三个线程也可以读取第一个线程操作过的变量。</p><p>代码5.9 使用获取和释放序传递同步</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; data[<span class="number">5</span>];</span><br><span class="line"><span class="function">std::atomic&lt;<span class="keyword">bool</span>&gt; <span class="title">sync1</span><span class="params">(<span class="literal">false</span>)</span>, <span class="title">sync2</span><span class="params">(<span class="literal">false</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  data[<span class="number">0</span>].<span class="built_in">store</span>(<span class="number">42</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">1</span>].<span class="built_in">store</span>(<span class="number">97</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">2</span>].<span class="built_in">store</span>(<span class="number">17</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">3</span>].<span class="built_in">store</span>(<span class="number">-141</span>,std::memory_order_relaxed);</span><br><span class="line">  data[<span class="number">4</span>].<span class="built_in">store</span>(<span class="number">2003</span>,std::memory_order_relaxed);</span><br><span class="line">  sync1.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);  <span class="comment">// 1.设置sync1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync1.<span class="built_in">load</span>(std::memory_order_acquire));  <span class="comment">// 2.直到sync1设置后，循环结束</span></span><br><span class="line">  sync2.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_release);  <span class="comment">// 3.设置sync2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!sync2.<span class="built_in">load</span>(std::memory_order_acquire));   <span class="comment">// 4.直到sync1设置后，循环结束</span></span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">0</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">42</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">1</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">97</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">2</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">17</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">3</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">-141</span>);</span><br><span class="line">  <span class="built_in">assert</span>(data[<span class="number">4</span>].<span class="built_in">load</span>(std::memory_order_relaxed)==<span class="number">2003</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>thread_1将数据存储到data中先行于存储sync1①(它们在同一个线程内)。因为加载sync1①的是一个while循环，它最终会看到thread_1存储的值。因此，对于sync1的存储先行于最终对于sync1的加载(在while循环中)。thread_3的加载操作④，位于存储sync2③操作的前面。存储sync2③因此先行于thread_3的加载④，加载又先行于存储sync2③，存储sync2又先行于加载sync2④，加载syn2又先行于加载data。因此，thread_1存储数据到data的操作先行于thread_3中对data的加载，并且保证断言都不会触发。</p><p>将sync1和sync2通过在thread_2中使用“读-改-写”操作(memory_order_acq_rel)合并成一个独立的变量。其中会使用compare_exchange_strong()来保证thread_1对变量只进行一次更新：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">std::atomic&lt;<span class="keyword">int</span>&gt; <span class="title">sync</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_1</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  sync.<span class="built_in">store</span>(<span class="number">1</span>,std::memory_order_release);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_2</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> expected=<span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span>(!sync.<span class="built_in">compare_exchange_strong</span>(expected,<span class="number">2</span>,</span><br><span class="line">              std::memory_order_acq_rel))</span><br><span class="line">    expected=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">thread_3</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(sync.<span class="built_in">load</span>(std::memory_order_acquire)&lt;<span class="number">2</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用memory_order_acq_rel语义的“读-改-写”操作，每一个动作都包含获取和释放操作，所以可以和之前的存储操作进行同步，并且可以对随后的加载操作进行同步，就像上面例子一样。</p><h3 id="释放队列与同步"><a href="#释放队列与同步" class="headerlink" title="释放队列与同步"></a>释放队列与同步</h3><p>通过线程在存储和加载操作之间有(有序的)多个“读-改-写”操作(所有操作都已经做了适当的标记)，所以可以获取原子变量存储与加载的同步关系。存储操作标记为memory_order_release，memory_order_acq_rel或memory_order_seq_cst，加载标记为memory_order_consum，memory_order_acquire或memory_order_sqy_cst，并且操作链上的每一加载操作都会读取之前操作写入的值，因此链上的操作构成了一个释放序列(<em>release sequence</em>)，并且初始化存储同步(对应memory_order_acquire或memory_order_seq_cst)或是前序依赖(对应memory_order_consume)的最终加载，操作链上的任何原子“读-改-写”操作可以拥有任意个内存序(甚至是memory_order_relaxed)。</p><p>假设使用<code>atomic&lt;int&gt;</code>对共享队列的元素进行计数：</p><p>代码5.11 使用原子操作从队列中读取数据</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; queue_data;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; count;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">populate_queue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">unsigned</span> <span class="keyword">const</span> number_of_items=<span class="number">20</span>;</span><br><span class="line">  queue_data.<span class="built_in">clear</span>();</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">unsigned</span> i=<span class="number">0</span>;i&lt;number_of_items;++i)</span><br><span class="line">  &#123;</span><br><span class="line">    queue_data.<span class="built_in">push_back</span>(i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  count.<span class="built_in">store</span>(number_of_items,std::memory_order_release);  <span class="comment">// 1 初始化存储</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">consume_queue_items</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">int</span> item_index;</span><br><span class="line">    <span class="keyword">if</span>((item_index=count.<span class="built_in">fetch_sub</span>(<span class="number">1</span>,std::memory_order_acquire))&lt;=<span class="number">0</span>)  <span class="comment">// 2 一个“读-改-写”操作</span></span><br><span class="line">    &#123;</span><br><span class="line">      <span class="built_in">wait_for_more_items</span>();  <span class="comment">// 3 等待更多元素</span></span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">process</span>(queue_data[item_index<span class="number">-1</span>]);  <span class="comment">// 4 安全读取queue_data</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(populate_queue)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">c</span><span class="params">(consume_queue_items)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  c.<span class="built_in">join</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有一个消费者线程时还好，fetch_sub()带有memory_order_acquire的读取操作，并且存储操作是带有memory_order_release语义，所以存储与加载同步，线程可以从缓存中读取元素。当有两个读取线程时，第二个fetch_sub()操作将看到第一个线程修改的值，且没有值通过store写入其中。先不管释放序列的规则，第二个线程与第一个线程不存在先行关系，并且对共享内存中值的读取也不安全。除非第一个fetch_sub()是带有memory_order_release语义，为两个消费者线程建立了不必要的同步。无论是释放序列的规则，还是具有memory_order_release语义的fetch_sub操作，第二个消费者看到的是一个空的queue_data，无法从其获取任何数据，并且还会产生条件竞争。</p><p>不过，第一个fetch_sub()对释放顺序做了一些事情，所以store()能同步与第二个fetch_sub()操作。两个消费者线程间不需要同步关系。过程在图5.7中展示，其中虚线表示的就是释放顺序，实线表示的是先行关系。</p><img src="/posts/20a59019/5-7.png" alt="5-7" style="zoom: 67%;"><p>图5.7 代码5.11中对队列操作的释放顺序</p><p>操作链中可以有任意数量的链接，提供的都是“读-改-写”操作，比如fetch_sub()，store()，每一个都会与使用memory_order_acquire语义的操作进行同步。</p><h3 id="栅栏"><a href="#栅栏" class="headerlink" title="栅栏"></a>栅栏</h3><p>栅栏操作会对内存序列进行约束，使其无法对任何数据进行修改，典型的做法是与使用memory_order_relaxed约束序的原子操作一起使用。</p><p>栅栏属于全局操作，执行栅栏操作可以影响到在线程中的其他原子操作。因为这类操作就像画了一条任何代码都无法跨越的线一样，所以栅栏操作通常也被称为<em>内存栅栏</em>(memory barriers)。</p><p>代码5.12 栅栏可以让自由操作变的有序</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; x,y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 1</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);  <span class="comment">// 2</span></span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 4</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);  <span class="comment">// 5</span></span><br><span class="line">  <span class="keyword">if</span>(x.<span class="built_in">load</span>(std::memory_order_relaxed))  <span class="comment">// 6</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为加载y的操作④读取③处存储的值，所以释放栅栏②与获取栅栏⑤同步。①处存储x先行于⑥处加载x，最后x读取出来必为true，并且不会触发断言⑦。</p><p>这两个栅栏都是必要的：需要在一个线程中进行释放，然后在另一个线程中进行获取，这样才能构建同步关系。</p><p>当获取操作能看到释放栅栏操作后的存储结果，那么这个栅栏就与获取操作同步。并且，当加载操作在获取栅栏操作前，看到一个释放操作的结果，那么这个释放操作同步于获取栅栏。</p><p>虽然，栅栏同步依赖于读取/写入的操作发生于栅栏之前/后，但是这里有一点很重要：同步点，就是栅栏本身。当执行代码5.12中的write_x_then_y，并且在栅栏操作之后对x进行写入，就像下面的代码一样。触发断言的条件就不保证一定为true了，尽管写入x的操作在写入y的操作之前发生。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_release);</span><br><span class="line">  x.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栅栏不会分开这里的两个操作，并且也不再有序。只有当栅栏出现在存储x和存储y操作之间时，顺序才是硬性的。当然，栅栏是否存在不会影响任何拥有先行关系的执行序列。</p><h3 id="原子操作对非原子的操作排序"><a href="#原子操作对非原子的操作排序" class="headerlink" title="原子操作对非原子的操作排序"></a>原子操作对非原子的操作排序</h3><p>使用普通的非原子bool类型来替换代码5.12中的x，行为和替换前完全一样。</p><p>代码5.13 使用非原子操作执行序列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;atomic&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;assert.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">bool</span> x=<span class="literal">false</span>;  <span class="comment">// x现在是一个非原子变量</span></span><br><span class="line">std::atomic&lt;<span class="keyword">bool</span>&gt; y;</span><br><span class="line">std::atomic&lt;<span class="keyword">int</span>&gt; z;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write_x_then_y</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">true</span>;  <span class="comment">// 1 在栅栏前存储x</span></span><br><span class="line">  <span class="function">std::atomic_thread_fe <span class="title">nce</span><span class="params">(std::memory_order_release)</span></span>;</span><br><span class="line">  y.<span class="built_in">store</span>(<span class="literal">true</span>,std::memory_order_relaxed);  <span class="comment">// 2 在栅栏后存储y</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">read_y_then_x</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(!y.<span class="built_in">load</span>(std::memory_order_relaxed));  <span class="comment">// 3 在#2写入前，持续等待</span></span><br><span class="line">  std::<span class="built_in">atomic_thread_fence</span>(std::memory_order_acquire);</span><br><span class="line">  <span class="keyword">if</span>(x)  <span class="comment">// 4 这里读取到的值，是#1中写入</span></span><br><span class="line">    ++z;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  x=<span class="literal">false</span>;</span><br><span class="line">  y=<span class="literal">false</span>;</span><br><span class="line">  z=<span class="number">0</span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">a</span><span class="params">(write_x_then_y)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">b</span><span class="params">(read_y_then_x)</span></span>;</span><br><span class="line">  a.<span class="built_in">join</span>();</span><br><span class="line">  b.<span class="built_in">join</span>();</span><br><span class="line">  <span class="built_in">assert</span>(z.<span class="built_in">load</span>()!=<span class="number">0</span>);  <span class="comment">// 5 断言将不会触发</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>栅栏仍然为存储x①和存储y②，还为加载y③和加载x④提供一个执行序，并且这里存储x和加载x之间仍然有一个先行关系，所以不会触发断言⑤。②中的存储和③中对y的加载必须是原子操作，否则会在y上产生条件竞争。当读取线程看到存储到y的操作，栅栏将会对x执行有序的操作，这个执行序意味着x上不存在条件竞争。</p><p>不仅是栅栏可对非原子操作排序，memory_order_release/memory_order_consume也为非原子访问排序，可以动态分配对象，并且本章中的许多例子都可以使用普通的非原子操作，去替代memory_order_relaxed的操作。</p><h3 id="非原子操作排序"><a href="#非原子操作排序" class="headerlink" title="非原子操作排序"></a>非原子操作排序</h3><p>某一内存位置上，lock()作为一个获取操作，在同样的位置上unlock()作为一个释放操作。</p><p>以下的工具都可以提供同步：</p><p><strong>std::thread</strong></p><ul><li>std::thread构造新线程时，构造函数与调用函数或新线程的可调用对象间的同步。</li><li>对std::thread对象调用join，可以和对应的线程进行同步。</li></ul><p><strong>std::mutex, std::timed_mutex, std::recursive_mutex, std::recursibe_timed_mutex</strong></p><ul><li>对给定互斥量对象调用lock和unlock，以及对try_lock，try_lock_for或try_lock_until，会形成该互斥量的锁序。</li><li>对给定的互斥量调用unlock，需要在调用lock或成功调用try_lock，try_lock_for或try_lock_until之后，这样才符合互斥量的锁序。</li><li>对try_lock，try_lock_for或try_lock_until失败的调用，不具有任何同步关系。</li></ul><p><strong>std::shared_mutex ,  std::shared_timed_mutex</strong></p><ul><li>对给定互斥量对象调用lock、unlock、lock_shared和unlock_shared，以及对 try_lock ,  try_lock_for ,  try_lock_until ,  try_lock_shared ,  try_lock_shared_for或 try_lock_shared_until的成功调用，会形成该互斥量的锁序。</li><li>对给定的互斥量调用unlock，需要在调用lock或shared_lock，亦或是成功调用try_lock ,  try_lock_for,  try_lock_until,  try_lock_shared,  try_lock_shared_for或try_lock_shared_until之后，才符合互斥量的锁序。</li><li>对try_lock，try_lock_for，try_lock_until，try_lock_shared，try_lock_shared_for或try_lock_shared_until 失败的调用，不具有任何同步关系。</li></ul><p><strong>std::shared_mutex和std::shared_timed_mutex</strong></p><ul><li>成功的调用std::promise对象的set_value或set_exception与成功的调用wait或get之间同步，或是调用wait_for或wait_until的返回例如future状态std::future_status::ready与promise共享同步状态。</li><li>给定std::promise对象的析构函数，该对象存储了一个std::future_error异常，成功的调用wait或get后，共享同步状态与promise之间的同步，或是调用wait_for或wait_until返回的future状态std::future_status::ready时，与promise共享同步状态。</li></ul><p><strong>std::packaged_task ,  std::future和std::shared_future</strong></p><ul><li>成功的调用std::packaged_task对象的函数操作符与成功的调用wait或get之间同步，或是调用wait_for或wait_until的返回future状态std::future_status::ready与打包任务共享同步状态。</li><li>std::packaged_task对象的析构函数，该对象存储了一个std::future_error异常，其共享同步状态与打包任务之间的同步在于成功的调用wait或get，或是调用wait_for或wait_until返回的future状态std::future_status::ready与打包任务共享同步状态。</li></ul><p><strong>std::async ,  std::future和std::shared_future</strong></p><ul><li>使用std::launch::async策略性的通过std::async启动线程执行任务与成功的调用wait和get之间是同步的，或调用wait_for或wait_until返回的future状态std::future_status::ready与产生的任务共享同步状态。</li><li>使用std::launch::deferred策略性的通过std::async启动任务与成功的调用wait和get之间是同步的，或调用wait_for或wait_until返回的future状态std::future_status::ready与promise共享同步状态。</li></ul><p><strong>std::experimental::future ,  std::experimental::shared_future和持续性</strong></p><ul><li>异步共享状态变为就绪的事件与该共享状态上调度延续函数的调用同步。</li><li>持续性函数的完成与成功调用wait或get的返回同步，或调用wait_for或wait_until返回的期望值状态std::future_status::ready与调用then构建的持续性返回的future同步，或是与在调度用使用这个future的操作同步。</li></ul><p><strong>std::experimental::latch</strong></p><ul><li>对std::experimental::latch实例调用count_down或count_down_and_wait与在该对象上成功的调用wait或count_down_and_wait之间是同步的。</li></ul><p><strong>std::experimental::barrier</strong></p><ul><li>对std::experimental::barrier实例调用arrive_and_wait或arrive_and_drop与在该对象上随后成功完成的arrive_and_wait之间是同步的。</li></ul><p><strong>std::experimental::flex_barrier</strong></p><ul><li>对std::experimental::flex_barrier实例调用arrive_and_wait或arrive_and_drop与在该对象上随后成功完成的arrive_and_wait之间是同步的。</li><li>对std::experimental::flex_barrier实例调用arrive_and_wait或arrive_and_drop与在该对象上随后完成的给定函数之间是同步的。</li><li>对std::experimental::flex_barrier实例的给定函数的返回与每次对arrive_and_wait的调用同步，当调用给定函数线程会在栅栏处阻塞等待。</li></ul><p><strong>std::condition_variable和std::condition_variable_any</strong></p><ul><li>条件变量不提供任何同步关系，它们是对忙等待的优化，所有同步都由互斥量提供。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 并发编程 </tag>
            
            <tag> c++多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>高频算法考察</title>
      <link href="/posts/605267a3/"/>
      <url>/posts/605267a3/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="合并有序链表"><a href="#合并有序链表" class="headerlink" title="合并有序链表"></a>合并有序链表</h2><p><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof/">力扣链接</a></p><p>将两个有序的链表合并为一个新链表，要求新的链表是通过拼接两个链表的节点来生成的。</p><p>输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4 输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> l1;</span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* node = dummy;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="literal">nullptr</span> &amp;&amp; l2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            node-&gt;next = l1;</span><br><span class="line">            l1 = l1-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            node-&gt;next = l2;</span><br><span class="line">            l2 = l2-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        node = node-&gt;next;;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="literal">nullptr</span>) node-&gt;next = l2;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="literal">nullptr</span>) node-&gt;next = l1;</span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ListNode* node0 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">    ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">    ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">    ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">    node0-&gt;next = node1;</span><br><span class="line">    node1-&gt;next = node2;</span><br><span class="line">    node2-&gt;next = node3;</span><br><span class="line">    node3-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    node4-&gt;next = node5;</span><br><span class="line">    node5-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> node = <span class="built_in">merge</span>(node0, node4);</span><br><span class="line">    <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        cout &lt;&lt; node-&gt;val &lt;&lt; endl;</span><br><span class="line">        node = node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="反转链表"><a href="#反转链表" class="headerlink" title="反转链表"></a>反转链表</h2><p>定义一个函数，输入一个链表的头节点，反转该链表并输出反转后链表的头节点。</p><p>输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL 输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    ListNode* next;</span><br><span class="line">    <span class="built_in">ListNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//头插法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">ReverseList</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pHead == <span class="literal">nullptr</span> || pHead-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> pHead;</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span>  <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">ListNode* pre =dummy;</span><br><span class="line">pre-&gt;next = pHead;</span><br><span class="line">ListNode* cur = pHead-&gt;next;</span><br><span class="line">pHead-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="comment">//pre = cur;</span></span><br><span class="line">ListNode* temp = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">temp = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">temp-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line"><span class="comment">//for_each(data.begin(), data.end(), [](const auto a) &#123;cout &lt;&lt; a &lt;&lt; &quot; &quot;; &#125;);</span></span><br><span class="line"><span class="comment">//cout &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">if</span> (low &gt;= high) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> key = data[low], begin = low, end = high;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end) &#123;</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp; data[end] &gt; key) &#123;</span><br><span class="line">end--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin &lt; end) data[begin++] = data[end];</span><br><span class="line"><span class="keyword">while</span> (begin &lt; end &amp;&amp; data[begin] &lt;= key) &#123;</span><br><span class="line">begin++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (begin &lt; end) data[end--] = data[begin];</span><br><span class="line">&#125;</span><br><span class="line">data[begin] = key;</span><br><span class="line"><span class="built_in">quickSort</span>(data, low, begin - <span class="number">1</span>);</span><br><span class="line"><span class="built_in">quickSort</span>(data, begin + <span class="number">1</span>, high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//data和copy数组大小相同，copy数组变为有序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, vector&lt;<span class="keyword">int</span>&gt;&amp; copy, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line"><span class="keyword">int</span> index = begin;</span><br><span class="line"><span class="built_in">mergeSort</span>(copy, data, low1, high1);</span><br><span class="line"><span class="built_in">mergeSort</span>(copy, data, low2, high2);</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) &#123;</span><br><span class="line">copy[index++] = data[low1] &lt; data[low2] ? data[low1++] : data[low2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1) copy[index++] = data[low1++];</span><br><span class="line"><span class="keyword">while</span> (low2 &lt;= high2) copy[index++] = data[low2++];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对原数组进行归并排序。</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; data, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (begin &gt;= end) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = begin + (end - begin) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">int</span> low1 = begin, high1 = mid, low2 = mid + <span class="number">1</span>, high2 = end;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">mergeSort2</span>(data, low1, high1);</span><br><span class="line"><span class="built_in">mergeSort2</span>(data, low2, high2);</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(end - begin + <span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1 &amp;&amp; low2 &lt;= high2) &#123;</span><br><span class="line">help[index++] = data[low1] &lt; data[low2] ? data[low1++] : data[low2++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (low1 &lt;= high1) help[index++] = data[low1++];</span><br><span class="line"><span class="keyword">while</span> (low2 &lt;= high2) help[index++] = data[low2++];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">data[begin + i] = help[i];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个堆排序"><a href="#实现一个堆排序" class="headerlink" title="实现一个堆排序"></a>实现一个堆排序</h2><p>堆排序过程：</p><ul><li>将n个元素的序列构建一个大顶堆或小顶堆</li><li>将堆顶的元素放到序列末尾</li><li>将前n-1个元素重新构建大顶堆或小顶堆，重复这个过程，直到所有元素都已经排序</li></ul><p>整体时间复杂度为O(nlogn)，空间复杂度O(1)</p><p>注：堆排序是<strong>不稳定</strong>的排序算法，是一种树形选择排序。恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。不适合记录较少的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> maxid = index;</span><br><span class="line"><span class="comment">// 计算左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line"><span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 寻找当前以index为根的子树中最大/最小的元素的下标</span></span><br><span class="line"><span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[maxid]) maxid = left;</span><br><span class="line"><span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[maxid]) maxid = right;</span><br><span class="line">    <span class="comment">// maxid是3个数中最大数的下标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 进行交换，记得要递归进行adjust,传入的index是maxid</span></span><br><span class="line"><span class="keyword">if</span> (maxid != index) &#123; <span class="comment">// 如果maxid的值有更新</span></span><br><span class="line"><span class="built_in">swap</span>(arr[maxid], arr[index]);</span><br><span class="line"><span class="built_in">adjust</span>(arr, len, maxid); <span class="comment">//递归调整其他不满足堆性质的部分</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 初次构建堆，i要从最后一个非叶子节点开始，所以是(len-1-1)/2，0这个位置要加等号</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = (len - <span class="number">1</span> - <span class="number">1</span>) / <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 对每一个非叶结点进行堆调整(从最后一个非叶结点开始)</span></span><br><span class="line"><span class="built_in">adjust</span>(arr, len, i);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 从最后一个元素的下标开始往前遍历，每次将堆顶元素交换至当前位置，并且缩小长度（i为长度），从0处开始adjust</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line"><span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]); <span class="comment">// 将当前最大的放置到数组末尾，将未完成排序的部分继续进行堆排序</span></span><br><span class="line"><span class="built_in">adjust</span>(arr, i, <span class="number">0</span>);<span class="comment">// 注意每次adjust是从根往下调整，所以这里index是0！</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; arr = &#123; <span class="number">3</span>,<span class="number">4</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">8</span>,<span class="number">7</span>,<span class="number">6</span> &#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;before: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr) cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 3 4 2 1 5 8 7 6</span></span><br><span class="line"><span class="built_in">heapsort</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;after: &quot;</span> &lt;&lt; endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> item : arr)cout &lt;&lt; item &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"><span class="comment">//1 2 3 4 5 6 7 8</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="设计LRU缓存"><a href="#设计LRU缓存" class="headerlink" title="设计LRU缓存"></a>设计LRU缓存</h2><p><a href="https://leetcode-cn.com/problems/lru-cache-lcci">力扣链接(opens new window)</a></p><p>设计和构建一个“最近最少使用”缓存，该缓存会删除最近最少使用的项目。缓存应该从键映射到值(允许你插入和检索特定键对应的值)，并在初始化时指定最大容量。当缓存被填满时，它应该删除最近最少使用的项目。</p><p>它应该支持以下操作： 获取数据 get 和 写入数据 put 。</p><p>获取数据 get(key) - 如果密钥 (key) 存在于缓存中，则获取密钥的值（总是正数），否则返回 -1。 写入数据 put(key, value) - 如果密钥不存在，则写入其数据值。当缓存容量达到上限时，它应该在写入新数据之前删除最近最少使用的数据值，从而为新的数据值留出空间。</p><p>样例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">LRUCache cache = <span class="keyword">new</span> <span class="built_in">LRUCache</span>( <span class="number">2</span> <span class="comment">/* 缓存容量 */</span> );</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">1</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">3</span>);       <span class="comment">// 返回  3</span></span><br><span class="line">cache.<span class="built_in">get</span>(<span class="number">4</span>);       <span class="comment">// 返回  4</span></span><br></pre></td></tr></table></figure><p>代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">DoubleList</span> &#123;</span><span class="comment">// 定义双向链表</span></span><br><span class="line"><span class="keyword">int</span> key, val;</span><br><span class="line">DoubleList* pre, *next;</span><br><span class="line"><span class="built_in">DoubleList</span>(<span class="keyword">int</span> _key, <span class="keyword">int</span> _val) : <span class="built_in">key</span>(_key), <span class="built_in">val</span>(_val), <span class="built_in">pre</span>(<span class="literal">nullptr</span>), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRU</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="keyword">int</span> capcity;<span class="comment">// LRU容量</span></span><br><span class="line">DoubleList* head, *tail;<span class="comment">// 头尾哨兵节点</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, DoubleList*&gt; memory;<span class="comment">// 哈希表存储key对应的双向链表</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRU</span>(<span class="keyword">int</span> _capcity) &#123;<span class="comment">// 初始化LRU，设置双向链表的头尾哨兵节点</span></span><br><span class="line"><span class="keyword">this</span>-&gt;capcity = _capcity;</span><br><span class="line">head = <span class="keyword">new</span> <span class="built_in">DoubleList</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">tail = <span class="keyword">new</span> <span class="built_in">DoubleList</span>(<span class="number">-1</span>, <span class="number">-1</span>);</span><br><span class="line">head-&gt;next = tail;</span><br><span class="line">tail-&gt;pre = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">LRU</span>() &#123;<span class="comment">// 析构删除不为空的指针</span></span><br><span class="line"><span class="keyword">if</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> head;</span><br><span class="line">head = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (tail != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> tail;</span><br><span class="line">tail = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span>&amp; a : memory) &#123;</span><br><span class="line"><span class="keyword">if</span> (a.second != <span class="literal">nullptr</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> a.second;</span><br><span class="line">a.second = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 写入数据（key,val)形式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> _key, <span class="keyword">int</span> _val)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果存储哈希表中有key值存在，更新val值，当前节点先删后加</span></span><br><span class="line"><span class="keyword">if</span> (memory.<span class="built_in">find</span>(_key) != memory.<span class="built_in">end</span>()) &#123;</span><br><span class="line">DoubleList* node = memory[_key];</span><br><span class="line"><span class="built_in">removeNode</span>(node);</span><br><span class="line">node-&gt;val = _val;</span><br><span class="line"><span class="built_in">pushNode</span>(node);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">// 哈希表中未存储key，检查当前哈希表的大小与存储容量比较</span></span><br><span class="line"><span class="keyword">if</span> (memory.<span class="built_in">size</span>() == <span class="keyword">this</span>-&gt;capcity) &#123; <span class="comment">// 这里很重要，也很爱错，千万记得更新memory</span></span><br><span class="line"><span class="keyword">int</span> topKey = head-&gt;next-&gt;key;<span class="comment">// 取得key值，方便在后面删除</span></span><br><span class="line"><span class="built_in">removeNode</span>(head-&gt;next);<span class="comment">// 移除头部的下一个</span></span><br><span class="line">memory.<span class="built_in">erase</span>(topKey);<span class="comment">// 在memory中删除当前头部的值</span></span><br><span class="line">&#125;</span><br><span class="line">DoubleList* node = <span class="keyword">new</span> <span class="built_in">DoubleList</span>(_key, _val);<span class="comment">// 新增node</span></span><br><span class="line"><span class="built_in">pushNode</span>(node);<span class="comment">// 放在尾部</span></span><br><span class="line">memory[_key] = node;<span class="comment">// 记得在memory中添加进去</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 读取数据</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> _key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 哈希表中存在key，返回存储的key对应的val</span></span><br><span class="line"><span class="keyword">if</span> (memory.<span class="built_in">find</span>(_key) != memory.<span class="built_in">end</span>()) &#123;</span><br><span class="line">DoubleList* node = memory[_key];</span><br><span class="line"><span class="built_in">removeNode</span>(node);<span class="comment">// 注意读取的节点先删后加，进行更新</span></span><br><span class="line"><span class="built_in">pushNode</span>(node);</span><br><span class="line"><span class="keyword">return</span> node-&gt;val;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">tail-&gt;pre-&gt;next = node;</span><br><span class="line">node-&gt;pre = tail-&gt;pre;</span><br><span class="line">node-&gt;next = tail;</span><br><span class="line">tail-&gt;pre = node;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="function">LRU <span class="title">cache</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;       <span class="comment">// 返回  1</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">3</span>, <span class="number">3</span>);    <span class="comment">// 该操作会使得密钥 2 作废</span></span><br><span class="line">cout&lt;&lt; cache.<span class="built_in">get</span>(<span class="number">2</span>) &lt;&lt; endl;       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cache.<span class="built_in">put</span>(<span class="number">4</span>, <span class="number">4</span>);    <span class="comment">// 该操作会使得密钥 1 作废</span></span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">1</span>) &lt;&lt; endl;       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">3</span>) &lt;&lt; endl;       <span class="comment">// 返回  3</span></span><br><span class="line">cout &lt;&lt; cache.<span class="built_in">get</span>(<span class="number">4</span>) &lt;&lt; endl;       <span class="comment">// 返回  4</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h2><p><a href="https://leetcode-cn.com/problems/reorder-list/">力扣链接</a></p><p>给定一个单链表 L：L0→L1→…→Ln-1→Ln ， 将其重新排列后变为： L0→Ln→L1→Ln-1→L2→Ln-2→…</p><p>你不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> val;</span><br><span class="line">ListNode* next;</span><br><span class="line"><span class="built_in">ListNode</span>(<span class="keyword">int</span> _val) : <span class="built_in">val</span>(_val), <span class="built_in">next</span>(<span class="literal">nullptr</span>) &#123; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 翻转链表，定义哨兵节点，头插法</span></span><br><span class="line"><span class="function">ListNode* <span class="title">myReverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line">pre-&gt;next = head;</span><br><span class="line">ListNode* cur = head-&gt;next;</span><br><span class="line">head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">ListNode* node = <span class="literal">nullptr</span>;</span><br><span class="line"><span class="keyword">while</span> (cur != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">node = cur;</span><br><span class="line">cur = cur-&gt;next;</span><br><span class="line">node-&gt;next = pre-&gt;next;</span><br><span class="line">pre-&gt;next = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// merge归并过程，链表长度p1 &gt;= p2</span></span><br><span class="line"><span class="function">ListNode* <span class="title">myMerge</span><span class="params">(ListNode* p1, ListNode* p2)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p1 == <span class="literal">nullptr</span>) <span class="keyword">return</span> p2;</span><br><span class="line"><span class="keyword">if</span> (p2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> p1;</span><br><span class="line"></span><br><span class="line">ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);<span class="comment">// 定义哨兵节点</span></span><br><span class="line">ListNode* pre = dummy;</span><br><span class="line"><span class="keyword">while</span> (p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">pre-&gt;next = p1;</span><br><span class="line">p1 = p1-&gt;next;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">pre-&gt;next = p2;</span><br><span class="line">p2 = p2-&gt;next;</span><br><span class="line">pre = pre-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p1 != <span class="literal">nullptr</span>) pre-&gt;next = p1;</span><br><span class="line"><span class="keyword">return</span> dummy-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 重排链表主函数</span></span><br><span class="line"><span class="function">ListNode* <span class="title">myReverOrderList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* slow = head, * fast = head-&gt;next;</span><br><span class="line">    <span class="comment">// 快慢指针确定链表中点位置slow</span></span><br><span class="line"><span class="keyword">while</span> (fast != <span class="literal">nullptr</span> &amp;&amp; fast-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">slow = slow-&gt;next;</span><br><span class="line">fast = fast-&gt;next-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">// 切分后半部分链表，前半部的链表末尾指向nullptr</span></span><br><span class="line">ListNode* second = slow-&gt;next;</span><br><span class="line">slow-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">second = <span class="built_in">myReverseList</span>(second);<span class="comment">//翻转后半部分链表</span></span><br><span class="line">head = <span class="built_in">myMerge</span>(head, second);<span class="comment">//归并merge链表返回头节点head</span></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span>  <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">ListNode* head = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">1</span>);</span><br><span class="line">ListNode* node1 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">2</span>);</span><br><span class="line">ListNode* node2 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">3</span>);</span><br><span class="line">ListNode* node3 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">4</span>);</span><br><span class="line">ListNode* node4 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">5</span>);</span><br><span class="line">ListNode* node5 = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">6</span>);</span><br><span class="line"></span><br><span class="line">head-&gt;next = node1;</span><br><span class="line">node1-&gt;next = node2;</span><br><span class="line">node2-&gt;next = node3;</span><br><span class="line">node3-&gt;next = node4;</span><br><span class="line">node4-&gt;next = node5;</span><br><span class="line">node5-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">head = <span class="built_in">myReverOrderList</span>(head);</span><br><span class="line"><span class="keyword">while</span> (head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">cout &lt;&lt; head-&gt;val &lt;&lt; endl;</span><br><span class="line">head = head-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="奇偶链表"><a href="#奇偶链表" class="headerlink" title="奇偶链表"></a>奇偶链表</h2><p><a href="https://leetcode-cn.com/problems/odd-even-linked-list/">力扣链接</a></p><p>给定一个单链表，把所有的奇数节点和偶数节点分别排在一起。请注意，这里的奇数节点和偶数节点指的是节点编号的奇偶性，而不是节点的值的奇偶性。</p><p>请尝试使用原地算法完成。你的算法的空间复杂度应为 O(1)，时间复杂度应为 O(nodes)，nodes 为节点总数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 1-&gt;3-&gt;5-&gt;2-&gt;4-&gt;NULL</span><br><span class="line">示例 2:</span><br><span class="line">输入: 2-&gt;1-&gt;3-&gt;5-&gt;6-&gt;4-&gt;7-&gt;NULL </span><br><span class="line">输出: 2-&gt;3-&gt;6-&gt;7-&gt;1-&gt;5-&gt;4-&gt;NULL</span><br></pre></td></tr></table></figure><p>注意：应当保持奇数节点和偶数节点的相对顺序。链表的第一个节点视为奇数节点，第二个节点视为偶数节点，以此类推。</p><p>法一：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head-&gt;next == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* first = head;<span class="comment">// 奇链表头结点</span></span><br><span class="line">ListNode* second = head-&gt;next;<span class="comment">// 偶链表头结点</span></span><br><span class="line">ListNode* cur = second;<span class="comment">// 保存偶链表头结点</span></span><br><span class="line"><span class="keyword">while</span> (second != <span class="literal">nullptr</span> &amp;&amp; second-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">first-&gt;next = second-&gt;next;</span><br><span class="line">second-&gt;next = first-&gt;next-&gt;next;</span><br><span class="line">first = first-&gt;next;</span><br><span class="line">second = second-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">first-&gt;next = cur;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>法二：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">oddEvenList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> head;</span><br><span class="line">ListNode* p = head;</span><br><span class="line">ListNode* q = head-&gt;next;</span><br><span class="line">ListNode* evenhead = q;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (q != <span class="literal">nullptr</span> &amp;&amp; q-&gt;next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">p-&gt;next = p-&gt;next-&gt;next;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">q-&gt;next = q-&gt;next-&gt;next;</span><br><span class="line">q = q-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">p-&gt;next = evenhead;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><p>Top K问题的常见形式：</p><ul><li>给定10000个整数，找到第K大（第K小）的数</li><li>给定10000个整数，找出最大（最小）的前K个数</li><li>给定100000个单词，求前K词频的单词</li></ul><p>解决Top K问题若干种方法：</p><ul><li>使用最大最小堆。求最大的数用最小堆，求最小的数用最大堆。</li><li>Quick Select算法。使用类似快排的思路，根据pivot划分数组。</li><li>使用排序方法，排序后再寻找top K元素。</li><li>使用选择排序的思想，对前K个元素部分排序。</li><li>将1000…..个数分成m组，每组寻找top K个数，得到m×K个数，在这m×k个数里面找top K个数</li></ul><ol><li><p>使用最大最小堆的思路（以top K 最大元素为例）</p><p>按顺序扫描这10000个数，先取出K个元素构建一个大小为K的最小堆。每扫描到一个元素，如果这个元素大于堆顶的元素（这个堆最小的一个数），就放入堆中，并删除堆顶的元素，同时整理堆。如果这个元素小于堆顶的元素，就直接pass。最后堆中剩下的元素就是最大的前Top K个元素，最右的叶节点就是Top 第K大的元素。</p></li></ol><p>注意：最小堆的插入时间复杂度为log(n), n为堆中元素个数，在这里是K。最小堆的初始化时间复杂度是nlog(n)</p><p>C++中的最大最小堆要用标准库的priority_queue来实现。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> idx;</span><br><span class="line">    <span class="built_in">Node</span> (<span class="keyword">int</span> v, <span class="keyword">int</span> i) : <span class="built_in">value</span>(v), <span class="built_in">idx</span>(i) &#123;&#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> struct Node &amp;n1, <span class="keyword">const</span> struct Node &amp;n2) &#123;</span><br><span class="line">    <span class="keyword">return</span> n1.value &lt; n2.value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">priority_queue&lt;Node&gt; pq; <span class="comment">// 此时pq为最大堆</span></span><br></pre></td></tr></table></figure><ol start="2"><li><p>使用Quick Select的思路（以寻找第K大的元素为例）</p><p>Quick Select脱胎于快速排序，提出这两个算法的都是同一个人。算法的过程是这样的： 首先选取一个枢轴，然后将数组中小于该枢轴的数放到左边，大于该枢轴的数放到右边。 此时，如果左边的数组中的元素个数大于等于K，则第K大的数肯定在左边数组中，继续对左边数组执行相同操作； 如果左边的数组元素个数等于K-1，则第K大的数就是pivot； 如果左边的数组元素个数小于K，则第K大的数肯定在右边数组中，对右边数组执行相同操作。</p></li></ol><p>这个算法与快排最大的区别是，每次划分后只处理左半边或者右半边，而快排在划分后对左右半边都继续排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, k, <span class="number">0</span>, nums.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// quick select to find the kth-largest element</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelect</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == right) <span class="keyword">return</span> nums[right];</span><br><span class="line">    <span class="keyword">int</span> index = <span class="built_in">partition</span>(nums, left, right);<span class="comment">// 确定第k大（第k小）关键找对边界p</span></span><br><span class="line">    <span class="keyword">if</span> (index - left + <span class="number">1</span> &gt; k) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, k, left, index - <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (index - left + <span class="number">1</span> == k) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums[index];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">quickSelect</span>(nums, k - (index - left + <span class="number">1</span>), index + <span class="number">1</span>, right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数确定边界p，左边比p大，右边比p小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> begin = left, end = right;</span><br><span class="line">    <span class="keyword">int</span> key = nums[begin];</span><br><span class="line">    <span class="keyword">while</span> (begin &gt; end) &#123;</span><br><span class="line">        <span class="keyword">while</span> (begin &gt; end &amp;&amp; nums[end] &lt; key) &#123;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) nums[begin++] = nums[end];</span><br><span class="line">        <span class="keyword">while</span> (begin &gt; end &amp;&amp; nums[begin] &gt;= key) &#123;</span><br><span class="line">            begin++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (begin &gt; end) nums[end--] = nums[begin];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[begin] = key;</span><br><span class="line">    <span class="keyword">return</span> begin;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数确定边界p，左边比p小，右边比p大，使用交换法</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high, pivot = arr[low];<span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) j--;<span class="comment">//向左扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;<span class="comment">//向右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j--]);<span class="comment">//交换arr[i]和arr[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[low], arr[i - <span class="number">1</span>]);<span class="comment">//交换arr[i - 1]和arr[low]，并返回基准元素位置i - 1</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[low]);<span class="comment">//交换arr[i]和arr[low]，并返回基准元素位置i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>使用选择排序的思想对前K个元素排序 （ 以寻找前K大个元素为例）<br>扫描一遍数组，选出最大的一个元素，然后再扫描一遍数组，找出第二大的元素，再扫描一遍数组，找出第三大的元素。。。。。以此类推，找K个元素，时间复杂度为O(N*K)</li></ol><h2 id="写三个线程交替打印ABC"><a href="#写三个线程交替打印ABC" class="headerlink" title="写三个线程交替打印ABC"></a>写三个线程交替打印ABC</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;thread&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;mutex&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;condition_variable&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">mutex mymutex;</span><br><span class="line">condition_variable cv;</span><br><span class="line"><span class="keyword">int</span> flag=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printa</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> count=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(count&lt;<span class="number">10</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">0</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 1: a&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">1</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 1 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printb</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">1</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 2: b&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">2</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 2 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(mymutex)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">        <span class="keyword">while</span>(flag!=<span class="number">2</span>) cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;thread 3: c&quot;</span>&lt;&lt;endl;</span><br><span class="line">        flag=<span class="number">0</span>;</span><br><span class="line">        cv.<span class="built_in">notify_all</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;my thread 3 finish&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">thread <span class="title">th2</span><span class="params">(printa)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th1</span><span class="params">(printb)</span></span>;</span><br><span class="line">    <span class="function">thread <span class="title">th3</span><span class="params">(printc)</span></span>;</span><br><span class="line"></span><br><span class="line">    th1.<span class="built_in">join</span>();</span><br><span class="line">    th2.<span class="built_in">join</span>();</span><br><span class="line">    th3.<span class="built_in">join</span>();</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot; main thread &quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>操作系统笔记01</title>
      <link href="/posts/80d55e53/"/>
      <url>/posts/80d55e53/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="OS概述"><a href="#OS概述" class="headerlink" title="OS概述"></a>OS概述</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p><strong>操作系统的两个职责：</strong></p><ul><li><p><strong>对硬件进行管理与抽象</strong></p><ul><li><p>管理硬件：内存分配、设备驱动</p></li><li><p>对硬件进行抽象：将有限的、离散的资源高效地抽象为无限的、连续的资源。将硬件通过易用的接口提供给上层的</p><p>应用，从而使应用无须关心硬件的具体细节。</p></li></ul></li><li><p><strong>为应用提供服务并管理</strong></p><ul><li>服务于应用：提供接口（如系统调用），不同类型的访问控制、应用间交互等服务</li><li>管理应用：应用生命周期管理，包括应用的加载、启动、切换、调度、销毁等。</li></ul></li></ul><p>狭义的OS：操作系统内核 + Shell(命令行界面)</p><p>广义的OS：</p><ul><li><strong>操作系统内核</strong>（对硬件资源的管理与抽象，为操作系统框架提供基础的系统服务）</li><li><strong>操作系统框架</strong>（基于操作系统内核提供的服务，为不同的应用领域提供编程接口与运行环境）</li></ul><p>OS发展历史：</p><p>批处理操作系统 -&gt; 分时处理操作系统（UNIX), shell命令行交互 -&gt; 个人PC（macOS/Windows），人机交互更好</p><h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><ul><li><strong>系统调用接口</strong> 向内核申请服务</li><li><strong>POSIX接口</strong> 可移植操作系统接口，通常通过C library（libc）来实现。</li><li><strong>领域应用接口</strong> 封装面向不同领域的领域应用接口</li></ul><h2 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h2><p>计算机硬件结构主要为<strong>冯·诺伊曼结构</strong></p><ul><li>中央处理器 CPU</li><li>存储器（内存）</li><li>输入输出 I/O</li></ul><p>CPU缓存，比物理内存访问速度快。</p><p><img src="/OS-1/image-20220527155653122.png" alt="image-20220527155653122"></p><p>设备与中断</p><p>内存映射输入输出 MIMO：</p><p>把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配相应的地址。</p><p>轮询与中断</p><p>让CPU不断通过MIMO查看是否有输入，但会使CPU长时间处于等待状态造成浪费。</p><p>获得输入后，向CPU发送一个中断。</p><p>MMIO使得CPU可以主动地访问设备,中断使得设备能够主动地通知CPU，这两种机制是CPU与设备之间交互的重要方式。</p><p>内存</p><p><img src="/OS-1/image-20220527231741888.png" alt="image-20220527231741888"></p><h3 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程 Process"></a>进程 Process</h3><p>与每个进程相关的是<strong>地址空间</strong></p><p>地址空间中存放可执行程序、程序所需要的数据和栈</p><p>进程可以看作是容纳运行一个程序所有信息的容器</p><p><strong>进程表：</strong> 数组或链表结构，存放进程信息</p><p>进程树：一个进程可以创建多个进程（子进程），树形结构</p><p>系统管理器授权每个进程一个给定的UID，子进程与父进程拥有一样的UID</p><h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>管理进程，每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值。一个进程可以拥有的最大地址空间小于主存。</p><p>虚拟内存：操作系统把部分地址空间装入主存，部分留在磁盘上，并在需要的时候交换回来</p><h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>抽象文件模型</p><p>创建文件、删除文件、读和写文件 都需要系统调用。</p><p><strong>文件描述符：</strong> 读写文件前，检查权限可以打开，系统返回一个小整数，供后续操作使用；若禁止使用返回一个错误码</p><p><strong>管道：</strong> 一种虚文件，可以连接两个进程</p><p><img src="/OS-1/image-20220528171527111.png" alt="image-20220528171527111"></p><h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统的两大功能：</p><ul><li>为用户提供应用程序抽象</li><li>管理计算机资源</li></ul><p>只有<strong>系统调用能够进入内核态而过程调用则不能进行内核态</strong></p><h4 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h4><p>UNIX中唯一可以在POSIX中创建进程的途径：fork</p><p>fork调用返回一个值，在子进程中为0，在父进程中等于子进程的进程标识符PID。使用返回的PID可以看出哪个是父进程和子进程。</p><p>POSIX：可移植操作系统接口</p><p>waitpid系统调用：为等待子进程完成，父进程执行waitpid</p><p>execve系统调用：实现系统执行，三个参数：将要执行的文件名称、一个指向变量数组的指针、一个指向环境数组的指针。</p><p>一个shell指令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure><p>此命令将file1复制到file2文件中，在shell执行fork之后，子进程定位并执行文件拷贝，将将源文件和目标文件的名称传递给它。</p><p>cp的主程序包含声明：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">main</span>(agrc, argv, envp)</span><br></pre></td></tr></table></figure><p>argc：命令行中参数数目的计数，包括程序名称。对于上面的例子，argc是3。</p><p>argv：数组的指针，该数组的元素i为第i个字符串的指针，例如，argc[0]指向字符串cp，argc[1]指向字符串file1，argc[2]指向字符串file2。</p><p>envp：指向环境的指针，该环境是一个数组，含有name = value的赋值形式，例子中，没有环境参数传递给execve，所以execve的第三个参数为0。</p><p>UNIX中的进程将内存划分为三部分：</p><ul><li>text segment，文本区，例如程序代码</li><li>data segment，数据区，例如变量</li><li>stack segment，栈区域，数据向上增长而堆栈向下增长。</li></ul><img src="/posts/80d55e53/image-20220529153518116.png" alt="image-20220529153518116" style="zoom:35%;"><h4 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h4><p>与某个文件有关的系统调用</p><p>常用的调用read和write</p><p>UNIX为每个文件保存了该文件的类型、大小、最后修改时间以及其他信息，程序可以通过stat系统调用查看这些信息。</p><h4 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h4><p>与整个文件系统有关的系统调用</p><p>mkdir和rmdir分别用于创建和删除空目录。</p><p>mount系统调用将两个文件系统合并为一个。</p><h4 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h4><p>chdir调用更改当前工作目录</p><p>chmod系统调用提供改变文件模式的操作</p><p>UNIX与Win32系统调用API</p><table><thead><tr><th>UNIX</th><th>Win32</th><th>说明</th></tr></thead><tbody><tr><td>fork</td><td>CreateProcess</td><td>创建一个进程</td></tr><tr><td>waitpid</td><td>WaitForSingleObject</td><td>等待一个进程退出</td></tr><tr><td>execve</td><td>none</td><td>CraeteProcess = fork + service</td></tr><tr><td>exit</td><td>ExitProcess</td><td>终止执行</td></tr><tr><td>open</td><td>CreateFile</td><td>创建一个文件或打开一个已有的文件</td></tr><tr><td>close</td><td>CloseHandle</td><td>关闭文件</td></tr><tr><td>read</td><td>ReadFile</td><td>从单个文件中读取数据</td></tr><tr><td>write</td><td>WriteFile</td><td>向单个文件中写数据</td></tr><tr><td>lseek</td><td>SetFilePointer</td><td>移动文件指针</td></tr><tr><td>stat</td><td>GetFileAttributesEx</td><td>获得不同的文件属性</td></tr><tr><td>mkdir</td><td>CreateDirectory</td><td>创建一个新的目录</td></tr><tr><td>rmdir</td><td>RemoveDirectory</td><td>移除一个空的目录</td></tr><tr><td>link</td><td>none</td><td>Win32不支持link</td></tr><tr><td>unlink</td><td>DeleteFile</td><td>销毁一个已有的文件</td></tr><tr><td>mount</td><td>none</td><td>Win32不支持mount</td></tr><tr><td>umount</td><td>none</td><td>Win32不支持mount</td></tr><tr><td>chdir</td><td>SetCurrentDirectory</td><td>切换当前工作目录</td></tr><tr><td>chmod</td><td>none</td><td>Win32不支持安全</td></tr><tr><td>kill</td><td>none</td><td>Win32不支持信号</td></tr><tr><td>time</td><td>GetLocalTime</td><td>获取当前时间</td></tr></tbody></table><h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul><li>单体系统</li><li>分层系统</li><li>微内核</li><li>客户-服务端系统</li><li>虚拟机</li><li>外核</li></ul><h4 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h4><p>整个系统在内核态以单一程序的方式运行</p><p>整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行文件</p><p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中。</p><p>三层模型：</p><ul><li>主程序：调用请求服务程序</li><li>服务程序：执行系统调用</li><li>实用程序：辅助服务过程调用</li></ul><h4 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h4><p>使用层来分隔不同的功能单元，每一层只与该层的上层和下层通信。</p><p>每一层都使用下面的层来执行其功能，层之间的通信通过预定义的固定接口通信。</p><table><thead><tr><th>层号</th><th>功能</th></tr></thead><tbody><tr><td>5</td><td>操作员</td></tr><tr><td>4</td><td>用户程序</td></tr><tr><td>3</td><td>输入/输出管理</td></tr><tr><td>2</td><td>操作员-进程通信</td></tr><tr><td>1</td><td>存储器和磁鼓管理</td></tr><tr><td>0</td><td>处理器分配和多道程序编程</td></tr></tbody></table><h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核运行在内核态，其余模块可以作为普通用户进程运行。</p><img src="/posts/80d55e53/image-20220529222250168.png" alt="image-20220529222250168" style="zoom:60%;"><p>机制与策略分离，比如系统调度，一个简单的调度算法是对每个进程赋予优先级，让内核执行优先级最高的进程。内核的机制是寻找最高的优先级进程并运行，而策略（赋予进程优先级）可以在用户态中的进程完成。策略与机制分离，使得内核变得更小。</p><h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h4><p>把进程划分为两类：</p><ul><li>服务器，每个服务器用来提供服务</li><li>客户端，使用这些服务</li></ul><img src="/posts/80d55e53/image-20220529222837516.png" alt="image-20220529222837516" style="zoom:67%;"><p>两种载体：</p><ul><li>计算机既是客户端又是服务器</li><li>客户端与服务器在不同机器上（普遍情况），通过局域网或广域网连接</li></ul><p>客户端发送请求并得到回应。</p><h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程：对正在运行中的程序的抽象，操作系统最核心的概念。</p><p><strong>伪并发</strong>：单核或多核处理器同时执行多个进程，从而使程序更快。以非常有限的时间间隔在程序之间快速切换CPU。</p><p>缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。</p><h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>计算机上运行的软件包括操作系统，被组织为若干<strong>顺序进程</strong> </p><p>进程包括：程序计数器、寄存器、变量的当前值</p><p>在进程不断切换的过程中，程序计数器也在不同的变化</p><img src="/posts/80d55e53/image-20220530113613610.png" alt="image-20220530113613610" style="zoom:67%;"><p>任何一个给定的瞬间仅有一个进程真正运行</p><p>一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU），每一个核也只能一次运行一个线程。</p><h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ul><li>系统初始化（init)</li><li>正在运行的程序执行了创建进程的系统调用（比如fork）</li><li>用户请求创建一个新进程</li><li>初始化一个批处理工作</li></ul><h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>前台进程：同用户进行交互并替他们完成工作的进程</p><p>守护进程：进程运行在后台用来处理一些活动如Email、web网页、打印等</p><p>UNIX中，ps程序可以列出正在运行的进程，Windows中使用任务管理器</p><h4 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h4><p>一个正在运行的进程会发出系统调用，用来创建一个或多个新进程来帮助其完成工作。</p><p>多处理器中，每个进程运行在不同的CPU上可以使工作更快。</p><p>UNIX中，仅有一个系统调用可以创建一个新进程：<strong>fork</strong> ，该调用会创建一个与调用进程相关的副本。</p><h4 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h4><p>交互式系统中，输入一个命令或双击图标可以启动程序，这些操作可以选择开启一个新的进程。</p><p>新进程将接管启动它的窗口，每个窗口都可以运行进程。</p><h3 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h3><p>大型机的批处理系统</p><p>用户提交批处理作业，当操作系统决定它有资源来运行另一个任务时，将创建一个新进程并从其中的输入队列中运行下一个作业。</p><h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ul><li>正常退出（自愿的）</li><li>错误退出（自愿的）</li><li>严重错误（非自愿的）</li><li>被其他进程杀死（非自愿的）</li></ul><h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止</p><p>UNIX调用是exit。</p><h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>例如编译foo.c 但是该文件不存在，编译器会发出声明并退出。</p><p>通常会弹出对话框告知用户发生系统错误</p><h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>通常由于程序中的错误导致。例如，执行了一条非法指令，引用不存在的内存，除数为0等。</p><p>UNIX中，这类错误，进程会收到信号（中断），而不是在这类错误出现时直接终止进程</p><h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>UNIX中调用kill，某个进程执行系统调用告诉操作系统杀死某个进程。</p><h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>每个进程是一个独立的实体，有其自己的程序计数器和内部状态。</p><p>进程之间需要相互帮助，例如，一个进程的结果可以作为另一个进程的输入</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure><p>第一个进程cat，将三个文件级联并输出。</p><p>第二个进程grep，从输入中选取包含有关键字tree的内容。</p><p>可能出现grep准备就绪开始执行，但是输入还未完成，于是必须阻塞grep进程，直到输入完毕。</p><p>进程状态的切换：</p><img src="/posts/80d55e53/image-20220530160754572.png" alt="image-20220530160754572" style="zoom:50%;"><p>进程状态有三种：</p><ul><li><strong>运行态</strong>：进程实际占用CPU时间片运行时</li><li><strong>就绪态</strong>：可运行，但因为其他进程正在运行而处于就绪状态</li><li><strong>阻塞态</strong>：除非某种外部事件发生，否则进程不能运行</li></ul><p>运行态与就绪态很相似，都表示进程可运行，区别在于就绪状态没有获得CPU时间分片。</p><p>阻塞态与前两个不同，进程不能运行，CPU空闲时也不能运行。</p><p>在操作系统发现进程不能继续执行时发生转换1，某些系统执行系统调用如pause，获取一个阻塞的状态。UNIX中，当进程从管道或特殊文件（如终端）中读取没有可用的输入时，该进程自动终止。</p><p>转换2和3由进程调度程序引起。</p><p>进程等待一个外部事件发生（如从外部输入一些数据后），发生转换4；若此时没有其他进程在运行，则立即触发转换3，该进程开始运行，否则该进程处于就绪阶段，等待CPU空闲后再轮到它运行。</p><p><strong>操作系统最底层的就是调度程序。</strong>所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。</p><h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p><strong>进程表</strong> 进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状态、所打开文件的状态、调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后可以再次启动，就像从未中断过一样。</p><p>关键字段：</p><ul><li>进程管理</li><li>存储管理</li><li>文件管理</li></ul><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程thread，线程也会有程序计数器、寄存器、堆栈。</p><p>进程用于把资源集中到一起，<strong>线程是CPU上调度执行的实体</strong>。</p><p>线程比进程创建快。</p><p>线程不像进程那样有较强的独立性。由于每个线程都可以访问进程地址空间的每个内存地址，因此<strong>一个线程可以读取、写入甚至擦除另一个线程的堆栈。</strong></p><img src="/posts/80d55e53/image-20220530234435504.png" alt="image-20220530234435504" style="zoom:50%;"><p>线程的状态：运行中、阻塞、就绪和终止。线程之间的状态转换与进程之间的状态转换是一样的。</p><p>线程无法利用时钟中断强制让线程让出CPU。</p><p>线程创建：调用库函数，线程创建函数会要求指定新创建线程的名称，创建的线程通常会返回一个线程标识符，该标识符就是新线程的名字。</p><h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要三种实现方式</p><ul><li>在用户空间中实现线程</li><li>在内核空间中实现线程</li><li>在用户和内核空间中混合实现线程</li></ul><h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。</p><img src="/posts/80d55e53/image-20220531103211795.png" alt="image-20220531103211795" style="zoom:50%;"><p>运行时系统：也叫运行时环境，提供了程序在其中运行的环境。</p><p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p><p>每个进程需要有其专用的线程表，用来跟踪该进程中的线程。</p><p>优势：</p><ul><li>启动线程比内核调用效率更高，不需要切换到内核，也不需要上下文切换，不需要对内存高速缓存进行刷新，线程调用非常便捷，因此效率高</li><li>允许每个进程有自己定制的调度算法，用户线程具有较好的可扩展性。</li></ul><p>劣势：</p><ul><li>阻塞系统调用问题，使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程</li><li>缺页中断问题，如果某个程序发生函数调用或跳转指令到了一条不在内存的指令上，会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，称为缺页故障。</li><li>如果一个线程开始运行，该线程所在进程中的其他线程都不能运行，单进程内部没有时钟中断，不能使用轮转调度的方式调度线程。</li></ul><h4 id="在内核空间中实现线程"><a href="#在内核空间中实现线程" class="headerlink" title="在内核空间中实现线程"></a>在内核空间中实现线程</h4><p>不需要运行时环境，每个进程中也没有线程表，在内核中会有记录系统中所有线程的线程表。某个线程希望创建新线程或撤销一个已有线程，会执行一个系统调用，完成对线程表的更新。</p><img src="/posts/80d55e53/image-20220531104923664.png" alt="image-20220531104923664" style="zoom:50%;"><p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，例如运行同一个进程中的另一个线程或者运行另一个进程中的一个线程。</p><p>内核中创建或销毁线程的开销比较大，某些系统会采用可循环利用的方式来回收线程。当某个线程被销毁时，就把他标志为不可运行的状态，但其内部结构没有收到影响，稍后在创建一个新线程时，就会重新启用旧线程，标志为可用状态。</p><h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>内核级线程，将用户级线程与某些或全部内核线程多路复用起来。</p><img src="/posts/80d55e53/image-20220531115650409.png" alt="image-20220531115650409" style="zoom:50%;"><p>编程人员可以自由控制用户线程和内核线程的数量，灵活度高。内核只识别内核级线程，对其进行调度，其中一些内核级线程会被多个用户级线程多路复用。</p><h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p>三个问题：</p><ul><li>进程如何传递消息给其他进程</li><li>确保两个或多个线程之间不会相互干扰</li><li>数据的先后顺序问题</li></ul><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>存在共享资源、共享文件、共享内存</p><p>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性。</p><p>如何避免：</p><p><strong>禁止一个或多个进程在同一时刻对共享资源（包括共享文件、共享内存等）进行读写。</strong></p><p>需要<strong>互斥条件</strong>。</p><h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区（临界区域）：对共享内存进行访问的程序片。</p><p>使两个不同进程不可能同时处于临界区，就能避免竞争条件。</p><p>使用临界区的互斥</p><img src="/posts/80d55e53/image-20220531121115455.png" alt="image-20220531121115455" style="zoom:50%;"><h3 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h3><h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>单核处理器，每个进程在进入临界区后立即<strong>屏蔽所有中断</strong>，并在离开临界区之前重新启用他们。屏蔽中断后CPU不会切换到其他进程。一旦某个进程屏蔽中断后，就可以检查和修改共享内存，而不担心其他进程介入访问共享数据。</p><p>屏蔽中断对于操作系统本身是一种有用的技术，但是对于用户线程来说，屏蔽中断不是一项通用的互斥机制。</p><h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>考虑有单个共享的锁变量，初始值为0。当一个线程想要进入关键区域时，会首先查看锁的值是否为0，如果锁的值为0，进程会把它设置为1并让进程进入关键区域；如果锁的状态为1，进程会等待直到锁变量的值为0。</p><p>锁变量值为0，表示没有线程进入关键区域，如果为1，表示有进程在关键区域内。</p><img src="/posts/80d55e53/image-20220606180447319.png" alt="image-20220606180447319" style="zoom:50%;"><p>会发生竞争条件，临界区可能会有两个进程同时运行，set-before-check 不是一种原子性操作。</p><h4 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h4><p>先抛出一段代码，用c语言编写。</p><p>进程0的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">/* 进入关键区域*/</span> </span><br><span class="line"> critical_region();</span><br><span class="line"> turn = <span class="number">1</span>;</span><br><span class="line"><span class="comment">/* 离开关键区域*/</span> </span><br><span class="line"> noncritical_region();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>进程1的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line"><span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line"><span class="comment">/* 进入关键区域*/</span> </span><br><span class="line"> critical_region();</span><br><span class="line"> turn = <span class="number">0</span>;</span><br><span class="line"><span class="comment">/* 离开关键区域*/</span> </span><br><span class="line"> noncritical_region();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>变量turn初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新内存。</p><p>忙等待：连续检查一个变量直到某个值出现为止，但是这种方式浪费CPU时间，通常应该避免。</p><p>只有在有理由认为等待时间是非常短的情况下，才能使用忙等待。用于忙等待的锁，，称为自旋锁。</p><p>可能会出现违反 <strong>位于临界区外的进程不得阻塞其他进程</strong> 的情况，不算一个好的方案。</p><h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量mutex，一些共享资源和一段代码保持互斥。</p><p>两种状态：解锁和加锁。</p><p>当一个线程（或进程）需要访问关键区域时，会调用mutex_lock进行加锁。如果互斥锁处于解锁状态（表示关键区域可用），则调用成功，并且调用线程可以自由进入关键区域。</p><p>如果mutex互斥量已经锁定，调用线程会阻塞直到关键区域内的线程执行完毕并且调用了mutex_unlock。如果多个线程在mutex互斥量上阻塞，将随机选择一个线程并选择一个线程并允许它获得锁。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图论基础与拓补排序</title>
      <link href="/posts/75bf15f1/"/>
      <url>/posts/75bf15f1/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h2><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><p>二元组G = &lt;V, E&gt;, V节点集，E边集；</p><p>节点的度：与该节点相关联的边数</p><p>分为：有向图、无向图</p><h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>一个一维数组存储图中节点的信息，一个二维数组存储图中节点之间的邻接关系。</p><p><strong>无向图：</strong></p><img src="/posts/75bf15f1/image-20220520174528197.png" alt="image-20220520174528197" style="zoom:80%;"><p>特点：</p><ul><li><p>无向图的邻接矩阵是<strong>对称矩阵，并且是唯一的</strong>。</p></li><li><p>第i行或第i列非零元素的个数正好是第i个节点的度。上图中的邻接矩阵，第3列非零元素的个数为2，说明第3个节点c的度为2。</p></li></ul><p><strong>有向图：</strong></p><p>以尖括号&lt;vi, vj&gt;表示的是有序对，以圆括号(vi ,vj)表示的是无序对。</p><p>有向图的邻接矩阵不一定是对称的</p><img src="/posts/75bf15f1/image-20220520174937549.png" alt="image-20220520174937549" style="zoom:80%;"><p>特点：</p><ul><li>有向图的邻接矩阵<strong>不一定是对称</strong>的。</li><li><strong>第i行非零元素的个数正好是第i个节点的出度，第i列非零元素的个数正好是第i个节点的入度。</strong>上图中的邻接矩阵，第3行非零元素的个数为2，第3列非零元素的个数也为2，说明第3个节点c的出度和入度均为2。</li></ul><p><strong>网（带权图）：</strong></p><img src="/posts/75bf15f1/image-20220520175300124.png" alt="image-20220520175300124" style="zoom:80%;"><p><strong>邻接矩阵的优点：</strong></p><ul><li><p>快速判断在两节点之间是否有边。在图中，<code>Edge[i][j]=1</code>，表示有边；<code>Edge[i][j]=0</code>，表示无边。在网中，<code>Edge[i][j]=∞</code>，表示无边，否则表示有边。时间复杂度为O (1)。</p></li><li><p>方便计算各节点的度。在无向图中，邻接矩阵第i行元素之和就是节点i的度；在有向图中，第i行元素之和就是节点i的出度，第i列元素之和就是节点i的入度。时间复杂度为O(n)。</p></li></ul><p><strong>邻接矩阵的缺点：</strong></p><ul><li><p>不便于增删节点。增删节点时，需要改变邻接矩阵的大小，效率较低。</p></li><li><p>不便于访问所有邻接点。访问第i个节点的所有邻接点时，需要访问第i行的所有元素，时间复杂度为O(n)。访问所有节点的邻接点，时间复杂度为O(n^2)。</p></li><li><p>空间复杂度高，为O(n^2)。</p></li></ul><h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表是图的一种链式存储方法，其数据结构包括两部分：节点和邻接点。</p><ol><li>无向图</li></ol><p>一个节点的所有邻接点构成一个单链表。</p><p><img src="/20220520/image-20220520175923798.png" alt="image-20220520175923798"></p><p>无向图特点：</p><ul><li><p>如果无向图有n个节点、e条边，则节点表有n个节点，邻接点表有2e个节点。</p></li><li><p>节点的度为该节点后面单链表中的节点数。</p></li></ul><ol start="2"><li>有向图</li></ol><p><img src="/20220520/image-20220520180303332.png" alt="image-20220520180303332"></p><p>对有向图中节点的邻接点，只看该节点的出边（出弧）。</p><p>有向图特点：</p><ul><li><p>如果有向图有n个节点、e条边，则节点表有n个节点，邻接点表有e个节点。</p></li><li><p>节点的出度为该节点后面单链表中的节点数。</p></li></ul><p>在有向图邻接表中很<strong>容易找到节点的出度</strong>，但是<strong>找入度很难，需要遍历所有邻接点表中的节点</strong>，查找到<strong>该节点出现了多少次，入度就是多少</strong>。</p><h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>参考多叉树，多叉树的遍历框架如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 多叉树遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">for</span> (TreeNode* child : root -&gt; children) &#123;</span><br><span class="line"><span class="built_in">traverse</span>(child);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>图和多叉树最⼤的区别是，图是可能包含环的，你从图的某⼀个节点开始遍历，有可能⾛了⼀圈⼜回到这个 </p><p>节点。 </p><p>因此，遍历需要一个<code>visited</code>辅助数组，不走重复的节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于图的遍历，应该把<code>onPath</code>的操作放到for循环外⾯，否则会漏掉记录起始点的遍历。</p><p>如果图中不含有环，可以把<code>visited</code>数组省略。</p><p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797.所有可能路径</a></p><p>题目描述： </p><p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） <code>graph[i]</code>是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 <code>graph[i][j]</code>存在一条有向边）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure><p>解析：</p><p>有向无环图，以0为起点开始遍历，同时记录走过的路径，当遍历到终点时将路径记录下来。</p><p>可以不使用visited数组辅助。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res; <span class="comment">//记录所有的路径</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//维护递归过程中经过的路径</span></span><br><span class="line">    <span class="built_in">tranverse</span>(graph, path, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加节点index到路径</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == n - <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, path, v);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//从路径移除节点index</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="判断图是否有环（图的遍历）"><a href="#判断图是否有环（图的遍历）" class="headerlink" title="判断图是否有环（图的遍历）"></a>判断图是否有环（图的遍历）</h2><p><a href="https://leetcode.cn/problems/course-schedule/">207.课程表</a></p><p>存在依赖问题，⾸先把问题转化成「有向图」这种数据结构，<strong>只要图中存在环，那就说明存在循环依赖</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure><p><strong>graph[index]</strong> 是⼀个列表，存储着节点 index 所指向的节点。 </p><p>先建图 + 遍历图判断是否存在环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle = <span class="number">0</span>; <span class="comment">// 记录图中是否有环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//防止重复遍历同一节点</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//记录当前走过的路径</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历图中的所有节点</span></span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, i, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 只要没有循环依赖可以完成所有课程</span></span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立图的邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    <span class="comment">//图中共有numCourses个节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to  = v[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 修完课程 from 才能修课程 to</span></span><br><span class="line"><span class="comment">// 在图中添加⼀条从 from 指向 to 的有向边</span></span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited,vector&lt;<span class="keyword">bool</span>&gt;&amp; path, <span class="keyword">int</span> index, <span class="keyword">bool</span>&amp; hasCycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[index]) &#123; <span class="comment">//如果发现Path[index] 已经被标记说明出现了环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>; <span class="comment">//发现环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[index] || hasCycle) &#123; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//将节点index标记为已遍历</span></span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//开始遍历节点index</span></span><br><span class="line">    path[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, v, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点index遍历完成</span></span><br><span class="line">    path[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拓补排序"><a href="#拓补排序" class="headerlink" title="拓补排序"></a>拓补排序</h2><p><a href="https://leetcode.cn/problems/course-schedule-ii/submissions/">210.课程表II</a></p><p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure><p>拓扑排序（Topological Sorting）</p><p>直观地说就是，让你把⼀幅图「拉平」，⽽且这个「拉平」的图⾥⾯，所有箭头⽅向都是⼀致的。</p><p>如果⼀幅有向图中存在环，是⽆法进⾏拓扑排序的，因为肯定做不到所有箭头⽅向⼀致；反过来，如果⼀幅图是<strong>「有向⽆环图」</strong>，那么<strong>⼀定可以进⾏拓扑排序</strong>。 </p><p><strong>将后序遍历的结果进⾏反转，就是拓扑排序的结果。</strong></p><p>先对图进行DFS遍历，记录后序遍历结果，最后将后序遍历结果反转。</p><p>进⾏<strong>拓扑排序之前要进⾏环检测</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; postorder; <span class="comment">// 记录后序遍历结果</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle = <span class="literal">false</span>; <span class="comment">// 记录是否存在环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 建立图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, i, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有环图⽆法进⾏拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 逆后序遍历结果即为拓扑排序结果</span></span><br><span class="line">    <span class="built_in">reverse</span>(postorder.<span class="built_in">begin</span>(), postorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postorder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立图的邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to  = v[<span class="number">0</span>];</span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited,vector&lt;<span class="keyword">bool</span>&gt;&amp; path, <span class="keyword">int</span> index, <span class="keyword">bool</span>&amp; hasCycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[index]) &#123;</span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[index] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">// 前序遍历位置</span></span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    path[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited, path, v, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    postorder.<span class="built_in">push_back</span>(index);</span><br><span class="line">    path[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且 </p><p>两个⼦集内的顶点不相邻。</p><p>给出一副图，用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p><img src="/posts/75bf15f1/image-20220520214203061.png" alt="image-20220520214203061" style="zoom:50%;"><p>二分图的判定：</p><p>遍历⼀遍图，⼀边遍历⼀边染⾊，看看能不能⽤两种颜⾊给所有节点染⾊，且相邻节点的颜⾊都不相同。 </p><p><strong>图的遍历框架1：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>图的遍历框架2：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 只遍历没标记过的相邻节点</span></span><br><span class="line">            <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种写法把对 visited 的判断放到递归调⽤之前，和之前的写法唯⼀的不同就是，你需要保证调⽤</p><p>traverse(v) 的时候，visited[v] == false。 </p><p><a href="https://leetcode.cn/problems/is-graph-bipartite/">785.判断⼆分图</a></p><p>输⼊⼀个 邻接表 表示⼀幅⽆向图，请你判断这幅图是否是⼆分图。 </p><img src="/posts/75bf15f1/image-20220520215456736.png" alt="image-20220520215456736" style="zoom:80%;"><p>解析：</p><p>遍历图，相邻节点涂不同颜色，额外使用一个color数组记录每个节点的颜色。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 记录图是否符合⼆分图性质</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; color; <span class="comment">// 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited; <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，输⼊邻接表，判断是否是⼆分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    color.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 因为图不⼀定是联通的，可能存在多个⼦图</span></span><br><span class="line"> <span class="comment">// 所以要把每个节点都作为起点进⾏⼀次遍历</span></span><br><span class="line"> <span class="comment">// 如果发现任何⼀个⼦图不是⼆分图，整幅图都不算⼆分图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">tranverse</span>(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经确定不是⼆分图了，就不⽤浪费时间再递归遍历了</span></span><br><span class="line"> <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 没有被访问过</span></span><br><span class="line"> <span class="comment">// 那么应该给节点 s 涂上和节点 v 不同的颜⾊</span></span><br><span class="line"> color[s] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 s</span></span><br><span class="line">            <span class="built_in">tranverse</span>(graph, s);</span><br><span class="line">            <span class="comment">//bfs(graph, s);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 已经被访问过</span></span><br><span class="line"> <span class="comment">// 根据 v 和 s 的颜⾊判断是否是⼆分图</span></span><br><span class="line">            <span class="keyword">if</span> (color[s] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS遍历</span></span><br><span class="line"><span class="comment">// 从 start 节点开始进⾏ BFS 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; ok) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                color[w] = !color[v];</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(w);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[w] == color[v]) &#123;</span><br><span class="line">                    <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p><p>给定一组 n 人（编号为 1, 2, …, n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p><p>给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和  bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：group1 [1,4], group2 [2,3]</span><br><span class="line"></span><br><span class="line">输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>二分图的判定，每个人看作节点，相互关系看作边，双色图，按照颜色分成两组。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 记录图是否符合⼆分图性质</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; color; <span class="comment">// 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited; <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 图节点编号从 1 开始</span></span><br><span class="line">    color.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 转化成邻接表表示图结构</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(n, dislikes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">tranverse</span>(graph, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes) &#123;</span><br><span class="line">    <span class="comment">// 图节点编号为 1...n</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : dislikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 「⽆向图」相当于「双向图」</span></span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        graph[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经确定不是⼆分图了，就不⽤浪费时间再递归遍历了</span></span><br><span class="line"> <span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 没有被访问过</span></span><br><span class="line"> <span class="comment">// 那么应该给节点 s 涂上和节点 v 不同的颜⾊</span></span><br><span class="line"> color[s] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 s</span></span><br><span class="line">            <span class="built_in">tranverse</span>(graph, s);</span><br><span class="line">            <span class="comment">//bfs(graph, s);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 已经被访问过</span></span><br><span class="line"> <span class="comment">// 根据 v 和 s 的颜⾊判断是否是⼆分图</span></span><br><span class="line">            <span class="keyword">if</span> (color[s] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题随笔02</title>
      <link href="/posts/6832ed80/"/>
      <url>/posts/6832ed80/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="01-绳子覆盖最多的节点"><a href="#01-绳子覆盖最多的节点" class="headerlink" title="01 绳子覆盖最多的节点"></a>01 绳子覆盖最多的节点</h2><p>题目：</p><p>给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？<br>即使绳子边缘处盖住点也算盖住</p><p>例如，<code>arr = [1, 3, 4, 7, 13, 16, 17]</code>, <code>target = 4</code>, 子数组<code>[3, 4, 7]</code>满足所有节点被覆盖</p><p>解析：</p><ol><li>普通解</li></ol><p>利用贪心，每一个点向前推，记录每个节点前target距离内覆盖个数最大值，一次遍历</p><p>小优化：数组有序，每个点向前找符合条件的节点个数，二分搜索优化，复杂度O(Nlog(N))</p><ol start="2"><li>最优解</li></ol><p>双指针，L和起始位置指向0，<code>arr[R] - arr[L] &lt;= target</code>, R++向右移动；<code>arr[R] - arr[L] &gt; target</code>, L++向左移动。绳子起始边缘为L的最大覆盖节点个数，依次遍历。复杂度O(N)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：贪心+二分搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nearest = <span class="built_in">nearestIndex</span>(arr, i, arr[i] - target);</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - nearest + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> R, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = R;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + (R- L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：贪心+双指针，滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; arr[right] - arr[left] &lt;= target) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="built_in">max</span>(count, right - left);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="02-两种字符最少交换次数"><a href="#02-两种字符最少交换次数" class="headerlink" title="02 两种字符最少交换次数"></a>02 两种字符最少交换次数</h2><p>题目：</p><p>一个数组中只有两种字符’G’和’B’，可以让所有的G都放在左侧，所有的B都放在右侧<br>或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在<strong>相邻字符之间进行交换操作</strong>，返回至少需要交换几次</p><p>解析：</p><p>贪心，遍历遇到第一个G，移到0位置，遇到第二个G，移到位置1……，双指针</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStep</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//G在左边，B在右边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">            step1 += i - gi;</span><br><span class="line">            gi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//G在右边，B在左边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            step2 += i - bi;</span><br><span class="line">            bi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(step1,step2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="03-数组目标和为target的所有排列个数"><a href="#03-数组目标和为target的所有排列个数" class="headerlink" title="03 数组目标和为target的所有排列个数"></a>03 数组目标和为target的所有排列个数</h2><p>题目：</p><p>给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target<br>请问最后算出target的方法数</p><p>leetcode：494</p><p>解析：</p><ol><li>递归暴力求解</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays1</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归函数，可以自由使用arr[index...]所有的数字</span></span><br><span class="line"><span class="comment">//能够得出target这个数，方法数是多少，返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123; <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> target ==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, target - arr[index]) + <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, target + arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态规划，记忆化搜索</li></ol><ul><li>假设将arr变为非负数组，前面进行加减不影响</li><li>非负arr累加和为sum，target &gt; sum 则不存在</li><li>target与sum的奇偶性不一致，不存在</li><li>取正集合和为P，取负集合和为N，P - N = target, p + N = sum, ==&gt; p = (sum + target) / 2,转化为取正集合和为P的组合有多少个</li><li>二维动态规划的空间压缩</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays2</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  n : arr) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || ((sum &amp; <span class="number">1</span>) ^ (target &amp; <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subset</span>(arr, (sum + target) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subset</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= n; i--) &#123;</span><br><span class="line">            dp[i] += dp[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="04-总体最多收入分配"><a href="#04-总体最多收入分配" class="headerlink" title="04 总体最多收入分配"></a>04 总体最多收入分配</h2><p>题目：</p><p>现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为<code>income[i][0]</code>，去B可得收入为<code>income[i][1]</code>, 返回能使所有司机总收入最高的方案是多少钱?</p><p>解析：</p><ol><li>递归暴力 O(N^2)</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  income -&gt; N * 2 的矩阵 N是偶数！</span></span><br><span class="line"><span class="comment">// 0 [9, 13]</span></span><br><span class="line"><span class="comment">// 1 [45,60]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMoney1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = income.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || (N &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//N为奇数返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>; <span class="comment">//M = N / 2, 去A地区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(income, <span class="number">0</span>, M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.....所有的司机，往A和B区域分配！</span></span><br><span class="line"><span class="comment">// A区域还有rest个名额!</span></span><br><span class="line"><span class="comment">// 返回把index...司机，分配完，并且最终A和B区域同样多的情况下，index...这些司机，整体收入最大是多少！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == income.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 还剩下司机！</span></span><br><span class="line">    <span class="keyword">if</span> (income.<span class="built_in">size</span>() - index == rest) &#123; <span class="comment">//B区域满了</span></span><br><span class="line">        <span class="keyword">return</span> income[index][<span class="number">0</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;<span class="comment">//A区域满了</span></span><br><span class="line">        <span class="keyword">return</span> income[index][<span class="number">1</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前司机，可以去A，或者去B</span></span><br><span class="line">    <span class="keyword">int</span> p1 = income[index][<span class="number">0</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> p2 = income[index][<span class="number">1</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li>动态规划</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMoney2</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = income.length;</span><br><span class="line">    <span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(M + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N - i == j) &#123;</span><br><span class="line">                dp[i][j] = income[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = income[i][<span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = income[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> p2 = income[i][<span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(p1, p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="05-含有SetAll功能的哈希表"><a href="#05-含有SetAll功能的哈希表" class="headerlink" title="05 含有SetAll功能的哈希表"></a>05 含有SetAll功能的哈希表</h2><p>题目：</p><p>设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)</p><p>setAll(num), 将所有的key对应的value值改为num</p><p>解析：</p><p>加入时间戳，记录加入的时间，key -&gt; int, value -&gt; (int, long)</p><p>setAlltime默认无穷大，调用setAll(num)后，时间戳早于当前值的进行更新，setAlltime更新为当前时间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line"><span class="keyword">public</span> V value;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MyValue</span><span class="params">(V v, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">value = v;</span><br><span class="line">time = t;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="keyword">private</span> MyValue&lt;V&gt; setAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(<span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAll</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.get(key).time &gt; setAll.time) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key).value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> setAll.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="06-最长无重复字串的子串长度"><a href="#06-最长无重复字串的子串长度" class="headerlink" title="06 最长无重复字串的子串长度"></a>06 最长无重复字串的子串长度</h2><p>题目：</p><p>求一个字符串中，最长无重复字符子串长度</p><p>解析：</p><p>子串子数组问题，想每个<code>i</code>结尾时，满足条件的情况，无重复的子串长度<code>dp[i]</code></p><p>从第<code>i</code>个位置向前推影响因素：某个位置与<code>i</code>位置的字符相同，或者i-1位置向左推的距离</p><p>可以滑动窗口</p><p>也可动态规划：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//acsii取值范围0~255</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">map</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="comment">//map存放上次出现的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        map[i] = <span class="number">-1</span>; <span class="comment">//初始默认出现在-1位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    map[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;<span class="comment">//上一个位置，向左推了多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre = <span class="built_in">min</span>(i - map[s[i]], pre + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pre);</span><br><span class="line">        map[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="07-差值为k的数对的最大组数"><a href="#07-差值为k的数对的最大组数" class="headerlink" title="07 差值为k的数对的最大组数"></a>07 差值为k的数对的最大组数</h2><p>题目描述：</p><p>给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛<br>一局比赛只有两个人，返回最多可以同时有多少场比赛</p><p>解析：</p><p>数组arr排序后，滑动窗口求解+贪心</p><p>暴力解：全排列寻找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPairNUm1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(arr, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123;<span class="comment">//全排列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = index; r &lt; arr.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[index], arr[r]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, k));</span><br><span class="line">            <span class="built_in">swap</span>(arr[index], arr[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(N*logN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPairNum2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());<span class="comment">//排序，满足单调性，先满足小值的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;<span class="comment">//双指针窗口</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">usedR</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (usedR[L]) &#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">            R++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不止一个数，而且都没用过！</span></span><br><span class="line">            <span class="keyword">int</span> dis = arr[R] - arr[L];</span><br><span class="line">            <span class="keyword">if</span> (dis == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                usedR[R++] = <span class="literal">true</span>;</span><br><span class="line">                L++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis &lt; k) &#123;</span><br><span class="line">                R++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="08-最多载两个人的船同时过河问题"><a href="#08-最多载两个人的船同时过河问题" class="headerlink" title="08 最多载两个人的船同时过河问题"></a>08 最多载两个人的船同时过河问题</h2><p>题目描述：</p><p>给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重<br>想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数<br>Leetcode链接 : <a href="https://leetcode.com/problems/boats-to-save-people/">https://leetcode.com/problems/boats-to-save-people/</a></p><p>解析：</p><p>先排序，如果arr中某个值大于limit，返回无穷大不合题意。</p><p>寻找&gt;=limit/2的右边界，边界右侧的值大于limit/2，两个指针指向边界左侧和右侧</p><p>相加和大于limit，左指针左移</p><p>一侧先耗尽，左侧未满足条件的数量除以2（向上取整），加上满足条件的数量，加上右侧剩余未满足条件的数量</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (arr[N<span class="number">-1</span>] &gt; limit) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lessR = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= limit / <span class="number">2</span>) &#123;</span><br><span class="line">            lessR = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lessR == <span class="number">-1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> L = lessR, R = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> noUsed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> solved = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) &#123;</span><br><span class="line">            R++;</span><br><span class="line">            solved++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (solved == <span class="number">0</span>) &#123;</span><br><span class="line">            noUsed++;</span><br><span class="line">            L--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = <span class="built_in">max</span>(<span class="number">-1</span>, L - solved);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> used = all - noUsed;</span><br><span class="line">    <span class="keyword">int</span> moreUnsolved = (N - all) - used;</span><br><span class="line">    <span class="keyword">return</span> used + ((noUsed + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + moreUnsolved;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：首尾双指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        sum = L == R ? arr[L] : arr[L] + arr[R];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; limit) &#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L++;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="09-子数组的最大累加和"><a href="#09-子数组的最大累加和" class="headerlink" title="09 子数组的最大累加和"></a>09 子数组的最大累加和</h2><p>题目描述：</p><p>返回一个数组arr中，子数组最大累加和</p><p>解析：</p><p>子数组以arr[i]结尾的最大累加和，求其最大值</p><p><code>dp[i] = max(dp[i - 1] + arr[i], arr[i])</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上一步，dp的值</span></span><br><span class="line">    <span class="comment">// dp[0]</span></span><br><span class="line">    <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre + arr[i], arr[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(pre, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="10-分糖果问题"><a href="#10-分糖果问题" class="headerlink" title="10 分糖果问题"></a>10 分糖果问题</h2><p>题目描述：</p><p>老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，返回老师至少需要准备多少颗糖果<br>进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果</p><p>解析：<br>从左遍历，坡度值加一，从右遍历，坡度值加一，二者取最大值，以坡度大的为准</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">max</span>(left[i], right[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>补充规则：相邻孩子分数一样则分的糖果数一样</p><p>解析：比左边大++，和左边相等不变，比左边小置1，右侧遍历同理</p><h2 id="11-字符串交错组成问题"><a href="#11-字符串交错组成问题" class="headerlink" title="11 字符串交错组成问题"></a>11 字符串交错组成问题</h2><p>题目描述：</p><p>给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的</p><p>Leetcode题目：<a href="https://leetcode.com/problems/interleaving-string/">https://leetcode.com/problems/interleaving-string/</a></p><p>解析：</p><p>长度s1.size() + s2.size() != s3.size()，不成立</p><p>动态规划，<code>dp[i][j]</code>长度为i的s1与长度为j的s2，能否组成长度i + j的s3</p><p>s1长度i，下标0 ~ i-1;</p><p>s2长度j，下标0 ~ j-1;</p><p>s3长度i + j, 下标0 ~ i + j - 1</p><p>每个位置最后一个字符可能来着s1或s2</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterLeave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (s3.<span class="built_in">size</span>() != m + n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i - <span class="number">1</span>] != s3[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2[j - <span class="number">1</span>] != s3[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="12-求相等子树的数量"><a href="#12-求相等子树的数量" class="headerlink" title="12 求相等子树的数量"></a>12 求相等子树的数量</h2><p>题目描述：</p><p>如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树</p><p>解析：<br>递归，head左子树的相等子树+head右子树的相等子树+head是否为相等子树</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 时间复杂度O(N * logN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sameNumber1</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sameNumber1</span>(head -&gt; left) + <span class="built_in">sameNumber1</span>(head -&gt; right) + (<span class="built_in">same</span>(head-&gt;left, head -&gt; right) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(TreeNode* h1, TreeNode* h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span> ^ h2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span> &amp;&amp; h2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//两个都不为空</span></span><br><span class="line">    <span class="keyword">return</span> h1 -&gt; val == h2 -&gt; val &amp;&amp; <span class="built_in">same</span>(h1 -&gt; left, h2 -&gt; left) &amp;&amp; <span class="built_in">same</span>(h1 -&gt; right, h2 -&gt; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题随笔01</title>
      <link href="/posts/bba1d2c5/"/>
      <url>/posts/bba1d2c5/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="01-复杂度、排序与二分法"><a href="#01-复杂度、排序与二分法" class="headerlink" title="01 复杂度、排序与二分法"></a>01 复杂度、排序与二分法</h1><h2 id="十大排序"><a href="#十大排序" class="headerlink" title="十大排序"></a>十大排序</h2><p>1、稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 仍然在 b 的前面，则为稳定排序。</p><p>2、非稳定排序：如果 a 原本在 b 的前面，且 a == b，排序之后 a 可能不在 b 的前面，则为非稳定排序。</p><p>3、原地排序：原地排序就是指在排序过程中不申请多余的存储空间，只利用原来存储待排数据的存储空间进行比较和交换的数据排序。</p><p>4、非原地排序：需要利用额外的数组来辅助排序。</p><p>5、时间复杂度：一个算法执行所消耗的时间。</p><p>6、空间复杂度：运行完一个算法所需的内存大小</p><h3 id="十大排序一图总览"><a href="#十大排序一图总览" class="headerlink" title="十大排序一图总览"></a>十大排序一图总览</h3><img src="/posts/bba1d2c5/202205072325169.png" alt="img" style="zoom:80%;"><h3 id="稳定排序"><a href="#稳定排序" class="headerlink" title="稳定排序"></a>稳定排序</h3><ul><li>冒泡排序（bubble sort） — O(n2) </li><li>插入排序 （insertion sort）— O(n2) </li><li>归并排序 （merge sort）— O(n log n)</li></ul><h3 id="非稳定性排序"><a href="#非稳定性排序" class="headerlink" title="非稳定性排序"></a>非稳定性排序</h3><ul><li>选择排序 （selection sort）— O(n2) </li><li>希尔排序 （shell sort）— O(n log n) </li><li>堆排序 （heapsort）— O(n log n) </li><li>快速排序 （quicksort）— O(n log n)</li></ul><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数组索引0 ~ N-1，找到最小值，放到0位置上；</p><p>依次向后遍历，在i ~ N-1中，找到最小值，放到i位置上。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//在i ~ n-1上找到最小值的下标</span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIdex] ? j : minIdex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>0-1，1-2，2-3…依次两两交换，大的交换到后边，每一轮的最大值到最后。</p><p>[3 2 5 1 6 4] ==&gt; [2 3 1 5 4 6] ==&gt; [2 1 3 4 5 6] ==&gt; [1 2 3 4 5 6]</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 0 ~ N-1</span></span><br><span class="line">    <span class="comment">// 0 ~ N-2</span></span><br><span class="line">    <span class="comment">// 0 ~ N-3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.<span class="built_in">size</span>() - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>0 ~ 0，0 ~ 1 , 0 ~ 2, … 0 ~ n -1，依次变得有序。第i轮，若第i个数小于前一个数，二者交换，直到i大于等于前一个数。</p><p>类似与摸牌后，每次进行插入排序。</p><p>初始数据状况会影响时间复杂度。最差O(n ^ 2)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//0~0 有序的</span></span><br><span class="line">    <span class="comment">//0~i 变为有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>经常在有序数组上，使用二分搜索，但是有序不是必要条件。</p><p><strong>只要能正确构建左右两侧的逻辑，就可以使用二分。</strong></p><ul><li>一个有序数组，找某个数是否存在</li><li>一个有序数组，找 &gt;= 某个数的最左侧位置</li><li>一个有序数组，找 &lt;= 某个数的最右侧位置</li><li>局部最小值问题</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sortArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortArr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = sortArr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//L...R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123; <span class="comment">//L..R 至少两个数</span></span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">//mid = (L + R) / 2</span></span><br><span class="line">        <span class="keyword">if</span> (sortArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>搜索&gt;= 某个数的最左侧位置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;<span class="comment">//记录最左的对号</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">//至少一个数的时候</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>无序数组，任意两个相邻的数不相等，返回任意一个局部最小值（比左右相邻的数小）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[n - <span class="number">1</span>] &lt; arr[n - <span class="number">2</span>]) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="02-异或运算"><a href="#02-异或运算" class="headerlink" title="02 异或运算"></a>02 异或运算</h1><p>异或运算：相同为0，不同为1，二进制<strong>无进位相加</strong>（不进位）</p><p>同或运算：相同为1，不同为0</p><p>异或运算 (^) 性质：</p><ul><li>0 ^ N = N</li><li>N ^ N = 0</li><li>a ^ b = b ^ a （交换律）</li><li>(a ^ b) ^ c = a ^ (b ^ c) （结合律）</li><li>a ^ b = c ==&gt; a = c ^ b ==&gt; b = c ^ a</li></ul><h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>不使用额外空间变量交换两个数</p><p>利用异或运算的性质，注意：<strong>交换的两个数不能是同一块内存空间</strong>，否则二者变为0.</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>一个数组中有<strong>一个数出现了奇数次</strong>，其他数出现了偶数次，找到并打印这个数（O(1) 额外空间复杂度完成）</p><p>解析：设置变量eor，顺序遍历异或所有的值，返回最后的eor</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; eor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p>把一个int类型的数，提取出最右侧的1</p><p>a = 0xb 00110110 ==&gt; ans = 0xb 00000010</p><p>解析：<strong>a &amp; (-a)</strong> 等价于 <strong>a &amp; (~a + 1)</strong></p><h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><p>一个数组中有<strong>两种数出现了奇数次</strong>，其他数出现了偶数次，找到并打印这两种数（O(1) 额外空间复杂度完成）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">//提取出最右的1, eor != 0</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">//eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// arr[1] = 11100010</span></span><br><span class="line">        <span class="comment">//rightOne= 00000010</span></span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            onlyOne ^= arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; onlyOne &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (eor ^ onlyOne) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h2><p>一个数组中<strong>只有一种数出现K次</strong>，其他数都出现了M次，已知M &gt; 1，K &lt; M，找到出现了K次的数<br>要求额外空间复杂度O(1)，时间复杂度O(N)</p><p>解析：设置一个int数组长度为32，累加每个数的二进制位置的1的数量。每一位是否为M的整数倍判断出现K次的数的二进制最后一个1出现的位置</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onlyKtimes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//help[i]位置的1出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((num &gt;&gt; i) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            help[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*返回只出现k次的数，如果不是k次，返回-1；</span></span><br><span class="line"><span class="comment">        if (help[i] % m == 0) continue;</span></span><br><span class="line"><span class="comment">        if (help[i] % m == k) &#123;</span></span><br><span class="line"><span class="comment">        ans |= 1 &lt;&lt; i;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">        return -1;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (help[i] % m != <span class="number">0</span>) &#123; <span class="comment">//在第i位上有1</span></span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="03-归并排序"><a href="#03-归并排序" class="headerlink" title="03 归并排序"></a>03 归并排序</h1><p>左半部分有序 + 右半部分有序 + merge </p><p>merge过程双指针，顺序copy结果到新有序数组</p><p>总体时间复杂度为 O(n * log(N))</p><p><strong>递归写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr[L...R]排有序</span></span><br><span class="line"><span class="comment">// T(N) = 2 * T(N / 2) + O(N)</span></span><br><span class="line"><span class="comment">// O(N * logN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">process</span>(arr, L, mid);</span><br><span class="line">    <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">merge</span>(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(R - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>迭代写法：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 步长</span></span><br><span class="line">    <span class="keyword">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">// log N</span></span><br><span class="line">        <span class="comment">// 当前左组的，第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mergeSize &gt;= N - L) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = <span class="built_in">min</span>(mergeSize + M, N - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">            L = R + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目1：小和问题"><a href="#题目1：小和问题" class="headerlink" title="题目1：小和问题"></a>题目1：小和问题</h2><p>在一个数组中，一个数左边比它小的数的总和，叫该数的小和<br>所有数的小和累加起来，叫数组小和</p><p>给定一个数组，求最小和，到第i个数，若第j （j &lt; i）个数的值小于第i个数，累加上第j个数。</p><p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p><p>[6 3 2 1 6 7] ==&gt; i = 0, sum = 0; i = 1, sum = 0; i = 2, sum = 0; i = 3, sum = 0; i = 4, sum = 4, sum = 0;</p><p>i = 5, sum = 3 +2 + 1 = 6; i = 6, sum = 18; 返回 res = 6 + 18 = 24;</p><p>每个位置，之前比自己小的数累加起来，各个位置累加和再求和。</p><p>暴力法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comparator</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res += arr[j] &lt; arr[i] ? arr[j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>归并排序法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求小和返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的小和，累加</span></span><br><span class="line"><span class="comment">// 左 排序   merge</span></span><br><span class="line"><span class="comment">// 右 排序  merge</span></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="built_in">process</span>(arr, l, mid) </span><br><span class="line">        + </span><br><span class="line">        <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) </span><br><span class="line">        + </span><br><span class="line">        <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目2：逆序对总数"><a href="#题目2：逆序对总数" class="headerlink" title="题目2：逆序对总数"></a>题目2：逆序对总数</h2><p>在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为逆序对<br>给定一个数组arr，求数组的逆序对总数量</p><p>[3 1 0 4 3 1] ==&gt; 6</p><p>每一个数右边有多少个数比他小，从右向左merge</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverPairNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求逆序对数量返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的逆序对数量，累加，返回</span></span><br><span class="line"><span class="comment">// 左 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="comment">// 右 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//l &lt; r</span></span><br><span class="line"><span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">process</span>(arr, l, mid) + <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = help.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = m, p2 = r;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L &amp;&amp; p2 &gt; m) &#123;</span><br><span class="line">        res += arr[p1] &gt; arr[p2] ? (p2 - m) : <span class="number">0</span>;</span><br><span class="line">        help[i--] = arr[p1] &gt; arr[p2] ? arr[p1--] : arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L) &#123;</span><br><span class="line">        help[i--] = arr[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &gt; m) &#123;</span><br><span class="line">        help[i--] = arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="题目3：Bigger-than-right-twice"><a href="#题目3：Bigger-than-right-twice" class="headerlink" title="题目3：Bigger than right twice"></a>题目3：Bigger than right twice</h2><p>在一个数组中，对于任何一个数num，求有多少个(后面的数*2)依然&lt;num，返回总个数<br>比如：[3,1,7,0,2]<br>3的后面有：1，0<br>1的后面有：0<br>7的后面有：0，2<br>0的后面没有<br>2的后面没有<br>所以总共有5个</p><p>解析：左组有序+有组有序+merge，双指针从左向右遍历不回退，记录个数</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//l &lt; r</span></span><br><span class="line"><span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">process</span>(arr, l, mid) + <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [L....M] [M+1....R]</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目前囊括进来的数，是从[M+1, windowR)</span></span><br><span class="line">    <span class="keyword">int</span> windowR = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (windowR &lt;= r &amp;&amp; (<span class="keyword">long</span>) arr[i] &gt; (<span class="keyword">long</span>) arr[windowR] * <span class="number">2</span>) &#123;</span><br><span class="line">            windowR++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += windowR - m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= L) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="04-快速排序"><a href="#04-快速排序" class="headerlink" title="04 快速排序"></a>04 快速排序</h1><p>快速排序是基于分治策略的，其算法思想如下。<br>（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。<br>（2）治理：对两个子序列进行快速排序。</p><p>（3）合并：将排好序的两个子序列合并在一起，得到原问题的解。</p><p>代码实现：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//划分函数，对原序列进行分解，将其分解为两个子序列，以基准元素pivot为界，</span></span><br><span class="line"><span class="comment">//左侧子序列都比pivot小，右侧子序列都比pivot大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high, pivot = arr[low];<span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) j--;<span class="comment">//向左扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;<span class="comment">//向右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j--]);<span class="comment">//交换arr[i]和arr[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[low], arr[i - <span class="number">1</span>]);<span class="comment">//交换arr[i - 1]和arr[low]，并返回基准元素位置i - 1</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[low]);<span class="comment">//交换arr[i]和arr[low]，并返回基准元素位置i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序函数。首先对原序列划分，得到划分的中间位置mid；然后以中间位置为界，</span></span><br><span class="line"><span class="comment">//分别对左半部分(low,mid-1)执行快速排序，对右半部分(mid+1,high)执行快速排序。</span></span><br><span class="line"><span class="comment">//递归结束的条件是low≥high</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(arr, low, high);<span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">qsort</span>(arr, low, p - <span class="number">1</span>);<span class="comment">//左区间递归快排</span></span><br><span class="line">        <span class="built_in">qsort</span>(arr, p + <span class="number">1</span>, high);<span class="comment">//右区间递归快排</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">qsort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最好情况时间复杂度为O(nlogn)</p><p>最坏情况下的时间复杂度为O(n^2)</p><p>平均情况下的空间复杂度为O(nlogn)</p><h1 id="05-希尔排序"><a href="#05-希尔排序" class="headerlink" title="05 希尔排序"></a>05 希尔排序</h1><p>希尔排序：插入排序的改进版，实现简单，对于中等规模数据的性能表现还不错。对较大规模并且无序的数据也非常有效率</p><p>无论是插入排序还是冒泡排序，如果数组的最大值刚好是在第一位，要将它挪到正确的位置就需要n - 1次移动。也就是说，原数组的一个元素如果距离它正确的位置很远的话，则需要与相邻元素交换很多次才能到达正确的位置，这样是相对比较花时间了。</p><p>希尔排序的思想是采用插入排序的方法，先让数组中任意间隔为h的元素有序，刚开始h的大小可以是h = n / 2，接着让 h = n / 4，让h一直缩小，当h = 1 时，也就是此时数组中任意间隔为1的元素有序，此时的数组就是有序的了。</p><p>把较大的数据集合分割成若干个小组（逻辑上分组），然后对每一个小组分别进行插入排序，此时，插入排序所作用的数据量比较小（每一个小组），插入的效率比较高。</p><p>希尔排序的复杂度和增量序列是相关的</p><p>希尔排序不稳定，在插入的时候是跳跃性插入的，有可能破坏稳定性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将nums[i]插入到所在分组的正确位置上， nums[i]所在分组为：</span></span><br><span class="line"><span class="comment">// …nums[i-2*gap], nums[i-gap], nums[i], nums[i+gap], nums[i+2*gap]…</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSortCore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> gap, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> inserted = nums[i];</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    <span class="comment">// 插入的时候按组进行插入（组内元素两两相隔gap）</span></span><br><span class="line">    <span class="keyword">for</span> (j = i - gap; j&gt;= <span class="number">0</span> &amp;&amp; inserted &lt; nums[j]; j -= gap) &#123;</span><br><span class="line">        nums[j + gap] = nums[j];</span><br><span class="line">    &#125;</span><br><span class="line">    nums[j + gap] = inserted;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shellSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 进行分组，最开始的时候，gap为数组长度一半</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> gap = len / <span class="number">2</span>; gap &gt; <span class="number">0</span>; gap /= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 对各个分组进行插入分组</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; len; i++) &#123;</span><br><span class="line">            <span class="comment">// 将nums[i]插入到所在分组正确的位置上</span></span><br><span class="line">            <span class="built_in">shellSortCore</span>(nums, gap, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印希尔排序后的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> a : nums) &#123;</span><br><span class="line">cout &lt;&lt; a &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="06-堆排序"><a href="#06-堆排序" class="headerlink" title="06 堆排序"></a>06 堆排序</h1><p>大顶堆：父节点的值大于子节点，堆排序中为升序排列</p><p>小顶堆：父节点的值小于子节点，堆排序中为降序排列</p><p>先把数组构造成一个大顶堆，然后把堆顶（数组最大值，数组的第一个元素）和数组的最后一个元素交换，把最大值放到了最后边。数组长度n-1，再进行构造堆，把剩余的第二大值放到堆顶，输出堆顶（放到数组最后）。依此类推，直到数组排序完成。</p><p>堆符合两个特点：</p><ul><li>是一个完全二叉树</li><li>所有父节点的值都大于（或小于）子节点的值</li></ul><p>平均时间复杂度：O(nlogn)</p><p>注：堆排序是<strong>不稳定</strong>的排序算法，是一种树形选择排序。恰好利用树形的特点保存了部分前面的比较结果，因此可以减少比较次数。不适合记录较少的排序。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对有一定顺序的堆，当前第i个结点取根左右的最大值（这个操作称heapfiy）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = i * <span class="number">2</span> + <span class="number">1</span>, r = i * <span class="number">2</span> + <span class="number">2</span>;<span class="comment">// 左右节点索引, left=2*i+1  right=2*i+2  </span></span><br><span class="line">    <span class="keyword">int</span> maxid = i;</span><br><span class="line">    <span class="keyword">if</span> (l &lt; n &amp;&amp; nums[l] &gt; nums[maxid]) &#123;</span><br><span class="line">        maxid = l;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r &lt; n &amp;&amp; nums[r] &gt; nums[maxid]) &#123;</span><br><span class="line">        maxid = r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (maxid != i) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[maxid]);</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, maxid);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立大根堆，从树的倒数第二层第一个结点开始，对每个结点进行heapify操作，然后向上走</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify_build</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = (n - <span class="number">2</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = temp; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">heapify</span>(nums, n, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 打印当前数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">cout &lt;&lt; nums[i] &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 建立大根堆之后，每次交换最后一个结点和根节点（最大值），</span></span><br><span class="line"><span class="comment">// 对交换后的根节点继续进行heapify（此时堆的最后一位是最大值，因此不用管他，n变为n-1）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify_sort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">heapify_build</span>(nums, n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(nums.<span class="built_in">front</span>(), nums[n - i - <span class="number">1</span>]);</span><br><span class="line"><span class="built_in">heapify</span>(nums, n - i - <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>换一种写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 辅助函数，构造大根堆</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">adjust</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxid = index;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span> * index + <span class="number">1</span>, right = <span class="number">2</span> * index + <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 计算第i个节点的左右子节点的下标   left=2*i+1  right=2*i+2  parent=(i-1)/2</span></span><br><span class="line">    <span class="keyword">if</span> (left &lt; len &amp;&amp; arr[left] &gt; arr[maxid]) maxid = left;</span><br><span class="line">    <span class="keyword">if</span> (right &lt; len &amp;&amp; arr[right] &gt; arr[maxid]) maxid = right;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (maxid != index) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[maxid], arr[index]);</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, maxid); <span class="comment">// 递归调整其他不满足堆性质的部分</span></span><br><span class="line">    &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSortCore</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 初次构建堆，i从第一个非叶子节点开始进行堆调整，i节点的父节点为parent=(i-1)/2，即(len-1-1)/2</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len / <span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">adjust</span>(arr, len, i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = len - <span class="number">1</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[<span class="number">0</span>], arr[i]);<span class="comment">// 将当前最大的放置到数组末尾，将未完成排序的部分继续进行堆排序</span></span><br><span class="line">        <span class="built_in">adjust</span>(arr, i, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">heapSortCore</span>(arr, arr.<span class="built_in">size</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="07-计数排序"><a href="#07-计数排序" class="headerlink" title="07 计数排序"></a>07 计数排序</h1><p>统计小于等于该元素值的元素的个数i，于是该元素就放在目标数组的索引i位（i≥0）。</p><ul><li>计数排序基于一个假设，待排序数列的所有数均为整数，且出现在（0，k）的区间之内。</li><li>如果 k（待排数组的最大值） 过大则会引起较大的空间复杂度，一般是用来排序 0 到 100 之间的数字的最好的算法，但是它不适合按字母顺序排序人名。</li><li>计数排序不是比较排序，排序的速度快于任何比较排序算法。</li></ul><p>算法思想：</p><ul><li>找出待排序的数组中最大和最小的元素；</li><li>统计数组中每个值为i的元素出现的次数，存入数组C的第i项；</li><li>对所有的计数累加（从C中的第一个元素开始，每一项和前一项相加）；</li><li>向填充目标数组：将每个元素i放在新数组的第C[i]项，每放一个元素就将C[i]减去 1。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 计数排序, 输入原始数组与目标数组（初始化与原数组相同）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">countSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; vecRaw, vector&lt;<span class="keyword">int</span>&gt;&amp; vecObj)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 确保待排序容器非空</span></span><br><span class="line">    <span class="keyword">if</span>(vecRaw.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使用 vecRaw 的最大值 + 1 作为计数容器 countVec 的大小</span></span><br><span class="line">    <span class="keyword">int</span> vecCountLen = (*<span class="built_in">max_element</span>(vecRaw.<span class="built_in">begin</span>(), vecRaw.<span class="built_in">end</span>())) + <span class="number">1</span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecCount</span><span class="params">(vecCountLen, <span class="number">0</span>)</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 统计每个键值出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecRaw.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        vecCount[vecRaw[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 后面的键值出现的位置为前面所有键值出现的次数之和</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; vecCountLen; i++) &#123;</span><br><span class="line">        vecCount[i] += vecCount[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 将键值放到目标位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = vecRaw.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123; <span class="comment">// 此处逆序是为了保持相同键值的稳定性</span></span><br><span class="line">        vecObj[--vecCount[vecRaw[i]]] = vecRaw[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; vecRaw = &#123; <span class="number">0</span>,<span class="number">5</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">6</span>,<span class="number">9</span>,<span class="number">2</span>,<span class="number">1</span> &#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vecObj</span><span class="params">(vecRaw.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">countSort</span>(vecRaw, vecObj);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; vecObj.<span class="built_in">size</span>(); ++i)</span><br><span class="line">cout &lt;&lt; vecObj[i] &lt;&lt; <span class="string">&quot;  &quot;</span>;</span><br><span class="line">cout &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="08-桶排序"><a href="#08-桶排序" class="headerlink" title="08 桶排序"></a>08 桶排序</h1><p>将值为i的元素放入i号桶，最后依次把桶里的元素倒出来。是计数排序的变种，利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。把计数排序中相邻的m个”小桶”放到一个”大桶”中，在分完桶后，对每个桶进行排序（一般用快排），然后合并成最后的结果。</p><p>算法思想：</p><ul><li>设置一个定量的数组当作空桶子。</li><li>寻访序列，并且把项目一个一个放到对应的桶子去。</li><li>对每个不是空的桶子进行排序。</li><li>从不是空的桶子里把项目再放回原来的序列中。</li></ul><p>平均时间复杂度：O(n + k)</p><p>空间复杂度：O(n * k)</p><p>稳定性：稳定</p><p>桶排序最好情况下使用线性时间O(n)，桶排序的时间复杂度，取决与对各个桶之间数据进行排序的时间复杂度，因为其它部分的时间复杂度都为O(n)。很显然，桶划分的越小，各个桶之间的数据越少，排序所用的时间也会越少。但相应的空间消耗就会增大。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 桶排序，输入原始数组和桶的数量（默认可为5）</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bucketSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> bucketSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 确定数组的最大值与最小值</span></span><br><span class="line">    <span class="keyword">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> minVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt; minVal) &#123;</span><br><span class="line">            minVal = arr[i];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[i] &gt; maxVal) &#123;</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置每个桶的容量大小</span></span><br><span class="line">    <span class="keyword">int</span> bucketCount = (maxVal - minVal) / bucketSize + <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buckets</span>(bucketCount);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 利用映射函数将数据分配到各个桶中</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> index = (arr[i] - minVal) / bucketSize; <span class="comment">// 第index个桶</span></span><br><span class="line">        buckets[index].<span class="built_in">push_back</span>(arr[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> arrIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> bucket : buckets) &#123;</span><br><span class="line">        <span class="keyword">if</span> (bucket.<span class="built_in">size</span>() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 对每个桶进行排序，这里使用了插入排序</span></span><br><span class="line">        <span class="built_in">insertSort</span>(bucket);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> value : bucket) &#123;</span><br><span class="line">            arr[arrIndex++] = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//0~0 有序的</span></span><br><span class="line">    <span class="comment">//0~i 变为有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="09-基数排序"><a href="#09-基数排序" class="headerlink" title="09 基数排序"></a>09 基数排序</h1><p>一种多关键字的排序算法，可用桶排序实现。</p><p>算法思想：</p><ul><li><p>取得数组中的最大数，并取得位数；</p></li><li><p>arr为原始数组，从最低位开始取每个位组成radix数组；</p></li><li><p>对radix进行计数排序（利用计数排序适用于小范围数的特点）</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//辅助函数，求数据的最大位数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxbit</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxVal = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxVal &lt; arr[i]) &#123;</span><br><span class="line">            maxVal = arr[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="number">1</span>;<span class="comment">// 位数</span></span><br><span class="line">    <span class="keyword">int</span> p = <span class="number">10</span>;<span class="comment">//尾数0-9，10进制</span></span><br><span class="line">    <span class="keyword">while</span> (maxVal &gt;= p) &#123;</span><br><span class="line">        maxVal /= <span class="number">10</span>;</span><br><span class="line">        d++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 基数排序 </span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">radixSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> d = <span class="built_in">maxbit</span>(arr, n);</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">tmp</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">count</span><span class="params">(<span class="number">10</span>, <span class="number">0</span>)</span></span>;<span class="comment">// 计数器</span></span><br><span class="line">    <span class="keyword">int</span> i, j, k;</span><br><span class="line">    <span class="keyword">int</span> radix = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= d; i++) &#123;<span class="comment">// 进行d次排序</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            count[j] = <span class="number">0</span>;<span class="comment">// 每次分配前清空计数器</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (arr[j] / radix) % <span class="number">10</span>;<span class="comment">// 统计每个桶中的记录数     </span></span><br><span class="line">            count[k]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; <span class="number">10</span>; j++) &#123;</span><br><span class="line">            count[j] = count[j - <span class="number">1</span>] + count[j];<span class="comment">// 将tmp中的位置依次分配给每个桶</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> k = (arr[j] / radix) % <span class="number">10</span>;</span><br><span class="line">            tmp[count[k] - <span class="number">1</span>] = arr[j];</span><br><span class="line">            count[k]--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;<span class="comment">// 将临时数组的内容复制到arr中</span></span><br><span class="line">            arr[j] = tmp[j];</span><br><span class="line">        &#125;</span><br><span class="line">        radix *= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>刷题笔记：数模运算</title>
      <link href="/posts/bbb48ce1/"/>
      <url>/posts/bbb48ce1/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h1><p>素数：只能被1或其本身整除。</p><p>实现一个函数，输入一个整数<code>n</code>，返回<code>[2, n]</code>中的素数个数</p><p>暴力解法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i)) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断整数n是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暴力解法时间复杂度为O(n^2)，不够高效。</p><p>改进：</p><ul><li><code>i</code> 只需遍历到<code>sqrt(n)</code>；</li><li>筛数法，2，3…的所有倍数都不是素数，但存在计算冗余；</li><li>内层<code>for</code>循环的<code>j</code>从<code>i</code>的平方开始遍历，不是从<code>2 * i </code>开始.</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j++) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h1><h2 id="位运算n-amp-n-1-的妙用"><a href="#位运算n-amp-n-1-的妙用" class="headerlink" title="位运算n &amp; (n-1)的妙用"></a>位运算<code>n &amp; (n-1)</code>的妙用</h2><p><code>n&amp;(n-1)</code>作用：将<code>n</code>的二进制表示中的<strong>最低位为<code>1</code>的改为<code>0</code></strong></p><p><code>n = 10100</code>(二进制），则<code>(n-1) = 10011</code>  –&gt; <code>n&amp;(n-1) = 10000</code></p><ul><li><p>判断一个数是否是2的n次幂<br><code>n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0 )</code></p><p>解释<code>((n &amp; (n-1)) == 0)：</code></p><p>如果<code>A &amp; B == 0</code>，表示A与B的二进制形式<strong>没有在同一个位置都为1</strong>的时候。</p></li><li><p>求某一个数的二进制表示中1的个数</p><p><code>while (n &gt; 0 ) &#123;    count ++;    n &amp;= (n-1); &#125;</code></p></li></ul><h2 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h2><p>整数<code>a</code>，数组<code>b</code>，返回幂运算<code>a ^ b</code>的结果，与<code>1337</code>取模（mod，余数）运算后的结果。</p><p>例如输入<code>a = 2, b = [1, 2]</code>，返回<code>2 ^ 12</code> 和<code>1337</code>取模的结果，<code>4096 % 1337 = 85</code></p><ul><li><p>处理指数数组</p><p>注：b为指数数组，可以采用递归求幂，<code>superPow(a, [1, 2, 5, 6])  ==&gt;  superPow(a, [1, 2, 5])</code></p></li><li><p>处理模运算</p><p><code>(a * b) % base = (a % k) * (b % k) % k</code></p><p><strong>对乘法的结果求模，等价于先对每个因子求模，然后对因子相乘的结果再求模。</strong></p></li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line">    <span class="comment">//先对a求模，然后每次多对乘法结果res求模</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res *= a;</span><br><span class="line">        res %= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vecter&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = b.<span class="built_in">back</span>();</span><br><span class="line">    b.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> part1 = <span class="built_in">mypow</span>(a, last);</span><br><span class="line">    <span class="keyword">int</span> part2 = <span class="built_in">mypow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (part1 * part2) % base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>高效求幂</p><p>幂运算的递归关系式：</p><p><code>a ^ b = a * a ^ (b - 1) </code>, b为奇数</p><p><code>a ^ b = (a ^ (b / 2)) ^ 2 </code>, b为偶数</p><p>加上对<code>base</code>求模运算：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (a * <span class="built_in">mypow</span>(a, k - <span class="number">1</span>)) % base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sub = <span class="built_in">mypow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (sub * sub) % base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="连续N个数的和"><a href="#连续N个数的和" class="headerlink" title="连续N个数的和"></a>连续N个数的和</h2><p>求 1 2 … n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p><p>示例：</p><ul><li>输入：n = 3 输出：6</li><li>输入：n = 9 输出：45</li></ul><p>限制：1 &lt;= n &lt;= 1000</p><p><strong>解析：</strong></p><p>因为不能使用公式直接计算（公式中包含乘除法），所以考虑使用递归进行求解，又不能使用if等判断返回条件，采用<code>A &amp;&amp; B </code>的特性进行判断。</p><ul><li><p>如果A为true，返回B的布尔值（继续往下执行）</p></li><li><p>如果A为false，直接返回false（相当于短路）</p></li></ul><p><strong>将递归的返回条件取非然后作为</strong> <strong>&amp;&amp;</strong> <strong>的第一个条件，递归主体转换为第二个条件语句</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> b = n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二分搜索剪枝"><a href="#二分搜索剪枝" class="headerlink" title="二分搜索剪枝"></a>二分搜索剪枝</h1><ol start="875"><li><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">Koko食香蕉</a></li></ol><p>有 <code>N</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉，Koko要在<code>H</code>小时内吃完，吃香蕉的速度为每小时<code>K</code>根，每小时最多吃一堆香蕉，若吃不下到下一小时再吃，如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 <strong>计算Koko每小时至少吃几根香蕉，才能在<code>H</code>小时内全部吃完？</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br></pre></td></tr></table></figure><p>解析：求<code>H</code>小时内吃完的最小速率，假设为<code>speed</code>，<code>speed</code>至少为1，最大为<code>max(piles)</code>，一小时最多吃一堆。</p><p>暴力解法：从1开始穷举到<code>max(piles)</code>，一旦发现某个值符合，就为最小速度。</p><p>改进：可以<strong>利用二分搜索剪枝，搜索左侧边界。</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSpeed</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="built_in">getMax</span>(piles) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canFinish</span>(piles, mid, h)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> speed, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        time += (n + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time &lt;= h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="1011"><li><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></li></ol><p>传送带上的第<code> i</code> 个包裹的重量为<code> weights[i]</code>。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p><p>返回能在 <code>days </code>天内将传送带上的所有包裹送达的船的最低运载能力。</p><p><strong>货物不可分割且必须按顺序运输</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br></pre></td></tr></table></figure><p>解法：本质上和koko食香蕉的问题是一样的，首先确定最小载重<code>cap</code>，最小值为<code>max(weights)</code>和<code>sum(weights)</code>，<strong>求最小载重。</strong></p><p>暴力法顺序遍历，改进<strong>二分搜索左侧边界剪枝</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> left = <span class="built_in">getMax</span>(weights);</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">accumulate</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canFinish</span>(weights, days, mid)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; days; day++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxCap = cap;</span><br><span class="line">        <span class="keyword">while</span> ((maxCap -= weights[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == weights.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : weights) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 模运算 </tag>
            
            <tag> 幂运算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>c++笔试题常用技巧</title>
      <link href="/posts/413d4c3c/"/>
      <url>/posts/413d4c3c/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="C-笔试输入输出"><a href="#C-笔试输入输出" class="headerlink" title="C++笔试输入输出"></a>C++笔试输入输出</h2><p>牛客网常用头文件</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure><table><thead><tr><th align="center">函数</th><th align="center">解释</th></tr></thead><tbody><tr><td align="center"><code>cin&gt;&gt;</code></td><td align="center">遇到空格和换行符自动停止读入，下次读入自动跳过，读取后面的字符</td></tr><tr><td align="center"><code>cin.get()</code></td><td align="center">读入字符，包括换行符<code>&#39;\n&#39;</code>和空格<code>&#39; &#39;</code></td></tr><tr><td align="center"><code>getline(cin, str)</code></td><td align="center">读取整行数据到<code>str</code>中</td></tr><tr><td align="center"><code>cin.getline(char*, int)</code></td><td align="center">接收字符串储存到char*中，长度为n可以接受空格</td></tr><tr><td align="center"><code>char a; cin.get(a)</code></td><td align="center"><code>a</code>中可以储存被<code>cin</code>丢弃的换行符</td></tr></tbody></table><ul><li><strong>cin&gt;&gt;输入的数据不包含空格和回车，空格和回车会存入到cin的缓冲区中</strong></li><li><strong>如果想拿到输入的空格和回车，通过cin.get()获得</strong></li></ul><ol><li><p>输入T组数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>输入2个数字</p></li></ol><blockquote><p>输入：两个正整数a, b</p><p>1 5</p><p>10 20</p></blockquote><blockquote><p>输出：a + b 结果</p><p>6 </p><p>30</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="3"><li><p>单组数据，已知有多少个数据，<strong>数据长度已知</strong>，一般用空格分隔。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多组数据，已知有多少个数据，数据长度已知</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">nums</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单组数据，未告知多少个数据，<strong>数据长度未知</strong>，用逗号或空格隔开的数据</p></li></ol><ul><li><p>法1：</p><blockquote><p>输入：用空格隔开每一个数据（逗号，分号同理）</p><p>123 456 789</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; tmp) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//只处理一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>输入：用空格隔开每一个数据，数据有多行</p><p>123 456 789</p><p>321 654 987</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; tmp) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vec.push_back(path);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : c) &#123;</span><br><span class="line">            cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>法2：构造split函数，指定分隔符，对字符串进行切片</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">split</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    str += pattern;</span><br><span class="line">    <span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern, i);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size) &#123;</span><br><span class="line">            string s = str.<span class="built_in">substr</span>(i, pos - i);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s));</span><br><span class="line">            i = pos + pattern.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">    <span class="comment">//input = &quot;7 17 27 35 8 49 50&quot;;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">split</span>(input, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="comment">//input为&quot;123, 456, 756&quot;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">split</span>(input, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="常用数据结构与函数"><a href="#常用数据结构与函数" class="headerlink" title="常用数据结构与函数"></a>常用数据结构与函数</h2><h3 id="map与set的使用"><a href="#map与set的使用" class="headerlink" title="map与set的使用"></a>map与set的使用</h3><ul><li><p>初始化：</p><ul><li>对于set：直接初始化<code>set&lt;int&gt; myset=&#123;0,1,2&#125;;</code> 或者把<code>vector</code>复制过来<code>set&lt;int&gt; myset(v.begin(),v.end());</code></li><li>对于map：<code>map&lt;int,int&gt; mymap=&#123;&#123;0,1&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;</code></li></ul></li><li><p>插入：</p><ul><li>对于set：<code>myset.insert(888);</code></li><li>对于map：<code>mymap.insert(make_pair(6,7));</code>or, <code>mymap.insert(pair&lt;int ,int&gt;(6,7));</code>or, <code>mymap.insert&#123;6,7&#125;</code></li></ul></li></ul><table><thead><tr><th align="center">成员函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">begin()</td><td align="center">返回指向头部的迭代器</td></tr><tr><td align="center">end()</td><td align="center">返回指向末尾的迭代器</td></tr><tr><td align="center">empty()</td><td align="center">如果为空则返回 true</td></tr><tr><td align="center">find(val)</td><td align="center">查找一个值为val的元素，如果成功找到，则返回<br>指向该元素的双向迭代器；反之，返回 指向end() 的迭代器。</td></tr><tr><td align="center">count(val)</td><td align="center">返回指定元素val出现的次数</td></tr><tr><td align="center">insert()</td><td align="center">向容器中插入元素</td></tr><tr><td align="center">erase()</td><td align="center">删除容器中存储的一个元素</td></tr><tr><td align="center">size()</td><td align="center">返回容器中元素的个数</td></tr><tr><td align="center">clear()</td><td align="center">清空容器中所有的元素，即令容器的 size() 为 0</td></tr><tr><td align="center">lower_bound(val)</td><td align="center">返回一个指向当前容器中（key）第一个大于或等于 val 的元素的双向迭代器。</td></tr><tr><td align="center">upper_bound(val)</td><td align="center">返回一个指向当前容器中（key）第一个大于 val 的元素的迭代器。</td></tr></tbody></table><h3 id="queue与stack的使用"><a href="#queue与stack的使用" class="headerlink" title="queue与stack的使用"></a>queue与stack的使用</h3><ul><li>queue成员函数</li></ul><table><thead><tr><th align="center">成员函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">empty()</td><td align="center">如果 queue 中没有元素的话，返回 true</td></tr><tr><td align="center">size()</td><td align="center">返回 queue 中元素的个数</td></tr><tr><td align="center">front()</td><td align="center">返回 queue 中第一个元素的引用</td></tr><tr><td align="center">back()</td><td align="center">返回 queue 中最后一个元素的引用</td></tr><tr><td align="center">push(const T&amp; obj)</td><td align="center">在 queue 的尾部添加一个元素的副本。<br>调用底层容器的成员函数 push_back() 。</td></tr><tr><td align="center">emplace()</td><td align="center">在 queue 的尾部直接添加一个元素。</td></tr><tr><td align="center">push(T&amp;&amp; obj)</td><td align="center">以移动的方式在 queue 的尾部添加元素。<br>调用底层容器的具有右值引用参数的成员函数 push_back()</td></tr><tr><td align="center">pop()</td><td align="center">删除 queue 中的第一个元素。</td></tr></tbody></table><ul><li>stack成员函数</li></ul><table><thead><tr><th align="center">成员函数</th><th align="center">功能</th></tr></thead><tbody><tr><td align="center">empty()</td><td align="center">当 stack 栈中没有元素时，该成员函数返回 true</td></tr><tr><td align="center">size()</td><td align="center">返回 stack 栈中存储元素的个数</td></tr><tr><td align="center">top()</td><td align="center">返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td></tr><tr><td align="center">push(const T&amp; val)</td><td align="center">先复制 val，再将 val 副本压入栈顶。调用底层容器的 push_back() 函数。</td></tr><tr><td align="center">push(T&amp;&amp; obj)</td><td align="center">以移动元素的方式将其压入栈顶。调用底层容器的有右值引用参数的 push_back() 函数。</td></tr><tr><td align="center">pop()</td><td align="center">弹出栈顶元素。</td></tr></tbody></table><ul><li><strong>stack 和queue 没有迭代器</strong>，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。</li></ul><h3 id="priority-queue的使用"><a href="#priority-queue的使用" class="headerlink" title="priority_queue的使用"></a>priority_queue的使用</h3><p>优先队列具有与队列相似的操作：<code>top()</code>返回队首元素、<code>pop()</code>弹出队首元素、<code>push()</code>插入至队尾并排序。优先队列在内部添加了一个排序。其模板有3个参数：<code>priority_queue&lt; type, container, function &gt;</code>，<code>type</code>是存放的数据类型，<code>container</code>是实现优先队列的底层容器（一般都是<code>vector&lt;int&gt;</code>），<code>function</code>是元素之间的排序方式。</p><ul><li><p>大顶堆（降序队列）</p><p><code>priority_queue&lt;int&gt; a; //缺省情况下同下面定义</code></p><p><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; a;</code></p></li><li><p>小顶堆（升序队列）</p><p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c;</code></p></li><li><p>常常把<code>pair&lt;int,int&gt;</code>作为数据类型存放进<code>priority_queue</code>里面，这时排序的规则就是先比较第一个元素，如果第一个元素相等再比较第二个元素。</p></li><li><p>对于自定义类型存放进<code>priority_queue</code>，那么仿函数<code>function</code>需要自己写。</p><p>具体写法定义一个类，里面定义<code>bool operator()(xxx,xxx)&#123;return a.x&lt;b.x;&#125;</code></p></li></ul><h3 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法"></a>STL常用算法</h3><ul><li><p>交换<code>swap()</code></p><p><code>vector</code>常用（交换容器中各元素的内存地址，并不是交换各个元素变量所存储的值）。</p><p>注意string是个例外，对string调用swap会导致迭代器、引用和指针失效</p><p>用法为：<code>swap(vec1,vec2);</code></p></li><li><p>逆序<code>reverse()</code></p><p><code>vector, string</code> 常用，反转在<code>[first,last)</code>范围内的顺序（包括first指向的元素，不包括last指向的元素），无返回值。</p><p>用法为<code>reverse(str.begin(),str.end());</code></p></li><li><p>统计<code>count()</code></p><p>统计某一值在一定范围内<code>[first,last)</code>出现的次数。</p><p>比如<code>int num = count(s.begin(),s.end(),&#39;a&#39;);</code></p></li><li><p>排序<code>sort()</code></p><p><code>sort (first, last) </code>对容器或普通数组中<code>[first, last)</code>范围内的元素进行排序，默认进行升序排序。</p><p><code>is_sorted (first, last)</code> 检测 <code>[first, last) </code>范围内是否已经排好序，默认检测是否按升序排序。</p><p><code>sort(vec.begin(), vec.end(), cmp)</code> 自定义比较函数<code>cmp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;</span><br><span class="line">    <span class="comment">//降序排列，通过自定义比较规则进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), mycomp);</span><br><span class="line">    <span class="comment">//降序排列，利用lambda函数</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span>&amp; i, <span class="keyword">int</span>&amp; j)&#123;<span class="keyword">return</span> i &gt; j;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义结构体排序：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myData</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">myData</span>(<span class="keyword">int</span> a_, b_) : <span class="built_in">a</span>(a_), <span class="built_in">b</span>(b_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义排序，按照a的大小，降序排列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> myData&amp; data1, <span class="keyword">const</span> myData&amp; data2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data1.a &gt; data2.a;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;myData, cmp&gt; myset;</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">2</span>, <span class="number">200</span>));</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">3</span>, <span class="number">300</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : myset) &#123;</span><br><span class="line">        cout &lt;&lt; c.a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>二分查找函数：</p><p><code>lower_bound(vec.begin(), vec.end(), target)</code>寻找<code>vec</code>数组中大于等于<code>target</code>的第一个数，返回其迭代器。</p><p><code>Upper_bound()</code>则是寻找第一个大于target的数。</p></li><li><p>全排列函数</p><p><code>next_permutation()</code>寻找下一个排列组合，<code>prev_permutation()</code>为上一个。</p><p>当<code> next_permutation()</code> 返回<code> false</code> 时，循环结束，表明到达最小排列。这样恰好可以生成 序列的全部排列。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">string str = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li><li><p>原地删除<code>erase()</code></p><p>对于string：</p><ul><li><code>erase(pos,n);</code> 删除从下标<code>pos</code>开始的n个字符，比如<code>erase(0,1)</code>就是删除第一个字符。</li><li><code>erase(position);</code> 删除<code>postion</code>处的一个字符（<strong>position是一个string类型的迭代器</strong>）。</li><li><code>erase(first,last);</code> 删除从<code>first</code>到<code>last</code>之间的字符（<code>first</code>和<code>last</code>都是迭代器），注意是左闭右开。</li></ul><p>对于map：</p><ul><li><code>mymap.erase(key)</code>，会按key来删除map中对应的键值对。</li><li><code>mymap.erase(position)</code>，position为迭代器。</li><li><code>mymap.erase(first,last)</code>，删除迭代器表示的范围。</li></ul></li><li><p>子字符串<code>substr()</code></p><p><code>string sub=s.substr(pos);</code>复制从下标<code>pos</code>开始的一直到结尾的字符串为新的sub子串。</p><p><code>string sub=s.substr(pos,n)；</code>复制从下标<code>pos</code>开始的<code>n</code>个字符。</p></li><li><p>技巧：字符与数字的转换</p><ul><li><p>字符char 转为 数字int，利用<code>str[0]-‘0’</code></p></li><li><p>数字int 转为 字符char，利用<code>(7+&#39;0&#39;)</code></p></li><li><p>特殊字符char 转为 int，比如要把<code>&#39;a&#39;</code>转为0，<code>&#39;d&#39;</code>转为3。利用ASICII码，<code>’a’</code>的ASICII码为97，所以<code>(int)str[2]-97</code></p></li><li><p>字符串string 转为 int，<code>atoi()/stoi()</code>函数</p></li><li><p>整数int 转为字符串string，<code>to_string(value)</code>函数</p></li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> c++输入处理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>回溯算法思想</title>
      <link href="/posts/6957245a/"/>
      <url>/posts/6957245a/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h1 id="回溯算法思想"><a href="#回溯算法思想" class="headerlink" title="回溯算法思想"></a>回溯算法思想</h1><p>回溯算法相当于一个决策树，解决一个决策树的遍历问题，需要考虑：</p><ul><li>路径：已经做出的选择</li><li>选择列表：可以做的选择</li><li>结束条件：到达决策树底层，无法做出选择的条件</li></ul><p>回溯框架：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径，选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure><h2 id="子集穷举"><a href="#子集穷举" class="headerlink" title="子集穷举"></a>子集穷举</h2><ol start="78"><li>给定一组不含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</li></ol><p>说明：解集不能包含重复的子集。</p><p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p><p><a href="https://leetcode-cn.com/problems/subsets/">力扣题目链接</a></p><img src="/posts/6957245a/image-20220404212935154.png" alt="image-20220404212935154" style="zoom:50%;"><p><code>[1, 2, 3]</code>的全部子集为递归树上的所有节点，for循环横向遍历，递归纵向遍历</p><ul><li><p>递归参数：二维数组<code>result</code>存放子集组合，一维数组<code>path</code>收集路径元素，需要<code>start</code>参数控制递归</p></li><li><p>递归终止条件：<code>start</code>大于等于数组的长度。没有元素可取</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>单层逻辑：遍历整棵树，不需要剪枝</p></li></ul><p>完整代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存储所有子集</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">//记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*回溯算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(path); <span class="comment">//收集子集，始终在上面，防止漏掉自己，前序遍历的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>; <span class="comment">//可以不加，每次递归的下一层就是从i+1开始的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从start开始，防止产生重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">//递归回溯</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, path);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="90"><li>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li></ol><p>说明：解集不能包含重复的子集。</p><p>示例:</p><ul><li>输入: [1,2,2]</li><li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li></ul><p><a href="https://leetcode-cn.com/problems/subsets-ii/">力扣题目链接</a></p><p>解法：回溯+去重，同一层横向遍历需要去重（需要首先对集合排序）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 对同一树层使用过的元素进行跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] ) &#123; <span class="comment">// 注意这里使用i &gt; start</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 去重需要排序</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录走过的路径</span></span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p><p>示例:<br>输入: <code> n = 4, k = 2</code><br>输出: <code> [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</code></p><p>解法：<code>combine(4, 2)</code>的结果，决策树的高度为k，宽度为n的所有叶子节点。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//记录所有组合</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录走过的路径</span></span><br><span class="line">    <span class="built_in">backtrack</span>(n, k, <span class="number">1</span>, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//到达叶子节点更新result</span></span><br><span class="line">    <span class="keyword">if</span> (k == path.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i从start开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>, path); <span class="comment">// 递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>组合可以看作特定长度的子集，<code>combine(3, 2) </code>等价于 <code>subset([1, 2, 3])</code>长度为2 的子集</p><h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><ol start="46"><li>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</li></ol><p>示例:</p><ul><li>输入:<code> [1,2,3]</code></li><li>输出: <code>[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</code></li></ul><p><a href="https://leetcode-cn.com/problems/permutations/">力扣题目链接</a></p><p>解法：排列是有序的， <code>[1,2] </code>和 <code>[2,1]</code> 是两个集合，处理全排列问题不需要start防止重复。需要排除已经选择过的数字，将所有叶子节点作为结果。可以使用一个<code>used</code>数组，标记此时<code>path</code>中已经选择的元素，<strong>一个排列里一个元素只能使用一次</strong>。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时说明到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">//标记bool数组</span></span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="47"><li>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</li></ol><p>示例 1：</p><ul><li>输入：<code>nums = [1,1,2]</code></li><li>输出：<code> [[1,1,2], [1,2,1], [2,1,1]]</code></li></ul><p>示例 2：</p><ul><li>输入：<code>nums = [1,2,3]</code></li><li>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li></ul><p><a href="https://leetcode-cn.com/problems/permutations-ii/">力扣题目链接</a></p><p>解法：回溯+去重，去重需要对元素序列排序，方便通过相近节点判断是否重复使用。</p><p>去重逻辑的关键代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line"><span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总体代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 回溯算法 </tag>
            
            <tag> 子集 </tag>
            
            <tag> 排列 </tag>
            
            <tag> 组合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树基础</title>
      <link href="/posts/84ac9751/"/>
      <url>/posts/84ac9751/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul><li><strong>满二叉树</strong>：一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。</li></ul><img src="/posts/84ac9751/image-20220326214418676.png" alt="image-20220326214418676" style="zoom: 30%;"><p>满二叉树的深度为k，有2^k-1个节点的二叉树。</p><ul><li><strong>完全二叉树</strong>：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</li></ul><img src="/posts/84ac9751/image-20220326214559918.png" alt="image-20220326214559918" style="zoom:75%;"><ul><li><strong>二叉搜索树</strong>：有序树，满足：<ul><li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li><li>它的左、右子树也分别为二叉排序树。</li></ul></li></ul><img src="/posts/84ac9751/image-20220326214858888.png" alt="image-20220326214858888" style="zoom:75%;"><ul><li><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，满足：<ul><li>是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li><li>左右两个子树都是一棵平衡二叉树。</li></ul></li></ul><img src="/posts/84ac9751/image-20220326215122495.png" alt="image-20220326215122495" style="zoom:75%;"><table><thead><tr><th align="center">C++中常用容器</th><th align="center">底层实现</th></tr></thead><tbody><tr><td align="center">map、set、multimap，multiset</td><td align="center">平衡二叉搜索树</td></tr><tr><td align="center">unordered_map、unordered_set，<br>unordered_map、unordered_map</td><td align="center">哈希表</td></tr></tbody></table><h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>二叉树主要有两种遍历方式：</p><ol><li>深度优先遍历：先往深走，遇到叶子节点再往回走。前中后序遍历。</li><li>广度优先遍历：一层一层的去遍历。层次遍历。</li></ol><p>遍历顺序：</p><ul><li>前序遍历：中左右</li><li>中序遍历：左中右</li><li>后序遍历：左右中</li></ul><img src="/posts/84ac9751/image-20220326221443483.png" alt="image-20220326221443483" style="zoom:75%;"><h3 id="二叉树定义："><a href="#二叉树定义：" class="headerlink" title="二叉树定义："></a>二叉树定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><p>递归三要素：</p><ol><li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li><li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li><li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li></ol><p><strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。</p><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*辅助遍历函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">traversal</span>(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><p>迭代法：用栈来实现递归</p><p>中序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>前序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*和中序遍历相比仅仅改变了两行代码的顺序*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>后序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>解法：广度优先遍历，使用辅助队列，先进先出</p><p>层序遍历：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h2><h3 id="中序与后序遍历序列构造二叉树"><a href="#中序与后序遍历序列构造二叉树" class="headerlink" title="中序与后序遍历序列构造二叉树"></a>中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接</a></p><p>根据一棵树的中序遍历与后序遍历构造二叉树。</p><p>解法：对中序和后序遍历序列进行切割，找好切割区间，建议左闭右开。</p><p>中序数组 ==&gt; 左中序数组 + 根 + 右中序数组</p><p>后序数组 ==&gt; 左后序数组 + 右后序数组 + 根</p><p>递归求解：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">    <span class="keyword">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">    <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">    <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割中序数组</span></span><br><span class="line">    <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line">    <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">    postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割后序数组</span></span><br><span class="line">    <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">    <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line">    <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h3><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">力扣题目地址</a></p><p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p><ul><li>二叉树的根是数组中的最大元素。</li><li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li><li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li></ul><p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p><p>解析：首先找到序列的最大值，以最大值构造根节点，左子树区间 + 根节点（最大值）+ 右子树区间，递归构造子区间至少一个值</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到数组中最大的值和对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">            maxValueIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;val = maxValue;</span><br><span class="line">    <span class="comment">// 最大值所在的下标左区间 构造左子树</span></span><br><span class="line">    <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">        node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大值所在的下标右区间 构造右子树</span></span><br><span class="line">    <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题必会：快速排序/选择</title>
      <link href="/posts/202ade3b/"/>
      <url>/posts/202ade3b/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的逻辑是，若要对<code> nums[lo..hi]</code> 进⾏排序，我们先找⼀个分界点<code> p</code>，通过交换元素使得<code>nums[lo..p-1] </code>都⼩于等于<code> nums[p]</code>，且 <code>nums[p+1..hi] </code>都⼤于<code> nums[p]</code>，然后递归地去<code>nums[lo..p-1] </code>和<code>nums[p+1..hi] </code>中寻找新的分界点，最后整个数组就被排序了。</p><p>关键就在于这个分界点索引 <code>p</code> 的确定</p><img src="/posts/202ade3b/image-20220322165722861.png" alt="image-20220322165722861" style="zoom:50%;"><p>索引<code>p</code>左侧的元素都⽐ <code>nums[p] </code>⼩，右侧的元素都⽐ <code>nums[p]</code>⼤，意味着这个元素已经放到了正确的位置 。</p><p>实现代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 快速排序主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 将 nums 数组随机打乱</span></span><br><span class="line"> <span class="built_in">shuffle</span>(nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"> <span class="built_in">quicksort</span>(nums, lo, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序核⼼逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line"> <span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line"> <span class="built_in">quicksort</span>(nums, lo, p - <span class="number">1</span>);</span><br><span class="line"> <span class="built_in">quicksort</span>(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分界点索引 p 的确定 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>, j = hi;</span><br><span class="line">    <span class="comment">// 将 nums[lo] 作为默认分界点 p</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= nums[lo]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; j &amp;&amp; nums[j] &gt;= nums[lo]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//此时， nums[i] &gt; p &amp;&amp; nums[j] &lt; p，需交换 nums[i] 和 nums[j]</span></span><br><span class="line">            <span class="comment">//保证 nums[lo..i] &lt; p &lt; nums[j..hi]</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//将 p值（nums[lo]）交换到正确的位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[lo], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组元素进⾏随机打乱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><blockquote><p>相关题目：</p><ol start="215"><li>数组中的第 K 个最⼤元素（中等）</li></ol></blockquote><p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p><p> 解法：快排简化，可以在O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择需要找到第<code>k </code>大的枢（pivot），不需要对其左右再进行排序。快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为O($n^2$).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// ⾸先随机打乱数组</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数 - 快速选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 排序 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小知识：二叉树</title>
      <link href="/posts/471b5238/"/>
      <url>/posts/471b5238/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><blockquote><p>相关题目：</p><ol start="226"><li><p>翻转⼆叉树（简单） </p></li><li><p>⼆叉树展开为链表（中等） </p></li><li><p>填充每个节点的下⼀个右侧节点指针（中等）</p></li></ol></blockquote><p>二叉树递归：明确函数的定义，根据定义递归推导最终结果。先搞清楚当前根节点”该做什么”与”什么时候做”，然后根据函数定义递归调⽤⼦节点，让孩⼦节点做相同的事情。</p><h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>输⼊⼀个⼆叉树根节点<code> root</code>，把整棵树镜像翻转，⼆叉树上的每⼀个节点的左右⼦节点进⾏交换。</p><img src="/posts/471b5238/invert1-tree.jpg" alt="img" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将整棵树的节点翻转</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">//root节点需要交换它的左右节点</span></span><br><span class="line">    TreeNode* tmp = root -&gt; left;</span><br><span class="line">    root -&gt; left = root -&gt; right;</span><br><span class="line">    root -&gt; right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让左右⼦节点继续翻转它们的⼦节点</span></span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="填充⼆叉树节点的右侧指针"><a href="#填充⼆叉树节点的右侧指针" class="headerlink" title="填充⼆叉树节点的右侧指针"></a>填充⼆叉树节点的右侧指针</h3><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个<code> next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><img src="/posts/471b5238/116_sample.png" alt="img" style="zoom:50%;"><p>⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情，如果只依赖一个节点进行递归，无法连接跨父节点的两个相邻节点。需细化为两个节点进行递归。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">nullptr</span> || node2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传⼊的两个节点连接</span></span><br><span class="line">    node1 -&gt; next = node2;</span><br><span class="line">    <span class="comment">// 连接相同⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; left, node1 -&gt; right);</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node2 -&gt; left, node2 -&gt; right);</span><br><span class="line">    <span class="comment">// 连接跨越⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; right, node2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小知识：队列/栈</title>
      <link href="/posts/16a357/"/>
      <url>/posts/16a357/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>队列主要⽤在 BFS 算法，栈主要⽤在括号相关的问题</p><h2 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h2><blockquote><p>相关题目：</p><ol start="232"><li><p>⽤栈实现队列（简单） </p></li><li><p>⽤队列实现栈（简单） </p></li></ol></blockquote><p>队列：先进先出；栈：先进后出</p><h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>双栈实现队列</p><img src="/posts/16a357/image-20220315182119191.png" alt="image-20220315182119191" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到队尾 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除队头的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">peek</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回队头元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>双队列实现栈</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到栈顶 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断栈是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="括号字符串问题"><a href="#括号字符串问题" class="headerlink" title="括号字符串问题"></a>括号字符串问题</h2><blockquote><p>相关题目：</p><ol start="20"><li><p>有效的括号（简单） </p></li><li><p>使括号有效的最⼩添加（中等） </p></li><li><p>平衡括号串的最少插⼊（中等） </p></li></ol></blockquote><h3 id="判断合法括号字符串"><a href="#判断合法括号字符串" class="headerlink" title="判断合法括号字符串"></a>判断合法括号字符串</h3><p>输⼊⼀个字符串，其中包含<code>[]()&#123;&#125;</code>六种括号，判断这个字符串组成的括号是否合法。 </p><p>每个右括号 <code>)</code> 的左边必须有⼀个左括号 <code>(</code> 和它匹配。</p><p>解法：使用栈，遇到左括号就⼊栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            left.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字符 c 是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (!left.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">leftOf</span>(c) == left.<span class="built_in">top</span>())</span><br><span class="line">                left.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">// 和最近的左括号不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡括号串"><a href="#平衡括号串" class="headerlink" title="平衡括号串"></a>平衡括号串</h3><p>输⼊⼀个字符串 <code>s</code>，你可以在其中的任意位置插⼊左括号<code>(</code>或者右括号<code> )</code>，返回需要⼏次插⼊才能使得 <code>s </code>变成⼀个合法的括号串</p><p>输⼊ <code>s = &quot;())(&quot;</code>，算法应该返回 2，因为⾄少需要插⼊两次把 s 变成<code> &quot;(())()&quot;</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 记录插⼊次数</span></span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>; <span class="comment">// need 变量记录右括号的需求量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 + 1</span></span><br><span class="line">            need++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 - 1\</span></span><br><span class="line"><span class="comment">            need--;</span></span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">                need = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 需插⼊⼀个左括号</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><blockquote><p>相关题目：</p><ol start="496"><li><p>下⼀个更⼤元素I（简单） </p></li><li><p>下⼀个更⼤元素II（中等） </p></li><li><p>每⽇温度（中等） </p></li></ol></blockquote><p>单调栈：每次新元素⼊栈后，栈内的元素都保持有序（单调递增或单调递减）。 </p><p>一般只用来处理Next Greater Element 问题。</p><h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><p>⽐如：输⼊⼀个数组<code> nums = [2,1,2,4,3]</code>，返回数组<code> [4,2,4,-1,-1]</code>。 </p><p>解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4 ⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt;  s;</span><br><span class="line">    <span class="comment">// 倒着往栈⾥放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ;i++) &#123;</span><br><span class="line">        <span class="comment">// 判定个⼦⾼矮</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的 next great number</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定⼀个数组 T，这个数组存放的是近⼏天的天⽓⽓温，你返回⼀个等⻓的数组，计算：对于每⼀天，还要⾄少等多少天才能等到⼀个更暖和的⽓温；如果等不到那⼀天，填 0。</p><p>⽐如：输⼊ <code>T = [73,74,75,71,69,76]</code>，返回 <code>[1,1,3,2,1,0]</code>。 </p><p>解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天，只要等⼀天就能等到⼀个更暖和的⽓温，后⾯的同理。 </p><p>解法：单调栈，区别在于需要返回与Next Greater Number 的距离。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这⾥放元素索引，⽽不是元素</span></span><br><span class="line">    <span class="comment">/* 单调栈模板 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; T[s.<span class="built_in">top</span>()] &lt;= T[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : (s.<span class="built_in">top</span>() - i);</span><br><span class="line">        s.<span class="built_in">push</span>(i); <span class="comment">// 将索引⼊栈，⽽不是元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题小知识：数组/链表</title>
      <link href="/posts/a0fdfee0/"/>
      <url>/posts/a0fdfee0/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><p>数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储。</p><p>主要算法：双指针，可分为</p><ul><li>中间向两端扩散</li><li>两端向中间收缩</li><li>快慢指针</li></ul><h2 id="1-前缀和数组"><a href="#1-前缀和数组" class="headerlink" title="1. 前缀和数组"></a>1. 前缀和数组</h2><p>前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。</p><p><strong>注：原始数组/矩阵不可变，频繁查询某个区间的累加和。</strong></p><blockquote><p>相关题目：</p><ol start="303"><li><p>区域和检索 - 数组不可变（中等） </p></li><li><p>⼆维区域和检索 - 矩阵不可变（中等） </p></li><li><p>和为K的⼦数组（中等） </p></li></ol></blockquote><p>一维数组的前缀和</p><img src="/posts/a0fdfee0/image-20220310181632054.png" alt="image-image-20220310181632054" style="zoom:50%;"><p>新建一个<code>preSum</code>数组，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p><p>如果我想求索引区间<code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1] </code>得出。 </p><p>核心代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixSum</span> &#123;</span></span><br><span class="line"> <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; prefix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">     <span class="built_in">PrefixSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">     prefix.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">         prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     &#125;</span><br><span class="line"> <span class="comment">/* 查询闭区间 [i, j] 的累加和 */</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>二维数组前缀和</p><img src="/posts/a0fdfee0/image-20220310183903115.png" alt="image-20220310183903115" style="zoom:33%;"><p>如果我想计算红⾊的这个⼦矩阵的元素之和，可以⽤绿⾊矩阵减去蓝⾊矩阵减去橙⾊矩阵最后加上粉⾊矩 阵，⽽绿蓝橙粉这四个矩阵有⼀个共同的特点，就是左上⻆就是 (0, 0) 原点。 </p><p>那么我们可以维护⼀个⼆维 <code>preSum </code>数组，专⻔记录以原点为顶点的矩阵的元素之和，就可以⽤⼏次加减运算算出任何⼀个⼦矩阵的元素和：</p><h2 id="2-差分数组"><a href="#2-差分数组" class="headerlink" title="2. 差分数组"></a>2. 差分数组</h2><blockquote><p>相关题目：</p><ol start="370"><li><p>区间加法（中等） </p></li><li><p>航班预订统计（中等） </p></li><li><p>拼⻋（中等）</p></li></ol></blockquote><p>差分数组的主要适⽤场景是<strong>频繁对原始数组的某个区间的元素进⾏增减</strong>。 </p><p>对 <code>nums</code> 数组构造⼀个 <code>diff</code> 差分数组，**<code>diff[i]</code>** 就是 <strong><code>nums[i]</code></strong> 和 <strong><code>nums[i-1]</code></strong> 之差：</p><img src="/posts/a0fdfee0/image-20220311120935829.jpg" alt="image-20220311120935829" style="zoom:50%;"><p>这样构造差分数组 **<code>diff</code>**，就可以快速进⾏区间增减的操作，如果你想对区间 <code>nums[i..j] </code>的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让<code> diff[j+1] -= 3</code> 即可：</p><p>把差分数组抽象成⼀个类，包含 increment ⽅法和 result ⽅法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 差分数组⼯具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span>   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; diff;<span class="comment">//差分数组</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        assert nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">        diff,<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123; <span class="comment">//当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff数组减 val 了。</span></span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h2><blockquote><p>相关题目：</p><ol start="76"><li><p>最⼩覆盖⼦串（困难） </p></li><li><p>字符串的排列（中等） </p></li><li><p>找到字符串中所有字⺟异位词（中等） </p></li><li><p>⽆重复字符的最⻓⼦串（中等） </p></li></ol></blockquote><p>滑动窗⼝算法的代码框架：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗⼝算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"> <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line"><span class="comment">// c 是将移⼊窗⼝的字符</span></span><br><span class="line"><span class="keyword">char</span> c = s[right];</span><br><span class="line"><span class="comment">// 右移窗⼝</span></span><br><span class="line">right++;</span><br><span class="line"><span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> ...</span><br><span class="line"><span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line"><span class="comment">/********************/</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">// 判断左侧窗⼝是否要收缩</span></span><br><span class="line"><span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line"> <span class="comment">// d 是将移出窗⼝的字符</span></span><br><span class="line"> <span class="keyword">char</span> d = s[left];</span><br><span class="line"> <span class="comment">// 左移窗⼝</span></span><br><span class="line"> left++;</span><br><span class="line"> <span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> ...</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="4-二分搜索"><a href="#4-二分搜索" class="headerlink" title="4. 二分搜索"></a>4. 二分搜索</h2><blockquote><p>相关题目：</p><ol start="704"><li><p>⼆分查找（简单） </p></li><li><p>在排序数组中查找元素的第⼀个和最后⼀个位置（中等） </p></li></ol></blockquote><p>搜索一个元素，搜索区间两端闭，while带等号</p><p>搜索左右边界，左闭右开常用，while用小于号</p><p>零、二分查找框架</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。</p><h3 id="寻找一个数：存在返回其索引，不存在返回-1"><a href="#寻找一个数：存在返回其索引，不存在返回-1" class="headerlink" title="寻找一个数：存在返回其索引，不存在返回-1."></a>寻找一个数：存在返回其索引，不存在返回-1.</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找左侧边界的二分搜索："><a href="#寻找左侧边界的二分搜索：" class="headerlink" title="寻找左侧边界的二分搜索："></a>寻找左侧边界的二分搜索：</h3><p>左闭右开区间写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target ⽐所有数都⼤</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 类似之前算法的处理⽅式</span></span><br><span class="line"><span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全闭区间写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="寻找右侧边界的⼆分查找"><a href="#寻找右侧边界的⼆分查找" class="headerlink" title="寻找右侧边界的⼆分查找:"></a>寻找右侧边界的⼆分查找:</h3><p>左闭右开写法（常见）：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>全闭区间写法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>建议搜索区间全都统⼀成了<strong>两端都闭</strong>，便于记忆，只要修改两处即可变化出三种写法</p><h2 id="5-原地修改数组"><a href="#5-原地修改数组" class="headerlink" title="5. 原地修改数组"></a>5. 原地修改数组</h2><blockquote><p>相关题目：</p><ol start="26"><li><p>删除有序数组中的重复项（简单） </p></li><li><p>删除排序链表中的重复元素（简单） </p></li><li><p>移除元素（简单） </p></li><li><p>移动零（简单） </p></li></ol></blockquote><h3 id="有序数组-链表去重"><a href="#有序数组-链表去重" class="headerlink" title="有序数组/链表去重"></a>有序数组/链表去重</h3><p>通⽤解法：快慢指针技巧</p><h3 id="有序数组去重："><a href="#有序数组去重：" class="headerlink" title="有序数组去重："></a>有序数组去重：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != num[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] ⽆重复</span></span><br><span class="line">            num[slow] = num[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组⻓度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="有序链表去重："><a href="#有序链表去重：" class="headerlink" title="有序链表去重："></a>有序链表去重：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast -&gt; val != slow -&gt; val) &#123;</span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            slow -&gt; next = fast;</span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开与后⾯重复元素的连接</span></span><br><span class="line">    slow -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="数组原地删除元素："><a href="#数组原地删除元素：" class="headerlink" title="数组原地删除元素："></a>数组原地删除元素：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="原地修改，将数组中的所有值为-0-的元素移到数组末尾："><a href="#原地修改，将数组中的所有值为-0-的元素移到数组末尾：" class="headerlink" title="原地修改，将数组中的所有值为 0 的元素移到数组末尾："></a>原地修改，将数组中的所有值为 0 的元素移到数组末尾：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line"><span class="comment">// 去除 nums 中的所有 0</span></span><br><span class="line"><span class="comment">// 返回去除 0 之后的数组⻓度</span></span><br><span class="line"><span class="keyword">int</span> p = <span class="built_in">removeElement</span>(nums, <span class="number">0</span>);</span><br><span class="line"><span class="comment">// 将 p 之后的所有元素赋值为 0</span></span><br><span class="line"><span class="keyword">for</span> (; p &lt; nums.length; p++) &#123;</span><br><span class="line">nums[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⻅上⽂代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="6-单链表"><a href="#6-单链表" class="headerlink" title="6. 单链表"></a>6. 单链表</h2><blockquote><p>相关题目：</p><ol start="21"><li><p>合并两个有序链表（简单） </p></li><li><p>合并K个升序链表（困难） </p></li><li><p>环形链表（简单） </p></li><li><p>环形链表 II（中等） </p></li><li><p>链表的中间结点（简单） </p></li><li><p>相交链表（简单） </p></li><li><p>删除链表的倒数第 N 个结点（中等）</p></li></ol></blockquote><h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>给定输⼊两个有序链表，把他俩合并成⼀个新的有序链表。</p><p>输入：<code>l1 = [1, 2, 4], l2 = [1, 3, 4]</code></p><p>输出：<code>[1, 1, 2, 3, 4, 4]</code></p><p>解法：设立虚拟头节点<code>dummy</code>，避免处理空指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// ⽐较 p1 和 p2 两个指针</span></span><br><span class="line"> <span class="comment">// 将值较⼩的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span>(p1 -&gt; val &gt; p2 -&gt; val) &#123;</span><br><span class="line">            p -&gt; next = p2;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p -&gt; next = p1;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h3><p>给定输⼊k个有序链表，把他们合并成⼀个新的有序链表。</p><p>输入：<code>lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</code></p><p>输出：<code>[1, 1, 2, 3, 4, 4, 5, 6]</code></p><p>解法：优先级队列（二叉堆），把链表节点放⼊⼀个最⼩堆，就可以每次获得 k 个节点中的最⼩节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; n) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.val &lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 优先级队列，最⼩堆</span></span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 k 个链表的头结点加⼊最⼩堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;head -&gt; val, head&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取最⼩节点，接到结果链表中</span></span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>().p;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            p -&gt; next = node;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;node -&gt; next -&gt; val, node -&gt; next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h3><p>要点：只遍历⼀次链表，就算出倒数第 k 个节点</p><img src="/posts/a0fdfee0/image-20220314210806020.png" alt="image-20220314210806020" style="zoom:50%;"><p>指针<code>p1</code>指向<code>head</code>节点，开始走<code>k</code>步；</p><img src="/posts/a0fdfee0/image-20220314211006249.png" alt="image-20220314211006249" style="zoom:50%;"><p>指针<code>p2</code>指向<code>head</code>节点，<code>p1</code>和<code>p2</code>同时走，<code>n-k</code>步后<code>p1</code>走到链表末尾空指针结束，返回<code>p2</code>即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    <span class="comment">// p1 先⾛ k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时⾛ n - k 步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p2 = p2 -&gt; next;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="单链表中点"><a href="#单链表中点" class="headerlink" title="单链表中点"></a>单链表中点</h3><p>解法：让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点<code> head</code>。 每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> ⾛到链表末尾时，<code>slow</code> 就指向了链 表中点。 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> ListNode* slow = head, *fast = head;</span><br><span class="line"> <span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> slow = slow -&gt; next;</span><br><span class="line"> fast = fast -&gt; next -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：如果链表⻓度为偶数，也就是说中点有两个的时候，这个解法返回的节点是靠后的那个节点。 </p><h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><p>解法：快慢指针，每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast </code>最终和<code>slow</code>相遇，那肯定是<code> fast</code> 超过了<code>slow</code> ⼀圈，说明链表中含有环。</p><p>只需要把寻找链表中点的代码稍加修改：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> ListNode* slow = head, *fast = head;</span><br><span class="line"> <span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> slow = slow -&gt; next;</span><br><span class="line"> fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算环的起点*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line"> fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> <span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"> <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> &#125;</span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line"> slow = head;</span><br><span class="line"> <span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"> <span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"> fast = fast -&gt; next;</span><br><span class="line">     slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>输⼊两个链表的头结点<code>headA</code>和<code> headB</code>，这两个链表可能存在相交。如果相交，应该返回相交的那个节点；如果没相交，则返回 <code>nullptr</code>。</p><p>解法：可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让<code> p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表<code> A</code>，这样相 当于「逻辑上」两条链表接在了⼀起。让<code> p1</code> 和<code> p2</code> 同时进⼊公共部分，也就是同时到达相交节点<code> c1</code></p><img src="/posts/a0fdfee0/image-20220315104422008.png" alt="image-20220315104422008" style="zoom:50%;"><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode* p1 = headA, *p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="7-链表操作的递归实现"><a href="#7-链表操作的递归实现" class="headerlink" title="7. 链表操作的递归实现"></a>7. 链表操作的递归实现</h2><blockquote><p>相关题目：</p><ol start="206"><li><p>反转链表（简单） </p></li><li><p>反转链表II（中等） </p></li></ol></blockquote><h3 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h3><p>输⼊⼀个节点 <code>head</code>，将以<code>head</code>为起点的链表反转，并返回反转之后的头结点。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归函数base case，如果链表只有⼀个节点的时候，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的头结点是last, 将head之后部分反转</span></span><br><span class="line">    ListNode* last = <span class="built_in">reverse</span>(head -&gt; next);</span><br><span class="line">    head -&gt; next -&gt; next = head;</span><br><span class="line">    <span class="comment">//head 变成了最后⼀个节点，别忘了链表的末尾要指向 null</span></span><br><span class="line">    head -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h3><p>解决思路和反转整个链表差不多，稍加修改即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">ListNode* successor = <span class="literal">nullptr</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"> <span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line"> successor = head -&gt; next;</span><br><span class="line"> <span class="keyword">return</span> head;</span><br><span class="line"> &#125;</span><br><span class="line"> <span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line"> ListNode* last = <span class="built_in">reverseN</span>(head -&gt; next, n - <span class="number">1</span>);</span><br><span class="line"> head -&gt; next -&gt; next = head;</span><br><span class="line"><span class="comment">// 让反转之后的 head 节点和后⾯的节点连起来</span></span><br><span class="line"> head -&gt; next = successor;</span><br><span class="line"> <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h3><p>给⼀个索引区间<code> [left, right]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//接上部分反转链表代码</span></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 刷题笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Zhang-Tong-CV</title>
      <link href="/posts/676dd596/"/>
      <url>/posts/676dd596/</url>
      
        <content type="html"><![CDATA[<hr><span id="more"></span><table>    <tr>        <td width="80%">            <table>                <tr>                                        <td align="left"><b>Master</b></td>                </tr>                <tr>                                        <td align="left"><b>School of Mechanical & Automotive Engineering, South China University of Technology</b></td>                </tr>                <tr>                                        <td align="left"><b>Mail: zt_scut@163.com</b></td>                </tr>                <tr>                                        <td align="left"><b>Phone: +1 ‪(971) 373-7549‬</b></td>                </tr>                <tr>                                        <td align="left"><b>Address: 381 Wushan Road, Tianhe District, Guangzhou,Guangdong, China</b></td>                </tr>                            </table>        </td>        <td width="30%" height="100%">            <img src="/images/image-20220306.jpg">        </td>    </tr></table><h2 id="Educational-Qualification"><a href="#Educational-Qualification" class="headerlink" title="Educational Qualification"></a>Educational Qualification</h2><ul><li><strong>Master</strong> in Vehicle Engineering(2023)<br>South China University of Technology,Guangzhou, China</li><li><strong>B.Eng</strong> in Vehicle Engineering(2020)<br>Hefei University of Technology, China</li></ul><h2 id="Project-amp-Internship-Experience"><a href="#Project-amp-Internship-Experience" class="headerlink" title="Project &amp; Internship Experience"></a>Project &amp; Internship Experience</h2><p><em>Software Testing Engineer Intern in Kaizeli Technology Co. ,Ltd. (2020.07-2020.09)</em></p><ul><li>Write test scripts according to requirements documents, using Linux command and shell language</li><li>Responsible for the on-board OTA and IVI module testing projects, complete the test unit and upload test reports</li><li>Participated in the project of automated test platform, and improve the design of the testing interface, carry out a detailed needs analysis and use case design. </li></ul><p><em>Software Testing Engineer Intern in GAC R&amp;D Center. (2020.10—2020.12)</em></p><ul><li>Understand the principle of CAN communication, and using CAN communication tools,  such as Vehicle-Spy、KVaser, to sample the test signal </li><li>Carry out on-board system function module test, and complete data detection, calibration, log acquisition and analysis</li><li>Participate in on-board system test of multiple models, and update test cases according to requirements and feedback</li></ul><p><em>Software Design Engineer Intern in Shenzhen Lan-You Technology Co. ,Ltd. (2021.08-2021.11)</em></p><ul><li>Assisted in the implementation of simulation software of automatic vehicle, design test scenarios in ACC、AEB、LKA , complete design documents and scenario scripts</li><li>Responsible for the parking area map design and visualization, compile the program scripts for parsing XML files, and using QT software for visual display</li><li>Complete the preliminary project and generate 858 test scenario scripts totally,  and  using the  parking area visualization program to help verify the reliability of map file data</li></ul><h2 id="Research-Experience"><a href="#Research-Experience" class="headerlink" title="Research Experience"></a>Research Experience</h2><ul><li>Participate in the Innovation training program for college students in Anhui Province 2018, Intelligent lane changing auxiliary system Based on longitudinal and lateral dynamic control,  responsible for building vehicle dynamics model and using CarSim software for simulation</li><li>Participate in the Innovation training program for college students in Anhui Province 2019, Design and motion control of multi-mode reconfigurable for self-driving vehicle, responsible for help generate physical model using Catia drawing software, and Assisted in the implementation of the printed circuit board design</li><li>Research on driver fatigue detection method based on facial features, the graduation project, used CNN for facial landmarks detection and a pre-trained network for training on the data set, using SVM algorithm to generate model of facial fatigue feature classification </li></ul><h2 id="Campus-Experience"><a href="#Campus-Experience" class="headerlink" title="Campus Experience"></a>Campus Experience</h2><p><em>Commissary in charge of studies, School of Automotive &amp; Transportation Engineering, Hefei University of Technology (2016-2020)</em></p><ul><li>Responsible for the study management in class and communicate with teachers to arrange experimental courses</li><li>Planning and hosting the meeting for exchange of learning experience, responsible for inviting outstanding graduates to give speeches and more than 300 college students participate in the Event</li></ul><h2 id="Social-Practice-Experience"><a href="#Social-Practice-Experience" class="headerlink" title="Social Practice Experience"></a>Social Practice Experience</h2><p><em>Support Teacher of Feng huang primary school, Chaohu, Anhui Province (2017)</em></p><ul><li>As a math teacher and physical education teacher for primary school students, spent a pleasant and meaningful summer with them</li><li>Planted the seeds of learning and encouraged them to explore the world</li><li>Increased responsibilities and accountability through communication with primary school students</li></ul><h2 id="Awards"><a href="#Awards" class="headerlink" title="Awards"></a>Awards</h2><ul><li>Second-class scholarship(2x) and Third-class scholarship in Hefei University of Technology </li><li>Outstanding student cadres in HFUT</li><li>Excellent graduation project for Bachelor’s degree</li><li>No.7 of men’s team competition in the National Student Shuttlecock Championship College group </li></ul><h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul><li>CET-6</li><li>Familiar with C/C++, Python</li><li>Familiar with the Linux operating system</li></ul><h2 id="Self-evaluation"><a href="#Self-evaluation" class="headerlink" title="Self-evaluation"></a>Self-evaluation</h2><p>I am an optimistic and positive person and interested in the emergence of new things and new ideas. I can set goals with others and accomplish them through the power of teamwork and communication. My main research interest is computer vision and deep learning,  and I have an understanding of machine learning, sensor fusion and computer science.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156/"/>
      <url>/posts/4a17b156/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="52444d4cb1ffc588615b9d0abc49282209d3ebce20a5bcf437b678a72bf16e52">1b693c4938223286468132b2f7068bf6098157620d78df6a8d32bb51e3f325b181ab70623eeb2a3f7a6bc681afafbdfe713bdd1c6f193890fe2449d416193fec46af80b0cd7431187dd1f97bc499b3a9ff9add79cea27c3015bb48123e899a7fb3295784c80b5d0b121aef398aca2f36d3661e78c54305f10d7d8f9de07de7e9a370641812f840a8f68bb7686e6e75bf5aaa69b4f328fe94d17a00647b6bdeefac5ff68db076f26d217b7be239abd3dad05c88857aa0945ec9bbce8c501724e9cddcda090e0b5dd17670bc5b0aa146e5c15ead49d5bedec7e2d0ba426f9bac50c6fb7f935f8a01d86b0fb15bfc31774d8b2e748468978a57c9f314cf3474a8908c962e62d793d4202cc789c89f172859f6c45d905ca5828e4fcc14dcd0b72bc60fed7d44f9e29b4be00939342e416c9e56c67e04b79fdec1dcef56c7602d391c51365f0885c5f1e7daa21ef5f34ec737ba851e91be020d6b473ff53dc5082093a33f1899d7be4ed55ecb8a865ada024c8a8ccf66b6e0c51f2843e1248a0f483d118e82308bd4ea916657024bf2c31a5fb01da6ef08a8316c44e217bc4792319d995741257cca7ddaab847de991c6537d986a79b83e8cee1d44c948ed237bbcc65fe83890021b84452bd350bbc4b8eace2cf7b56a5ee838ce3f76d847cd9b091176a88ddd8759125c5ef6f3a128951a6a60b4eb9b3000103e3fc21e28fefb5237e8dff0724bbe862d7bd8b9bf0bed10f0b85b68b8267130266e872060622d62bcab8182471f42324384a307a3f7cf68a591c3e5123d7d983dde563a046f30df65686ba53da8448fba75896080e1fc7bfc6685c2bd7cd91d28907af15fdc166854210f6d488a3c62336376333997a4440bd58288eeb52b359fd4fa62455ee3f5f10c53851924baa240880212ebf3801c2f496b21c0fb67bddddc6b3884e9dca3b6f3742e05f59e3fb3035436dce19683e5ecbb48d4df737592b11ece81856380177c37c7309f768d3b64c48649aa82ebe5d29649bdba9af2df082e771827d4835afab8fe8e69b87e8b2404de6c41cc60fa45c843bf89bc83d73d1a8b7d55dc6f00f0e1e9480890bf6a324e584fc0c45ae457e9031622981ee83f0f275eb5682b05f2cd81b5f6b4776c9f3b90bf1857e78a3ea5bb4c83a4654de516eadfd438a5f4d9c25c2e48b6d7fead8c1cedb027faf44d8d9ce375ffc87532cc56f002835e0e55b75b96dad4592e56417416aaa6d22e08af6e5c565e005c516dfe25927804e35c11ed470916d60e9e941489205c98c96a1c888ec4fcabf2cd59cf7ed77d51cb5d4b8aa1a0837099b37341d56b907e8ddeec5e34bff8bbefffa2c864d1ef7de812c4e874d2b420505ae8e4416dd9a33cd3713be4adbe572af303bc6904b8a281f9df07fd21b063fc85f7540f2b44976f593cbd622314605f4e2e391b20c0ea22f3895d13e668c979815c9bdfda25095fb79ef6c023139f1d0f3acf0ab15ef22a6373a11b906fb98209de8a83f85444cb96081129e2c7c8421791beecabb01241aa70f09346209d23bfe18d60338ba3abb4792d594197c9abc95d1d962a49bbc34c25e156e252f6510f8441a614bea22f2f7116575536cd4d2b8f12df6d82d2d65026003aa1cd2996ddd6c1d93fd308591391dd88d7d70cca7d5f9fea6f9500b11312df71132d053f8da3910d17eb455a1dd11462bd65159ecc86cfb61b3f130c2f1be650e86328833e99d8d121a1a5632a250b3ab29980d598255adab11607e9da1b5156f399c285e3d748d84aa460fc4b3c71d8120e0d056fa0707e1d876213ddcefae8b856a0a8384b037dfc6ed753ac31508f19bd2321a9da8adb4b9fbbd3e28be1d495e338871e63b948a663665d9671a349abbc5aa7d895e794785302d5260eede14246baa774210d9d0fea4bf36853a865a781b35c8c482b46675e2ef1161d78856120df62ab968a5e8726f7d58f7f4d7824daff425475d82858438b9a4d06ede3f489262c13637eab07914138236b60f73ebef728d93aa59e789a6c21e4868886308f79701a80cce6098a7d050424f478e9151a87e9de5c53b3c2bc81b15b601a40ac452486f1149a6af9d4f70d4dbb9cc233e8cc2703e8bf13aa35a4fca77bcb9cec9e6f1195475ac4af9952e31a4319c1ad417666c224efa7eb95a7f957cffa0541af71a66bdb3759cf72a3bca8bbb5036ebf135ee0f0ad0fcc1170aefc5c9881466f69582a0bd565161355fc447fc0121359014e08b1533f1c896eedef7e15e3c770fe2c2f4068bdae19fc24d286ec5fd0f0925586cb2b481031bded5c5e1ff5fcc581d17df686aca3266e519cbb70c9189e4145ff103d5facc16bf1d9f7660967180fe8795f400729b8422768e0af1b32dfbdbe6414a5b94b593247c2cb2c9b10ec80be7d55726ded5c724c7c8ce4f2a76ca5021331ba0286ae6b94c3fb0b137d2b826ad083f4c2d1e1ae70fcbb8fe81d638464af4d326d60b621db96b26194ab2fb1fcb2913b0634ac96c2e9a62baaaf0816cc903f1a5e96c6db24c9217efa7494bc43e85cc8016ac2cb7e31b7b63fbebcd70b47ea05a756893dd823673bd077b20bd5bf23ba92ebfc0556679994403d835e852da90fbaf894e326028fe892fc04fe5b32d965877af6b24e4f3f924e54a3d3cbf4518c36662dca2cb4afaefbe8600cb747e49e0e2212149a02961e3a9cecd985188fcb7217e7fe08172a65d854b5aa33a7365a6c28cb1ad4a2e05de66c8c404f1a39f3ee5d858d42c0d5f9276b6ce0c28190d7db0b3c8606f1c420e17d74e241c44756c9aff1789827b3a00b20d0d87f7f2ac159df12d8389c7eed139660934d7be7bb284f7529fb1e8bb000685742a6a1bff1bf41a0cbc05736e8fcec2428f54bcc6570c75cc89fc2894d87e0f1c5e64750f197b02fca53580902f57818e9e08988555ea17ff42bb449dd547e955ce96f2fe96eaa09708b4dde5098748432d8ea7491ad60e20930453b941a79c0f6ce9721cb6f34e915abc5e8be238e448d573d435ba3ba7f04efabd82896385e9747a56a5f2fd83fb874031ca98abe25cd3f5059a05b7242ef1147aad5dba834d3eefac1e0d04b36b8b2c6fca0bb35349ab66544cd487b47ca08d12da5a2a443129b16b4326f17b5d94d3787e2d4a3110f2bbb3aab5078e00cdc3ddcb1327d98763f419487ec2f2535</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
