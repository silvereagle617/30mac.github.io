<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Zhang-Tong-CV</title>
    <url>/posts/676dd596/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<table>
    <tr>
        <td width="80%">
            <table>
                <tr>                    
                    <td align="left"><b>Master</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>School of Mechanical & Automotive Engineering, South China University of Technology</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Mail: zt_scut@163.com</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Phone: +1 ‪(971) 373-7549‬</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Address: 381 Wushan Road, Tianhe District, Guangzhou,Guangdong, China</b></td>
                </tr>                
            </table>
        </td>
        <td width="30%" height="100%">
            <img src="/images/image-20220306.jpg">
        </td>
    </tr>
</table>




<h2 id="Educational-Qualification"><a href="#Educational-Qualification" class="headerlink" title="Educational Qualification"></a>Educational Qualification</h2><ul>
<li><strong>Master</strong> in Vehicle Engineering(2023)<br>South China University of Technology,Guangzhou, China</li>
<li><strong>B.Eng</strong> in Vehicle Engineering(2020)<br>Hefei University of Technology, China</li>
</ul>
<h2 id="Project-amp-Internship-Experience"><a href="#Project-amp-Internship-Experience" class="headerlink" title="Project &amp; Internship Experience"></a>Project &amp; Internship Experience</h2><p><em>Software Testing Engineer Intern in Kaizeli Technology Co. ,Ltd. (2020.07-2020.09)</em></p>
<ul>
<li>Write test scripts according to requirements documents, using Linux command and shell language</li>
<li>Responsible for the on-board OTA and IVI module testing projects, complete the test unit and upload test reports</li>
<li>Participated in the project of automated test platform, and improve the design of the testing interface, carry out a detailed needs analysis and use case design. </li>
</ul>
<p><em>Software Testing Engineer Intern in GAC R&amp;D Center. (2020.10—2020.12)</em></p>
<ul>
<li>Understand the principle of CAN communication, and using CAN communication tools,  such as Vehicle-Spy、KVaser, to sample the test signal </li>
<li>Carry out on-board system function module test, and complete data detection, calibration, log acquisition and analysis</li>
<li>Participate in on-board system test of multiple models, and update test cases according to requirements and feedback</li>
</ul>
<p><em>Software Design Engineer Intern in Shenzhen Lan-You Technology Co. ,Ltd. (2021.08-2021.11)</em></p>
<ul>
<li>Assisted in the implementation of simulation software of automatic vehicle, design test scenarios in ACC、AEB、LKA , complete design documents and scenario scripts</li>
<li>Responsible for the parking area map design and visualization, compile the program scripts for parsing XML files, and using QT software for visual display</li>
<li>Complete the preliminary project and generate 858 test scenario scripts totally,  and  using the  parking area visualization program to help verify the reliability of map file data</li>
</ul>
<h2 id="Research-Experience"><a href="#Research-Experience" class="headerlink" title="Research Experience"></a>Research Experience</h2><ul>
<li>Participate in the Innovation training program for college students in Anhui Province 2018, Intelligent lane changing auxiliary system Based on longitudinal and lateral dynamic control,  responsible for building vehicle dynamics model and using CarSim software for simulation</li>
<li>Participate in the Innovation training program for college students in Anhui Province 2019, Design and motion control of multi-mode reconfigurable for self-driving vehicle, responsible for help generate physical model using Catia drawing software, and Assisted in the implementation of the printed circuit board design</li>
<li>Research on driver fatigue detection method based on facial features, the graduation project, used CNN for facial landmarks detection and a pre-trained network for training on the data set, using SVM algorithm to generate model of facial fatigue feature classification </li>
</ul>
<h2 id="Campus-Experience"><a href="#Campus-Experience" class="headerlink" title="Campus Experience"></a>Campus Experience</h2><p><em>Commissary in charge of studies, School of Automotive &amp; Transportation Engineering, Hefei University of Technology (2016-2020)</em></p>
<ul>
<li>Responsible for the study management in class and communicate with teachers to arrange experimental courses</li>
<li>Planning and hosting the meeting for exchange of learning experience, responsible for inviting outstanding graduates to give speeches and more than 300 college students participate in the Event</li>
</ul>
<h2 id="Social-Practice-Experience"><a href="#Social-Practice-Experience" class="headerlink" title="Social Practice Experience"></a>Social Practice Experience</h2><p><em>Support Teacher of Feng huang primary school, Chaohu, Anhui Province (2017)</em></p>
<ul>
<li>As a math teacher and physical education teacher for primary school students, spent a pleasant and meaningful summer with them</li>
<li>Planted the seeds of learning and encouraged them to explore the world</li>
<li>Increased responsibilities and accountability through communication with primary school students</li>
</ul>
<h2 id="Awards"><a href="#Awards" class="headerlink" title="Awards"></a>Awards</h2><ul>
<li>Second-class scholarship(2x) and Third-class scholarship in Hefei University of Technology </li>
<li>Outstanding student cadres in HFUT</li>
<li>Excellent graduation project for Bachelor’s degree</li>
<li>No.7 of men’s team competition in the National Student Shuttlecock Championship College group </li>
</ul>
<h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul>
<li>CET-6</li>
<li>Familiar with C/C++, Python</li>
<li>Familiar with the Linux operating system</li>
</ul>
<h2 id="Self-evaluation"><a href="#Self-evaluation" class="headerlink" title="Self-evaluation"></a>Self-evaluation</h2><p>I am an optimistic and positive person and interested in the emergence of new things and new ideas. I can set goals with others and accomplish them through the power of teamwork and communication. My main research interest is computer vision and deep learning,  and I have an understanding of machine learning, sensor fusion and computer science.</p>
]]></content>
  </entry>
  <entry>
    <title>操作系统笔记01</title>
    <url>/posts/80d55e53/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="OS概述"><a href="#OS概述" class="headerlink" title="OS概述"></a>OS概述</h1><h2 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h2><p><strong>操作系统的两个职责：</strong></p>
<ul>
<li><p><strong>对硬件进行管理与抽象</strong></p>
<ul>
<li><p>管理硬件：内存分配、设备驱动</p>
</li>
<li><p>对硬件进行抽象：将有限的、离散的资源高效地抽象为无限的、连续的资源。将硬件通过易用的接口提供给上层的</p>
<p>应用，从而使应用无须关心硬件的具体细节。</p>
</li>
</ul>
</li>
<li><p><strong>为应用提供服务并管理</strong></p>
<ul>
<li>服务于应用：提供接口（如系统调用），不同类型的访问控制、应用间交互等服务</li>
<li>管理应用：应用生命周期管理，包括应用的加载、启动、切换、调度、销毁等。</li>
</ul>
</li>
</ul>
<p>狭义的OS：操作系统内核 + Shell(命令行界面)</p>
<p>广义的OS：</p>
<ul>
<li><strong>操作系统内核</strong>（对硬件资源的管理与抽象，为操作系统框架提供基础的系统服务）</li>
<li><strong>操作系统框架</strong>（基于操作系统内核提供的服务，为不同的应用领域提供编程接口与运行环境）</li>
</ul>
<p>OS发展历史：</p>
<p>批处理操作系统 -&gt; 分时处理操作系统（UNIX), shell命令行交互 -&gt; 个人PC（macOS/Windows），人机交互更好</p>
<h2 id="操作系统接口"><a href="#操作系统接口" class="headerlink" title="操作系统接口"></a>操作系统接口</h2><ul>
<li><strong>系统调用接口</strong> 向内核申请服务</li>
<li><strong>POSIX接口</strong> 可移植操作系统接口，通常通过C library（libc）来实现。</li>
<li><strong>领域应用接口</strong> 封装面向不同领域的领域应用接口</li>
</ul>
<h2 id="硬件结构"><a href="#硬件结构" class="headerlink" title="硬件结构"></a>硬件结构</h2><p>计算机硬件结构主要为<strong>冯·诺伊曼结构</strong></p>
<ul>
<li>中央处理器 CPU</li>
<li>存储器（内存）</li>
<li>输入输出 I/O</li>
</ul>
<p>CPU缓存，比物理内存访问速度快。</p>
<p><img src="/OS-1/image-20220527155653122.png" alt="image-20220527155653122"></p>
<p>设备与中断</p>
<p>内存映射输入输出 MIMO：</p>
<p>把输入输出设备和物理内存放到同一个地址空间，为设备内部的内存和寄存器也分配相应的地址。</p>
<p>轮询与中断</p>
<p>让CPU不断通过MIMO查看是否有输入，但会使CPU长时间处于等待状态造成浪费。</p>
<p>获得输入后，向CPU发送一个中断。</p>
<p>MMIO使得CPU可以主动地访问设备,中断使得设备能够主动地通知CPU，这两种机制是CPU与设备之间交互的重要方式。</p>
<p>内存</p>
<p><img src="/OS-1/image-20220527231741888.png" alt="image-20220527231741888"></p>
<h3 id="进程-Process"><a href="#进程-Process" class="headerlink" title="进程 Process"></a>进程 Process</h3><p>与每个进程相关的是<strong>地址空间</strong></p>
<p>地址空间中存放可执行程序、程序所需要的数据和栈</p>
<p>进程可以看作是容纳运行一个程序所有信息的容器</p>
<p><strong>进程表：</strong> 数组或链表结构，存放进程信息</p>
<p>进程树：一个进程可以创建多个进程（子进程），树形结构</p>
<p>系统管理器授权每个进程一个给定的UID，子进程与父进程拥有一样的UID</p>
<h3 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h3><p>管理进程，每个进程有一些可以使用的地址集合，典型值从0开始直到某个最大值。一个进程可以拥有的最大地址空间小于主存。</p>
<p>虚拟内存：操作系统把部分地址空间装入主存，部分留在磁盘上，并在需要的时候交换回来</p>
<h3 id="文件"><a href="#文件" class="headerlink" title="文件"></a>文件</h3><p>抽象文件模型</p>
<p>创建文件、删除文件、读和写文件 都需要系统调用。</p>
<p><strong>文件描述符：</strong> 读写文件前，检查权限可以打开，系统返回一个小整数，供后续操作使用；若禁止使用返回一个错误码</p>
<p><strong>管道：</strong> 一种虚文件，可以连接两个进程</p>
<p><img src="/OS-1/image-20220528171527111.png" alt="image-20220528171527111"></p>
<h3 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h3><p>操作系统的两大功能：</p>
<ul>
<li>为用户提供应用程序抽象</li>
<li>管理计算机资源</li>
</ul>
<p>只有<strong>系统调用能够进入内核态而过程调用则不能进行内核态</strong></p>
<h4 id="用于进程管理的系统调用"><a href="#用于进程管理的系统调用" class="headerlink" title="用于进程管理的系统调用"></a>用于进程管理的系统调用</h4><p>UNIX中唯一可以在POSIX中创建进程的途径：fork</p>
<p>fork调用返回一个值，在子进程中为0，在父进程中等于子进程的进程标识符PID。使用返回的PID可以看出哪个是父进程和子进程。</p>
<p>POSIX：可移植操作系统接口</p>
<p>waitpid系统调用：为等待子进程完成，父进程执行waitpid</p>
<p>execve系统调用：实现系统执行，三个参数：将要执行的文件名称、一个指向变量数组的指针、一个指向环境数组的指针。</p>
<p>一个shell指令：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp file1 file2</span><br></pre></td></tr></table></figure>

<p>此命令将file1复制到file2文件中，在shell执行fork之后，子进程定位并执行文件拷贝，将将源文件和目标文件的名称传递给它。</p>
<p>cp的主程序包含声明：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="built_in">main</span>(agrc, argv, envp)</span><br></pre></td></tr></table></figure>

<p>argc：命令行中参数数目的计数，包括程序名称。对于上面的例子，argc是3。</p>
<p>argv：数组的指针，该数组的元素i为第i个字符串的指针，例如，argc[0]指向字符串cp，argc[1]指向字符串file1，argc[2]指向字符串file2。</p>
<p>envp：指向环境的指针，该环境是一个数组，含有name = value的赋值形式，例子中，没有环境参数传递给execve，所以execve的第三个参数为0。</p>
<p>UNIX中的进程将内存划分为三部分：</p>
<ul>
<li>text segment，文本区，例如程序代码</li>
<li>data segment，数据区，例如变量</li>
<li>stack segment，栈区域，数据向上增长而堆栈向下增长。</li>
</ul>
<img src="/posts/80d55e53/image-20220529153518116.png" alt="image-20220529153518116" style="zoom:35%;">

<h4 id="用于文件管理的系统调用"><a href="#用于文件管理的系统调用" class="headerlink" title="用于文件管理的系统调用"></a>用于文件管理的系统调用</h4><p>与某个文件有关的系统调用</p>
<p>常用的调用read和write</p>
<p>UNIX为每个文件保存了该文件的类型、大小、最后修改时间以及其他信息，程序可以通过stat系统调用查看这些信息。</p>
<h4 id="用于目录管理的系统调用"><a href="#用于目录管理的系统调用" class="headerlink" title="用于目录管理的系统调用"></a>用于目录管理的系统调用</h4><p>与整个文件系统有关的系统调用</p>
<p>mkdir和rmdir分别用于创建和删除空目录。</p>
<p>mount系统调用将两个文件系统合并为一个。</p>
<h4 id="其他系统调用"><a href="#其他系统调用" class="headerlink" title="其他系统调用"></a>其他系统调用</h4><p>chdir调用更改当前工作目录</p>
<p>chmod系统调用提供改变文件模式的操作</p>
<p>UNIX与Win32系统调用API</p>
<table>
<thead>
<tr>
<th>UNIX</th>
<th>Win32</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>fork</td>
<td>CreateProcess</td>
<td>创建一个进程</td>
</tr>
<tr>
<td>waitpid</td>
<td>WaitForSingleObject</td>
<td>等待一个进程退出</td>
</tr>
<tr>
<td>execve</td>
<td>none</td>
<td>CraeteProcess = fork + service</td>
</tr>
<tr>
<td>exit</td>
<td>ExitProcess</td>
<td>终止执行</td>
</tr>
<tr>
<td>open</td>
<td>CreateFile</td>
<td>创建一个文件或打开一个已有的文件</td>
</tr>
<tr>
<td>close</td>
<td>CloseHandle</td>
<td>关闭文件</td>
</tr>
<tr>
<td>read</td>
<td>ReadFile</td>
<td>从单个文件中读取数据</td>
</tr>
<tr>
<td>write</td>
<td>WriteFile</td>
<td>向单个文件中写数据</td>
</tr>
<tr>
<td>lseek</td>
<td>SetFilePointer</td>
<td>移动文件指针</td>
</tr>
<tr>
<td>stat</td>
<td>GetFileAttributesEx</td>
<td>获得不同的文件属性</td>
</tr>
<tr>
<td>mkdir</td>
<td>CreateDirectory</td>
<td>创建一个新的目录</td>
</tr>
<tr>
<td>rmdir</td>
<td>RemoveDirectory</td>
<td>移除一个空的目录</td>
</tr>
<tr>
<td>link</td>
<td>none</td>
<td>Win32不支持link</td>
</tr>
<tr>
<td>unlink</td>
<td>DeleteFile</td>
<td>销毁一个已有的文件</td>
</tr>
<tr>
<td>mount</td>
<td>none</td>
<td>Win32不支持mount</td>
</tr>
<tr>
<td>umount</td>
<td>none</td>
<td>Win32不支持mount</td>
</tr>
<tr>
<td>chdir</td>
<td>SetCurrentDirectory</td>
<td>切换当前工作目录</td>
</tr>
<tr>
<td>chmod</td>
<td>none</td>
<td>Win32不支持安全</td>
</tr>
<tr>
<td>kill</td>
<td>none</td>
<td>Win32不支持信号</td>
</tr>
<tr>
<td>time</td>
<td>GetLocalTime</td>
<td>获取当前时间</td>
</tr>
</tbody></table>
<h3 id="操作系统结构"><a href="#操作系统结构" class="headerlink" title="操作系统结构"></a>操作系统结构</h3><ul>
<li>单体系统</li>
<li>分层系统</li>
<li>微内核</li>
<li>客户-服务端系统</li>
<li>虚拟机</li>
<li>外核</li>
</ul>
<h4 id="单体系统"><a href="#单体系统" class="headerlink" title="单体系统"></a>单体系统</h4><p>整个系统在内核态以单一程序的方式运行</p>
<p>整个操作系统是以程序集合来编写的，链接在一块形成一个大的二进制可执行文件</p>
<p>在单体系统中构造实际目标程序时，会首先编译所有单个过程（或包含这些过程的文件），然后使用系统链接器将它们全部绑定到一个可执行文件中。</p>
<p>三层模型：</p>
<ul>
<li>主程序：调用请求服务程序</li>
<li>服务程序：执行系统调用</li>
<li>实用程序：辅助服务过程调用</li>
</ul>
<h4 id="分层系统"><a href="#分层系统" class="headerlink" title="分层系统"></a>分层系统</h4><p>使用层来分隔不同的功能单元，每一层只与该层的上层和下层通信。</p>
<p>每一层都使用下面的层来执行其功能，层之间的通信通过预定义的固定接口通信。</p>
<table>
<thead>
<tr>
<th>层号</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>5</td>
<td>操作员</td>
</tr>
<tr>
<td>4</td>
<td>用户程序</td>
</tr>
<tr>
<td>3</td>
<td>输入/输出管理</td>
</tr>
<tr>
<td>2</td>
<td>操作员-进程通信</td>
</tr>
<tr>
<td>1</td>
<td>存储器和磁鼓管理</td>
</tr>
<tr>
<td>0</td>
<td>处理器分配和多道程序编程</td>
</tr>
</tbody></table>
<h4 id="微内核"><a href="#微内核" class="headerlink" title="微内核"></a>微内核</h4><p>微内核运行在内核态，其余模块可以作为普通用户进程运行。</p>
<img src="/posts/80d55e53/image-20220529222250168.png" alt="image-20220529222250168" style="zoom:60%;">

<p>机制与策略分离，比如系统调度，一个简单的调度算法是对每个进程赋予优先级，让内核执行优先级最高的进程。内核的机制是寻找最高的优先级进程并运行，而策略（赋予进程优先级）可以在用户态中的进程完成。策略与机制分离，使得内核变得更小。</p>
<h4 id="客户-服务器模式"><a href="#客户-服务器模式" class="headerlink" title="客户-服务器模式"></a>客户-服务器模式</h4><p>把进程划分为两类：</p>
<ul>
<li>服务器，每个服务器用来提供服务</li>
<li>客户端，使用这些服务</li>
</ul>
<img src="/posts/80d55e53/image-20220529222837516.png" alt="image-20220529222837516" style="zoom:67%;">

<p>两种载体：</p>
<ul>
<li>计算机既是客户端又是服务器</li>
<li>客户端与服务器在不同机器上（普遍情况），通过局域网或广域网连接</li>
</ul>
<p>客户端发送请求并得到回应。</p>
<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><p>进程：对正在运行中的程序的抽象，操作系统最核心的概念。</p>
<p><strong>伪并发</strong>：单核或多核处理器同时执行多个进程，从而使程序更快。以非常有限的时间间隔在程序之间快速切换CPU。</p>
<p>缺点是CPU时间可能分配给下一个进程，也可能不分配给下一个进程。</p>
<h3 id="进程模型"><a href="#进程模型" class="headerlink" title="进程模型"></a>进程模型</h3><p>计算机上运行的软件包括操作系统，被组织为若干<strong>顺序进程</strong> </p>
<p>进程包括：程序计数器、寄存器、变量的当前值</p>
<p>在进程不断切换的过程中，程序计数器也在不同的变化</p>
<img src="/posts/80d55e53/image-20220530113613610.png" alt="image-20220530113613610" style="zoom:67%;">

<p>任何一个给定的瞬间仅有一个进程真正运行</p>
<p>一个CPU只能真正一次运行一个进程的时候，即使有2个核（或CPU），每一个核也只能一次运行一个线程。</p>
<h3 id="进程的创建"><a href="#进程的创建" class="headerlink" title="进程的创建"></a>进程的创建</h3><ul>
<li>系统初始化（init)</li>
<li>正在运行的程序执行了创建进程的系统调用（比如fork）</li>
<li>用户请求创建一个新进程</li>
<li>初始化一个批处理工作</li>
</ul>
<h4 id="系统初始化"><a href="#系统初始化" class="headerlink" title="系统初始化"></a>系统初始化</h4><p>前台进程：同用户进行交互并替他们完成工作的进程</p>
<p>守护进程：进程运行在后台用来处理一些活动如Email、web网页、打印等</p>
<p>UNIX中，ps程序可以列出正在运行的进程，Windows中使用任务管理器</p>
<h4 id="系统调用创建"><a href="#系统调用创建" class="headerlink" title="系统调用创建"></a>系统调用创建</h4><p>一个正在运行的进程会发出系统调用，用来创建一个或多个新进程来帮助其完成工作。</p>
<p>多处理器中，每个进程运行在不同的CPU上可以使工作更快。</p>
<p>UNIX中，仅有一个系统调用可以创建一个新进程：<strong>fork</strong> ，该调用会创建一个与调用进程相关的副本。</p>
<h4 id="用户请求创建"><a href="#用户请求创建" class="headerlink" title="用户请求创建"></a>用户请求创建</h4><p>交互式系统中，输入一个命令或双击图标可以启动程序，这些操作可以选择开启一个新的进程。</p>
<p>新进程将接管启动它的窗口，每个窗口都可以运行进程。</p>
<h3 id="批处理创建"><a href="#批处理创建" class="headerlink" title="批处理创建"></a>批处理创建</h3><p>大型机的批处理系统</p>
<p>用户提交批处理作业，当操作系统决定它有资源来运行另一个任务时，将创建一个新进程并从其中的输入队列中运行下一个作业。</p>
<h3 id="进程的终止"><a href="#进程的终止" class="headerlink" title="进程的终止"></a>进程的终止</h3><ul>
<li>正常退出（自愿的）</li>
<li>错误退出（自愿的）</li>
<li>严重错误（非自愿的）</li>
<li>被其他进程杀死（非自愿的）</li>
</ul>
<h4 id="正常退出"><a href="#正常退出" class="headerlink" title="正常退出"></a>正常退出</h4><p>多数进程是由于完成了工作而终止</p>
<p>UNIX调用是exit。</p>
<h4 id="错误退出"><a href="#错误退出" class="headerlink" title="错误退出"></a>错误退出</h4><p>例如编译foo.c 但是该文件不存在，编译器会发出声明并退出。</p>
<p>通常会弹出对话框告知用户发生系统错误</p>
<h4 id="严重错误"><a href="#严重错误" class="headerlink" title="严重错误"></a>严重错误</h4><p>通常由于程序中的错误导致。例如，执行了一条非法指令，引用不存在的内存，除数为0等。</p>
<p>UNIX中，这类错误，进程会收到信号（中断），而不是在这类错误出现时直接终止进程</p>
<h4 id="被其他进程杀死"><a href="#被其他进程杀死" class="headerlink" title="被其他进程杀死"></a>被其他进程杀死</h4><p>UNIX中调用kill，某个进程执行系统调用告诉操作系统杀死某个进程。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>每个进程是一个独立的实体，有其自己的程序计数器和内部状态。</p>
<p>进程之间需要相互帮助，例如，一个进程的结果可以作为另一个进程的输入</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cat chapter1 chapter2 chapter3 | grep tree</span><br></pre></td></tr></table></figure>

<p>第一个进程cat，将三个文件级联并输出。</p>
<p>第二个进程grep，从输入中选取包含有关键字tree的内容。</p>
<p>可能出现grep准备就绪开始执行，但是输入还未完成，于是必须阻塞grep进程，直到输入完毕。</p>
<p>进程状态的切换：</p>
<img src="/posts/80d55e53/image-20220530160754572.png" alt="image-20220530160754572" style="zoom:50%;">

<p>进程状态有三种：</p>
<ul>
<li><strong>运行态</strong>：进程实际占用CPU时间片运行时</li>
<li><strong>就绪态</strong>：可运行，但因为其他进程正在运行而处于就绪状态</li>
<li><strong>阻塞态</strong>：除非某种外部事件发生，否则进程不能运行</li>
</ul>
<p>运行态与就绪态很相似，都表示进程可运行，区别在于就绪状态没有获得CPU时间分片。</p>
<p>阻塞态与前两个不同，进程不能运行，CPU空闲时也不能运行。</p>
<p>在操作系统发现进程不能继续执行时发生转换1，某些系统执行系统调用如pause，获取一个阻塞的状态。UNIX中，当进程从管道或特殊文件（如终端）中读取没有可用的输入时，该进程自动终止。</p>
<p>转换2和3由进程调度程序引起。</p>
<p>进程等待一个外部事件发生（如从外部输入一些数据后），发生转换4；若此时没有其他进程在运行，则立即触发转换3，该进程开始运行，否则该进程处于就绪阶段，等待CPU空闲后再轮到它运行。</p>
<p><strong>操作系统最底层的就是调度程序。</strong>所有关于中断处理、启动进程和停止进程的具体细节都隐藏在调度程序中。</p>
<h3 id="进程的实现"><a href="#进程的实现" class="headerlink" title="进程的实现"></a>进程的实现</h3><p><strong>进程表</strong> 进程状态的重要信息，包括程序计数器、堆栈指针、内存分配状态、所打开文件的状态、调度信息，以及其他在进程由运行态转换到就绪态或阻塞态时所必须保存的信息，从而保证该进程随后可以再次启动，就像从未中断过一样。</p>
<p>关键字段：</p>
<ul>
<li>进程管理</li>
<li>存储管理</li>
<li>文件管理</li>
</ul>
<h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="线程模型"><a href="#线程模型" class="headerlink" title="线程模型"></a>线程模型</h3><p>线程thread，线程也会有程序计数器、寄存器、堆栈。</p>
<p>进程用于把资源集中到一起，<strong>线程是CPU上调度执行的实体</strong>。</p>
<p>线程比进程创建快。</p>
<p>线程不像进程那样有较强的独立性。由于每个线程都可以访问进程地址空间的每个内存地址，因此<strong>一个线程可以读取、写入甚至擦除另一个线程的堆栈。</strong></p>
<img src="/posts/80d55e53/image-20220530234435504.png" alt="image-20220530234435504" style="zoom:50%;">

<p>线程的状态：运行中、阻塞、就绪和终止。线程之间的状态转换与进程之间的状态转换是一样的。</p>
<p>线程无法利用时钟中断强制让线程让出CPU。</p>
<p>线程创建：调用库函数，线程创建函数会要求指定新创建线程的名称，创建的线程通常会返回一个线程标识符，该标识符就是新线程的名字。</p>
<h3 id="线程实现"><a href="#线程实现" class="headerlink" title="线程实现"></a>线程实现</h3><p>主要三种实现方式</p>
<ul>
<li>在用户空间中实现线程</li>
<li>在内核空间中实现线程</li>
<li>在用户和内核空间中混合实现线程</li>
</ul>
<h4 id="在用户空间中实现线程"><a href="#在用户空间中实现线程" class="headerlink" title="在用户空间中实现线程"></a>在用户空间中实现线程</h4><p>把整个线程包放在用户空间中，内核对线程一无所知，它不知道线程的存在。</p>
<img src="/posts/80d55e53/image-20220531103211795.png" alt="image-20220531103211795" style="zoom:50%;">

<p>运行时系统：也叫运行时环境，提供了程序在其中运行的环境。</p>
<p>线程在运行时系统之上运行，运行时系统是管理线程过程的集合。</p>
<p>每个进程需要有其专用的线程表，用来跟踪该进程中的线程。</p>
<p>优势：</p>
<ul>
<li>启动线程比内核调用效率更高，不需要切换到内核，也不需要上下文切换，不需要对内存高速缓存进行刷新，线程调用非常便捷，因此效率高</li>
<li>允许每个进程有自己定制的调度算法，用户线程具有较好的可扩展性。</li>
</ul>
<p>劣势：</p>
<ul>
<li>阻塞系统调用问题，使用线程的一个目标是能够让线程进行阻塞调用，并且要避免被阻塞的线程影响其他线程</li>
<li>缺页中断问题，如果某个程序发生函数调用或跳转指令到了一条不在内存的指令上，会发生页面故障，而操作系统将到磁盘上取回这个丢失的指令，称为缺页故障。</li>
<li>如果一个线程开始运行，该线程所在进程中的其他线程都不能运行，单进程内部没有时钟中断，不能使用轮转调度的方式调度线程。</li>
</ul>
<h4 id="在内核空间中实现线程"><a href="#在内核空间中实现线程" class="headerlink" title="在内核空间中实现线程"></a>在内核空间中实现线程</h4><p>不需要运行时环境，每个进程中也没有线程表，在内核中会有记录系统中所有线程的线程表。某个线程希望创建新线程或撤销一个已有线程，会执行一个系统调用，完成对线程表的更新。</p>
<img src="/posts/80d55e53/image-20220531104923664.png" alt="image-20220531104923664" style="zoom:50%;">

<p>所有能够阻塞的调用都会通过系统调用的方式来实现，当一个线程阻塞时，内核可以进行选择，例如运行同一个进程中的另一个线程或者运行另一个进程中的一个线程。</p>
<p>内核中创建或销毁线程的开销比较大，某些系统会采用可循环利用的方式来回收线程。当某个线程被销毁时，就把他标志为不可运行的状态，但其内部结构没有收到影响，稍后在创建一个新线程时，就会重新启用旧线程，标志为可用状态。</p>
<h3 id="混合实现"><a href="#混合实现" class="headerlink" title="混合实现"></a>混合实现</h3><p>内核级线程，将用户级线程与某些或全部内核线程多路复用起来。</p>
<img src="/posts/80d55e53/image-20220531115650409.png" alt="image-20220531115650409" style="zoom:50%;">

<p>编程人员可以自由控制用户线程和内核线程的数量，灵活度高。内核只识别内核级线程，对其进行调度，其中一些内核级线程会被多个用户级线程多路复用。</p>
<h2 id="进程间通信IPC"><a href="#进程间通信IPC" class="headerlink" title="进程间通信IPC"></a>进程间通信IPC</h2><p>三个问题：</p>
<ul>
<li>进程如何传递消息给其他进程</li>
<li>确保两个或多个线程之间不会相互干扰</li>
<li>数据的先后顺序问题</li>
</ul>
<h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><p>存在共享资源、共享文件、共享内存</p>
<p>两个或多个线程同时对一共享数据进行修改，从而影响程序运行的正确性。</p>
<p>如何避免：</p>
<p><strong>禁止一个或多个进程在同一时刻对共享资源（包括共享文件、共享内存等）进行读写。</strong></p>
<p>需要<strong>互斥条件</strong>。</p>
<h3 id="临界区"><a href="#临界区" class="headerlink" title="临界区"></a>临界区</h3><p>临界区（临界区域）：对共享内存进行访问的程序片。</p>
<p>使两个不同进程不可能同时处于临界区，就能避免竞争条件。</p>
<p>使用临界区的互斥</p>
<img src="/posts/80d55e53/image-20220531121115455.png" alt="image-20220531121115455" style="zoom:50%;">

<h3 id="忙等互斥"><a href="#忙等互斥" class="headerlink" title="忙等互斥"></a>忙等互斥</h3><h4 id="屏蔽中断"><a href="#屏蔽中断" class="headerlink" title="屏蔽中断"></a>屏蔽中断</h4><p>单核处理器，每个进程在进入临界区后立即<strong>屏蔽所有中断</strong>，并在离开临界区之前重新启用他们。屏蔽中断后CPU不会切换到其他进程。一旦某个进程屏蔽中断后，就可以检查和修改共享内存，而不担心其他进程介入访问共享数据。</p>
<p>屏蔽中断对于操作系统本身是一种有用的技术，但是对于用户线程来说，屏蔽中断不是一项通用的互斥机制。</p>
<h4 id="锁变量"><a href="#锁变量" class="headerlink" title="锁变量"></a>锁变量</h4><p>考虑有单个共享的锁变量，初始值为0。当一个线程想要进入关键区域时，会首先查看锁的值是否为0，如果锁的值为0，进程会把它设置为1并让进程进入关键区域；如果锁的状态为1，进程会等待直到锁变量的值为0。</p>
<p>锁变量值为0，表示没有线程进入关键区域，如果为1，表示有进程在关键区域内。</p>
<img src="/posts/80d55e53/image-20220606180447319.png" alt="image-20220606180447319" style="zoom:50%;">

<p>会发生竞争条件，临界区可能会有两个进程同时运行，set-before-check 不是一种原子性操作。</p>
<h4 id="严格轮询法"><a href="#严格轮询法" class="headerlink" title="严格轮询法"></a>严格轮询法</h4><p>先抛出一段代码，用c语言编写。</p>
<p>进程0的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">	<span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/* 进入关键区域*/</span> </span><br><span class="line"> 		critical_region();</span><br><span class="line"> 		turn = <span class="number">1</span>;</span><br><span class="line">		<span class="comment">/* 离开关键区域*/</span> </span><br><span class="line"> 		noncritical_region();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>进程1的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(TRUE)&#123;</span><br><span class="line">	<span class="keyword">while</span>(turn != <span class="number">0</span>)&#123;</span><br><span class="line">		<span class="comment">/* 进入关键区域*/</span> </span><br><span class="line"> 		critical_region();</span><br><span class="line"> 		turn = <span class="number">0</span>;</span><br><span class="line">		<span class="comment">/* 离开关键区域*/</span> </span><br><span class="line"> 		noncritical_region();</span><br><span class="line"> 	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>变量turn初始值为0，用于记录轮到哪个进程进入临界区，并检查或更新内存。</p>
<p>忙等待：连续检查一个变量直到某个值出现为止，但是这种方式浪费CPU时间，通常应该避免。</p>
<p>只有在有理由认为等待时间是非常短的情况下，才能使用忙等待。用于忙等待的锁，，称为自旋锁。</p>
<p>可能会出现违反 <strong>位于临界区外的进程不得阻塞其他进程</strong> 的情况，不算一个好的方案。</p>
<h3 id="互斥量"><a href="#互斥量" class="headerlink" title="互斥量"></a>互斥量</h3><p>互斥量mutex，一些共享资源和一段代码保持互斥。</p>
<p>两种状态：解锁和加锁。</p>
<p>当一个线程（或进程）需要访问关键区域时，会调用mutex_lock进行加锁。如果互斥锁处于解锁状态（表示关键区域可用），则调用成功，并且调用线程可以自由进入关键区域。</p>
<p>如果mutex互斥量已经锁定，调用线程会阻塞直到关键区域内的线程执行完毕并且调用了mutex_unlock。如果多个线程在mutex互斥量上阻塞，将随机选择一个线程并选择一个线程并允许它获得锁。</p>
]]></content>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>图论基础与拓补排序</title>
    <url>/posts/75bf15f1/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="图论基础"><a href="#图论基础" class="headerlink" title="图论基础"></a>图论基础</h2><h3 id="图的表示"><a href="#图的表示" class="headerlink" title="图的表示"></a>图的表示</h3><p>二元组G = &lt;V, E&gt;, V节点集，E边集；</p>
<p>节点的度：与该节点相关联的边数</p>
<p>分为：有向图、无向图</p>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><h4 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h4><p>一个一维数组存储图中节点的信息，一个二维数组存储图中节点之间的邻接关系。</p>
<p><strong>无向图：</strong></p>
<img src="/posts/75bf15f1/image-20220520174528197.png" alt="image-20220520174528197" style="zoom:80%;">

<p>特点：</p>
<ul>
<li><p>无向图的邻接矩阵是<strong>对称矩阵，并且是唯一的</strong>。</p>
</li>
<li><p>第i行或第i列非零元素的个数正好是第i个节点的度。上图中的邻接矩阵，第3列非零元素的个数为2，说明第3个节点c的度为2。</p>
</li>
</ul>
<p><strong>有向图：</strong></p>
<p>以尖括号&lt;vi, vj&gt;表示的是有序对，以圆括号(vi ,vj)表示的是无序对。</p>
<p>有向图的邻接矩阵不一定是对称的</p>
<img src="/posts/75bf15f1/image-20220520174937549.png" alt="image-20220520174937549" style="zoom:80%;">

<p>特点：</p>
<ul>
<li>有向图的邻接矩阵<strong>不一定是对称</strong>的。</li>
<li><strong>第i行非零元素的个数正好是第i个节点的出度，第i列非零元素的个数正好是第i个节点的入度。</strong>上图中的邻接矩阵，第3行非零元素的个数为2，第3列非零元素的个数也为2，说明第3个节点c的出度和入度均为2。</li>
</ul>
<p><strong>网（带权图）：</strong></p>
<img src="/posts/75bf15f1/image-20220520175300124.png" alt="image-20220520175300124" style="zoom:80%;">

<p><strong>邻接矩阵的优点：</strong></p>
<ul>
<li><p>快速判断在两节点之间是否有边。在图中，<code>Edge[i][j]=1</code>，表示有边；<code>Edge[i][j]=0</code>，表示无边。在网中，<code>Edge[i][j]=∞</code>，表示无边，否则表示有边。时间复杂度为O (1)。</p>
</li>
<li><p>方便计算各节点的度。在无向图中，邻接矩阵第i行元素之和就是节点i的度；在有向图中，第i行元素之和就是节点i的出度，第i列元素之和就是节点i的入度。时间复杂度为O(n)。</p>
</li>
</ul>
<p><strong>邻接矩阵的缺点：</strong></p>
<ul>
<li><p>不便于增删节点。增删节点时，需要改变邻接矩阵的大小，效率较低。</p>
</li>
<li><p>不便于访问所有邻接点。访问第i个节点的所有邻接点时，需要访问第i行的所有元素，时间复杂度为O(n)。访问所有节点的邻接点，时间复杂度为O(n^2)。</p>
</li>
<li><p>空间复杂度高，为O(n^2)。</p>
</li>
</ul>
<h4 id="邻接表"><a href="#邻接表" class="headerlink" title="邻接表"></a>邻接表</h4><p>邻接表是图的一种链式存储方法，其数据结构包括两部分：节点和邻接点。</p>
<ol>
<li>无向图</li>
</ol>
<p>一个节点的所有邻接点构成一个单链表。</p>
<p><img src="/20220520/image-20220520175923798.png" alt="image-20220520175923798"></p>
<p>无向图特点：</p>
<ul>
<li><p>如果无向图有n个节点、e条边，则节点表有n个节点，邻接点表有2e个节点。</p>
</li>
<li><p>节点的度为该节点后面单链表中的节点数。</p>
</li>
</ul>
<ol start="2">
<li>有向图</li>
</ol>
<p><img src="/20220520/image-20220520180303332.png" alt="image-20220520180303332"></p>
<p>对有向图中节点的邻接点，只看该节点的出边（出弧）。</p>
<p>有向图特点：</p>
<ul>
<li><p>如果有向图有n个节点、e条边，则节点表有n个节点，邻接点表有e个节点。</p>
</li>
<li><p>节点的出度为该节点后面单链表中的节点数。</p>
</li>
</ul>
<p>在有向图邻接表中很<strong>容易找到节点的出度</strong>，但是<strong>找入度很难，需要遍历所有邻接点表中的节点</strong>，查找到<strong>该节点出现了多少次，入度就是多少</strong>。</p>
<h2 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h2><p>参考多叉树，多叉树的遍历框架如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 多叉树遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">for</span> (TreeNode* child : root -&gt; children) &#123;</span><br><span class="line">		<span class="built_in">traverse</span>(child);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>图和多叉树最⼤的区别是，图是可能包含环的，你从图的某⼀个节点开始遍历，有可能⾛了⼀圈⼜回到这个 </p>
<p>节点。 </p>
<p>因此，遍历需要一个<code>visited</code>辅助数组，不走重复的节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于图的遍历，应该把<code>onPath</code>的操作放到for循环外⾯，否则会漏掉记录起始点的遍历。</p>
<p>如果图中不含有环，可以把<code>visited</code>数组省略。</p>
<p><a href="https://leetcode.cn/problems/all-paths-from-source-to-target/">797.所有可能路径</a></p>
<p>题目描述： </p>
<p>给你一个有 n 个节点的 有向无环图（DAG），请你找出所有从节点 0 到节点 n-1 的路径并输出（不要求按特定顺序） <code>graph[i]</code>是一个从节点 i 可以访问的所有节点的列表（即从节点 i 到节点 <code>graph[i][j]</code>存在一条有向边）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：graph = [[1,2],[3],[3],[]]</span><br><span class="line">输出：[[0,1,3],[0,2,3]]</span><br><span class="line">解释：有两条路径 0 -&gt; 1 -&gt; 3 和 0 -&gt; 2 -&gt; 3</span><br></pre></td></tr></table></figure>

<p>解析：</p>
<p>有向无环图，以0为起点开始遍历，同时记录走过的路径，当遍历到终点时将路径记录下来。</p>
<p>可以不使用visited数组辅助。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res; <span class="comment">//记录所有的路径</span></span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">allPathsSourceTarget</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph) &#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//维护递归过程中经过的路径</span></span><br><span class="line">    <span class="built_in">tranverse</span>(graph, path, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//图的遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">int</span>&gt;&amp; path, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//添加节点index到路径</span></span><br><span class="line">    path.<span class="built_in">push_back</span>(index);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (index == n - <span class="number">1</span>) &#123; </span><br><span class="line">        <span class="comment">//到达终点</span></span><br><span class="line">        res.<span class="built_in">push_back</span>(path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//递归每个相邻节点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, path, v);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//从路径移除节点index</span></span><br><span class="line">    path.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="判断图是否有环（图的遍历）"><a href="#判断图是否有环（图的遍历）" class="headerlink" title="判断图是否有环（图的遍历）"></a>判断图是否有环（图的遍历）</h2><p><a href="https://leetcode.cn/problems/course-schedule/">207.课程表</a></p>
<p>存在依赖问题，⾸先把问题转化成「有向图」这种数据结构，<strong>只要图中存在环，那就说明存在循环依赖</strong>。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：true</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 2, prerequisites = [[1,0],[0,1]]</span><br><span class="line">输出：false</span><br><span class="line">解释：总共有 2 门课程。学习课程 1 之前，你需要先完成​课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。</span><br></pre></td></tr></table></figure>

<p><strong>graph[index]</strong> 是⼀个列表，存储着节点 index 所指向的节点。 </p>
<p>先建图 + 遍历图判断是否存在环</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle = <span class="number">0</span>; <span class="comment">// 记录图中是否有环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//防止重复遍历同一节点</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>; <span class="comment">//记录当前走过的路径</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="comment">// 遍历图中的所有节点</span></span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, i, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 只要没有循环依赖可以完成所有课程</span></span><br><span class="line">    <span class="keyword">return</span> !hasCycle;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//建立图的邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    <span class="comment">//图中共有numCourses个节点</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to  = v[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 修完课程 from 才能修课程 to</span></span><br><span class="line">		<span class="comment">// 在图中添加⼀条从 from 指向 to 的有向边</span></span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited,vector&lt;<span class="keyword">bool</span>&gt;&amp; path, <span class="keyword">int</span> index, <span class="keyword">bool</span>&amp; hasCycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[index]) &#123; <span class="comment">//如果发现Path[index] 已经被标记说明出现了环</span></span><br><span class="line">        hasCycle = <span class="literal">true</span>; <span class="comment">//发现环</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[index] || hasCycle) &#123; </span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">//将节点index标记为已遍历</span></span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//开始遍历节点index</span></span><br><span class="line">    path[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, v, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//节点index遍历完成</span></span><br><span class="line">    path[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="拓补排序"><a href="#拓补排序" class="headerlink" title="拓补排序"></a>拓补排序</h2><p><a href="https://leetcode.cn/problems/course-schedule-ii/submissions/">210.课程表II</a></p>
<p>返回你为了学完所有课程所安排的学习顺序。可能会有多个正确的顺序，你只要返回 <strong>任意一种</strong> 就可以了。如果不可能完成所有课程，返回 <strong>一个空数组</strong> 。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：numCourses = 2, prerequisites = [[1,0]]</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 4, prerequisites = [[1,0],[2,0],[3,1],[3,2]]</span><br><span class="line">输出：[0,2,1,3]</span><br><span class="line">解释：总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。</span><br><span class="line">因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。</span><br><span class="line"></span><br><span class="line">输入：numCourses = 1, prerequisites = []</span><br><span class="line">输出：[0]</span><br></pre></td></tr></table></figure>

<p>拓扑排序（Topological Sorting）</p>
<p>直观地说就是，让你把⼀幅图「拉平」，⽽且这个「拉平」的图⾥⾯，所有箭头⽅向都是⼀致的。</p>
<p>如果⼀幅有向图中存在环，是⽆法进⾏拓扑排序的，因为肯定做不到所有箭头⽅向⼀致；反过来，如果⼀幅图是<strong>「有向⽆环图」</strong>，那么<strong>⼀定可以进⾏拓扑排序</strong>。 </p>
<p><strong>将后序遍历的结果进⾏反转，就是拓扑排序的结果。</strong></p>
<p>先对图进行DFS遍历，记录后序遍历结果，最后将后序遍历结果反转。</p>
<p>进⾏<strong>拓扑排序之前要进⾏环检测</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; postorder; <span class="comment">// 记录后序遍历结果</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findOrder</span><span class="params">(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> hasCycle = <span class="literal">false</span>; <span class="comment">// 记录是否存在环</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">visited</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">path</span><span class="params">(numCourses, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 建立图</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(numCourses, prerequisites);</span><br><span class="line">    <span class="comment">// 遍历图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numCourses; i++) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited,path, i, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 有环图⽆法进⾏拓扑排序</span></span><br><span class="line">    <span class="keyword">if</span> (hasCycle) <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    <span class="comment">// 逆后序遍历结果即为拓扑排序结果</span></span><br><span class="line">    <span class="built_in">reverse</span>(postorder.<span class="built_in">begin</span>(), postorder.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> postorder;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//建立图的邻接表</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> numCourses, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; prerequisites) &#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(numCourses);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : prerequisites) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = v[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to  = v[<span class="number">0</span>];</span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 图遍历函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, vector&lt;<span class="keyword">bool</span>&gt;&amp; visited,vector&lt;<span class="keyword">bool</span>&gt;&amp; path, <span class="keyword">int</span> index, <span class="keyword">bool</span>&amp; hasCycle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (path[index]) &#123;</span><br><span class="line">        hasCycle = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (visited[index] || hasCycle) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 前序遍历位置</span></span><br><span class="line">    visited[index] = <span class="literal">true</span>;</span><br><span class="line">    path[index] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> v : graph[index]) &#123;</span><br><span class="line">        <span class="built_in">tranverse</span>(graph, visited, path, v, hasCycle);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 后序遍历位置</span></span><br><span class="line">    postorder.<span class="built_in">push_back</span>(index);</span><br><span class="line">    path[index] = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分图"><a href="#二分图" class="headerlink" title="二分图"></a>二分图</h2><p>⼆分图的顶点集可分割为两个互不相交的⼦集，图中每条边依附的两个顶点都分属于这两个⼦集，且 </p>
<p>两个⼦集内的顶点不相邻。</p>
<p>给出一副图，用两种颜色将图中的所有顶点着色，且使得任意一条边的两个端点的颜色都不相同。</p>
<img src="/posts/75bf15f1/image-20220520214203061.png" alt="image-20220520214203061" style="zoom:50%;">

<p>二分图的判定：</p>
<p>遍历⼀遍图，⼀边遍历⼀边染⾊，看看能不能⽤两种颜⾊给所有节点染⾊，且相邻节点的颜⾊都不相同。 </p>
<p><strong>图的遍历框架1：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 记录被遍历过的节点</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="comment">// 记录从起点到当前节点的路径</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; onPath;</span><br><span class="line"><span class="comment">/* 图遍历框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> s)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (visited[s]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 经过节点 s，标记为已遍历</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">// 做选择：标记节点 s 在路径上</span></span><br><span class="line">    onPath[s] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(s)) &#123;</span><br><span class="line">        <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 撤销选择：节点 s 离开路径</span></span><br><span class="line">    onPath[s] = <span class="literal">false</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>图的遍历框架2：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traverse</span><span class="params">(Graph graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 前序遍历位置，标记节点 v 已访问</span></span><br><span class="line">    visited[s] = <span class="literal">true</span>;</span><br><span class="line">   </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> neighbor : graph.<span class="built_in">neighbors</span>(v)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[neighbor]) &#123;</span><br><span class="line">            <span class="comment">// 只遍历没标记过的相邻节点</span></span><br><span class="line">            <span class="built_in">traverse</span>(graph, neighbor);</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这种写法把对 visited 的判断放到递归调⽤之前，和之前的写法唯⼀的不同就是，你需要保证调⽤</p>
<p>traverse(v) 的时候，visited[v] == false。 </p>
<p><a href="https://leetcode.cn/problems/is-graph-bipartite/">785.判断⼆分图</a></p>
<p>输⼊⼀个 邻接表 表示⼀幅⽆向图，请你判断这幅图是否是⼆分图。 </p>
<img src="/posts/75bf15f1/image-20220520215456736.png" alt="image-20220520215456736" style="zoom:80%;">

<p>解析：</p>
<p>遍历图，相邻节点涂不同颜色，额外使用一个color数组记录每个节点的颜色。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 记录图是否符合⼆分图性质</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; color; <span class="comment">// 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited; <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 主函数，输⼊邻接表，判断是否是⼆分图</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isBipartite</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n = graph.<span class="built_in">size</span>();</span><br><span class="line">    color.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 因为图不⼀定是联通的，可能存在多个⼦图</span></span><br><span class="line"> 	<span class="comment">// 所以要把每个节点都作为起点进⾏⼀次遍历</span></span><br><span class="line"> 	<span class="comment">// 如果发现任何⼀个⼦图不是⼆分图，整幅图都不算⼆分图</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">tranverse</span>(graph, i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经确定不是⼆分图了，就不⽤浪费时间再递归遍历了</span></span><br><span class="line"> 	<span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 没有被访问过</span></span><br><span class="line"> 			<span class="comment">// 那么应该给节点 s 涂上和节点 v 不同的颜⾊</span></span><br><span class="line"> 			color[s] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 s</span></span><br><span class="line">            <span class="built_in">tranverse</span>(graph, s);</span><br><span class="line">            <span class="comment">//bfs(graph, s);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 已经被访问过</span></span><br><span class="line"> 			<span class="comment">// 根据 v 和 s 的颜⾊判断是否是⼆分图</span></span><br><span class="line">            <span class="keyword">if</span> (color[s] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BFS遍历</span></span><br><span class="line"><span class="comment">// 从 start 节点开始进⾏ BFS 遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> start)</span> </span>&#123;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">    visited[start] = <span class="literal">true</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(start);</span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>() &amp;&amp; ok) &#123;</span><br><span class="line">        <span class="keyword">int</span> v = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> w : graph[v]) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!visited[w]) &#123;</span><br><span class="line">                color[w] = !color[v];</span><br><span class="line">                visited[w] = <span class="literal">true</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(w);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (color[w] == color[v]) &#123;</span><br><span class="line">                    <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                    ok = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><a href="https://leetcode.cn/problems/possible-bipartition/">886. 可能的二分法</a></p>
<p>给定一组 n 人（编号为 1, 2, …, n）， 我们想把每个人分进任意大小的两组。每个人都可能不喜欢其他人，那么他们不应该属于同一组。</p>
<p>给定整数 n 和数组 dislikes ，其中 dislikes[i] = [ai, bi] ，表示不允许将编号为 ai 和  bi的人归入同一组。当可以用这种方法将所有人分进两组时，返回 true；否则返回 false。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：n = 4, dislikes = [[1,2],[1,3],[2,4]]</span><br><span class="line">输出：true</span><br><span class="line">解释：group1 [1,4], group2 [2,3]</span><br><span class="line"></span><br><span class="line">输入：n = 3, dislikes = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出：false</span><br><span class="line"></span><br><span class="line">输入：n = 5, dislikes = [[1,2],[2,3],[3,4],[4,5],[1,5]]</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure>

<p>二分图的判定，每个人看作节点，相互关系看作边，双色图，按照颜色分成两组。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">bool</span> ok = <span class="literal">true</span>; <span class="comment">// 记录图是否符合⼆分图性质</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; color; <span class="comment">// 记录图中节点的颜⾊，false 和 true 代表两种不同颜⾊</span></span><br><span class="line">vector&lt;<span class="keyword">bool</span>&gt; visited; <span class="comment">// 记录图中节点是否被访问过</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">possibleBipartition</span><span class="params">(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 图节点编号从 1 开始</span></span><br><span class="line">    color.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    visited.<span class="built_in">resize</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 转化成邻接表表示图结构</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; graph = <span class="built_in">buildGraph</span>(n, dislikes);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[i]) &#123;</span><br><span class="line">            <span class="built_in">tranverse</span>(graph, n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ok;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建图函数</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">buildGraph</span>(<span class="keyword">int</span> n, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; dislikes) &#123;</span><br><span class="line">    <span class="comment">// 图节点编号为 1...n</span></span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> edge : dislikes) &#123;</span><br><span class="line">        <span class="keyword">int</span> from = edge[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> to = edge[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">// 「⽆向图」相当于「双向图」</span></span><br><span class="line">        graph[from].<span class="built_in">push_back</span>(to);</span><br><span class="line">        graph[to].<span class="built_in">push_back</span>(from);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graph;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// DFS 遍历框架</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tranverse</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph, <span class="keyword">int</span> v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果已经确定不是⼆分图了，就不⽤浪费时间再递归遍历了</span></span><br><span class="line"> 	<span class="keyword">if</span> (!ok) <span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    visited[v] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> s : graph[v]) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!visited[s]) &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 没有被访问过</span></span><br><span class="line"> 			<span class="comment">// 那么应该给节点 s 涂上和节点 v 不同的颜⾊</span></span><br><span class="line"> 			color[s] = !color[v];</span><br><span class="line">            <span class="comment">// 继续遍历 s</span></span><br><span class="line">            <span class="built_in">tranverse</span>(graph, s);</span><br><span class="line">            <span class="comment">//bfs(graph, s);</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 相邻节点 s 已经被访问过</span></span><br><span class="line"> 			<span class="comment">// 根据 v 和 s 的颜⾊判断是否是⼆分图</span></span><br><span class="line">            <span class="keyword">if</span> (color[s] == color[v]) &#123;</span><br><span class="line">                <span class="comment">// 若相同，则此图不是⼆分图</span></span><br><span class="line">                ok = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>刷题随笔02</title>
    <url>/posts/6832ed80/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="01-绳子覆盖最多的节点"><a href="#01-绳子覆盖最多的节点" class="headerlink" title="01 绳子覆盖最多的节点"></a>01 绳子覆盖最多的节点</h2><p>题目：</p>
<p>给定一个有序数组arr，代表坐落在X轴上的点，给定一个正数K，代表绳子的长度，返回绳子最多压中几个点？<br>即使绳子边缘处盖住点也算盖住</p>
<p>例如，<code>arr = [1, 3, 4, 7, 13, 16, 17]</code>, <code>target = 4</code>, 子数组<code>[3, 4, 7]</code>满足所有节点被覆盖</p>
<p>解析：</p>
<ol>
<li>普通解</li>
</ol>
<p>利用贪心，每一个点向前推，记录每个节点前target距离内覆盖个数最大值，一次遍历</p>
<p>小优化：数组有序，每个点向前找符合条件的节点个数，二分搜索优化，复杂度O(Nlog(N))</p>
<ol start="2">
<li>最优解</li>
</ol>
<p>双指针，L和起始位置指向0，<code>arr[R] - arr[L] &lt;= target</code>, R++向右移动；<code>arr[R] - arr[L] &gt; target</code>, L++向左移动。绳子起始边缘为L的最大覆盖节点个数，依次遍历。复杂度O(N)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：贪心+二分搜索</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> nearest = <span class="built_in">nearestIndex</span>(arr, i, arr[i] - target);</span><br><span class="line">        res = <span class="built_in">max</span>(res, i - nearest + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二分搜索函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> R, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> index = R;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = L + (R- L) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：贪心+双指针，滑动窗口</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPoint1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; n) &#123;</span><br><span class="line">        <span class="keyword">while</span> (right &lt; n &amp;&amp; arr[right] - arr[left] &lt;= target) &#123;</span><br><span class="line">            right++;</span><br><span class="line">        &#125;</span><br><span class="line">        count = <span class="built_in">max</span>(count, right - left);</span><br><span class="line">        left++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="02-两种字符最少交换次数"><a href="#02-两种字符最少交换次数" class="headerlink" title="02 两种字符最少交换次数"></a>02 两种字符最少交换次数</h2><p>题目：</p>
<p>一个数组中只有两种字符’G’和’B’，可以让所有的G都放在左侧，所有的B都放在右侧<br>或者可以让所有的G都放在右侧，所有的B都放在左侧，但是只能在<strong>相邻字符之间进行交换操作</strong>，返回至少需要交换几次</p>
<p>解析：</p>
<p>贪心，遍历遇到第一个G，移到0位置，遇到第二个G，移到位置1……，双指针</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minStep</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> step1 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> gi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//G在左边，B在右边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;G&#x27;</span>) &#123;</span><br><span class="line">            step1 += i - gi;</span><br><span class="line">            gi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> step2 = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> bi = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//G在右边，B在左边</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i&lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;B&#x27;</span>) &#123;</span><br><span class="line">            step2 += i - bi;</span><br><span class="line">            bi++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">min</span>(step1,step2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="03-数组目标和为target的所有排列个数"><a href="#03-数组目标和为target的所有排列个数" class="headerlink" title="03 数组目标和为target的所有排列个数"></a>03 数组目标和为target的所有排列个数</h2><p>题目：</p>
<p>给定一个数组arr，你可以在每个数字之前决定+或者-但是必须所有数字都参与，再给定一个数target<br>请问最后算出target的方法数</p>
<p>leetcode：494</p>
<p>解析：</p>
<ol>
<li>递归暴力求解</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//递归暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays1</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//递归函数，可以自由使用arr[index...]所有的数字</span></span><br><span class="line"><span class="comment">//能够得出target这个数，方法数是多少，返回</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index,<span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123; <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span> target ==<span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, target - arr[index]) + <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, target + arr[index]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>动态规划，记忆化搜索</li>
</ol>
<ul>
<li>假设将arr变为非负数组，前面进行加减不影响</li>
<li>非负arr累加和为sum，target &gt; sum 则不存在</li>
<li>target与sum的奇偶性不一致，不存在</li>
<li>取正集合和为P，取负集合和为N，P - N = target, p + N = sum, ==&gt; p = (sum + target) / 2,转化为取正集合和为P的组合有多少个</li>
<li>二维动态规划的空间压缩</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays2</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  n : arr) &#123;</span><br><span class="line">        sum += n;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (sum &lt; target || ((sum &amp; <span class="number">1</span>) ^ (target &amp; <span class="number">1</span>)) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">subset</span>(arr, (sum + target) / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">subset</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp</span><span class="params">(target + <span class="number">1</span>)</span></span>;</span><br><span class="line">    dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = target; i &gt;= n; i--) &#123;</span><br><span class="line">            dp[i] += dp[i - n];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[target];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="04-总体最多收入分配"><a href="#04-总体最多收入分配" class="headerlink" title="04 总体最多收入分配"></a>04 总体最多收入分配</h2><p>题目：</p>
<p>现有司机N*2人，调度中心会将所有司机平分给A、B两区域，i号司机去A可得收入为<code>income[i][0]</code>，去B可得收入为<code>income[i][1]</code>, 返回能使所有司机总收入最高的方案是多少钱?</p>
<p>解析：</p>
<ol>
<li>递归暴力 O(N^2)</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  income -&gt; N * 2 的矩阵 N是偶数！</span></span><br><span class="line"><span class="comment">// 0 [9, 13]</span></span><br><span class="line"><span class="comment">// 1 [45,60]</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMoney1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = income.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (N &lt; <span class="number">2</span> || (N &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//N为奇数返回0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>; <span class="comment">//M = N / 2, 去A地区</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(income, <span class="number">0</span>, M);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// index.....所有的司机，往A和B区域分配！</span></span><br><span class="line"><span class="comment">// A区域还有rest个名额!</span></span><br><span class="line"><span class="comment">// 返回把index...司机，分配完，并且最终A和B区域同样多的情况下，index...这些司机，整体收入最大是多少！</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income, <span class="keyword">int</span> index, <span class="keyword">int</span> rest)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index == income.<span class="built_in">size</span>()) <span class="keyword">return</span> <span class="number">0</span>; </span><br><span class="line">    <span class="comment">// 还剩下司机！</span></span><br><span class="line">    <span class="keyword">if</span> (income.<span class="built_in">size</span>() - index == rest) &#123; <span class="comment">//B区域满了</span></span><br><span class="line">        <span class="keyword">return</span> income[index][<span class="number">0</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rest == <span class="number">0</span>) &#123;	<span class="comment">//A区域满了</span></span><br><span class="line">        <span class="keyword">return</span> income[index][<span class="number">1</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当前司机，可以去A，或者去B</span></span><br><span class="line">    <span class="keyword">int</span> p1 = income[index][<span class="number">0</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> p2 = income[index][<span class="number">1</span>] + <span class="built_in">process1</span>(income, index + <span class="number">1</span>, rest);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">max</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>动态规划</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxMoney2</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; income)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = income.length;</span><br><span class="line">    <span class="keyword">int</span> M = N &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(N + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(M + <span class="number">1</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N - <span class="number">1</span>; i &gt;= <span class="number">0</span> ; i--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= M; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (N - i == j) &#123;</span><br><span class="line">                dp[i][j] = income[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (j == <span class="number">0</span>) &#123;</span><br><span class="line">                dp[i][j] = income[i][<span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> p1 = income[i][<span class="number">0</span>] + dp[i + <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">int</span> p2 = income[i][<span class="number">1</span>] + dp[i + <span class="number">1</span>][j];</span><br><span class="line">                dp[i][j] = <span class="built_in">max</span>(p1, p2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[<span class="number">0</span>][M];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="05-含有SetAll功能的哈希表"><a href="#05-含有SetAll功能的哈希表" class="headerlink" title="05 含有SetAll功能的哈希表"></a>05 含有SetAll功能的哈希表</h2><p>题目：</p>
<p>设计有setAll功能的哈希表，put、get、setAll方法，时间复杂度O(1)</p>
<p>setAll(num), 将所有的key对应的value值改为num</p>
<p>解析：</p>
<p>加入时间戳，记录加入的时间，key -&gt; int, value -&gt; (int, long)</p>
<p>setAlltime默认无穷大，调用setAll(num)后，时间戳早于当前值的进行更新，setAlltime更新为当前时间</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyValue</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">		<span class="keyword">public</span> V value;</span><br><span class="line">		<span class="keyword">public</span> <span class="keyword">long</span> time;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">public</span> <span class="title">MyValue</span><span class="params">(V v, <span class="keyword">long</span> t)</span> </span>&#123;</span><br><span class="line">			value = v;</span><br><span class="line">			time = t;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyHashMap</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> HashMap&lt;K, MyValue&lt;V&gt;&gt; map;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> time;</span><br><span class="line">    <span class="keyword">private</span> MyValue&lt;V&gt; setAll;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        time = <span class="number">0</span>;</span><br><span class="line">        setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(<span class="keyword">null</span>, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        map.put(key, <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAll</span><span class="params">(V value)</span> </span>&#123;</span><br><span class="line">        setAll = <span class="keyword">new</span> MyValue&lt;V&gt;(value, time++);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(K key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!map.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (map.get(key).time &gt; setAll.time) &#123;</span><br><span class="line">            <span class="keyword">return</span> map.get(key).value;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> setAll.value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="06-最长无重复字串的子串长度"><a href="#06-最长无重复字串的子串长度" class="headerlink" title="06 最长无重复字串的子串长度"></a>06 最长无重复字串的子串长度</h2><p>题目：</p>
<p>求一个字符串中，最长无重复字符子串长度</p>
<p>解析：</p>
<p>子串子数组问题，想每个<code>i</code>结尾时，满足条件的情况，无重复的子串长度<code>dp[i]</code></p>
<p>从第<code>i</code>个位置向前推影响因素：某个位置与<code>i</code>位置的字符相同，或者i-1位置向左推的距离</p>
<p>可以滑动窗口</p>
<p>也可动态规划：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//acsii取值范围0~255</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">map</span><span class="params">(<span class="number">256</span>)</span></span>;</span><br><span class="line">    <span class="comment">//map存放上次出现的位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">256</span>; i++) &#123;</span><br><span class="line">        map[i] = <span class="number">-1</span>; <span class="comment">//初始默认出现在-1位置</span></span><br><span class="line">    &#125;</span><br><span class="line">    map[s[<span class="number">0</span>]] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> pre = <span class="number">1</span>;<span class="comment">//上一个位置，向左推了多长</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        pre = <span class="built_in">min</span>(i - map[s[i]], pre + <span class="number">1</span>);</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, pre);</span><br><span class="line">        map[s[i]] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="07-差值为k的数对的最大组数"><a href="#07-差值为k的数对的最大组数" class="headerlink" title="07 差值为k的数对的最大组数"></a>07 差值为k的数对的最大组数</h2><p>题目描述：</p>
<p>给定一个数组arr，代表每个人的能力值。再给定一个非负数k，如果两个人能力差值正好为k，那么可以凑在一起比赛<br>一局比赛只有两个人，返回最多可以同时有多少场比赛</p>
<p>解析：</p>
<p>数组arr排序后，滑动窗口求解+贪心</p>
<p>暴力解：全排列寻找</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//暴力解</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPairNUm1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process1</span>(arr, <span class="number">0</span>, k);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//暴力递归函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> index, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (index == arr.<span class="built_in">size</span>()) &#123;	<span class="comment">//全排列</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i += <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] - arr[i - <span class="number">1</span>] == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> r = index; r &lt; arr.<span class="built_in">size</span>(); r++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[index], arr[r]);</span><br><span class="line">            ans = <span class="built_in">max</span>(ans, <span class="built_in">process1</span>(arr, index + <span class="number">1</span>, k));</span><br><span class="line">            <span class="built_in">swap</span>(arr[index], arr[r]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 时间复杂度O(N*logN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxPairNum2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt; <span class="number">0</span> || arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());<span class="comment">//排序，满足单调性，先满足小值的情况</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = <span class="number">0</span>;<span class="comment">//双指针窗口</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">usedR</span><span class="params">(N, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; N &amp;&amp; R &lt; N) &#123;</span><br><span class="line">        <span class="keyword">if</span> (usedR[L]) &#123;</span><br><span class="line">            L++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (L &gt;= R) &#123;</span><br><span class="line">            R++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 不止一个数，而且都没用过！</span></span><br><span class="line">            <span class="keyword">int</span> dis = arr[R] - arr[L];</span><br><span class="line">            <span class="keyword">if</span> (dis == k) &#123;</span><br><span class="line">                ans++;</span><br><span class="line">                usedR[R++] = <span class="literal">true</span>;</span><br><span class="line">                L++;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dis &lt; k) &#123;</span><br><span class="line">                R++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                L++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="08-最多载两个人的船同时过河问题"><a href="#08-最多载两个人的船同时过河问题" class="headerlink" title="08 最多载两个人的船同时过河问题"></a>08 最多载两个人的船同时过河问题</h2><p>题目描述：</p>
<p>给定一个正数数组arr，代表若干人的体重，再给定一个正数limit，表示所有船共同拥有的载重量，每艘船最多坐两人，且不能超过载重<br>想让所有的人同时过河，并且用最好的分配方法让船尽量少，返回最少的船数<br>Leetcode链接 : <a href="https://leetcode.com/problems/boats-to-save-people/">https://leetcode.com/problems/boats-to-save-people/</a></p>
<p>解析：</p>
<p>先排序，如果arr中某个值大于limit，返回无穷大不合题意。</p>
<p>寻找&gt;=limit/2的右边界，边界右侧的值大于limit/2，两个指针指向边界左侧和右侧</p>
<p>相加和大于limit，左指针左移</p>
<p>一侧先耗尽，左侧未满足条件的数量除以2（向上取整），加上满足条件的数量，加上右侧剩余未满足条件的数量</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//法一：</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">if</span> (arr[N<span class="number">-1</span>] &gt; limit) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> lessR = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = N <span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &lt;= limit / <span class="number">2</span>) &#123;</span><br><span class="line">            lessR = i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (lessR == <span class="number">-1</span>) <span class="keyword">return</span> N;</span><br><span class="line">    <span class="keyword">int</span> L = lessR, R = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> noUsed = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> solved = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (R &lt; N &amp;&amp; arr[L] + arr[R] &lt;= limit) &#123;</span><br><span class="line">            R++;</span><br><span class="line">            solved++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (solved == <span class="number">0</span>) &#123;</span><br><span class="line">            noUsed++;</span><br><span class="line">            L--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = <span class="built_in">max</span>(<span class="number">-1</span>, L - solved);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> all = lessR + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> used = all - noUsed;</span><br><span class="line">    <span class="keyword">int</span> moreUnsolved = (N - all) - used;</span><br><span class="line">    <span class="keyword">return</span> used + ((noUsed + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>) + moreUnsolved;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//法二：首尾双指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numRescueBoats2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> limit)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">sort</span>(arr.<span class="built_in">begin</span>(), arr.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> R = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123;</span><br><span class="line">        sum = L == R ? arr[L] : arr[L] + arr[R];</span><br><span class="line">        <span class="keyword">if</span> (sum &gt; limit) &#123;</span><br><span class="line">            R--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L++;</span><br><span class="line">            R--;</span><br><span class="line">        &#125;</span><br><span class="line">        ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="09-子数组的最大累加和"><a href="#09-子数组的最大累加和" class="headerlink" title="09 子数组的最大累加和"></a>09 子数组的最大累加和</h2><p>题目描述：</p>
<p>返回一个数组arr中，子数组最大累加和</p>
<p>解析：</p>
<p>子数组以arr[i]结尾的最大累加和，求其最大值</p>
<p><code>dp[i] = max(dp[i - 1] + arr[i], arr[i])</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 上一步，dp的值</span></span><br><span class="line">    <span class="comment">// dp[0]</span></span><br><span class="line">    <span class="keyword">int</span> pre = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">int</span> ans = arr[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        pre = <span class="built_in">max</span>(pre + arr[i], arr[i]);</span><br><span class="line">        ans = <span class="built_in">max</span>(pre, ans);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-分糖果问题"><a href="#10-分糖果问题" class="headerlink" title="10 分糖果问题"></a>10 分糖果问题</h2><p>题目描述：</p>
<p>老师想给孩子们分发糖果，有N个孩子站成了一条直线，老师会根据每个孩子的表现，预先给他们评分<br>你需要按照以下要求，帮助老师给这些孩子分发糖果：<br>每个孩子至少分配到 1 个糖果。<br>评分更高的孩子必须比他两侧的邻位孩子获得更多的糖果。<br>那么这样下来，返回老师至少需要准备多少颗糖果<br>进阶：在原来要求的基础上，增加一个要求，相邻的孩子间如果分数一样，分的糖果数必须一样，返回至少需要准备多少颗糖果</p>
<p>解析：<br>从左遍历，坡度值加一，从右遍历，坡度值加一，二者取最大值，以坡度大的为准</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">candy</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">left</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            left[i] = left[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">right</span><span class="params">(n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = n - <span class="number">2</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">        <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            right[i] = right[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        ans += <span class="built_in">max</span>(left[i], right[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补充规则：相邻孩子分数一样则分的糖果数一样</p>
<p>解析：比左边大++，和左边相等不变，比左边小置1，右侧遍历同理</p>
<h2 id="11-字符串交错组成问题"><a href="#11-字符串交错组成问题" class="headerlink" title="11 字符串交错组成问题"></a>11 字符串交错组成问题</h2><p>题目描述：</p>
<p>给定三个字符串s1、s2、s3，请你帮忙验证s3是否是由s1和s2交错组成的</p>
<p>Leetcode题目：<a href="https://leetcode.com/problems/interleaving-string/">https://leetcode.com/problems/interleaving-string/</a></p>
<p>解析：</p>
<p>长度s1.size() + s2.size() != s3.size()，不成立</p>
<p>动态规划，<code>dp[i][j]</code>长度为i的s1与长度为j的s2，能否组成长度i + j的s3</p>
<p>s1长度i，下标0 ~ i-1;</p>
<p>s2长度j，下标0 ~ j-1;</p>
<p>s3长度i + j, 下标0 ~ i + j - 1</p>
<p>每个位置最后一个字符可能来着s1或s2</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isInterLeave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m = s1.<span class="built_in">size</span>(), n = s2.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (s3.<span class="built_in">size</span>() != m + n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(n + <span class="number">1</span>));</span><br><span class="line">    dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s1[i - <span class="number">1</span>] != s3[i - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[i][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s2[j - <span class="number">1</span>] != s3[j - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        dp[<span class="number">0</span>][j] = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((s1[i - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i - <span class="number">1</span>][j]) || (s2[j - <span class="number">1</span>] == s3[i + j - <span class="number">1</span>] &amp;&amp; dp[i][j - <span class="number">1</span>])) &#123;</span><br><span class="line">                dp[i][j] = <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[m][n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-求相等子树的数量"><a href="#12-求相等子树的数量" class="headerlink" title="12 求相等子树的数量"></a>12 求相等子树的数量</h2><p>题目描述：</p>
<p>如果一个节点X，它左树结构和右树结构完全一样，那么我们说以X为头的树是相等树，给定一棵二叉树的头节点head，返回head整棵树上有多少棵相等子树</p>
<p>解析：<br>递归，head左子树的相等子树+head右子树的相等子树+head是否为相等子树</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode() : val(0), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) &#123;&#125;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// 时间复杂度O(N * logN)</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sameNumber1</span><span class="params">(TreeNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sameNumber1</span>(head -&gt; left) + <span class="built_in">sameNumber1</span>(head -&gt; right) + (<span class="built_in">same</span>(head-&gt;left, head -&gt; right) ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">same</span><span class="params">(TreeNode* h1, TreeNode* h2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span> ^ h2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (h1 == <span class="literal">nullptr</span> &amp;&amp; h2 == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//两个都不为空</span></span><br><span class="line">    <span class="keyword">return</span> h1 -&gt; val == h2 -&gt; val &amp;&amp; <span class="built_in">same</span>(h1 -&gt; left, h2 -&gt; left) &amp;&amp; <span class="built_in">same</span>(h1 -&gt; right, h2 -&gt; right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



]]></content>
  </entry>
  <entry>
    <title>刷题随笔01</title>
    <url>/posts/bba1d2c5/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="01-复杂度、排序与二分法"><a href="#01-复杂度、排序与二分法" class="headerlink" title="01 复杂度、排序与二分法"></a>01 复杂度、排序与二分法</h1><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>数组索引0 ~ N-1，找到最小值，放到0位置上；</p>
<p>依次向后遍历，在i ~ N-1中，找到最小值，放到i位置上。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">selectionSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> minIndex = i;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; arr.<span class="built_in">size</span>(); j++) &#123;</span><br><span class="line">            <span class="comment">//在i ~ n-1上找到最小值的下标</span></span><br><span class="line">            minIndex = arr[j] &lt; arr[minIdex] ? j : minIdex;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(arr[i], arr[minIndex]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>0-1，1-2，2-3…依次两两交换，大的交换到后边，每一轮的最大值到最后。</p>
<p>[3 2 5 1 6 4] ==&gt; [2 3 1 5 4 6] ==&gt; [2 1 3 4 5 6] ==&gt; [1 2 3 4 5 6]</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubbleSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">// 0 ~ N-1</span></span><br><span class="line">    <span class="comment">// 0 ~ N-2</span></span><br><span class="line">    <span class="comment">// 0 ~ N-3</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> e = arr.<span class="built_in">size</span>() - <span class="number">1</span>; e &gt; <span class="number">0</span>; e--) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; e; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[i] &gt; arr[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="built_in">swap</span>(arr[i], arr[i + <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>0 ~ 0，0 ~ 1 , 0 ~ 2, … 0 ~ n -1，依次变得有序。第i轮，若第i个数小于前一个数，二者交换，直到i大于等于前一个数。</p>
<p>类似与摸牌后，每次进行插入排序。</p>
<p>初始数据状况会影响时间复杂度。最差O(n ^ 2)</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insertSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//0~0 有序的</span></span><br><span class="line">    <span class="comment">//0~i 变为有序</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i - <span class="number">1</span>; j &gt;= <span class="number">0</span> &amp;&amp; arr[j] &gt; arr[j + <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[j], arr[j + <span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二分法"><a href="#二分法" class="headerlink" title="二分法"></a>二分法</h2><p>经常在有序数组上，使用二分搜索，但是有序不是必要条件。</p>
<p><strong>只要能正确构建左右两侧的逻辑，就可以使用二分。</strong></p>
<ul>
<li>一个有序数组，找某个数是否存在</li>
<li>一个有序数组，找 &gt;= 某个数的最左侧位置</li>
<li>一个有序数组，找 &lt;= 某个数的最右侧位置</li>
<li>局部最小值问题</li>
</ul>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">exist</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; sortArr, <span class="keyword">int</span> num)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sortArr.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = sortArr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//L...R</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123; <span class="comment">//L..R 至少两个数</span></span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>); <span class="comment">//mid = (L + R) / 2</span></span><br><span class="line">        <span class="keyword">if</span> (sortArr[mid] == num) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sortArr[mid] &gt; num) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sortArr[L] == num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>搜索&gt;= 某个数的最左侧位置：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">nearestIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">0</span>, R = arr.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> index = <span class="number">-1</span>;<span class="comment">//记录最左的对号</span></span><br><span class="line">    <span class="keyword">while</span> (L &lt;= R) &#123; <span class="comment">//至少一个数的时候</span></span><br><span class="line">        <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt;= value) &#123;</span><br><span class="line">            index = mid;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>无序数组，任意两个相邻的数不相等，返回任意一个局部最小值（比左右相邻的数小）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getLessIndex</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">1</span> || arr[<span class="number">0</span>] &lt; arr[<span class="number">1</span>]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (arr[n - <span class="number">1</span>] &lt; arr[n - <span class="number">2</span>]) <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> L = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> R = n - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (L &lt; R) &#123;</span><br><span class="line">        mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            R = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (arr[mid] &gt; arr[mid - <span class="number">1</span>]) &#123;</span><br><span class="line">            L = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L:</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="02-异或运算"><a href="#02-异或运算" class="headerlink" title="02 异或运算"></a>02 异或运算</h1><p>异或运算：相同为0，不同为1，二进制<strong>无进位相加</strong>（不进位）</p>
<p>同或运算：相同为1，不同为0</p>
<p>异或运算 (^) 性质：</p>
<ul>
<li>0 ^ N = N</li>
<li>N ^ N = 0</li>
<li>a ^ b = b ^ a （交换律）</li>
<li>(a ^ b) ^ c = a ^ (b ^ c) （结合律）</li>
<li>a ^ b = c ==&gt; a = c ^ b ==&gt; b = c ^ a</li>
</ul>
<h2 id="题目1"><a href="#题目1" class="headerlink" title="题目1"></a>题目1</h2><p>不使用额外空间变量交换两个数</p>
<p>利用异或运算的性质，注意：<strong>交换的两个数不能是同一块内存空间</strong>，否则二者变为0.</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span>&amp; a, <span class="keyword">int</span>&amp; b)</span> </span>&#123;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">    b = a ^ b;</span><br><span class="line">    a = a ^ b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目2"><a href="#题目2" class="headerlink" title="题目2"></a>题目2</h2><p>一个数组中有<strong>一个数出现了奇数次</strong>，其他数出现了偶数次，找到并打印这个数（O(1) 额外空间复杂度完成）</p>
<p>解析：设置变量eor，顺序遍历异或所有的值，返回最后的eor</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOddTimesNum1</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; eor &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目3"><a href="#题目3" class="headerlink" title="题目3"></a>题目3</h2><p>把一个int类型的数，提取出最右侧的1</p>
<p>a = 0xb 00110110 ==&gt; ans = 0xb 00000010</p>
<p>解析：<strong>a &amp; (-a)</strong> 等价于 <strong>a &amp; (~a + 1)</strong></p>
<h2 id="题目4"><a href="#题目4" class="headerlink" title="题目4"></a>题目4</h2><p>一个数组中有<strong>两种数出现了奇数次</strong>，其他数出现了偶数次，找到并打印这两种数（O(1) 额外空间复杂度完成）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printOddTimesNum2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> eor = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        eor ^= arr[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> rightOne = eor &amp; (-eor); <span class="comment">//提取出最右的1, eor != 0</span></span><br><span class="line">    <span class="keyword">int</span> onlyOne = <span class="number">0</span>; <span class="comment">//eor&#x27;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// arr[1] = 11100010</span></span><br><span class="line">        <span class="comment">//rightOne= 00000010</span></span><br><span class="line">        <span class="keyword">if</span> ((arr[i] &amp; rightOne) != <span class="number">0</span>) &#123;</span><br><span class="line">            onlyOne ^= arr[i]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; onlyOne &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; (eor ^ onlyOne) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目5"><a href="#题目5" class="headerlink" title="题目5"></a>题目5</h2><p>一个数组中<strong>只有一种数出现K次</strong>，其他数都出现了M次，已知M &gt; 1，K &lt; M，找到出现了K次的数<br>要求额外空间复杂度O(1)，时间复杂度O(N)</p>
<p>解析：设置一个int数组长度为32，累加每个数的二进制位置的1的数量。每一位是否为M的整数倍判断出现K次的数的二进制最后一个1出现的位置</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">onlyKtimes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> k, <span class="keyword">int</span> m)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(<span class="number">32</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="comment">//help[i]位置的1出现的次数</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : arr) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (((num &gt;&gt; i) &amp; <span class="number">1</span>) != <span class="number">0</span>)</span><br><span class="line">            	help[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">32</span>; i++) &#123;</span><br><span class="line">        <span class="comment">/*返回只出现k次的数，如果不是k次，返回-1；</span></span><br><span class="line"><span class="comment">        if (help[i] % m == 0) continue;</span></span><br><span class="line"><span class="comment">        if (help[i] % m == k) &#123;</span></span><br><span class="line"><span class="comment">        	ans |= 1 &lt;&lt; i;</span></span><br><span class="line"><span class="comment">        &#125; else &#123;</span></span><br><span class="line"><span class="comment">        	return -1;</span></span><br><span class="line"><span class="comment">        &#125;*/</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (help[i] % m != <span class="number">0</span>) &#123; <span class="comment">//在第i位上有1</span></span><br><span class="line">            ans |= <span class="number">1</span> &lt;&lt; i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="03-归并排序"><a href="#03-归并排序" class="headerlink" title="03 归并排序"></a>03 归并排序</h1><p>左半部分有序 + 右半部分有序 + merge </p>
<p>merge过程双指针，顺序copy结果到新有序数组</p>
<p>总体时间复杂度为 O(n * log(N))</p>
<p><strong>递归写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergeSort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//arr[L...R]排有序</span></span><br><span class="line"><span class="comment">// T(N) = 2 * T(N / 2) + O(N)</span></span><br><span class="line"><span class="comment">// O(N * logN)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (L == R) &#123; <span class="comment">//base case</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> mid = L + ((R - L) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">process</span>(arr, L, mid);</span><br><span class="line">    <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, R);</span><br><span class="line">    <span class="built_in">merge</span>(arr, L, mid, R);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(R - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>迭代写法：</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mergesort2</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; arr)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">1</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> N = arr.<span class="built_in">size</span>();</span><br><span class="line">    <span class="comment">// 步长</span></span><br><span class="line">    <span class="keyword">int</span> mergeSize = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (mergeSize &lt; N) &#123; <span class="comment">// log N</span></span><br><span class="line">        <span class="comment">// 当前左组的，第一个位置</span></span><br><span class="line">        <span class="keyword">int</span> L = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (L &lt; N) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mergeSize &gt;= N - L) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> M = L + mergeSize - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> R = <span class="built_in">min</span>(mergeSize + M, N - <span class="number">1</span>);</span><br><span class="line">            <span class="built_in">merge</span>(arr, L, M, R);</span><br><span class="line">            L = R + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 防止溢出</span></span><br><span class="line">        <span class="keyword">if</span> (mergeSize &gt; N / <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mergeSize &lt;&lt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> M, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; help = <span class="keyword">new</span> <span class="keyword">int</span>[R - L + <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = M + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M &amp;&amp; p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 要么p1越界了，要么p2越界了</span></span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= M) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= R) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.length; i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目1：小和问题"><a href="#题目1：小和问题" class="headerlink" title="题目1：小和问题"></a>题目1：小和问题</h2><p>在一个数组中，一个数左边比它小的数的总和，叫该数的小和<br>所有数的小和累加起来，叫数组小和</p>
<p>给定一个数组，求最小和，到第i个数，若第j （j &lt; i）个数的值小于第i个数，累加上第j个数。</p>
<p>例子： [1,3,4,2,5]<br>1左边比1小的数：没有<br>3左边比3小的数：1<br>4左边比4小的数：1、3<br>2左边比2小的数：1<br>5左边比5小的数：1、3、4、 2<br>所以数组的小和为1+1+3+1+1+3+4+2=16 </p>
<p>[6 3 2 1 6 7] ==&gt; i = 0, sum = 0; i = 1, sum = 0; i = 2, sum = 0; i = 3, sum = 0; i = 4, sum = 4, sum = 0;</p>
<p>i = 5, sum = 3 +2 + 1 = 6; i = 6, sum = 18; 返回 res = 6 + 18 = 24;</p>
<p>每个位置，之前比自己小的数累加起来，各个位置累加和再求和。</p>
<p>暴力法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">comparator</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++) &#123;</span><br><span class="line">            res += arr[j] &lt; arr[i] ? arr[j] : <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>归并排序法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">smallSum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求小和返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的小和，累加</span></span><br><span class="line"><span class="comment">// 左 排序   merge</span></span><br><span class="line"><span class="comment">// 右 排序  merge</span></span><br><span class="line"><span class="comment">// merge</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// l &lt; r</span></span><br><span class="line">    <span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> </span><br><span class="line">        <span class="built_in">process</span>(arr, l, mid) </span><br><span class="line">        + </span><br><span class="line">        <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) </span><br><span class="line">        + </span><br><span class="line">        <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> L, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - L + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = L;</span><br><span class="line">    <span class="keyword">int</span> p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        res += arr[p1] &lt; arr[p2] ? (r - p2 + <span class="number">1</span>) * arr[p1] : <span class="number">0</span>;</span><br><span class="line">        help[i++] = arr[p1] &lt; arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目2：逆序对总数"><a href="#题目2：逆序对总数" class="headerlink" title="题目2：逆序对总数"></a>题目2：逆序对总数</h2><p>在一个数组中，任何一个前面的数a，和任何一个后面的数b，如果(a,b)是降序的，就称为逆序对<br>给定一个数组arr，求数组的逆序对总数量</p>
<p>[3 1 0 4 3 1] ==&gt; 6</p>
<p>每一个数右边有多少个数比他小，从右向左merge</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverPairNumber</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// arr[L..R]既要排好序，也要求逆序对数量返回</span></span><br><span class="line"><span class="comment">// 所有merge时，产生的逆序对数量，累加，返回</span></span><br><span class="line"><span class="comment">// 左 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="comment">// 右 排序 merge并产生逆序对数量</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//l &lt; r</span></span><br><span class="line">	<span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">process</span>(arr, l, mid) + <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = help.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = m, p2 = r;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L &amp;&amp; p2 &gt; m) &#123;</span><br><span class="line">        res += arr[p1] &gt; arr[p2] ? (p2 - m) : <span class="number">0</span>;</span><br><span class="line">        help[i--] = arr[p1] &gt; arr[p2] ? arr[p1--] : arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &gt;= L) &#123;</span><br><span class="line">        help[i--] = arr[p1--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &gt; m) &#123;</span><br><span class="line">        help[i--] = arr[p2--];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[L + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="题目3：Bigger-than-right-twice"><a href="#题目3：Bigger-than-right-twice" class="headerlink" title="题目3：Bigger than right twice"></a>题目3：Bigger than right twice</h2><p>在一个数组中，对于任何一个数num，求有多少个(后面的数*2)依然&lt;num，返回总个数<br>比如：[3,1,7,0,2]<br>3的后面有：1，0<br>1的后面有：0<br>7的后面有：0，2<br>0的后面没有<br>2的后面没有<br>所以总共有5个</p>
<p>解析：左组有序+有组有序+merge，双指针从左向右遍历不回退，记录个数</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">reverPairs</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">size</span>() &lt; <span class="number">2</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">process</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">process</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//l &lt; r</span></span><br><span class="line">	<span class="keyword">int</span> mid = l + ((r - l) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span>  <span class="built_in">process</span>(arr, l, mid) + <span class="built_in">process</span>(arr, mid + <span class="number">1</span>, r) + <span class="built_in">merge</span>(arr, l, mid, r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> l, <span class="keyword">int</span> m, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// [L....M] [M+1....R]</span></span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 目前囊括进来的数，是从[M+1, windowR)</span></span><br><span class="line">    <span class="keyword">int</span> windowR = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = l; i &lt;= m; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (windowR &lt;= r &amp;&amp; (<span class="keyword">long</span>) arr[i] &gt; (<span class="keyword">long</span>) arr[windowR] * <span class="number">2</span>) &#123;</span><br><span class="line">            windowR++;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += windowR - m - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">help</span><span class="params">(r - l + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> p1 = l, p2 = m + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= m &amp;&amp; p2 &lt;= r) &#123;</span><br><span class="line">        help[i++] = arr[p1] &lt;= arr[p2] ? arr[p1++] : arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p1 &lt;= L) &#123;</span><br><span class="line">        help[i++] = arr[p1++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (p2 &lt;= m) &#123;</span><br><span class="line">        help[i++] = arr[p2++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; help.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        arr[l + i] = help[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="04-快速排序"><a href="#04-快速排序" class="headerlink" title="04 快速排序"></a>04 快速排序</h1><p>快速排序是基于分治策略的，其算法思想如下。<br>（1）分解：先从数列中取出一个元素作为基准元素。以基准元素为标准，将问题分解为两个子序列，使小于或等于基准元素的子序列在左侧，使大于基准元素的子序列在右侧。<br>（2）治理：对两个子序列进行快速排序。</p>
<p>（3）合并：将排好序的两个子序列合并在一起，得到原问题的解。</p>
<p>代码实现：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//划分函数，对原序列进行分解，将其分解为两个子序列，以基准元素pivot为界，</span></span><br><span class="line"><span class="comment">//左侧子序列都比pivot小，右侧子序列都比pivot大。</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = low, j = high, pivot = arr[low];	<span class="comment">//基准元素</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[j] &gt; pivot) j--;	<span class="comment">//向左扫描</span></span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; arr[i] &lt;= pivot) i++;	<span class="comment">//向右扫描</span></span><br><span class="line">        <span class="keyword">if</span> (i &lt; j) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(arr[i++], arr[j--]);	<span class="comment">//交换arr[i]和arr[j]</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (arr[i] &gt; pivot) &#123;</span><br><span class="line">        <span class="built_in">swap</span>(arr[low], arr[i - <span class="number">1</span>]);	<span class="comment">//交换arr[i - 1]和arr[low]，并返回基准元素位置i - 1</span></span><br><span class="line">        <span class="keyword">return</span> i - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(arr[i], arr[low]);	<span class="comment">//交换arr[i]和arr[low]，并返回基准元素位置i</span></span><br><span class="line">    <span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//快速排序函数。首先对原序列划分，得到划分的中间位置mid；然后以中间位置为界，</span></span><br><span class="line"><span class="comment">//分别对左半部分(low,mid-1)执行快速排序，对右半部分(mid+1,high)执行快速排序。</span></span><br><span class="line"><span class="comment">//递归结束的条件是low≥high</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr, <span class="keyword">int</span> low, <span class="keyword">int</span> high)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (low &lt; high) &#123;</span><br><span class="line">        <span class="keyword">int</span> p = <span class="built_in">partition</span>(arr, low, high);	<span class="comment">//划分</span></span><br><span class="line">        <span class="built_in">qsort</span>(arr, low, p - <span class="number">1</span>);		<span class="comment">//左区间递归快排</span></span><br><span class="line">        <span class="built_in">qsort</span>(arr, p + <span class="number">1</span>, high);	<span class="comment">//右区间递归快排	</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; arr&#123;<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    <span class="built_in">qsort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况时间复杂度为O(nlogn)</p>
<p>最坏情况下的时间复杂度为O(n^2)</p>
<p>平均情况下的空间复杂度为O(nlogn)</p>
]]></content>
  </entry>
  <entry>
    <title>刷题笔记：数模运算</title>
    <url>/posts/bbb48ce1/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="寻找素数"><a href="#寻找素数" class="headerlink" title="寻找素数"></a>寻找素数</h1><p>素数：只能被1或其本身整除。</p>
<p>实现一个函数，输入一个整数<code>n</code>，返回<code>[2, n]</code>中的素数个数</p>
<p>暴力解法：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">isPrime</span>(i)) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//判断整数n是否是素数</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPrime</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n % i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>暴力解法时间复杂度为O(n^2)，不够高效。</p>
<p>改进：</p>
<ul>
<li><code>i</code> 只需遍历到<code>sqrt(n)</code>；</li>
<li>筛数法，2，3…的所有倍数都不是素数，但存在计算冗余；</li>
<li>内层<code>for</code>循环的<code>j</code>从<code>i</code>的平方开始遍历，不是从<code>2 * i </code>开始.</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">countPrimes</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isPrime</span><span class="params">(n, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i * i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i * i; j &lt; n; j++) &#123;</span><br><span class="line">                isPrime[j] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isPrime[i]) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="模幂运算"><a href="#模幂运算" class="headerlink" title="模幂运算"></a>模幂运算</h1><h2 id="位运算n-amp-n-1-的妙用"><a href="#位运算n-amp-n-1-的妙用" class="headerlink" title="位运算n &amp; (n-1)的妙用"></a>位运算<code>n &amp; (n-1)</code>的妙用</h2><p><code>n&amp;(n-1)</code>作用：将<code>n</code>的二进制表示中的<strong>最低位为<code>1</code>的改为<code>0</code></strong></p>
<p><code>n = 10100</code>(二进制），则<code>(n-1) = 10011</code>  –&gt; <code>n&amp;(n-1) = 10000</code></p>
<ul>
<li><p>判断一个数是否是2的n次幂<br><code>n &gt; 0 &amp;&amp; ((n &amp; (n - 1)) == 0 )</code></p>
<p>解释<code>((n &amp; (n-1)) == 0)：</code></p>
<p>如果<code>A &amp; B == 0</code>，表示A与B的二进制形式<strong>没有在同一个位置都为1</strong>的时候。</p>
</li>
<li><p>求某一个数的二进制表示中1的个数</p>
<p><code>while (n &gt; 0 ) &#123;    count ++;    n &amp;= (n-1); &#125;</code></p>
</li>
</ul>
<h2 id="幂运算"><a href="#幂运算" class="headerlink" title="幂运算"></a>幂运算</h2><p>整数<code>a</code>，数组<code>b</code>，返回幂运算<code>a ^ b</code>的结果，与<code>1337</code>取模（mod，余数）运算后的结果。</p>
<p>例如输入<code>a = 2, b = [1, 2]</code>，返回<code>2 ^ 12</code> 和<code>1337</code>取模的结果，<code>4096 % 1337 = 85</code></p>
<ul>
<li><p>处理指数数组</p>
<p>注：b为指数数组，可以采用递归求幂，<code>superPow(a, [1, 2, 5, 6])  ==&gt;  superPow(a, [1, 2, 5])</code></p>
</li>
<li><p>处理模运算</p>
<p><code>(a * b) % base = (a % k) * (b % k) % k</code></p>
<p><strong>对乘法的结果求模，等价于先对每个因子求模，然后对因子相乘的结果再求模。</strong></p>
</li>
</ul>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line">    <span class="comment">//先对a求模，然后每次多对乘法结果res求模</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        res *= a;</span><br><span class="line">        res %= base;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">superPow</span><span class="params">(<span class="keyword">int</span> a, vecter&lt;<span class="keyword">int</span>&gt;&amp; b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b.<span class="built_in">empty</span>()) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> last = b.<span class="built_in">back</span>();</span><br><span class="line">    b.<span class="built_in">pop_back</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> part1 = <span class="built_in">mypow</span>(a, last);</span><br><span class="line">    <span class="keyword">int</span> part2 = <span class="built_in">mypow</span>(<span class="built_in">superPow</span>(a, b), <span class="number">10</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> (part1 * part2) % base;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>高效求幂</p>
<p>幂运算的递归关系式：</p>
<p><code>a ^ b = a * a ^ (b - 1) </code>, b为奇数</p>
<p><code>a ^ b = (a ^ (b / 2)) ^ 2 </code>, b为偶数</p>
<p>加上对<code>base</code>求模运算：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> base = <span class="number">1337</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mypow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    a %= base;</span><br><span class="line">    <span class="keyword">if</span> (k % <span class="number">2</span> == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> (a * <span class="built_in">mypow</span>(a, k - <span class="number">1</span>)) % base;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">int</span> sub = <span class="built_in">mypow</span>(a, b / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">return</span> (sub * sub) % base;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="连续N个数的和"><a href="#连续N个数的和" class="headerlink" title="连续N个数的和"></a>连续N个数的和</h2><p>求 1 2 … n ，要求不能使用乘除法、for、while、if、else、switch、case等关键字及条件判断语句（A?B:C）。</p>
<p>示例：</p>
<ul>
<li>输入：n = 3 输出：6</li>
<li>输入：n = 9 输出：45</li>
</ul>
<p>限制：1 &lt;= n &lt;= 1000</p>
<p><strong>解析：</strong></p>
<p>因为不能使用公式直接计算（公式中包含乘除法），所以考虑使用递归进行求解，又不能使用if等判断返回条件，采用<code>A &amp;&amp; B </code>的特性进行判断。</p>
<ul>
<li><p>如果A为true，返回B的布尔值（继续往下执行）</p>
</li>
<li><p>如果A为false，直接返回false（相当于短路）</p>
</li>
</ul>
<p><strong>将递归的返回条件取非然后作为</strong> <strong>&amp;&amp;</strong> <strong>的第一个条件，递归主体转换为第二个条件语句</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sumNums</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> b = n &amp;&amp; (n += <span class="built_in">sumNums</span>(n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">return</span> n; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h1 id="二分搜索剪枝"><a href="#二分搜索剪枝" class="headerlink" title="二分搜索剪枝"></a>二分搜索剪枝</h1><ol start="875">
<li><a href="https://leetcode-cn.com/problems/koko-eating-bananas/">Koko食香蕉</a></li>
</ol>
<p>有 <code>N</code> 堆香蕉，第 <code>i</code> 堆中有 <code>piles[i]</code> 根香蕉，Koko要在<code>H</code>小时内吃完，吃香蕉的速度为每小时<code>K</code>根，每小时最多吃一堆香蕉，若吃不下到下一小时再吃，如果这堆香蕉少于 <code>K</code> 根，她将吃掉这堆的所有香蕉，然后这一小时内不会再吃更多的香蕉。 <strong>计算Koko每小时至少吃几根香蕉，才能在<code>H</code>小时内全部吃完？</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入: piles = [3,6,7,11], H = 8</span><br><span class="line">输出: 4</span><br><span class="line"></span><br><span class="line">输入: piles = [30,11,23,4,20], H = 5</span><br><span class="line">输出: 30</span><br></pre></td></tr></table></figure>

<p>解析：求<code>H</code>小时内吃完的最小速率，假设为<code>speed</code>，<code>speed</code>至少为1，最大为<code>max(piles)</code>，一小时最多吃一堆。</p>
<p>暴力解法：从1开始穷举到<code>max(piles)</code>，一旦发现某个值符合，就为最小速度。</p>
<p>改进：可以<strong>利用二分搜索剪枝，搜索左侧边界。</strong></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minSpeed</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">1</span>, right = <span class="built_in">getMax</span>(piles) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canFinish</span>(piles, mid, h)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles, <span class="keyword">int</span> speed, <span class="keyword">int</span> h)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> time = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        time += (n + speed - <span class="number">1</span>) / speed;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> time &lt;= h;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; piles)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : piles) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="1011">
<li><a href="https://leetcode-cn.com/problems/capacity-to-ship-packages-within-d-days/">在 D 天内送达包裹的能力</a></li>
</ol>
<p>传送带上的第<code> i</code> 个包裹的重量为<code> weights[i]</code>。每一天，我们都会按给出重量（weights）的顺序往传送带上装载包裹。我们装载的重量不会超过船的最大运载重量。</p>
<p>返回能在 <code>days </code>天内将传送带上的所有包裹送达的船的最低运载能力。</p>
<p><strong>货物不可分割且必须按顺序运输</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">输入：weights = [1,2,3,4,5,6,7,8,9,10], days = 5</span><br><span class="line">输出：15</span><br><span class="line">解释：</span><br><span class="line">船舶最低载重 15 就能够在 5 天内送达所有包裹，如下所示：</span><br><span class="line">第 1 天：1, 2, 3, 4, 5</span><br><span class="line">第 2 天：6, 7</span><br><span class="line">第 3 天：8</span><br><span class="line">第 4 天：9</span><br><span class="line">第 5 天：10</span><br></pre></td></tr></table></figure>

<p>解法：本质上和koko食香蕉的问题是一样的，首先确定最小载重<code>cap</code>，最小值为<code>max(weights)</code>和<code>sum(weights)</code>，<strong>求最小载重。</strong></p>
<p>暴力法顺序遍历，改进<strong>二分搜索左侧边界剪枝</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">shipWithinDays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> left = <span class="built_in">getMax</span>(weights);</span><br><span class="line">    <span class="keyword">int</span> right = <span class="built_in">accumulate</span>(weights.<span class="built_in">begin</span>(), weights.<span class="built_in">end</span>(), <span class="number">0</span>) + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">canFinish</span>(weights, days, mid)) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">canFinish</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights, <span class="keyword">int</span> days, <span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> day = <span class="number">0</span>; day &lt; days; day++) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxCap = cap;</span><br><span class="line">        <span class="keyword">while</span> ((maxCap -= weights[i]) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == weights.<span class="built_in">size</span>()) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMax</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; weights)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> n : weights) &#123;</span><br><span class="line">        res = <span class="built_in">max</span>(res, n);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id><a href="#" class="headerlink" title></a></h1>]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>模运算</tag>
        <tag>幂运算</tag>
      </tags>
  </entry>
  <entry>
    <title>c++笔试题常用技巧</title>
    <url>/posts/413d4c3c/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="C-笔试输入输出"><a href="#C-笔试输入输出" class="headerlink" title="C++笔试输入输出"></a>C++笔试输入输出</h2><p>牛客网常用头文件</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br></pre></td></tr></table></figure>

<table>
<thead>
<tr>
<th align="center">函数</th>
<th align="center">解释</th>
</tr>
</thead>
<tbody><tr>
<td align="center"><code>cin&gt;&gt;</code></td>
<td align="center">遇到空格和换行符自动停止读入，下次读入自动跳过，读取后面的字符</td>
</tr>
<tr>
<td align="center"><code>cin.get()</code></td>
<td align="center">读入字符，包括换行符<code>&#39;\n&#39;</code>和空格<code>&#39; &#39;</code></td>
</tr>
<tr>
<td align="center"><code>getline(cin, str)</code></td>
<td align="center">读取整行数据到<code>str</code>中</td>
</tr>
<tr>
<td align="center"><code>cin.getline(char*, int)</code></td>
<td align="center">接收字符串储存到char*中，长度为n可以接受空格</td>
</tr>
<tr>
<td align="center"><code>char a; cin.get(a)</code></td>
<td align="center"><code>a</code>中可以储存被<code>cin</code>丢弃的换行符</td>
</tr>
</tbody></table>
<ul>
<li><strong>cin&gt;&gt;输入的数据不包含空格和回车，空格和回车会存入到cin的缓冲区中</strong></li>
<li><strong>如果想拿到输入的空格和回车，通过cin.get()获得</strong></li>
</ul>
<ol>
<li><p>输入T组数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> T;</span><br><span class="line">    cin &gt;&gt; T;</span><br><span class="line">    <span class="keyword">while</span> (T--) &#123;</span><br><span class="line">        <span class="comment">//code</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>输入2个数字</p>
</li>
</ol>
<blockquote>
<p>输入：两个正整数a, b</p>
<p>1 5</p>
<p>10 20</p>
</blockquote>
<blockquote>
<p>输出：a + b 结果</p>
<p>6 </p>
<p>30</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="keyword">while</span>(cin &gt;&gt; a &gt;&gt; b) &#123;</span><br><span class="line">        cout &lt;&lt; a + b &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol start="3">
<li><p>单组数据，已知有多少个数据，<strong>数据长度已知</strong>，一般用空格分隔。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(n, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>多组数据，已知有多少个数据，数据长度已知</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">nums</span>(n, vector&lt;<span class="keyword">int</span>&gt;(m, <span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">            cin &gt;&gt; nums[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单组数据，未告知多少个数据，<strong>数据长度未知</strong>，用逗号或空格隔开的数据</p>
</li>
</ol>
<ul>
<li><p>法1：</p>
<blockquote>
<p>输入：用空格隔开每一个数据（逗号，分号同理）</p>
<p>123 456 789</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; tmp) &#123;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) <span class="keyword">break</span>;<span class="comment">//只处理一行</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>输入：用空格隔开每一个数据，数据有多行</p>
<p>123 456 789</p>
<p>321 654 987</p>
</blockquote>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; vec;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="keyword">int</span> tmp;</span><br><span class="line">    <span class="keyword">while</span> (cin &gt;&gt; tmp) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        <span class="keyword">if</span> (cin.<span class="built_in">get</span>() == <span class="string">&#x27;\n&#x27;</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">push_back</span>(path);</span><br><span class="line">            path.<span class="built_in">clear</span>();</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//vec.push_back(path);</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> d : c) &#123;</span><br><span class="line">            cout &lt;&lt; d &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>法2：构造split函数，指定分隔符，对字符串进行切片</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">split</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> pos = <span class="number">0</span>;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">    str += pattern;</span><br><span class="line">    <span class="keyword">int</span> size = str.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        pos = str.<span class="built_in">find</span>(pattern, i);</span><br><span class="line">        <span class="keyword">if</span> (pos &lt; size) &#123;</span><br><span class="line">            string s = str.<span class="built_in">substr</span>(i, pos - i);</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="built_in">stoi</span>(s));</span><br><span class="line">            i = pos + pattern.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    string input;</span><br><span class="line">    <span class="built_in">getline</span>(cin, input);</span><br><span class="line">    <span class="comment">//input = &quot;7 17 27 35 8 49 50&quot;;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">split</span>(input, <span class="string">&quot; &quot;</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : vec) &#123;</span><br><span class="line">        cout &lt;&lt; c &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    string input;</span><br><span class="line">    cin &gt;&gt; input;</span><br><span class="line">    <span class="comment">//input为&quot;123, 456, 756&quot;</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec = <span class="built_in">split</span>(input, <span class="string">&quot;,&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<h2 id="常用数据结构与函数"><a href="#常用数据结构与函数" class="headerlink" title="常用数据结构与函数"></a>常用数据结构与函数</h2><h3 id="map与set的使用"><a href="#map与set的使用" class="headerlink" title="map与set的使用"></a>map与set的使用</h3><ul>
<li><p>初始化：</p>
<ul>
<li>对于set：直接初始化<code>set&lt;int&gt; myset=&#123;0,1,2&#125;;</code> 或者把<code>vector</code>复制过来<code>set&lt;int&gt; myset(v.begin(),v.end());</code></li>
<li>对于map：<code>map&lt;int,int&gt; mymap=&#123;&#123;0,1&#125;,&#123;2,3&#125;,&#123;4,5&#125;&#125;</code></li>
</ul>
</li>
<li><p>插入：</p>
<ul>
<li>对于set：<code>myset.insert(888);</code></li>
<li>对于map：<code>mymap.insert(make_pair(6,7));</code>or, <code>mymap.insert(pair&lt;int ,int&gt;(6,7));</code>or, <code>mymap.insert&#123;6,7&#125;</code></li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th align="center">成员函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">begin()</td>
<td align="center">返回指向头部的迭代器</td>
</tr>
<tr>
<td align="center">end()</td>
<td align="center">返回指向末尾的迭代器</td>
</tr>
<tr>
<td align="center">empty()</td>
<td align="center">如果为空则返回 true</td>
</tr>
<tr>
<td align="center">find(val)</td>
<td align="center">查找一个值为val的元素，如果成功找到，则返回<br>指向该元素的双向迭代器；反之，返回 指向end() 的迭代器。</td>
</tr>
<tr>
<td align="center">count(val)</td>
<td align="center">返回指定元素val出现的次数</td>
</tr>
<tr>
<td align="center">insert()</td>
<td align="center">向容器中插入元素</td>
</tr>
<tr>
<td align="center">erase()</td>
<td align="center">删除容器中存储的一个元素</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回容器中元素的个数</td>
</tr>
<tr>
<td align="center">clear()</td>
<td align="center">清空容器中所有的元素，即令容器的 size() 为 0</td>
</tr>
<tr>
<td align="center">lower_bound(val)</td>
<td align="center">返回一个指向当前容器中（key）第一个大于或等于 val 的元素的双向迭代器。</td>
</tr>
<tr>
<td align="center">upper_bound(val)</td>
<td align="center">返回一个指向当前容器中（key）第一个大于 val 的元素的迭代器。</td>
</tr>
</tbody></table>
<h3 id="queue与stack的使用"><a href="#queue与stack的使用" class="headerlink" title="queue与stack的使用"></a>queue与stack的使用</h3><ul>
<li>queue成员函数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">成员函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">empty()</td>
<td align="center">如果 queue 中没有元素的话，返回 true</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回 queue 中元素的个数</td>
</tr>
<tr>
<td align="center">front()</td>
<td align="center">返回 queue 中第一个元素的引用</td>
</tr>
<tr>
<td align="center">back()</td>
<td align="center">返回 queue 中最后一个元素的引用</td>
</tr>
<tr>
<td align="center">push(const T&amp; obj)</td>
<td align="center">在 queue 的尾部添加一个元素的副本。<br>调用底层容器的成员函数 push_back() 。</td>
</tr>
<tr>
<td align="center">emplace()</td>
<td align="center">在 queue 的尾部直接添加一个元素。</td>
</tr>
<tr>
<td align="center">push(T&amp;&amp; obj)</td>
<td align="center">以移动的方式在 queue 的尾部添加元素。<br>调用底层容器的具有右值引用参数的成员函数 push_back()</td>
</tr>
<tr>
<td align="center">pop()</td>
<td align="center">删除 queue 中的第一个元素。</td>
</tr>
</tbody></table>
<ul>
<li>stack成员函数</li>
</ul>
<table>
<thead>
<tr>
<th align="center">成员函数</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td align="center">empty()</td>
<td align="center">当 stack 栈中没有元素时，该成员函数返回 true</td>
</tr>
<tr>
<td align="center">size()</td>
<td align="center">返回 stack 栈中存储元素的个数</td>
</tr>
<tr>
<td align="center">top()</td>
<td align="center">返回一个栈顶元素的引用，类型为 T&amp;。如果栈为空，程序会报错。</td>
</tr>
<tr>
<td align="center">push(const T&amp; val)</td>
<td align="center">先复制 val，再将 val 副本压入栈顶。调用底层容器的 push_back() 函数。</td>
</tr>
<tr>
<td align="center">push(T&amp;&amp; obj)</td>
<td align="center">以移动元素的方式将其压入栈顶。调用底层容器的有右值引用参数的 push_back() 函数。</td>
</tr>
<tr>
<td align="center">pop()</td>
<td align="center">弹出栈顶元素。</td>
</tr>
</tbody></table>
<ul>
<li><strong>stack 和queue 没有迭代器</strong>，因此访问元素的唯一方式是遍历容器，通过不断移除访问过的元素，去访问下一个元素。</li>
</ul>
<h3 id="priority-queue的使用"><a href="#priority-queue的使用" class="headerlink" title="priority_queue的使用"></a>priority_queue的使用</h3><p>优先队列具有与队列相似的操作：<code>top()</code>返回队首元素、<code>pop()</code>弹出队首元素、<code>push()</code>插入至队尾并排序。优先队列在内部添加了一个排序。其模板有3个参数：<code>priority_queue&lt; type, container, function &gt;</code>，<code>type</code>是存放的数据类型，<code>container</code>是实现优先队列的底层容器（一般都是<code>vector&lt;int&gt;</code>），<code>function</code>是元素之间的排序方式。</p>
<ul>
<li><p>大顶堆（降序队列）</p>
<p><code>priority_queue&lt;int&gt; a; //缺省情况下同下面定义</code></p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, less&lt;int&gt;&gt; a;</code></p>
</li>
<li><p>小顶堆（升序队列）</p>
<p><code>priority_queue&lt;int, vector&lt;int&gt;, greater&lt;int&gt;&gt; c;</code></p>
</li>
<li><p>常常把<code>pair&lt;int,int&gt;</code>作为数据类型存放进<code>priority_queue</code>里面，这时排序的规则就是先比较第一个元素，如果第一个元素相等再比较第二个元素。</p>
</li>
<li><p>对于自定义类型存放进<code>priority_queue</code>，那么仿函数<code>function</code>需要自己写。</p>
<p>具体写法定义一个类，里面定义<code>bool operator()(xxx,xxx)&#123;return a.x&lt;b.x;&#125;</code></p>
</li>
</ul>
<h3 id="STL常用算法"><a href="#STL常用算法" class="headerlink" title="STL常用算法"></a>STL常用算法</h3><ul>
<li><p>交换<code>swap()</code></p>
<p><code>vector</code>常用（交换容器中各元素的内存地址，并不是交换各个元素变量所存储的值）。</p>
<p>注意string是个例外，对string调用swap会导致迭代器、引用和指针失效</p>
<p>用法为：<code>swap(vec1,vec2);</code></p>
</li>
<li><p>逆序<code>reverse()</code></p>
<p><code>vector, string</code> 常用，反转在<code>[first,last)</code>范围内的顺序（包括first指向的元素，不包括last指向的元素），无返回值。</p>
<p>用法为<code>reverse(str.begin(),str.end());</code></p>
</li>
<li><p>统计<code>count()</code></p>
<p>统计某一值在一定范围内<code>[first,last)</code>出现的次数。</p>
<p>比如<code>int num = count(s.begin(),s.end(),&#39;a&#39;);</code></p>
</li>
<li><p>排序<code>sort()</code></p>
<p><code>sort (first, last) </code>对容器或普通数组中<code>[first, last)</code>范围内的元素进行排序，默认进行升序排序。</p>
<p><code>is_sorted (first, last)</code> 检测 <code>[first, last) </code>范围内是否已经排好序，默认检测是否按升序排序。</p>
<p><code>sort(vec.begin(), vec.end(), cmp)</code> 自定义比较函数<code>cmp</code></p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycomp</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (i &gt; j);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    std::vector&lt;<span class="keyword">int</span>&gt; vec&#123; <span class="number">32</span>, <span class="number">71</span>, <span class="number">12</span>, <span class="number">45</span>, <span class="number">26</span>, <span class="number">80</span>, <span class="number">53</span>, <span class="number">33</span> &#125;</span><br><span class="line">    <span class="comment">//降序排列，通过自定义比较规则进行排序</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), mycomp);</span><br><span class="line">    <span class="comment">//降序排列，利用lambda函数</span></span><br><span class="line">    <span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(), vec.<span class="built_in">end</span>(), [&amp;](<span class="keyword">int</span>&amp; i, <span class="keyword">int</span>&amp; j)&#123;<span class="keyword">return</span> i &gt; j;&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>自定义结构体排序：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">myData</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a, b;</span><br><span class="line">    <span class="built_in">myData</span>(<span class="keyword">int</span> a_, b_) : <span class="built_in">a</span>(a_), <span class="built_in">b</span>(b_) &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//自定义排序，按照a的大小，降序排列</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">cmp</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> myData&amp; data1, <span class="keyword">const</span> myData&amp; data2)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> data1.a &gt; data2.a;</span><br><span class="line">    &#125;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    set&lt;myData, cmp&gt; myset;</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">1</span>, <span class="number">100</span>));</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">2</span>, <span class="number">200</span>));</span><br><span class="line">    myset.<span class="built_in">insert</span>(<span class="built_in">myData</span>(<span class="number">3</span>, <span class="number">300</span>));</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : myset) &#123;</span><br><span class="line">        cout &lt;&lt; c.a &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>二分查找函数：</p>
<p><code>lower_bound(vec.begin(), vec.end(), target)</code>寻找<code>vec</code>数组中大于等于<code>target</code>的第一个数，返回其迭代器。</p>
<p><code>Upper_bound()</code>则是寻找第一个大于target的数。</p>
</li>
<li><p>全排列函数</p>
<p><code>next_permutation()</code>寻找下一个排列组合，<code>prev_permutation()</code>为上一个。</p>
<p>当<code> next_permutation()</code> 返回<code> false</code> 时，循环结束，表明到达最小排列。这样恰好可以生成 序列的全部排列。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">string str = <span class="string">&quot;1234&quot;</span>;</span><br><span class="line"><span class="built_in">sort</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>());</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    cout &lt;&lt; str &lt;&lt; endl;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(str.<span class="built_in">begin</span>(), str.<span class="built_in">end</span>()));</span><br></pre></td></tr></table></figure></li>
<li><p>原地删除<code>erase()</code></p>
<p>对于string：</p>
<ul>
<li><code>erase(pos,n);</code> 删除从下标<code>pos</code>开始的n个字符，比如<code>erase(0,1)</code>就是删除第一个字符。</li>
<li><code>erase(position);</code> 删除<code>postion</code>处的一个字符（<strong>position是一个string类型的迭代器</strong>）。</li>
<li><code>erase(first,last);</code> 删除从<code>first</code>到<code>last</code>之间的字符（<code>first</code>和<code>last</code>都是迭代器），注意是左闭右开。</li>
</ul>
<p>对于map：</p>
<ul>
<li><code>mymap.erase(key)</code>，会按key来删除map中对应的键值对。</li>
<li><code>mymap.erase(position)</code>，position为迭代器。</li>
<li><code>mymap.erase(first,last)</code>，删除迭代器表示的范围。</li>
</ul>
</li>
<li><p>子字符串<code>substr()</code></p>
<p><code>string sub=s.substr(pos);</code>复制从下标<code>pos</code>开始的一直到结尾的字符串为新的sub子串。</p>
<p><code>string sub=s.substr(pos,n)；</code>复制从下标<code>pos</code>开始的<code>n</code>个字符。</p>
</li>
<li><p>技巧：字符与数字的转换</p>
<ul>
<li><p>字符char 转为 数字int，利用<code>str[0]-‘0’</code></p>
</li>
<li><p>数字int 转为 字符char，利用<code>(7+&#39;0&#39;)</code></p>
</li>
<li><p>特殊字符char 转为 int，比如要把<code>&#39;a&#39;</code>转为0，<code>&#39;d&#39;</code>转为3。利用ASICII码，<code>’a’</code>的ASICII码为97，所以<code>(int)str[2]-97</code></p>
</li>
<li><p>字符串string 转为 int，<code>atoi()/stoi()</code>函数</p>
</li>
<li><p>整数int 转为字符串string，<code>to_string(value)</code>函数</p>
</li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>c++输入处理</tag>
      </tags>
  </entry>
  <entry>
    <title>回溯算法思想</title>
    <url>/posts/6957245a/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h1 id="回溯算法思想"><a href="#回溯算法思想" class="headerlink" title="回溯算法思想"></a>回溯算法思想</h1><p>回溯算法相当于一个决策树，解决一个决策树的遍历问题，需要考虑：</p>
<ul>
<li>路径：已经做出的选择</li>
<li>选择列表：可以做的选择</li>
<li>结束条件：到达决策树底层，无法做出选择的条件</li>
</ul>
<p>回溯框架：</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">result = []</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">backtrack</span>(<span class="params">路径，选择列表</span>):</span></span><br><span class="line">    <span class="keyword">if</span> 满足结束条件:</span><br><span class="line">        result.add(路径)</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> 选择 <span class="keyword">in</span> 选择列表:</span><br><span class="line">        做选择</span><br><span class="line">        backtrack(路径，选择列表)</span><br><span class="line">        撤销选择</span><br></pre></td></tr></table></figure>

<h2 id="子集穷举"><a href="#子集穷举" class="headerlink" title="子集穷举"></a>子集穷举</h2><ol start="78">
<li>给定一组不含重复元素的整数数组 <code>nums</code>，返回该数组所有可能的子集（幂集）。</li>
</ol>
<p>说明：解集不能包含重复的子集。</p>
<p>示例: 输入: nums = [1,2,3] 输出: [ [3],  [1],  [2],  [1,2,3],  [1,3],  [2,3],  [1,2],  [] ]</p>
<p><a href="https://leetcode-cn.com/problems/subsets/">力扣题目链接</a></p>
<img src="/posts/6957245a/image-20220404212935154.png" alt="image-20220404212935154" style="zoom:50%;">

<p><code>[1, 2, 3]</code>的全部子集为递归树上的所有节点，for循环横向遍历，递归纵向遍历</p>
<ul>
<li><p>递归参数：二维数组<code>result</code>存放子集组合，一维数组<code>path</code>收集路径元素，需要<code>start</code>参数控制递归</p>
</li>
<li><p>递归终止条件：<code>start</code>大于等于数组的长度。没有元素可取</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>单层逻辑：遍历整棵树，不需要剪枝</p>
</li>
</ul>
<p>完整代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//存储所有子集</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsets</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="comment">//记录走过的路径</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*回溯算法*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    res.<span class="built_in">push_back</span>(path); <span class="comment">//收集子集，始终在上面，防止漏掉自己，前序遍历的位置</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (start &gt;= nums.<span class="built_in">size</span>()) <span class="keyword">return</span>; <span class="comment">//可以不加，每次递归的下一层就是从i+1开始的</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//从start开始，防止产生重复子集</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">//做选择</span></span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="comment">//递归回溯</span></span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, path);</span><br><span class="line">        <span class="comment">//撤销选择</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="90">
<li>给定一个可能包含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</li>
</ol>
<p>说明：解集不能包含重复的子集。</p>
<p>示例:</p>
<ul>
<li>输入: [1,2,2]</li>
<li>输出: [ [2], [1], [1,2,2], [2,2], [1,2], [] ]</li>
</ul>
<p><a href="https://leetcode-cn.com/problems/subsets-ii/">力扣题目链接</a></p>
<p>解法：回溯+去重，同一层横向遍历需要去重（需要首先对集合排序）</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    result.<span class="built_in">push_back</span>(path);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// 对同一树层使用过的元素进行跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; start &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] ) &#123; <span class="comment">// 注意这里使用i &gt; start</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtrack</span>(nums, i + <span class="number">1</span>, path);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">subsetsWithDup</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 去重需要排序</span></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录走过的路径</span></span><br><span class="line">    <span class="built_in">backtrack</span>(nums, <span class="number">0</span>, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="组合"><a href="#组合" class="headerlink" title="组合"></a>组合</h2><p>给定两个整数 n 和 k，返回 1 … n 中所有可能的 k 个数的组合。</p>
<p>示例:<br>输入: <code> n = 4, k = 2</code><br>输出: <code> [[2,4], [3,4], [2,3], [1,2], [1,3], [1,4]]</code></p>
<p>解法：<code>combine(4, 2)</code>的结果，决策树的高度为k，宽度为n的所有叶子节点。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">//记录所有组合</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (k &lt;= <span class="number">0</span> || n &lt;= <span class="number">0</span>) <span class="keyword">return</span> res;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录走过的路径</span></span><br><span class="line">    <span class="built_in">backtrack</span>(n, k, <span class="number">1</span>, path);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtrack</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k, <span class="keyword">int</span> start, vector&lt;<span class="keyword">int</span>&gt;&amp; path)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//到达叶子节点更新result</span></span><br><span class="line">    <span class="keyword">if</span> (k == path.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//i从start开始递增</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt;= n; i++) &#123;</span><br><span class="line">        path.<span class="built_in">push_back</span>(i); <span class="comment">// 处理节点 </span></span><br><span class="line">        <span class="built_in">backtracking</span>(n, k, i + <span class="number">1</span>, path); <span class="comment">// 递归</span></span><br><span class="line">        path.<span class="built_in">pop_back</span>(); <span class="comment">// 回溯，撤销处理的节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>组合可以看作特定长度的子集，<code>combine(3, 2) </code>等价于 <code>subset([1, 2, 3])</code>长度为2 的子集</p>
<h2 id="排列"><a href="#排列" class="headerlink" title="排列"></a>排列</h2><ol start="46">
<li>给定一个 <strong>没有重复</strong> 数字的序列，返回其所有可能的全排列。</li>
</ol>
<p>示例:</p>
<ul>
<li>输入:<code> [1,2,3]</code></li>
<li>输出: <code>[[1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1]]</code></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/permutations/">力扣题目链接</a></p>
<p>解法：排列是有序的， <code>[1,2] </code>和 <code>[2,1]</code> 是两个集合，处理全排列问题不需要start防止重复。需要排除已经选择过的数字，将所有叶子节点作为结果。可以使用一个<code>used</code>数组，标记此时<code>path</code>中已经选择的元素，<strong>一个排列里一个元素只能使用一次</strong>。</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path; <span class="comment">//记录路径</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时说明到达叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">true</span>) <span class="keyword">continue</span>; <span class="comment">// path里已经收录的元素，直接跳过</span></span><br><span class="line">        used[i] = <span class="literal">true</span>;</span><br><span class="line">        path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">        <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">        path.<span class="built_in">pop_back</span>();</span><br><span class="line">        used[i] = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>; <span class="comment">//标记bool数组</span></span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ol start="47">
<li>给定一个<strong>可包含重复数字</strong>的序列 nums ，按任意顺序 返回所有不重复的全排列。</li>
</ol>
<p>示例 1：</p>
<ul>
<li>输入：<code>nums = [1,1,2]</code></li>
<li>输出：<code> [[1,1,2], [1,2,1], [2,1,1]]</code></li>
</ul>
<p>示例 2：</p>
<ul>
<li>输入：<code>nums = [1,2,3]</code></li>
<li>输出：<code>[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</code></li>
</ul>
<p><a href="https://leetcode-cn.com/problems/permutations-ii/">力扣题目链接</a></p>
<p>解法：回溯+去重，去重需要对元素序列排序，方便通过相近节点判断是否重复使用。</p>
<p>去重逻辑的关键代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line"><span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line"><span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>总体代码：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; path;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">backtracking</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, vector&lt;<span class="keyword">bool</span>&gt;&amp; used)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 此时说明找到了一组</span></span><br><span class="line">    <span class="keyword">if</span> (path.<span class="built_in">size</span>() == nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        result.<span class="built_in">push_back</span>(path);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="comment">// used[i - 1] == true，说明同一树枝nums[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// used[i - 1] == false，说明同一树层nums[i - 1]使用过</span></span><br><span class="line">        <span class="comment">// 如果同一树层nums[i - 1]使用过则直接跳过</span></span><br><span class="line">        <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; nums[i] == nums[i - <span class="number">1</span>] &amp;&amp; used[i - <span class="number">1</span>] == <span class="literal">false</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (used[i] == <span class="literal">false</span>) &#123;</span><br><span class="line">            used[i] = <span class="literal">true</span>;</span><br><span class="line">            path.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">            <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">            path.<span class="built_in">pop_back</span>();</span><br><span class="line">            used[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">    <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>()); <span class="comment">// 排序</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">used</span><span class="params">(nums.size(), <span class="literal">false</span>)</span></span>;</span><br><span class="line">    <span class="built_in">backtracking</span>(nums, used);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>回溯算法</tag>
        <tag>子集</tag>
        <tag>排列</tag>
        <tag>组合</tag>
      </tags>
  </entry>
  <entry>
    <title>二叉树基础</title>
    <url>/posts/84ac9751/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="二叉树基础"><a href="#二叉树基础" class="headerlink" title="二叉树基础"></a>二叉树基础</h2><h3 id="种类"><a href="#种类" class="headerlink" title="种类"></a>种类</h3><ul>
<li><strong>满二叉树</strong>：一棵二叉树只有度为0的结点和度为2的结点，并且度为0的结点在同一层上。</li>
</ul>
<img src="/posts/84ac9751/image-20220326214418676.png" alt="image-20220326214418676" style="zoom: 30%;">

<p>满二叉树的深度为k，有2^k-1个节点的二叉树。</p>
<ul>
<li><strong>完全二叉树</strong>：除了最底层节点可能没填满外，其余每层节点数都达到最大值，并且最下面一层的节点都集中在该层最左边的若干位置。若最底层为第 h 层，则该层包含 1~ 2^(h-1)  个节点。</li>
</ul>
<img src="/posts/84ac9751/image-20220326214559918.png" alt="image-20220326214559918" style="zoom:75%;">

<ul>
<li><strong>二叉搜索树</strong>：有序树，满足：<ul>
<li>若它的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li>
<li>若它的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</li>
<li>它的左、右子树也分别为二叉排序树。</li>
</ul>
</li>
</ul>
<img src="/posts/84ac9751/image-20220326214858888.png" alt="image-20220326214858888" style="zoom:75%;">

<ul>
<li><strong>平衡二叉搜索树</strong>：又被称为AVL（Adelson-Velsky and Landis）树，满足：<ul>
<li>是一棵空树或它的左右两个子树的高度差的绝对值不超过1；</li>
<li>左右两个子树都是一棵平衡二叉树。</li>
</ul>
</li>
</ul>
<img src="/posts/84ac9751/image-20220326215122495.png" alt="image-20220326215122495" style="zoom:75%;">

<table>
<thead>
<tr>
<th align="center">C++中常用容器</th>
<th align="center">底层实现</th>
</tr>
</thead>
<tbody><tr>
<td align="center">map、set、multimap，multiset</td>
<td align="center">平衡二叉搜索树</td>
</tr>
<tr>
<td align="center">unordered_map、unordered_set，<br>unordered_map、unordered_map</td>
<td align="center">哈希表</td>
</tr>
</tbody></table>
<h3 id="遍历方式"><a href="#遍历方式" class="headerlink" title="遍历方式"></a>遍历方式</h3><p>二叉树主要有两种遍历方式：</p>
<ol>
<li>深度优先遍历：先往深走，遇到叶子节点再往回走。前中后序遍历。</li>
<li>广度优先遍历：一层一层的去遍历。层次遍历。</li>
</ol>
<p>遍历顺序：</p>
<ul>
<li>前序遍历：中左右</li>
<li>中序遍历：左中右</li>
<li>后序遍历：左右中</li>
</ul>
<img src="/posts/84ac9751/image-20220326221443483.png" alt="image-20220326221443483" style="zoom:75%;">

<h3 id="二叉树定义："><a href="#二叉树定义：" class="headerlink" title="二叉树定义："></a>二叉树定义：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    TreeNode *left;</span><br><span class="line">    TreeNode *right;</span><br><span class="line">    <span class="built_in">TreeNode</span>(<span class="keyword">int</span> x) : <span class="built_in">val</span>(x), <span class="built_in">left</span>(<span class="literal">NULL</span>), <span class="built_in">right</span>(<span class="literal">NULL</span>) &#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="递归遍历"><a href="#递归遍历" class="headerlink" title="递归遍历"></a>递归遍历</h2><p>递归三要素：</p>
<ol>
<li><strong>确定递归函数的参数和返回值：</strong> 确定哪些参数是递归的过程中需要处理的，那么就在递归函数里加上这个参数， 并且还要明确每次递归的返回值是什么进而确定递归函数的返回类型。</li>
<li><strong>确定终止条件：</strong> 写完了递归算法, 运行的时候，经常会遇到栈溢出的错误，就是没写终止条件或者终止条件写的不对，操作系统也是用一个栈的结构来保存每一层递归的信息，如果递归没有终止，操作系统的内存栈必然就会溢出。</li>
<li><strong>确定单层递归的逻辑：</strong> 确定每一层递归需要处理的信息。在这里也就会重复调用自己来实现递归的过程。</li>
</ol>
<p><strong>每一次递归调用都会把函数的局部变量、参数值和返回地址等压入调用栈中</strong>，然后递归返回的时候，从栈顶弹出上一次递归的各项参数。</p>
<p>前序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*辅助遍历函数*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">        vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">        <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">/*主函数*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">    <span class="built_in">traversal</span>(root, result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">traversal</span><span class="params">(TreeNode* cur, vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cur == <span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;left, vec);  <span class="comment">// 左</span></span><br><span class="line">    <span class="built_in">traversal</span>(cur-&gt;right, vec); <span class="comment">// 右</span></span><br><span class="line">    vec.<span class="built_in">push_back</span>(cur-&gt;val);    <span class="comment">// 中</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="迭代遍历"><a href="#迭代遍历" class="headerlink" title="迭代遍历"></a>迭代遍历</h2><p>迭代法：用栈来实现递归</p>
<p>中序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>(); <span class="comment">// 将该节点弹出，避免重复操作，下面再将右中左节点添加到栈中</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 添加右节点（空节点不入栈）</span></span><br><span class="line"></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 添加中节点</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>); <span class="comment">// 中节点访问过，但是还没有处理，加入空节点做为标记。</span></span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 添加左节点（空节点不入栈）</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// 只有遇到空节点的时候，才将下一个节点放进结果集</span></span><br><span class="line">                st.<span class="built_in">pop</span>();           <span class="comment">// 将空节点弹出</span></span><br><span class="line">                node = st.<span class="built_in">top</span>();    <span class="comment">// 重新取出栈中元素</span></span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val); <span class="comment">// 加入到结果集</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>前序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*和中序遍历相比仅仅改变了两行代码的顺序*/</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">preorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<p>后序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">postorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        stack&lt;TreeNode*&gt; st;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) st.<span class="built_in">push</span>(root);</span><br><span class="line">        <span class="keyword">while</span> (!st.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* node = st.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">if</span> (node != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                st.<span class="built_in">push</span>(node);                          <span class="comment">// 中</span></span><br><span class="line">                st.<span class="built_in">push</span>(<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) st.<span class="built_in">push</span>(node-&gt;right);  <span class="comment">// 右</span></span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) st.<span class="built_in">push</span>(node-&gt;left);    <span class="comment">// 左</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                node = st.<span class="built_in">top</span>();</span><br><span class="line">                st.<span class="built_in">pop</span>();</span><br><span class="line">                result.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="层序遍历"><a href="#层序遍历" class="headerlink" title="层序遍历"></a>层序遍历</h2><p>解法：广度优先遍历，使用辅助队列，先进先出</p>
<p>层序遍历：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">levelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        queue&lt;TreeNode*&gt; que;</span><br><span class="line">        <span class="keyword">if</span> (root != <span class="literal">NULL</span>) que.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">while</span> (!que.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">int</span> size = que.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            <span class="comment">// 这里一定要使用固定大小size，不要使用que.size()，因为que.size是不断变化的</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                TreeNode* node = que.<span class="built_in">front</span>();</span><br><span class="line">                que.<span class="built_in">pop</span>();</span><br><span class="line">                vec.<span class="built_in">push_back</span>(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) que.<span class="built_in">push</span>(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) que.<span class="built_in">push</span>(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">push_back</span>(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树构造"><a href="#二叉树构造" class="headerlink" title="二叉树构造"></a>二叉树构造</h2><h3 id="中序与后序遍历序列构造二叉树"><a href="#中序与后序遍历序列构造二叉树" class="headerlink" title="中序与后序遍历序列构造二叉树"></a>中序与后序遍历序列构造二叉树</h3><p><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-inorder-and-postorder-traversal/">力扣题目链接</a></p>
<p>根据一棵树的中序遍历与后序遍历构造二叉树。</p>
<p>解法：对中序和后序遍历序列进行切割，找好切割区间，建议左闭右开。</p>
<p>中序数组 ==&gt; 左中序数组 + 根 + 右中序数组</p>
<p>后序数组 ==&gt; 左后序数组 + 右后序数组 + 根</p>
<p>递归求解：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">traversal</span> <span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; inorder, vector&lt;<span class="keyword">int</span>&gt;&amp; postorder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后序遍历数组最后一个元素，就是当前的中间节点</span></span><br><span class="line">    <span class="keyword">int</span> rootValue = postorder[postorder.<span class="built_in">size</span>() - <span class="number">1</span>];</span><br><span class="line">    TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(rootValue);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 叶子节点</span></span><br><span class="line">    <span class="keyword">if</span> (postorder.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> root;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 找到中序遍历的切割点</span></span><br><span class="line">    <span class="keyword">int</span> delimiterIndex;</span><br><span class="line">    <span class="keyword">for</span> (delimiterIndex = <span class="number">0</span>; delimiterIndex &lt; inorder.<span class="built_in">size</span>(); delimiterIndex++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (inorder[delimiterIndex] == rootValue) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割中序数组</span></span><br><span class="line">    <span class="comment">// 左闭右开区间：[0, delimiterIndex)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftInorder</span><span class="params">(inorder.begin(), inorder.begin() + delimiterIndex)</span></span>;</span><br><span class="line">    <span class="comment">// [delimiterIndex + 1, end)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightInorder</span><span class="params">(inorder.begin() + delimiterIndex + <span class="number">1</span>, inorder.end() )</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// postorder 舍弃末尾元素</span></span><br><span class="line">    postorder.<span class="built_in">resize</span>(postorder.<span class="built_in">size</span>() - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 切割后序数组</span></span><br><span class="line">    <span class="comment">// 依然左闭右开，注意这里使用了左中序数组大小作为切割点</span></span><br><span class="line">    <span class="comment">// [0, leftInorder.size)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">leftPostorder</span><span class="params">(postorder.begin(), postorder.begin() + leftInorder.size())</span></span>;</span><br><span class="line">    <span class="comment">// [leftInorder.size(), end)</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">rightPostorder</span><span class="params">(postorder.begin() + leftInorder.size(), postorder.end())</span></span>;</span><br><span class="line"></span><br><span class="line">    root-&gt;left = <span class="built_in">traversal</span>(leftInorder, leftPostorder);</span><br><span class="line">    root-&gt;right = <span class="built_in">traversal</span>(rightInorder, rightPostorder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="构造最大二叉树"><a href="#构造最大二叉树" class="headerlink" title="构造最大二叉树"></a>构造最大二叉树</h3><p><a href="https://leetcode-cn.com/problems/maximum-binary-tree/">力扣题目地址</a></p>
<p>给定一个不含重复元素的整数数组。一个以此数组构建的最大二叉树定义如下：</p>
<ul>
<li>二叉树的根是数组中的最大元素。</li>
<li>左子树是通过数组中最大值左边部分构造出的最大二叉树。</li>
<li>右子树是通过数组中最大值右边部分构造出的最大二叉树。</li>
</ul>
<p>通过给定的数组构建最大二叉树，并且输出这个树的根节点。</p>
<p>解析：首先找到序列的最大值，以最大值构造根节点，左子树区间 + 根节点（最大值）+ 右子树区间，递归构造子区间至少一个值</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="function">TreeNode* <span class="title">constructMaximumBinaryTree</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    TreeNode* node = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">1</span>) &#123;</span><br><span class="line">        node-&gt;val = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 找到数组中最大的值和对应的下标</span></span><br><span class="line">    <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxValueIndex = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] &gt; maxValue) &#123;</span><br><span class="line">            maxValue = nums[i];</span><br><span class="line">            maxValueIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    node-&gt;val = maxValue;</span><br><span class="line">    <span class="comment">// 最大值所在的下标左区间 构造左子树</span></span><br><span class="line">    <span class="keyword">if</span> (maxValueIndex &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin(), nums.begin() + maxValueIndex)</span></span>;</span><br><span class="line">        node-&gt;left = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最大值所在的下标右区间 构造右子树</span></span><br><span class="line">    <span class="keyword">if</span> (maxValueIndex &lt; (nums.<span class="built_in">size</span>() - <span class="number">1</span>)) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">newVec</span><span class="params">(nums.begin() + maxValueIndex + <span class="number">1</span>, nums.end())</span></span>;</span><br><span class="line">        node-&gt;right = <span class="built_in">constructMaximumBinaryTree</span>(newVec);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题必会：快速排序/选择</title>
    <url>/posts/202ade3b/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的逻辑是，若要对<code> nums[lo..hi]</code> 进⾏排序，我们先找⼀个分界点<code> p</code>，通过交换元素使得<code>nums[lo..p-1] </code>都⼩于等于<code> nums[p]</code>，且 <code>nums[p+1..hi] </code>都⼤于<code> nums[p]</code>，然后递归地去<code>nums[lo..p-1] </code>和<code>nums[p+1..hi] </code>中寻找新的分界点，最后整个数组就被排序了。</p>
<p>关键就在于这个分界点索引 <code>p</code> 的确定</p>
<img src="/posts/202ade3b/image-20220322165722861.png" alt="image-20220322165722861" style="zoom:50%;">

<p>索引<code>p</code>左侧的元素都⽐ <code>nums[p] </code>⼩，右侧的元素都⽐ <code>nums[p]</code>⼤，意味着这个元素已经放到了正确的位置 。</p>
<p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 快速排序主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 将 nums 数组随机打乱</span></span><br><span class="line"> 	<span class="built_in">shuffle</span>(nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"> 	<span class="built_in">quicksort</span>(nums, lo, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序核⼼逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line"> 	<span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line"> 	<span class="built_in">quicksort</span>(nums, lo, p - <span class="number">1</span>);</span><br><span class="line"> 	<span class="built_in">quicksort</span>(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分界点索引 p 的确定 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>, j = hi;</span><br><span class="line">    	<span class="comment">// 将 nums[lo] 作为默认分界点 p</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= nums[lo]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; j &amp;&amp; nums[j] &gt;= nums[lo]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//此时， nums[i] &gt; p &amp;&amp; nums[j] &lt; p，需交换 nums[i] 和 nums[j]</span></span><br><span class="line">            <span class="comment">//保证 nums[lo..i] &lt; p &lt; nums[j..hi]</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//将 p值（nums[lo]）交换到正确的位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[lo], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组元素进⾏随机打乱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><blockquote>
<p>相关题目：</p>
<ol start="215">
<li>数组中的第 K 个最⼤元素（中等）</li>
</ol>
</blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p> 解法：快排简化，可以在O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择需要找到第<code>k </code>大的枢（pivot），不需要对其左右再进行排序。快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为O($n^2$).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// ⾸先随机打乱数组</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数 - 快速选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小知识：二叉树</title>
    <url>/posts/471b5238/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><blockquote>
<p>相关题目：</p>
<ol start="226">
<li><p>翻转⼆叉树（简单） </p>
</li>
<li><p>⼆叉树展开为链表（中等） </p>
</li>
<li><p>填充每个节点的下⼀个右侧节点指针（中等）</p>
</li>
</ol>
</blockquote>
<p>二叉树递归：明确函数的定义，根据定义递归推导最终结果。先搞清楚当前根节点”该做什么”与”什么时候做”，然后根据函数定义递归调⽤⼦节点，让孩⼦节点做相同的事情。</p>
<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>输⼊⼀个⼆叉树根节点<code> root</code>，把整棵树镜像翻转，⼆叉树上的每⼀个节点的左右⼦节点进⾏交换。</p>
<img src="/posts/471b5238/invert1-tree.jpg" alt="img" style="zoom:50%;">



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将整棵树的节点翻转</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">//root节点需要交换它的左右节点</span></span><br><span class="line">    TreeNode* tmp = root -&gt; left;</span><br><span class="line">    root -&gt; left = root -&gt; right;</span><br><span class="line">    root -&gt; right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让左右⼦节点继续翻转它们的⼦节点</span></span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="填充⼆叉树节点的右侧指针"><a href="#填充⼆叉树节点的右侧指针" class="headerlink" title="填充⼆叉树节点的右侧指针"></a>填充⼆叉树节点的右侧指针</h3><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个<code> next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/471b5238/116_sample.png" alt="img" style="zoom:50%;">

<p>⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情，如果只依赖一个节点进行递归，无法连接跨父节点的两个相邻节点。需细化为两个节点进行递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">nullptr</span> || node2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传⼊的两个节点连接</span></span><br><span class="line">    node1 -&gt; next = node2;</span><br><span class="line">    <span class="comment">// 连接相同⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; left, node1 -&gt; right);</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node2 -&gt; left, node2 -&gt; right);</span><br><span class="line">    <span class="comment">// 连接跨越⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; right, node2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小知识：队列/栈</title>
    <url>/posts/16a357/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>队列主要⽤在 BFS 算法，栈主要⽤在括号相关的问题</p>
<h2 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h2><blockquote>
<p>相关题目：</p>
<ol start="232">
<li><p>⽤栈实现队列（简单） </p>
</li>
<li><p>⽤队列实现栈（简单） </p>
</li>
</ol>
</blockquote>
<p>队列：先进先出；栈：先进后出</p>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>双栈实现队列</p>
<img src="/posts/16a357/image-20220315182119191.png" alt="image-20220315182119191" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到队尾 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除队头的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">peek</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回队头元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>双队列实现栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到栈顶 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断栈是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号字符串问题"><a href="#括号字符串问题" class="headerlink" title="括号字符串问题"></a>括号字符串问题</h2><blockquote>
<p>相关题目：</p>
<ol start="20">
<li><p>有效的括号（简单） </p>
</li>
<li><p>使括号有效的最⼩添加（中等） </p>
</li>
<li><p>平衡括号串的最少插⼊（中等） </p>
</li>
</ol>
</blockquote>
<h3 id="判断合法括号字符串"><a href="#判断合法括号字符串" class="headerlink" title="判断合法括号字符串"></a>判断合法括号字符串</h3><p>输⼊⼀个字符串，其中包含<code>[]()&#123;&#125;</code>六种括号，判断这个字符串组成的括号是否合法。 </p>
<p>每个右括号 <code>)</code> 的左边必须有⼀个左括号 <code>(</code> 和它匹配。</p>
<p>解法：使用栈，遇到左括号就⼊栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            left.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字符 c 是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (!left.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">leftOf</span>(c) == left.<span class="built_in">top</span>())</span><br><span class="line">                left.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">// 和最近的左括号不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡括号串"><a href="#平衡括号串" class="headerlink" title="平衡括号串"></a>平衡括号串</h3><p>输⼊⼀个字符串 <code>s</code>，你可以在其中的任意位置插⼊左括号<code>(</code>或者右括号<code> )</code>，返回需要⼏次插⼊才能使得 <code>s </code>变成⼀个合法的括号串</p>
<p>输⼊ <code>s = &quot;())(&quot;</code>，算法应该返回 2，因为⾄少需要插⼊两次把 s 变成<code> &quot;(())()&quot;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 记录插⼊次数</span></span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>; <span class="comment">// need 变量记录右括号的需求量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 + 1</span></span><br><span class="line">            need++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 - 1\</span></span><br><span class="line"><span class="comment">            need--;</span></span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">                need = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 需插⼊⼀个左括号</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><blockquote>
<p>相关题目：</p>
<ol start="496">
<li><p>下⼀个更⼤元素I（简单） </p>
</li>
<li><p>下⼀个更⼤元素II（中等） </p>
</li>
<li><p>每⽇温度（中等） </p>
</li>
</ol>
</blockquote>
<p>单调栈：每次新元素⼊栈后，栈内的元素都保持有序（单调递增或单调递减）。 </p>
<p>一般只用来处理Next Greater Element 问题。</p>
<h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><p>⽐如：输⼊⼀个数组<code> nums = [2,1,2,4,3]</code>，返回数组<code> [4,2,4,-1,-1]</code>。 </p>
<p>解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4 ⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt;  s;</span><br><span class="line">    <span class="comment">// 倒着往栈⾥放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ;i++) &#123;</span><br><span class="line">        <span class="comment">// 判定个⼦⾼矮</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的 next great number</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定⼀个数组 T，这个数组存放的是近⼏天的天⽓⽓温，你返回⼀个等⻓的数组，计算：对于每⼀天，还要⾄少等多少天才能等到⼀个更暖和的⽓温；如果等不到那⼀天，填 0。</p>
<p>⽐如：输⼊ <code>T = [73,74,75,71,69,76]</code>，返回 <code>[1,1,3,2,1,0]</code>。 </p>
<p>解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天，只要等⼀天就能等到⼀个更暖和的⽓温，后⾯的同理。 </p>
<p>解法：单调栈，区别在于需要返回与Next Greater Number 的距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这⾥放元素索引，⽽不是元素</span></span><br><span class="line">    <span class="comment">/* 单调栈模板 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; T[s.<span class="built_in">top</span>()] &lt;= T[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : (s.<span class="built_in">top</span>() - i);</span><br><span class="line">        s.<span class="built_in">push</span>(i); <span class="comment">// 将索引⼊栈，⽽不是元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小知识：数组/链表</title>
    <url>/posts/a0fdfee0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储。</p>
<p>主要算法：双指针，可分为</p>
<ul>
<li>中间向两端扩散</li>
<li>两端向中间收缩</li>
<li>快慢指针</li>
</ul>
<h2 id="1-前缀和数组"><a href="#1-前缀和数组" class="headerlink" title="1. 前缀和数组"></a>1. 前缀和数组</h2><p>前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。</p>
<p><strong>注：原始数组/矩阵不可变，频繁查询某个区间的累加和。</strong></p>
<blockquote>
<p>相关题目：</p>
<ol start="303">
<li><p>区域和检索 - 数组不可变（中等） </p>
</li>
<li><p>⼆维区域和检索 - 矩阵不可变（中等） </p>
</li>
<li><p>和为K的⼦数组（中等） </p>
</li>
</ol>
</blockquote>
<p>一维数组的前缀和</p>
<img src="/posts/a0fdfee0/image-20220310181632054.png" alt="image-image-20220310181632054" style="zoom:50%;">

<p>新建一个<code>preSum</code>数组，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p>
<p>如果我想求索引区间<code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1] </code>得出。 </p>
<p>核心代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixSum</span> &#123;</span></span><br><span class="line"> <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; prefix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">     <span class="built_in">PrefixSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">     prefix.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">         prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> 	<span class="comment">/* 查询闭区间 [i, j] 的累加和 */</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"> 	 	<span class="keyword">return</span> prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组前缀和</p>
<img src="/posts/a0fdfee0/image-20220310183903115.png" alt="image-20220310183903115" style="zoom:33%;">

<p>如果我想计算红⾊的这个⼦矩阵的元素之和，可以⽤绿⾊矩阵减去蓝⾊矩阵减去橙⾊矩阵最后加上粉⾊矩 阵，⽽绿蓝橙粉这四个矩阵有⼀个共同的特点，就是左上⻆就是 (0, 0) 原点。 </p>
<p>那么我们可以维护⼀个⼆维 <code>preSum </code>数组，专⻔记录以原点为顶点的矩阵的元素之和，就可以⽤⼏次加减运算算出任何⼀个⼦矩阵的元素和：</p>
<h2 id="2-差分数组"><a href="#2-差分数组" class="headerlink" title="2. 差分数组"></a>2. 差分数组</h2><blockquote>
<p>相关题目：</p>
<ol start="370">
<li><p>区间加法（中等） </p>
</li>
<li><p>航班预订统计（中等） </p>
</li>
<li><p>拼⻋（中等）</p>
</li>
</ol>
</blockquote>
<p>差分数组的主要适⽤场景是<strong>频繁对原始数组的某个区间的元素进⾏增减</strong>。 </p>
<p>对 <code>nums</code> 数组构造⼀个 <code>diff</code> 差分数组，**<code>diff[i]</code>** 就是 <strong><code>nums[i]</code></strong> 和 <strong><code>nums[i-1]</code></strong> 之差：</p>
<img src="/posts/a0fdfee0/image-20220311120935829.jpg" alt="image-20220311120935829" style="zoom:50%;">

<p>这样构造差分数组 **<code>diff</code>**，就可以快速进⾏区间增减的操作，如果你想对区间 <code>nums[i..j] </code>的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让<code> diff[j+1] -= 3</code> 即可：</p>
<p>把差分数组抽象成⼀个类，包含 increment ⽅法和 result ⽅法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差分数组⼯具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span>   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; diff;	<span class="comment">//差分数组</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        assert nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">        diff,<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        	diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123; <span class="comment">//当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff数组减 val 了。</span></span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h2><blockquote>
<p>相关题目：</p>
<ol start="76">
<li><p>最⼩覆盖⼦串（困难） </p>
</li>
<li><p>字符串的排列（中等） </p>
</li>
<li><p>找到字符串中所有字⺟异位词（中等） </p>
</li>
<li><p>⽆重复字符的最⻓⼦串（中等） </p>
</li>
</ol>
</blockquote>
<p>滑动窗⼝算法的代码框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗⼝算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"> 	<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;	</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// c 是将移⼊窗⼝的字符</span></span><br><span class="line">		<span class="keyword">char</span> c = s[right];</span><br><span class="line">		<span class="comment">// 右移窗⼝</span></span><br><span class="line">		right++;</span><br><span class="line">		<span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line">		 ...</span><br><span class="line">		<span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">		<span class="comment">/********************/</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 判断左侧窗⼝是否要收缩</span></span><br><span class="line">		<span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line"> 		<span class="comment">// d 是将移出窗⼝的字符</span></span><br><span class="line"> 		<span class="keyword">char</span> d = s[left];</span><br><span class="line"> 		<span class="comment">// 左移窗⼝</span></span><br><span class="line"> 		left++;</span><br><span class="line"> 		<span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> 		...</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二分搜索"><a href="#4-二分搜索" class="headerlink" title="4. 二分搜索"></a>4. 二分搜索</h2><blockquote>
<p>相关题目：</p>
<ol start="704">
<li><p>⼆分查找（简单） </p>
</li>
<li><p>在排序数组中查找元素的第⼀个和最后⼀个位置（中等） </p>
</li>
</ol>
</blockquote>
<p>搜索一个元素，搜索区间两端闭，while带等号</p>
<p>搜索左右边界，左闭右开常用，while用小于号</p>
<p>零、二分查找框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。</p>
<h3 id="寻找一个数：存在返回其索引，不存在返回-1"><a href="#寻找一个数：存在返回其索引，不存在返回-1" class="headerlink" title="寻找一个数：存在返回其索引，不存在返回-1."></a>寻找一个数：存在返回其索引，不存在返回-1.</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找左侧边界的二分搜索："><a href="#寻找左侧边界的二分搜索：" class="headerlink" title="寻找左侧边界的二分搜索："></a>寻找左侧边界的二分搜索：</h3><p>左闭右开区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target ⽐所有数都⼤</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 类似之前算法的处理⽅式</span></span><br><span class="line">	<span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全闭区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找右侧边界的⼆分查找"><a href="#寻找右侧边界的⼆分查找" class="headerlink" title="寻找右侧边界的⼆分查找:"></a>寻找右侧边界的⼆分查找:</h3><p>左闭右开写法（常见）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全闭区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议搜索区间全都统⼀成了<strong>两端都闭</strong>，便于记忆，只要修改两处即可变化出三种写法</p>
<h2 id="5-原地修改数组"><a href="#5-原地修改数组" class="headerlink" title="5. 原地修改数组"></a>5. 原地修改数组</h2><blockquote>
<p>相关题目：</p>
<ol start="26">
<li><p>删除有序数组中的重复项（简单） </p>
</li>
<li><p>删除排序链表中的重复元素（简单） </p>
</li>
<li><p>移除元素（简单） </p>
</li>
<li><p>移动零（简单） </p>
</li>
</ol>
</blockquote>
<h3 id="有序数组-链表去重"><a href="#有序数组-链表去重" class="headerlink" title="有序数组/链表去重"></a>有序数组/链表去重</h3><p>通⽤解法：快慢指针技巧</p>
<h3 id="有序数组去重："><a href="#有序数组去重：" class="headerlink" title="有序数组去重："></a>有序数组去重：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != num[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] ⽆重复</span></span><br><span class="line">            num[slow] = num[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组⻓度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序链表去重："><a href="#有序链表去重：" class="headerlink" title="有序链表去重："></a>有序链表去重：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast -&gt; val != slow -&gt; val) &#123;</span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            slow -&gt; next = fast;</span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开与后⾯重复元素的连接</span></span><br><span class="line">    slow -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组原地删除元素："><a href="#数组原地删除元素：" class="headerlink" title="数组原地删除元素："></a>数组原地删除元素：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原地修改，将数组中的所有值为-0-的元素移到数组末尾："><a href="#原地修改，将数组中的所有值为-0-的元素移到数组末尾：" class="headerlink" title="原地修改，将数组中的所有值为 0 的元素移到数组末尾："></a>原地修改，将数组中的所有值为 0 的元素移到数组末尾：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 去除 nums 中的所有 0</span></span><br><span class="line">	<span class="comment">// 返回去除 0 之后的数组⻓度</span></span><br><span class="line">	<span class="keyword">int</span> p = <span class="built_in">removeElement</span>(nums, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 将 p 之后的所有元素赋值为 0</span></span><br><span class="line">	<span class="keyword">for</span> (; p &lt; nums.length; p++) &#123;</span><br><span class="line">		nums[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⻅上⽂代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-单链表"><a href="#6-单链表" class="headerlink" title="6. 单链表"></a>6. 单链表</h2><blockquote>
<p>相关题目：</p>
<ol start="21">
<li><p>合并两个有序链表（简单） </p>
</li>
<li><p>合并K个升序链表（困难） </p>
</li>
<li><p>环形链表（简单） </p>
</li>
<li><p>环形链表 II（中等） </p>
</li>
<li><p>链表的中间结点（简单） </p>
</li>
<li><p>相交链表（简单） </p>
</li>
<li><p>删除链表的倒数第 N 个结点（中等）</p>
</li>
</ol>
</blockquote>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>给定输⼊两个有序链表，把他俩合并成⼀个新的有序链表。</p>
<p>输入：<code>l1 = [1, 2, 4], l2 = [1, 3, 4]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4]</code></p>
<p>解法：设立虚拟头节点<code>dummy</code>，避免处理空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// ⽐较 p1 和 p2 两个指针</span></span><br><span class="line"> 		<span class="comment">// 将值较⼩的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span>(p1 -&gt; val &gt; p2 -&gt; val) &#123;</span><br><span class="line">            p -&gt; next = p2;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p -&gt; next = p1;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h3><p>给定输⼊k个有序链表，把他们合并成⼀个新的有序链表。</p>
<p>输入：<code>lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4, 5, 6]</code></p>
<p>解法：优先级队列（二叉堆），把链表节点放⼊⼀个最⼩堆，就可以每次获得 k 个节点中的最⼩节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; n) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.val &lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 优先级队列，最⼩堆</span></span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 k 个链表的头结点加⼊最⼩堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;head -&gt; val, head&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取最⼩节点，接到结果链表中</span></span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>().p;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            p -&gt; next = node;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;node -&gt; next -&gt; val, node -&gt; next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h3><p>要点：只遍历⼀次链表，就算出倒数第 k 个节点</p>
<img src="/posts/a0fdfee0/image-20220314210806020.png" alt="image-20220314210806020" style="zoom:50%;">

<p>指针<code>p1</code>指向<code>head</code>节点，开始走<code>k</code>步；</p>
<img src="/posts/a0fdfee0/image-20220314211006249.png" alt="image-20220314211006249" style="zoom:50%;">

<p>指针<code>p2</code>指向<code>head</code>节点，<code>p1</code>和<code>p2</code>同时走，<code>n-k</code>步后<code>p1</code>走到链表末尾空指针结束，返回<code>p2</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    <span class="comment">// p1 先⾛ k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时⾛ n - k 步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p2 = p2 -&gt; next;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表中点"><a href="#单链表中点" class="headerlink" title="单链表中点"></a>单链表中点</h3><p>解法：让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点<code> head</code>。 每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> ⾛到链表末尾时，<code>slow</code> 就指向了链 表中点。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> 	ListNode* slow = head, *fast = head;</span><br><span class="line"> 	<span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> 		slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果链表⻓度为偶数，也就是说中点有两个的时候，这个解法返回的节点是靠后的那个节点。 </p>
<h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><p>解法：快慢指针，每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast </code>最终和<code>slow</code>相遇，那肯定是<code> fast</code> 超过了<code>slow</code> ⼀圈，说明链表中含有环。</p>
<p>只需要把寻找链表中点的代码稍加修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> 	ListNode* slow = head, *fast = head;</span><br><span class="line"> 	<span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> 		slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算环的起点*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> 		<span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line">	 slow = head;</span><br><span class="line"> 	<span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"> 	<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"> 		fast = fast -&gt; next;</span><br><span class="line">     	slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>输⼊两个链表的头结点<code>headA</code>和<code> headB</code>，这两个链表可能存在相交。如果相交，应该返回相交的那个节点；如果没相交，则返回 <code>nullptr</code>。</p>
<p>解法：可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让<code> p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表<code> A</code>，这样相 当于「逻辑上」两条链表接在了⼀起。让<code> p1</code> 和<code> p2</code> 同时进⼊公共部分，也就是同时到达相交节点<code> c1</code></p>
<img src="/posts/a0fdfee0/image-20220315104422008.png" alt="image-20220315104422008" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode* p1 = headA, *p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-链表操作的递归实现"><a href="#7-链表操作的递归实现" class="headerlink" title="7. 链表操作的递归实现"></a>7. 链表操作的递归实现</h2><blockquote>
<p>相关题目：</p>
<ol start="206">
<li><p>反转链表（简单） </p>
</li>
<li><p>反转链表II（中等） </p>
</li>
</ol>
</blockquote>
<h3 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h3><p>输⼊⼀个节点 <code>head</code>，将以<code>head</code>为起点的链表反转，并返回反转之后的头结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归函数base case，如果链表只有⼀个节点的时候，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的头结点是last, 将head之后部分反转</span></span><br><span class="line">    ListNode* last = <span class="built_in">reverse</span>(head -&gt; next);</span><br><span class="line">    head -&gt; next -&gt; next = head;</span><br><span class="line">    <span class="comment">//head 变成了最后⼀个节点，别忘了链表的末尾要指向 null</span></span><br><span class="line">    head -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h3><p>解决思路和反转整个链表差不多，稍加修改即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* successor = <span class="literal">nullptr</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"> 		<span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line"> 		successor = head -&gt; next;</span><br><span class="line"> 		<span class="keyword">return</span> head;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line"> 	ListNode* last = <span class="built_in">reverseN</span>(head -&gt; next, n - <span class="number">1</span>);</span><br><span class="line"> 	head -&gt; next -&gt; next = head;</span><br><span class="line">	<span class="comment">// 让反转之后的 head 节点和后⾯的节点连起来</span></span><br><span class="line"> 	head -&gt; next = successor;</span><br><span class="line"> 	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h3><p>给⼀个索引区间<code> [left, right]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接上部分反转链表代码</span></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="52444d4cb1ffc588615b9d0abc49282209d3ebce20a5bcf437b678a72bf16e52">1b693c4938223286468132b2f7068bf6098157620d78df6a8d32bb51e3f325b181ab70623eeb2a3f7a6bc681afafbdfe713bdd1c6f193890fe2449d416193fec46af80b0cd7431187dd1f97bc499b3a9ff9add79cea27c3015bb48123e899a7fb3295784c80b5d0b121aef398aca2f36d3661e78c54305f10d7d8f9de07de7e9a370641812f840a8f68bb7686e6e75bf5aaa69b4f328fe94d17a00647b6bdeefac5ff68db076f26d217b7be239abd3dad05c88857aa0945ec9bbce8c501724e9cddcda090e0b5dd17670bc5b0aa146e5c15ead49d5bedec7e2d0ba426f9bac50c6fb7f935f8a01d86b0fb15bfc31774d8b2e748468978a57c9f314cf3474a8908c962e62d793d4202cc789c89f172859f6c45d905ca5828e4fcc14dcd0b72bc60fed7d44f9e29b4be00939342e416c9e56c67e04b79fdec1dcef56c7602d391c51365f0885c5f1e7daa21ef5f34ec737ba851e91be020d6b473ff53dc5082093a33f1899d7be4ed55ecb8a865ada024c8a8ccf66b6e0c51f2843e1248a0f483d118e82308bd4ea916657024bf2c31a5fb01da6ef08a8316c44e217bc4792319d995741257cca7ddaab847de991c6537d986a79b83e8cee1d44c948ed237bbcc65fe83890021b84452bd350bbc4b8eace2cf7b56a5ee838ce3f76d847cd9b091176a88ddd8759125c5ef6f3a128951a6a60b4eb9b3000103e3fc21e28fefb5237e8dff0724bbe862d7bd8b9bf0bed10f0b85b68b8267130266e872060622d62bcab8182471f42324384a307a3f7cf68a591c3e5123d7d983dde563a046f30df65686ba53da8448fba75896080e1fc7bfc6685c2bd7cd91d28907af15fdc166854210f6d488a3c62336376333997a4440bd58288eeb52b359fd4fa62455ee3f5f10c53851924baa240880212ebf3801c2f496b21c0fb67bddddc6b3884e9dca3b6f3742e05f59e3fb3035436dce19683e5ecbb48d4df737592b11ece81856380177c37c7309f768d3b64c48649aa82ebe5d29649bdba9af2df082e771827d4835afab8fe8e69b87e8b2404de6c41cc60fa45c843bf89bc83d73d1a8b7d55dc6f00f0e1e9480890bf6a324e584fc0c45ae457e9031622981ee83f0f275eb5682b05f2cd81b5f6b4776c9f3b90bf1857e78a3ea5bb4c83a4654de516eadfd438a5f4d9c25c2e48b6d7fead8c1cedb027faf44d8d9ce375ffc87532cc56f002835e0e55b75b96dad4592e56417416aaa6d22e08af6e5c565e005c516dfe25927804e35c11ed470916d60e9e941489205c98c96a1c888ec4fcabf2cd59cf7ed77d51cb5d4b8aa1a0837099b37341d56b907e8ddeec5e34bff8bbefffa2c864d1ef7de812c4e874d2b420505ae8e4416dd9a33cd3713be4adbe572af303bc6904b8a281f9df07fd21b063fc85f7540f2b44976f593cbd622314605f4e2e391b20c0ea22f3895d13e668c979815c9bdfda25095fb79ef6c023139f1d0f3acf0ab15ef22a6373a11b906fb98209de8a83f85444cb96081129e2c7c8421791beecabb01241aa70f09346209d23bfe18d60338ba3abb4792d594197c9abc95d1d962a49bbc34c25e156e252f6510f8441a614bea22f2f7116575536cd4d2b8f12df6d82d2d65026003aa1cd2996ddd6c1d93fd308591391dd88d7d70cca7d5f9fea6f9500b11312df71132d053f8da3910d17eb455a1dd11462bd65159ecc86cfb61b3f130c2f1be650e86328833e99d8d121a1a5632a250b3ab29980d598255adab11607e9da1b5156f399c285e3d748d84aa460fc4b3c71d8120e0d056fa0707e1d876213ddcefae8b856a0a8384b037dfc6ed753ac31508f19bd2321a9da8adb4b9fbbd3e28be1d495e338871e63b948a663665d9671a349abbc5aa7d895e794785302d5260eede14246baa774210d9d0fea4bf36853a865a781b35c8c482b46675e2ef1161d78856120df62ab968a5e8726f7d58f7f4d7824daff425475d82858438b9a4d06ede3f489262c13637eab07914138236b60f73ebef728d93aa59e789a6c21e4868886308f79701a80cce6098a7d050424f478e9151a87e9de5c53b3c2bc81b15b601a40ac452486f1149a6af9d4f70d4dbb9cc233e8cc2703e8bf13aa35a4fca77bcb9cec9e6f1195475ac4af9952e31a4319c1ad417666c224efa7eb95a7f957cffa0541af71a66bdb3759cf72a3bca8bbb5036ebf135ee0f0ad0fcc1170aefc5c9881466f69582a0bd565161355fc447fc0121359014e08b1533f1c896eedef7e15e3c770fe2c2f4068bdae19fc24d286ec5fd0f0925586cb2b481031bded5c5e1ff5fcc581d17df686aca3266e519cbb70c9189e4145ff103d5facc16bf1d9f7660967180fe8795f400729b8422768e0af1b32dfbdbe6414a5b94b593247c2cb2c9b10ec80be7d55726ded5c724c7c8ce4f2a76ca5021331ba0286ae6b94c3fb0b137d2b826ad083f4c2d1e1ae70fcbb8fe81d638464af4d326d60b621db96b26194ab2fb1fcb2913b0634ac96c2e9a62baaaf0816cc903f1a5e96c6db24c9217efa7494bc43e85cc8016ac2cb7e31b7b63fbebcd70b47ea05a756893dd823673bd077b20bd5bf23ba92ebfc0556679994403d835e852da90fbaf894e326028fe892fc04fe5b32d965877af6b24e4f3f924e54a3d3cbf4518c36662dca2cb4afaefbe8600cb747e49e0e2212149a02961e3a9cecd985188fcb7217e7fe08172a65d854b5aa33a7365a6c28cb1ad4a2e05de66c8c404f1a39f3ee5d858d42c0d5f9276b6ce0c28190d7db0b3c8606f1c420e17d74e241c44756c9aff1789827b3a00b20d0d87f7f2ac159df12d8389c7eed139660934d7be7bb284f7529fb1e8bb000685742a6a1bff1bf41a0cbc05736e8fcec2428f54bcc6570c75cc89fc2894d87e0f1c5e64750f197b02fca53580902f57818e9e08988555ea17ff42bb449dd547e955ce96f2fe96eaa09708b4dde5098748432d8ea7491ad60e20930453b941a79c0f6ce9721cb6f34e915abc5e8be238e448d573d435ba3ba7f04efabd82896385e9747a56a5f2fd83fb874031ca98abe25cd3f5059a05b7242ef1147aad5dba834d3eefac1e0d04b36b8b2c6fca0bb35349ab66544cd487b47ca08d12da5a2a443129b16b4326f17b5d94d3787e2d4a3110f2bbb3aab5078e00cdc3ddcb1327d98763f419487ec2f2535</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>
