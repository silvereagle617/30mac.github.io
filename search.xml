<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Zhang-Tong-CV</title>
    <url>/posts/676dd596/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<table>
    <tr>
        <td width="80%">
            <table>
                <tr>                    
                    <td align="left"><b>Master</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>School of Mechanical & Automotive Engineering, South China University of Technology</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Mail: zt_scut@163.com</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Phone: +86-18603372600</b></td>
                </tr>
                <tr>                    
                    <td align="left"><b>Address: 381 Wushan Road, Tianhe District, Guangzhou,Guangdong, China</b></td>
                </tr>                
            </table>
        </td>
        <td width="30%" height="100%">
            <img src="/images/image-20220306.jpg">
        </td>
    </tr>
</table>



<h2 id="Educational-Qualification"><a href="#Educational-Qualification" class="headerlink" title="Educational Qualification"></a>Educational Qualification</h2><ul>
<li><strong>Master</strong> in Vehicle Engineering(2023)<br>South China University of Technology,Guangzhou, China</li>
<li><strong>B.Eng</strong> in Vehicle Engineering(2020)<br>Hefei University of Technology, China</li>
</ul>
<h2 id="Project-amp-Internship-Experience"><a href="#Project-amp-Internship-Experience" class="headerlink" title="Project &amp; Internship Experience"></a>Project &amp; Internship Experience</h2><p><em>Software Testing Engineer Intern in Kaizeli Technology Co. ,Ltd. (2020.07-2020.09)</em></p>
<ul>
<li>Write test scripts according to requirements documents, using Linux command and shell language</li>
<li>Responsible for the on-board OTA and IVI module testing projects, complete the test unit and upload test reports</li>
<li>Participated in the project of automated test platform, and improve the design of the testing interface, carry out a detailed needs analysis and use case design. </li>
</ul>
<p><em>Software Testing Engineer Intern in GAC R&amp;D Center. (2020.10—2020.12)</em></p>
<ul>
<li>Understand the principle of CAN communication, and using CAN communication tools,  such as Vehicle-Spy、KVaser, to sample the test signal </li>
<li>Carry out on-board system function module test, and complete data detection, calibration, log acquisition and analysis</li>
<li>Participate in on-board system test of multiple models, and update test cases according to requirements and feedback</li>
</ul>
<p><em>Software Design Engineer Intern in Shenzhen Lan-You Technology Co. ,Ltd. (2021.08-2021.11)</em></p>
<ul>
<li>Assisted in the implementation of simulation software of automatic vehicle, design test scenarios in ACC、AEB、LKA , complete design documents and scenario scripts</li>
<li>Responsible for the parking area map design and visualization, compile the program scripts for parsing XML files, and using QT software for visual display</li>
<li>Complete the preliminary project and generate 858 test scenario scripts totally,  and  using the  parking area visualization program to help verify the reliability of map file data</li>
</ul>
<h2 id="Research-Experience"><a href="#Research-Experience" class="headerlink" title="Research Experience"></a>Research Experience</h2><ul>
<li>Participate in the Innovation training program for college students in Anhui Province 2018, Intelligent lane changing auxiliary system Based on longitudinal and lateral dynamic control,  responsible for building vehicle dynamics model and using CarSim software for simulation</li>
<li>Participate in the Innovation training program for college students in Anhui Province 2019, Design and motion control of multi-mode reconfigurable for self-driving vehicle, responsible for help generate physical model using Catia drawing software, and Assisted in the implementation of the printed circuit board design</li>
<li>Research on driver fatigue detection method based on facial features, the graduation project, used CNN for facial landmarks detection and a pre-trained network for training on the data set, using SVM algorithm to generate model of facial fatigue feature classification </li>
</ul>
<h2 id="Campus-Experience"><a href="#Campus-Experience" class="headerlink" title="Campus Experience"></a>Campus Experience</h2><p><em>Commissary in charge of studies, School of Automotive &amp; Transportation Engineering, Hefei University of Technology (2016-2020)</em></p>
<ul>
<li>Responsible for the study management in class and communicate with teachers to arrange experimental courses</li>
<li>Planning and hosting the meeting for exchange of learning experience, responsible for inviting outstanding graduates to give speeches and more than 300 college students participate in the Event</li>
</ul>
<h2 id="Social-Practice-Experience"><a href="#Social-Practice-Experience" class="headerlink" title="Social Practice Experience"></a>Social Practice Experience</h2><p><em>Support Teacher of Feng huang primary school, Chaohu, Anhui Province (2017)</em></p>
<ul>
<li>As a math teacher and physical education teacher for primary school students, spent a pleasant and meaningful summer with them</li>
<li>Planted the seeds of learning and encouraged them to explore the world</li>
<li>Increased responsibilities and accountability through communication with primary school students</li>
</ul>
<h2 id="Awards"><a href="#Awards" class="headerlink" title="Awards"></a>Awards</h2><ul>
<li>Second-class scholarship(2x) and Third-class scholarship in Hefei University of Technology </li>
<li>Outstanding student cadres in HFUT</li>
<li>Excellent graduation project for Bachelor’s degree</li>
<li>No.7 of men’s team competition in the National Student Shuttlecock Championship College group </li>
</ul>
<h2 id="Skills"><a href="#Skills" class="headerlink" title="Skills"></a>Skills</h2><ul>
<li>CET-6</li>
<li>Familiar with C/C++, Python</li>
<li>Familiar with the Linux operating system</li>
</ul>
<h2 id="Self-evaluation"><a href="#Self-evaluation" class="headerlink" title="Self-evaluation"></a>Self-evaluation</h2><p>I am an optimistic and positive person and interested in the emergence of new things and new ideas. I can set goals with others and accomplish them through the power of teamwork and communication. My main research interest is computer vision and deep learning,  and I have an understanding of machine learning, sensor fusion and computer science.</p>
]]></content>
  </entry>
  <entry>
    <title>二叉树基础</title>
    <url>/posts/84ac9751/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id><a href="#" class="headerlink" title></a></h2>]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题必会：快速排序/选择</title>
    <url>/posts/202ade3b/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序的逻辑是，若要对<code> nums[lo..hi]</code> 进⾏排序，我们先找⼀个分界点<code> p</code>，通过交换元素使得<code>nums[lo..p-1] </code>都⼩于等于<code> nums[p]</code>，且 <code>nums[p+1..hi] </code>都⼤于<code> nums[p]</code>，然后递归地去<code>nums[lo..p-1] </code>和<code>nums[p+1..hi] </code>中寻找新的分界点，最后整个数组就被排序了。</p>
<p>关键就在于这个分界点索引 <code>p</code> 的确定</p>
<img src="/posts/202ade3b/image-20220322165722861.png" alt="image-20220322165722861" style="zoom:50%;">

<p>索引<code>p</code>左侧的元素都⽐ <code>nums[p] </code>⼩，右侧的元素都⽐ <code>nums[p]</code>⼤，意味着这个元素已经放到了正确的位置 。</p>
<p>实现代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 快速排序主函数 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">qsort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line"> 	<span class="comment">// 将 nums 数组随机打乱</span></span><br><span class="line"> 	<span class="built_in">shuffle</span>(nums);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> lo = <span class="number">0</span>, hi = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line"> 	<span class="built_in">quicksort</span>(nums, lo, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 快速排序核⼼逻辑 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (lo &gt;= hi) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">int</span> p = <span class="built_in">partition</span>(nums, lo, hi);</span><br><span class="line">    <span class="comment">// 现在 nums[lo..p-1] 都⼩于 nums[p]，</span></span><br><span class="line"> 	<span class="comment">// 且 nums[p+1..hi] 都⼤于 nums[p]</span></span><br><span class="line"> 	<span class="built_in">quicksort</span>(nums, lo, p - <span class="number">1</span>);</span><br><span class="line"> 	<span class="built_in">quicksort</span>(nums, p + <span class="number">1</span>, hi);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 分界点索引 p 的确定 */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> lo, <span class="keyword">int</span> hi)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = lo + <span class="number">1</span>, j = hi;</span><br><span class="line">    	<span class="comment">// 将 nums[lo] 作为默认分界点 p</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; hi &amp;&amp; nums[i] &lt;= nums[lo]) &#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (lo &lt; j &amp;&amp; nums[j] &gt;= nums[lo]) &#123;</span><br><span class="line">                --j;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//此时， nums[i] &gt; p &amp;&amp; nums[j] &lt; p，需交换 nums[i] 和 nums[j]</span></span><br><span class="line">            <span class="comment">//保证 nums[lo..i] &lt; p &lt; nums[j..hi]</span></span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">    	<span class="comment">//将 p值（nums[lo]）交换到正确的位置</span></span><br><span class="line">        <span class="built_in">swap</span>(nums[lo], nums[j]);</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对数组元素进⾏随机打乱</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="快速选择"><a href="#快速选择" class="headerlink" title="快速选择"></a>快速选择</h2><blockquote>
<p>相关题目：</p>
<ol start="215">
<li>数组中的第 K 个最⼤元素（中等）</li>
</ol>
</blockquote>
<p>给定整数数组 <code>nums</code> 和整数 <code>k</code>，请返回数组中第 <code>k</code> 个最大的元素。请注意，需要找的是数组排序后的第 <code>k</code> 个最大的元素，而不是第 <code>k</code> 个不同的元素。</p>
<p> 解法：快排简化，可以在O(n) 时间复杂度，O(1) 空间复杂度完成求解工作。快速选择需要找到第<code>k </code>大的枢（pivot），不需要对其左右再进行排序。快速选择一般需要先打乱数组，否则最坏情况下时间复杂度为O($n^2$).</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//主函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    	<span class="built_in">random_shuffle</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());<span class="comment">// ⾸先随机打乱数组</span></span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = nums.<span class="built_in">size</span>() - <span class="number">1</span>, target = nums.<span class="built_in">size</span>() - k;</span><br><span class="line">        <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = <span class="built_in">quickSelection</span>(nums, l, r);</span><br><span class="line">            <span class="keyword">if</span> (mid == target) &#123;</span><br><span class="line">                <span class="keyword">return</span> nums[mid];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (mid &gt; target) &#123;</span><br><span class="line">                r = mid - <span class="number">1</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[l];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//辅助函数 - 快速选择</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quickSelection</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = l + <span class="number">1</span>, j = r;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; r &amp;&amp; nums[i] &lt;= nums[l]) &#123;</span><br><span class="line">            ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; j &amp;&amp; nums[j] &gt;= nums[l]) &#123;</span><br><span class="line">            --j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">swap</span>(nums[l], nums[j]);</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>数组</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小知识：二叉树</title>
    <url>/posts/471b5238/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<h2 id="二叉树遍历"><a href="#二叉树遍历" class="headerlink" title="二叉树遍历"></a>二叉树遍历</h2><blockquote>
<p>相关题目：</p>
<ol start="226">
<li><p>翻转⼆叉树（简单） </p>
</li>
<li><p>⼆叉树展开为链表（中等） </p>
</li>
<li><p>填充每个节点的下⼀个右侧节点指针（中等）</p>
</li>
</ol>
</blockquote>
<p>二叉树递归：明确函数的定义，根据定义递归推导最终结果。先搞清楚当前根节点”该做什么”与”什么时候做”，然后根据函数定义递归调⽤⼦节点，让孩⼦节点做相同的事情。</p>
<h3 id="翻转二叉树"><a href="#翻转二叉树" class="headerlink" title="翻转二叉树"></a>翻转二叉树</h3><p>输⼊⼀个⼆叉树根节点<code> root</code>，把整棵树镜像翻转，⼆叉树上的每⼀个节点的左右⼦节点进⾏交换。</p>
<img src="/posts/471b5238/invert1-tree.jpg" alt="img" style="zoom:50%;">



<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 将整棵树的节点翻转</span></span><br><span class="line"><span class="function">TreeNode* <span class="title">invertTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//base case</span></span><br><span class="line">    <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">//root节点需要交换它的左右节点</span></span><br><span class="line">    TreeNode* tmp = root -&gt; left;</span><br><span class="line">    root -&gt; left = root -&gt; right;</span><br><span class="line">    root -&gt; right = tmp;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 让左右⼦节点继续翻转它们的⼦节点</span></span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; left);</span><br><span class="line">    <span class="built_in">invertTree</span>(root -&gt; right);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="填充⼆叉树节点的右侧指针"><a href="#填充⼆叉树节点的右侧指针" class="headerlink" title="填充⼆叉树节点的右侧指针"></a>填充⼆叉树节点的右侧指针</h3><p>给定一个 <strong>完美二叉树</strong> ，其所有叶子节点都在同一层，每个父节点都有两个子节点。填充它的每个<code> next</code> 指针，让这个指针指向其下一个右侧节点。如果找不到下一个右侧节点，则将 <code>next</code> 指针设置为 <code>NULL</code>。初始状态下，所有 next 指针都被设置为 <code>NULL</code>。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> val;</span><br><span class="line">  Node *left;</span><br><span class="line">  Node *right;</span><br><span class="line">  Node *next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<img src="/posts/471b5238/116_sample.png" alt="img" style="zoom:50%;">

<p>⼆叉树的问题难点在于，如何把题⽬的要求细化成每个节点需要做的事情，如果只依赖一个节点进行递归，无法连接跨父节点的两个相邻节点。需细化为两个节点进行递归。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 主函数</span></span><br><span class="line"><span class="function">Node* <span class="title">connect</span><span class="params">(Node* root)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(root -&gt; left, root -&gt; right);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 辅助函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">connectTwoNode</span><span class="params">(Node* node1, Node* node2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (node1 == <span class="literal">nullptr</span> || node2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**** 前序遍历位置 ****/</span></span><br><span class="line">    <span class="comment">// 将传⼊的两个节点连接</span></span><br><span class="line">    node1 -&gt; next = node2;</span><br><span class="line">    <span class="comment">// 连接相同⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; left, node1 -&gt; right);</span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node2 -&gt; left, node2 -&gt; right);</span><br><span class="line">    <span class="comment">// 连接跨越⽗节点的两个⼦节点</span></span><br><span class="line">    <span class="built_in">connectTwoNode</span>(node1 -&gt; right, node2 -&gt; left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <tags>
        <tag>二叉树</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小知识：队列/栈</title>
    <url>/posts/16a357/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>队列主要⽤在 BFS 算法，栈主要⽤在括号相关的问题</p>
<h2 id="队列实现栈以及栈实现队列"><a href="#队列实现栈以及栈实现队列" class="headerlink" title="队列实现栈以及栈实现队列"></a>队列实现栈以及栈实现队列</h2><blockquote>
<p>相关题目：</p>
<ol start="232">
<li><p>⽤栈实现队列（简单） </p>
</li>
<li><p>⽤队列实现栈（简单） </p>
</li>
</ol>
</blockquote>
<p>队列：先进先出；栈：先进后出</p>
<h3 id="用栈实现队列"><a href="#用栈实现队列" class="headerlink" title="用栈实现队列"></a>用栈实现队列</h3><p>双栈实现队列</p>
<img src="/posts/16a357/image-20220315182119191.png" alt="image-20220315182119191" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s1;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s2;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到队尾 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        s1.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除队头的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> res = <span class="built_in">peek</span>();</span><br><span class="line">        s2.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回队头元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!s1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                s2.<span class="built_in">push</span>(s1.<span class="built_in">top</span>());</span><br><span class="line">                s1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s2.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断队列是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s1.<span class="built_in">empty</span>() &amp;&amp; s2.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="用队列实现栈"><a href="#用队列实现栈" class="headerlink" title="用队列实现栈"></a>用队列实现栈</h3><p>双队列实现栈</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q1;</span><br><span class="line">    queue&lt;<span class="keyword">int</span>&gt; q2;</span><br><span class="line">    <span class="built_in">MyStack</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 添加元素到栈顶 */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        q2.<span class="built_in">push</span>(x);</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            q2.<span class="built_in">push</span>(q1.<span class="built_in">front</span>());</span><br><span class="line">            q1.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(q1, q2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 删除栈顶的元素并返回 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 返回栈顶元素 */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> r = q1.<span class="built_in">front</span>();</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** 判断栈是否为空 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="括号字符串问题"><a href="#括号字符串问题" class="headerlink" title="括号字符串问题"></a>括号字符串问题</h2><blockquote>
<p>相关题目：</p>
<ol start="20">
<li><p>有效的括号（简单） </p>
</li>
<li><p>使括号有效的最⼩添加（中等） </p>
</li>
<li><p>平衡括号串的最少插⼊（中等） </p>
</li>
</ol>
</blockquote>
<h3 id="判断合法括号字符串"><a href="#判断合法括号字符串" class="headerlink" title="判断合法括号字符串"></a>判断合法括号字符串</h3><p>输⼊⼀个字符串，其中包含<code>[]()&#123;&#125;</code>六种括号，判断这个字符串组成的括号是否合法。 </p>
<p>每个右括号 <code>)</code> 的左边必须有⼀个左括号 <code>(</code> 和它匹配。</p>
<p>解法：使用栈，遇到左括号就⼊栈，遇到右括号就去栈中寻找最近的左括号，看是否匹配</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">    stack&lt;<span class="keyword">char</span>&gt; left;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">char</span> c : str) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> || c == <span class="string">&#x27;[&#x27;</span> || c == <span class="string">&#x27;&#123;&#x27;</span>) &#123;</span><br><span class="line">            left.<span class="built_in">push</span>(c);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 字符 c 是右括号</span></span><br><span class="line">            <span class="keyword">if</span> (!left.<span class="built_in">empty</span>() &amp;&amp; <span class="built_in">leftOf</span>(c) == left.<span class="built_in">top</span>())</span><br><span class="line">                left.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                <span class="comment">// 和最近的左括号不匹配</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left.<span class="built_in">empty</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">char</span> <span class="title">leftOf</span><span class="params">(<span class="keyword">char</span> c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;)&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;(&#x27;</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="string">&#x27;&#125;&#x27;</span>) <span class="keyword">return</span> <span class="string">&#x27;&#123;&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">&#x27;[&#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="平衡括号串"><a href="#平衡括号串" class="headerlink" title="平衡括号串"></a>平衡括号串</h3><p>输⼊⼀个字符串 <code>s</code>，你可以在其中的任意位置插⼊左括号<code>(</code>或者右括号<code> )</code>，返回需要⼏次插⼊才能使得 <code>s </code>变成⼀个合法的括号串</p>
<p>输⼊ <code>s = &quot;())(&quot;</code>，算法应该返回 2，因为⾄少需要插⼊两次把 s 变成<code> &quot;(())()&quot;</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">minAddToMakeValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>; <span class="comment">// res 记录插⼊次数</span></span><br><span class="line">    <span class="keyword">int</span> need = <span class="number">0</span>; <span class="comment">// need 变量记录右括号的需求量</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 + 1</span></span><br><span class="line">            need++; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s[i] == <span class="string">&#x27;)&#x27;</span>) &#123;</span><br><span class="line">            <span class="comment">// 对右括号的需求 - 1\</span></span><br><span class="line"><span class="comment">            need--;</span></span><br><span class="line">            <span class="keyword">if</span> (need == <span class="number">-1</span>) &#123;</span><br><span class="line">                need = <span class="number">0</span>;</span><br><span class="line">                <span class="comment">// 需插⼊⼀个左括号</span></span><br><span class="line">                res++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res + need;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="单调栈结构"><a href="#单调栈结构" class="headerlink" title="单调栈结构"></a>单调栈结构</h2><blockquote>
<p>相关题目：</p>
<ol start="496">
<li><p>下⼀个更⼤元素I（简单） </p>
</li>
<li><p>下⼀个更⼤元素II（中等） </p>
</li>
<li><p>每⽇温度（中等） </p>
</li>
</ol>
</blockquote>
<p>单调栈：每次新元素⼊栈后，栈内的元素都保持有序（单调递增或单调递减）。 </p>
<p>一般只用来处理Next Greater Element 问题。</p>
<h3 id="单调栈模板"><a href="#单调栈模板" class="headerlink" title="单调栈模板"></a>单调栈模板</h3><p>⽐如：输⼊⼀个数组<code> nums = [2,1,2,4,3]</code>，返回数组<code> [4,2,4,-1,-1]</code>。 </p>
<p>解释：第⼀个 2 后⾯⽐ 2 ⼤的数是 4; 1 后⾯⽐ 1 ⼤的数是 2；第⼆个 2 后⾯⽐ 2 ⼤的数是 4; 4 后⾯没有⽐ 4 ⼤的数，填 -1；3 后⾯没有⽐ 3 ⼤的数，填 -1。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nextGreaterElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(nums.size())</span></span>; <span class="comment">// 存放答案的数组</span></span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt;  s;</span><br><span class="line">    <span class="comment">// 倒着往栈⾥放</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span> ;i++) &#123;</span><br><span class="line">        <span class="comment">// 判定个⼦⾼矮</span></span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; s.<span class="built_in">top</span>() &lt;= nums[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// nums[i] 身后的 next great number</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">        s.<span class="built_in">push</span>(nums[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="每日温度"><a href="#每日温度" class="headerlink" title="每日温度"></a>每日温度</h3><p>给定⼀个数组 T，这个数组存放的是近⼏天的天⽓⽓温，你返回⼀个等⻓的数组，计算：对于每⼀天，还要⾄少等多少天才能等到⼀个更暖和的⽓温；如果等不到那⼀天，填 0。</p>
<p>⽐如：输⼊ <code>T = [73,74,75,71,69,76]</code>，返回 <code>[1,1,3,2,1,0]</code>。 </p>
<p>解释：第⼀天 73 华⽒度，第⼆天 74 华⽒度，⽐ 73 ⼤，所以对于第⼀天，只要等⼀天就能等到⼀个更暖和的⽓温，后⾯的同理。 </p>
<p>解法：单调栈，区别在于需要返回与Next Greater Number 的距离。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dailyTemperatures</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; T)</span> </span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(T.size())</span></span>;</span><br><span class="line">    stack&lt;<span class="keyword">int</span>&gt; s; <span class="comment">// 这⾥放元素索引，⽽不是元素</span></span><br><span class="line">    <span class="comment">/* 单调栈模板 */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = T.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span>(!s.<span class="built_in">empty</span>() &amp;&amp; T[s.<span class="built_in">top</span>()] &lt;= T[i]) &#123;</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到索引间距</span></span><br><span class="line">        res[i] = s.<span class="built_in">empty</span>() ? <span class="number">0</span> : (s.<span class="built_in">top</span>() - i);</span><br><span class="line">        s.<span class="built_in">push</span>(i); <span class="comment">// 将索引⼊栈，⽽不是元素</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>队列</tag>
        <tag>栈</tag>
      </tags>
  </entry>
  <entry>
    <title>刷题小知识：数组/链表</title>
    <url>/posts/a0fdfee0/</url>
    <content><![CDATA[<hr>
<span id="more"></span>

<p>数组链表代表着计算机最基本的两种存储形式：顺序存储和链式存储。</p>
<p>主要算法：双指针，可分为</p>
<ul>
<li>中间向两端扩散</li>
<li>两端向中间收缩</li>
<li>快慢指针</li>
</ul>
<h2 id="1-前缀和数组"><a href="#1-前缀和数组" class="headerlink" title="1. 前缀和数组"></a>1. 前缀和数组</h2><p>前缀和技巧适⽤于快速、频繁地计算⼀个索引区间内的元素之和。</p>
<p><strong>注：原始数组/矩阵不可变，频繁查询某个区间的累加和。</strong></p>
<blockquote>
<p>相关题目：</p>
<ol start="303">
<li><p>区域和检索 - 数组不可变（中等） </p>
</li>
<li><p>⼆维区域和检索 - 矩阵不可变（中等） </p>
</li>
<li><p>和为K的⼦数组（中等） </p>
</li>
</ol>
</blockquote>
<p>一维数组的前缀和</p>
<img src="/posts/a0fdfee0/image-20220310181632054.png" alt="image-image-20220310181632054" style="zoom:50%;">

<p>新建一个<code>preSum</code>数组，<code>preSum[i]</code> 记录 <code>nums[0..i-1]</code> 的累加和</p>
<p>如果我想求索引区间<code>[1, 4]</code> 内的所有元素之和，就可以通过 <code>preSum[5] - preSum[1] </code>得出。 </p>
<p>核心代码：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PrefixSum</span> &#123;</span></span><br><span class="line"> <span class="comment">// 前缀和数组</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">     vector&lt;<span class="keyword">int</span>&gt; prefix;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="comment">/* 输⼊⼀个数组，构造前缀和 */</span></span><br><span class="line">     <span class="built_in">PrefixSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">     prefix.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">     <span class="comment">// 计算 nums 的累加和</span></span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prefix.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">         prefix[i] = prefix[i - <span class="number">1</span>] + nums[i - <span class="number">1</span>];</span><br><span class="line">     	&#125;</span><br><span class="line">     &#125;</span><br><span class="line"> 	<span class="comment">/* 查询闭区间 [i, j] 的累加和 */</span></span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">query</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line"> 	 	<span class="keyword">return</span> prefix[j + <span class="number">1</span>] - prefix[i];</span><br><span class="line"> 	 &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二维数组前缀和</p>
<img src="/posts/a0fdfee0/image-20220310183903115.png" alt="image-20220310183903115" style="zoom:33%;">

<p>如果我想计算红⾊的这个⼦矩阵的元素之和，可以⽤绿⾊矩阵减去蓝⾊矩阵减去橙⾊矩阵最后加上粉⾊矩 阵，⽽绿蓝橙粉这四个矩阵有⼀个共同的特点，就是左上⻆就是 (0, 0) 原点。 </p>
<p>那么我们可以维护⼀个⼆维 <code>preSum </code>数组，专⻔记录以原点为顶点的矩阵的元素之和，就可以⽤⼏次加减运算算出任何⼀个⼦矩阵的元素和：</p>
<h2 id="2-差分数组"><a href="#2-差分数组" class="headerlink" title="2. 差分数组"></a>2. 差分数组</h2><blockquote>
<p>相关题目：</p>
<ol start="370">
<li><p>区间加法（中等） </p>
</li>
<li><p>航班预订统计（中等） </p>
</li>
<li><p>拼⻋（中等）</p>
</li>
</ol>
</blockquote>
<p>差分数组的主要适⽤场景是<strong>频繁对原始数组的某个区间的元素进⾏增减</strong>。 </p>
<p>对 <code>nums</code> 数组构造⼀个 <code>diff</code> 差分数组，**<code>diff[i]</code>** 就是 <strong><code>nums[i]</code></strong> 和 <strong><code>nums[i-1]</code></strong> 之差：</p>
<img src="/posts/a0fdfee0/image-20220311120935829.jpg" alt="image-20220311120935829" style="zoom:50%;">

<p>这样构造差分数组 **<code>diff</code>**，就可以快速进⾏区间增减的操作，如果你想对区间 <code>nums[i..j] </code>的元素全部加 3，那么只需要让 <code>diff[i] += 3</code>，然后再让<code> diff[j+1] -= 3</code> 即可：</p>
<p>把差分数组抽象成⼀个类，包含 increment ⽅法和 result ⽅法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 差分数组⼯具类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Difference</span> &#123;</span>   </span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; diff;	<span class="comment">//差分数组</span></span><br><span class="line">   </span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Difference</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        assert nums.<span class="built_in">size</span>() &gt; <span class="number">0</span>;</span><br><span class="line">        diff,<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        <span class="comment">// 根据初始数组构造差分数组</span></span><br><span class="line">        diff[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">        	diff[i] = nums[i] - nums[i - <span class="number">1</span>];</span><br><span class="line">		&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 给闭区间 [i,j] 增加 val（可以是负数）*/</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">increment</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        diff[i] += val;</span><br><span class="line">        <span class="keyword">if</span> (j + <span class="number">1</span> &lt; diff.<span class="built_in">size</span>()) &#123; <span class="comment">//当 j+1 &gt;= diff.length 时，说明是对 nums[i] 及以后的整个数组都进⾏修改，那么就不需要再给 diff数组减 val 了。</span></span><br><span class="line">            diff[j + <span class="number">1</span>] -= val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/* 返回结果数组 */</span></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">result</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(diff.size())</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = diff[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; diff.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            res[i] = res[i - <span class="number">1</span>] + diff[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-滑动窗口"><a href="#3-滑动窗口" class="headerlink" title="3. 滑动窗口"></a>3. 滑动窗口</h2><blockquote>
<p>相关题目：</p>
<ol start="76">
<li><p>最⼩覆盖⼦串（困难） </p>
</li>
<li><p>字符串的排列（中等） </p>
</li>
<li><p>找到字符串中所有字⺟异位词（中等） </p>
</li>
<li><p>⽆重复字符的最⻓⼦串（中等） </p>
</li>
</ol>
</blockquote>
<p>滑动窗⼝算法的代码框架：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 滑动窗⼝算法框架 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">slidingWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">	unordered_map&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; need, window;	</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t) need[c]++;</span><br><span class="line"> 	<span class="keyword">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>;	</span><br><span class="line">    <span class="keyword">int</span> valid = <span class="number">0</span>; </span><br><span class="line">	<span class="keyword">while</span> (right &lt; s.<span class="built_in">size</span>()) &#123;</span><br><span class="line">		<span class="comment">// c 是将移⼊窗⼝的字符</span></span><br><span class="line">		<span class="keyword">char</span> c = s[right];</span><br><span class="line">		<span class="comment">// 右移窗⼝</span></span><br><span class="line">		right++;</span><br><span class="line">		<span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line">		 ...</span><br><span class="line">		<span class="comment">/*** debug 输出的位置 ***/</span></span><br><span class="line">		<span class="built_in">printf</span>(<span class="string">&quot;window: [%d, %d)\n&quot;</span>, left, right);</span><br><span class="line">		<span class="comment">/********************/</span></span><br><span class="line"> </span><br><span class="line">		<span class="comment">// 判断左侧窗⼝是否要收缩</span></span><br><span class="line">		<span class="keyword">while</span> (window needs shrink) &#123;</span><br><span class="line"> 		<span class="comment">// d 是将移出窗⼝的字符</span></span><br><span class="line"> 		<span class="keyword">char</span> d = s[left];</span><br><span class="line"> 		<span class="comment">// 左移窗⼝</span></span><br><span class="line"> 		left++;</span><br><span class="line"> 		<span class="comment">// 进⾏窗⼝内数据的⼀系列更新</span></span><br><span class="line"> 		...</span><br><span class="line"> 		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二分搜索"><a href="#4-二分搜索" class="headerlink" title="4. 二分搜索"></a>4. 二分搜索</h2><blockquote>
<p>相关题目：</p>
<ol start="704">
<li><p>⼆分查找（简单） </p>
</li>
<li><p>在排序数组中查找元素的第⼀个和最后⼀个位置（中等） </p>
</li>
</ol>
</blockquote>
<p>搜索一个元素，搜索区间两端闭，while带等号</p>
<p>搜索左右边界，左闭右开常用，while用小于号</p>
<p>零、二分查找框架</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = ...;</span><br><span class="line">    <span class="keyword">while</span>(...) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            left = ...</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> &#123;</span><br><span class="line">            right = ...</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ...;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>分析⼆分查找的⼀个技巧是：不要出现 else，⽽是把所有情况⽤ else if 写清楚，这样可以清楚地展现所有细节。</p>
<h3 id="寻找一个数：存在返回其索引，不存在返回-1"><a href="#寻找一个数：存在返回其索引，不存在返回-1" class="headerlink" title="寻找一个数：存在返回其索引，不存在返回-1."></a>寻找一个数：存在返回其索引，不存在返回-1.</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找左侧边界的二分搜索："><a href="#寻找左侧边界的二分搜索：" class="headerlink" title="寻找左侧边界的二分搜索："></a>寻找左侧边界的二分搜索：</h3><p>左闭右开区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// target ⽐所有数都⼤</span></span><br><span class="line">    <span class="keyword">if</span> (left == nums.length) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 类似之前算法的处理⽅式</span></span><br><span class="line">	<span class="keyword">return</span> nums[left] == target ? left : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全闭区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">left_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩右侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(left &gt;= nums.<span class="built_in">size</span>() || nums[left] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="寻找右侧边界的⼆分查找"><a href="#寻找右侧边界的⼆分查找" class="headerlink" title="寻找右侧边界的⼆分查找:"></a>寻找右侧边界的⼆分查找:</h3><p>左闭右开写法（常见）：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = nums.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(left &lt; right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;  <span class="comment">// 注意</span></span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="keyword">if</span> (left == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">return</span> nums[left<span class="number">-1</span>] == target ? (left<span class="number">-1</span>) : <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>全闭区间写法：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">right_bound</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//搜索区间为[left, right]</span></span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] &lt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [mid+1, right]</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] &gt; target) &#123;</span><br><span class="line">            <span class="comment">// 搜索区间变为 [left, mid-1]</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 收缩左侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查出界情况</span></span><br><span class="line">    <span class="keyword">if</span>(right &lt; <span class="number">0</span> || nums[right] != target) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建议搜索区间全都统⼀成了<strong>两端都闭</strong>，便于记忆，只要修改两处即可变化出三种写法</p>
<h2 id="5-原地修改数组"><a href="#5-原地修改数组" class="headerlink" title="5. 原地修改数组"></a>5. 原地修改数组</h2><blockquote>
<p>相关题目：</p>
<ol start="26">
<li><p>删除有序数组中的重复项（简单） </p>
</li>
<li><p>删除排序链表中的重复元素（简单） </p>
</li>
<li><p>移除元素（简单） </p>
</li>
<li><p>移动零（简单） </p>
</li>
</ol>
</blockquote>
<h3 id="有序数组-链表去重"><a href="#有序数组-链表去重" class="headerlink" title="有序数组/链表去重"></a>有序数组/链表去重</h3><p>通⽤解法：快慢指针技巧</p>
<h3 id="有序数组去重："><a href="#有序数组去重：" class="headerlink" title="有序数组去重："></a>有序数组去重：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (nums.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> slow = <span class="number">0</span>, fast = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != num[slow]) &#123;</span><br><span class="line">            slow++;</span><br><span class="line">            <span class="comment">// 维护 nums[0..slow] ⽆重复</span></span><br><span class="line">            num[slow] = num[fast];</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 数组⻓度为索引 + 1</span></span><br><span class="line">    <span class="keyword">return</span> slow + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="有序链表去重："><a href="#有序链表去重：" class="headerlink" title="有序链表去重："></a>有序链表去重：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">    ListNode slow = head, fast = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (fast -&gt; val != slow -&gt; val) &#123;</span><br><span class="line">            <span class="comment">// nums[slow] = nums[fast];</span></span><br><span class="line">            slow -&gt; next = fast;</span><br><span class="line">            <span class="comment">// slow++;</span></span><br><span class="line">            slow = slow -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// fast++</span></span><br><span class="line">        fast = fast -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 断开与后⾯重复元素的连接</span></span><br><span class="line">    slow -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="数组原地删除元素："><a href="#数组原地删除元素：" class="headerlink" title="数组原地删除元素："></a>数组原地删除元素：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fast = <span class="number">0</span>, slow = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(fast &lt; nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[fast] != val) &#123;</span><br><span class="line">            nums[slow] = nums[fast];</span><br><span class="line">            slow++;</span><br><span class="line">        &#125;</span><br><span class="line">        fast++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="原地修改，将数组中的所有值为-0-的元素移到数组末尾："><a href="#原地修改，将数组中的所有值为-0-的元素移到数组末尾：" class="headerlink" title="原地修改，将数组中的所有值为 0 的元素移到数组末尾："></a>原地修改，将数组中的所有值为 0 的元素移到数组末尾：</h3><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">moveZeroes</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 去除 nums 中的所有 0</span></span><br><span class="line">	<span class="comment">// 返回去除 0 之后的数组⻓度</span></span><br><span class="line">	<span class="keyword">int</span> p = <span class="built_in">removeElement</span>(nums, <span class="number">0</span>);</span><br><span class="line">	<span class="comment">// 将 p 之后的所有元素赋值为 0</span></span><br><span class="line">	<span class="keyword">for</span> (; p &lt; nums.length; p++) &#123;</span><br><span class="line">		nums[p] = <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// ⻅上⽂代码实现</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; nums, <span class="keyword">int</span> val)</span></span>;</span><br></pre></td></tr></table></figure>

<h2 id="6-单链表"><a href="#6-单链表" class="headerlink" title="6. 单链表"></a>6. 单链表</h2><blockquote>
<p>相关题目：</p>
<ol start="21">
<li><p>合并两个有序链表（简单） </p>
</li>
<li><p>合并K个升序链表（困难） </p>
</li>
<li><p>环形链表（简单） </p>
</li>
<li><p>环形链表 II（中等） </p>
</li>
<li><p>链表的中间结点（简单） </p>
</li>
<li><p>相交链表（简单） </p>
</li>
<li><p>删除链表的倒数第 N 个结点（中等）</p>
</li>
</ol>
</blockquote>
<h3 id="合并两个有序链表"><a href="#合并两个有序链表" class="headerlink" title="合并两个有序链表"></a>合并两个有序链表</h3><p>给定输⼊两个有序链表，把他俩合并成⼀个新的有序链表。</p>
<p>输入：<code>l1 = [1, 2, 4], l2 = [1, 3, 4]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4]</code></p>
<p>解法：设立虚拟头节点<code>dummy</code>，避免处理空指针</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 虚拟头结点</span></span><br><span class="line">    ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line">    ListNode* p1 = l1, *p2 = l2;</span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span> &amp;&amp; p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// ⽐较 p1 和 p2 两个指针</span></span><br><span class="line"> 		<span class="comment">// 将值较⼩的的节点接到 p 指针</span></span><br><span class="line">        <span class="keyword">if</span>(p1 -&gt; val &gt; p2 -&gt; val) &#123;</span><br><span class="line">            p -&gt; next = p2;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p -&gt; next = p1;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p 指针不断前进</span></span><br><span class="line">        p = p -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(p2 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p -&gt; next = p2;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h3><p>给定输⼊k个有序链表，把他们合并成⼀个新的有序链表。</p>
<p>输入：<code>lists = [[1, 4, 5], [1, 3, 4], [2, 6]]</code></p>
<p>输出：<code>[1, 1, 2, 3, 4, 4, 5, 6]</code></p>
<p>解法：优先级队列（二叉堆），把链表节点放⼊⼀个最⼩堆，就可以每次获得 k 个节点中的最⼩节点</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">        <span class="keyword">int</span> val = <span class="number">0</span>;</span><br><span class="line">        ListNode* p = <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Node &amp; n) <span class="keyword">const</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> n.val &lt; val;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 优先级队列，最⼩堆</span></span><br><span class="line">    priority_queue&lt;Node&gt; pq;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (lists.<span class="built_in">size</span>() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        <span class="comment">// 虚拟头结点</span></span><br><span class="line">        ListNode* dummy = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>), *p = dummy;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 k 个链表的头结点加⼊最⼩堆</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> head : lists) &#123;</span><br><span class="line">            <span class="keyword">if</span>(head != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;head -&gt; val, head&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (!pq.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 获取最⼩节点，接到结果链表中</span></span><br><span class="line">            ListNode* node = pq.<span class="built_in">top</span>().p;</span><br><span class="line">            pq.<span class="built_in">pop</span>();</span><br><span class="line">            p -&gt; next = node;</span><br><span class="line">            <span class="keyword">if</span>(node -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                pq.<span class="built_in">push</span>(&#123;node -&gt; next -&gt; val, node -&gt; next&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// p 指针不断前进</span></span><br><span class="line">            p = p -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummy -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="单链表的倒数第k个节点"><a href="#单链表的倒数第k个节点" class="headerlink" title="单链表的倒数第k个节点"></a>单链表的倒数第k个节点</h3><p>要点：只遍历⼀次链表，就算出倒数第 k 个节点</p>
<img src="/posts/a0fdfee0/image-20220314210806020.png" alt="image-20220314210806020" style="zoom:50%;">

<p>指针<code>p1</code>指向<code>head</code>节点，开始走<code>k</code>步；</p>
<img src="/posts/a0fdfee0/image-20220314211006249.png" alt="image-20220314211006249" style="zoom:50%;">

<p>指针<code>p2</code>指向<code>head</code>节点，<code>p1</code>和<code>p2</code>同时走，<code>n-k</code>步后<code>p1</code>走到链表末尾空指针结束，返回<code>p2</code>即可。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">findFromEnd</span><span class="params">(ListNode* head, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">    ListNode* p1 = head;</span><br><span class="line">    <span class="comment">// p1 先⾛ k 步</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode* p2 = head;</span><br><span class="line">    <span class="comment">// p1 和 p2 同时⾛ n - k 步</span></span><br><span class="line">    <span class="keyword">while</span>(p1 != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        p2 = p2 -&gt; next;</span><br><span class="line">        p1 = p1 -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// p2 现在指向第 n - k 个节点</span></span><br><span class="line">    <span class="keyword">return</span> p2;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表中点"><a href="#单链表中点" class="headerlink" title="单链表中点"></a>单链表中点</h3><p>解法：让两个指针 <code>slow</code> 和 <code>fast</code> 分别指向链表头结点<code> head</code>。 每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，这样，当 <code>fast</code> ⾛到链表末尾时，<code>slow</code> 就指向了链 表中点。 </p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">middleNode</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> 	ListNode* slow = head, *fast = head;</span><br><span class="line"> 	<span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> 		slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针指向中点</span></span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意：如果链表⻓度为偶数，也就是说中点有两个的时候，这个解法返回的节点是靠后的那个节点。 </p>
<h3 id="判断链表是否包含环"><a href="#判断链表是否包含环" class="headerlink" title="判断链表是否包含环"></a>判断链表是否包含环</h3><p>解法：快慢指针，每当慢指针<code> slow</code> 前进⼀步，快指针 <code>fast</code> 就前进两步，如果 <code>fast</code> 最终遇到空指针，说明链表中没有环；如果 <code>fast </code>最终和<code>slow</code>相遇，那肯定是<code> fast</code> 超过了<code>slow</code> ⼀圈，说明链表中含有环。</p>
<p>只需要把寻找链表中点的代码稍加修改：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 快慢指针初始化指向 head</span></span><br><span class="line"> 	ListNode* slow = head, *fast = head;</span><br><span class="line"> 	<span class="comment">// 快指针⾛到末尾时停⽌</span></span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// 慢指针⾛⼀步，快指针⾛两步</span></span><br><span class="line"> 		slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 不包含环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*计算环的起点*/</span></span><br><span class="line"><span class="function">ListNode* <span class="title">detectCycle</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    ListNode* fast = head, *slow = head;</span><br><span class="line">    <span class="keyword">while</span>(fast != <span class="literal">nullptr</span> &amp;&amp; fast -&gt; next != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        slow = slow -&gt; next;</span><br><span class="line"> 		fast = fast -&gt; next -&gt; next;</span><br><span class="line">        <span class="comment">// 快慢指针相遇，说明含有环</span></span><br><span class="line">        <span class="keyword">if</span>(slow == fast) <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (fast == <span class="literal">nullptr</span> || fast -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line"> 		<span class="comment">// fast 遇到空指针说明没有环</span></span><br><span class="line"> 		<span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line"> 	&#125;</span><br><span class="line">    <span class="comment">// 重新指向头结点</span></span><br><span class="line">	 slow = head;</span><br><span class="line"> 	<span class="comment">// 快慢指针同步前进，相交点就是环起点</span></span><br><span class="line"> 	<span class="keyword">while</span> (slow != fast) &#123;</span><br><span class="line"> 		fast = fast -&gt; next;</span><br><span class="line">     	slow = slow -&gt; next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="两个链表是否相交"><a href="#两个链表是否相交" class="headerlink" title="两个链表是否相交"></a>两个链表是否相交</h3><p>输⼊两个链表的头结点<code>headA</code>和<code> headB</code>，这两个链表可能存在相交。如果相交，应该返回相交的那个节点；如果没相交，则返回 <code>nullptr</code>。</p>
<p>解法：可以让 <code>p1</code> 遍历完链表 <code>A</code> 之后开始遍历链表 <code>B</code>，让<code> p2</code> 遍历完链表 <code>B</code> 之后开始遍历链表<code> A</code>，这样相 当于「逻辑上」两条链表接在了⼀起。让<code> p1</code> 和<code> p2</code> 同时进⼊公共部分，也就是同时到达相交节点<code> c1</code></p>
<img src="/posts/a0fdfee0/image-20220315104422008.png" alt="image-20220315104422008" style="zoom:50%;">

<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">getIntersectionNode</span><span class="params">(ListNode *headA, ListNode *headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// p1 指向 A 链表头结点，p2 指向 B 链表头结点</span></span><br><span class="line">    ListNode* p1 = headA, *p2 = headB;</span><br><span class="line">    <span class="keyword">while</span>(p1 != p2) &#123;</span><br><span class="line">        <span class="comment">// p1 ⾛⼀步，如果⾛到 A 链表末尾，转到 B 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p1 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p1 = headB;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p1 = p1 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// p2 ⾛⼀步，如果⾛到 B 链表末尾，转到 A 链表</span></span><br><span class="line">        <span class="keyword">if</span>(p2 == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            p2 = headA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            p2 = p2 -&gt; next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-链表操作的递归实现"><a href="#7-链表操作的递归实现" class="headerlink" title="7. 链表操作的递归实现"></a>7. 链表操作的递归实现</h2><blockquote>
<p>相关题目：</p>
<ol start="206">
<li><p>反转链表（简单） </p>
</li>
<li><p>反转链表II（中等） </p>
</li>
</ol>
</blockquote>
<h3 id="递归反转整个链表"><a href="#递归反转整个链表" class="headerlink" title="递归反转整个链表"></a>递归反转整个链表</h3><p>输⼊⼀个节点 <code>head</code>，将以<code>head</code>为起点的链表反转，并返回反转之后的头结点。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function">ListNode* <span class="title">reverse</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//递归函数base case，如果链表只有⼀个节点的时候，直接返回即可</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="literal">nullptr</span> || head -&gt; next == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//新的头结点是last, 将head之后部分反转</span></span><br><span class="line">    ListNode* last = <span class="built_in">reverse</span>(head -&gt; next);</span><br><span class="line">    head -&gt; next -&gt; next = head;</span><br><span class="line">    <span class="comment">//head 变成了最后⼀个节点，别忘了链表的末尾要指向 null</span></span><br><span class="line">    head -&gt; next = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h3><p>解决思路和反转整个链表差不多，稍加修改即可</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">ListNode* successor = <span class="literal">nullptr</span>; <span class="comment">// 后驱节点</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转以 head 为起点的 n 个节点，返回新的头结点</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseN</span><span class="params">(ListNode* head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (n == <span class="number">1</span>) &#123;</span><br><span class="line"> 		<span class="comment">// 记录第 n + 1 个节点</span></span><br><span class="line"> 		successor = head -&gt; next;</span><br><span class="line"> 		<span class="keyword">return</span> head;</span><br><span class="line"> 	&#125;</span><br><span class="line"> 	<span class="comment">// 以 head.next 为起点，需要反转前 n - 1 个节点</span></span><br><span class="line"> 	ListNode* last = <span class="built_in">reverseN</span>(head -&gt; next, n - <span class="number">1</span>);</span><br><span class="line"> 	head -&gt; next -&gt; next = head;</span><br><span class="line">	<span class="comment">// 让反转之后的 head 节点和后⾯的节点连起来</span></span><br><span class="line"> 	head -&gt; next = successor;</span><br><span class="line"> 	<span class="keyword">return</span> last;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="反转链表的一部分"><a href="#反转链表的一部分" class="headerlink" title="反转链表的一部分"></a>反转链表的一部分</h3><p>给⼀个索引区间<code> [left, right]</code>（索引从 1 开始），仅仅反转区间中的链表元素。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//接上部分反转链表代码</span></span><br><span class="line"><span class="comment">//反转链表的任意区间[left, right]</span></span><br><span class="line"><span class="function">ListNode* <span class="title">reverseBetween</span><span class="params">(ListNode* head, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">1</span>) <span class="keyword">return</span> <span class="built_in">reverseN</span>(head, right);</span><br><span class="line">    <span class="comment">// 前进到反转的起点触发 base case</span></span><br><span class="line">    head -&gt; next = <span class="built_in">reverseBetween</span>(head -&gt; next, left - <span class="number">1</span>, right - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>刷题笔记</category>
      </categories>
      <tags>
        <tag>数组</tag>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/posts/4a17b156/</url>
    <content><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">
  <script id="hbeData" type="hbeData" data-hmacdigest="52444d4cb1ffc588615b9d0abc49282209d3ebce20a5bcf437b678a72bf16e52">1b693c4938223286468132b2f7068bf6098157620d78df6a8d32bb51e3f325b181ab70623eeb2a3f7a6bc681afafbdfe713bdd1c6f193890fe2449d416193fec46af80b0cd7431187dd1f97bc499b3a9ff9add79cea27c3015bb48123e899a7fb3295784c80b5d0b121aef398aca2f36d3661e78c54305f10d7d8f9de07de7e9a370641812f840a8f68bb7686e6e75bf5aaa69b4f328fe94d17a00647b6bdeefac5ff68db076f26d217b7be239abd3dad05c88857aa0945ec9bbce8c501724e9cddcda090e0b5dd17670bc5b0aa146e5c15ead49d5bedec7e2d0ba426f9bac50c6fb7f935f8a01d86b0fb15bfc31774d8b2e748468978a57c9f314cf3474a8908c962e62d793d4202cc789c89f172859f6c45d905ca5828e4fcc14dcd0b72bc60fed7d44f9e29b4be00939342e416c9e56c67e04b79fdec1dcef56c7602d391c51365f0885c5f1e7daa21ef5f34ec737ba851e91be020d6b473ff53dc5082093a33f1899d7be4ed55ecb8a865ada024c8a8ccf66b6e0c51f2843e1248a0f483d118e82308bd4ea916657024bf2c31a5fb01da6ef08a8316c44e217bc4792319d995741257cca7ddaab847de991c6537d986a79b83e8cee1d44c948ed237bbcc65fe83890021b84452bd350bbc4b8eace2cf7b56a5ee838ce3f76d847cd9b091176a88ddd8759125c5ef6f3a128951a6a60b4eb9b3000103e3fc21e28fefb5237e8dff0724bbe862d7bd8b9bf0bed10f0b85b68b8267130266e872060622d62bcab8182471f42324384a307a3f7cf68a591c3e5123d7d983dde563a046f30df65686ba53da8448fba75896080e1fc7bfc6685c2bd7cd91d28907af15fdc166854210f6d488a3c62336376333997a4440bd58288eeb52b359fd4fa62455ee3f5f10c53851924baa240880212ebf3801c2f496b21c0fb67bddddc6b3884e9dca3b6f3742e05f59e3fb3035436dce19683e5ecbb48d4df737592b11ece81856380177c37c7309f768d3b64c48649aa82ebe5d29649bdba9af2df082e771827d4835afab8fe8e69b87e8b2404de6c41cc60fa45c843bf89bc83d73d1a8b7d55dc6f00f0e1e9480890bf6a324e584fc0c45ae457e9031622981ee83f0f275eb5682b05f2cd81b5f6b4776c9f3b90bf1857e78a3ea5bb4c83a4654de516eadfd438a5f4d9c25c2e48b6d7fead8c1cedb027faf44d8d9ce375ffc87532cc56f002835e0e55b75b96dad4592e56417416aaa6d22e08af6e5c565e005c516dfe25927804e35c11ed470916d60e9e941489205c98c96a1c888ec4fcabf2cd59cf7ed77d51cb5d4b8aa1a0837099b37341d56b907e8ddeec5e34bff8bbefffa2c864d1ef7de812c4e874d2b420505ae8e4416dd9a33cd3713be4adbe572af303bc6904b8a281f9df07fd21b063fc85f7540f2b44976f593cbd622314605f4e2e391b20c0ea22f3895d13e668c979815c9bdfda25095fb79ef6c023139f1d0f3acf0ab15ef22a6373a11b906fb98209de8a83f85444cb96081129e2c7c8421791beecabb01241aa70f09346209d23bfe18d60338ba3abb4792d594197c9abc95d1d962a49bbc34c25e156e252f6510f8441a614bea22f2f7116575536cd4d2b8f12df6d82d2d65026003aa1cd2996ddd6c1d93fd308591391dd88d7d70cca7d5f9fea6f9500b11312df71132d053f8da3910d17eb455a1dd11462bd65159ecc86cfb61b3f130c2f1be650e86328833e99d8d121a1a5632a250b3ab29980d598255adab11607e9da1b5156f399c285e3d748d84aa460fc4b3c71d8120e0d056fa0707e1d876213ddcefae8b856a0a8384b037dfc6ed753ac31508f19bd2321a9da8adb4b9fbbd3e28be1d495e338871e63b948a663665d9671a349abbc5aa7d895e794785302d5260eede14246baa774210d9d0fea4bf36853a865a781b35c8c482b46675e2ef1161d78856120df62ab968a5e8726f7d58f7f4d7824daff425475d82858438b9a4d06ede3f489262c13637eab07914138236b60f73ebef728d93aa59e789a6c21e4868886308f79701a80cce6098a7d050424f478e9151a87e9de5c53b3c2bc81b15b601a40ac452486f1149a6af9d4f70d4dbb9cc233e8cc2703e8bf13aa35a4fca77bcb9cec9e6f1195475ac4af9952e31a4319c1ad417666c224efa7eb95a7f957cffa0541af71a66bdb3759cf72a3bca8bbb5036ebf135ee0f0ad0fcc1170aefc5c9881466f69582a0bd565161355fc447fc0121359014e08b1533f1c896eedef7e15e3c770fe2c2f4068bdae19fc24d286ec5fd0f0925586cb2b481031bded5c5e1ff5fcc581d17df686aca3266e519cbb70c9189e4145ff103d5facc16bf1d9f7660967180fe8795f400729b8422768e0af1b32dfbdbe6414a5b94b593247c2cb2c9b10ec80be7d55726ded5c724c7c8ce4f2a76ca5021331ba0286ae6b94c3fb0b137d2b826ad083f4c2d1e1ae70fcbb8fe81d638464af4d326d60b621db96b26194ab2fb1fcb2913b0634ac96c2e9a62baaaf0816cc903f1a5e96c6db24c9217efa7494bc43e85cc8016ac2cb7e31b7b63fbebcd70b47ea05a756893dd823673bd077b20bd5bf23ba92ebfc0556679994403d835e852da90fbaf894e326028fe892fc04fe5b32d965877af6b24e4f3f924e54a3d3cbf4518c36662dca2cb4afaefbe8600cb747e49e0e2212149a02961e3a9cecd985188fcb7217e7fe08172a65d854b5aa33a7365a6c28cb1ad4a2e05de66c8c404f1a39f3ee5d858d42c0d5f9276b6ce0c28190d7db0b3c8606f1c420e17d74e241c44756c9aff1789827b3a00b20d0d87f7f2ac159df12d8389c7eed139660934d7be7bb284f7529fb1e8bb000685742a6a1bff1bf41a0cbc05736e8fcec2428f54bcc6570c75cc89fc2894d87e0f1c5e64750f197b02fca53580902f57818e9e08988555ea17ff42bb449dd547e955ce96f2fe96eaa09708b4dde5098748432d8ea7491ad60e20930453b941a79c0f6ce9721cb6f34e915abc5e8be238e448d573d435ba3ba7f04efabd82896385e9747a56a5f2fd83fb874031ca98abe25cd3f5059a05b7242ef1147aad5dba834d3eefac1e0d04b36b8b2c6fca0bb35349ab66544cd487b47ca08d12da5a2a443129b16b4326f17b5d94d3787e2d4a3110f2bbb3aab5078e00cdc3ddcb1327d98763f419487ec2f2535</script>
  <div class="hbe hbe-content">
    <div class="hbe hbe-input hbe-input-default">
      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">
      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">
        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Welcome to my blog, enter password to read.</span>
      </label>
    </div>
  </div>
</div>
<script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
  </entry>
</search>
